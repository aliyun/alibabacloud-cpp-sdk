// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_BAAS20180731_H_
#define ALIBABACLOUD_BAAS20180731_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Baas20180731 {
class ChainPurpose : public Darabonba::Model {
public:
  shared_ptr<bool> extend{};
  shared_ptr<string> id{};
  shared_ptr<bool> item{};
  shared_ptr<string> key{};
  shared_ptr<string> name{};
  shared_ptr<string> purposeItem{};
  shared_ptr<string> status{};
  shared_ptr<string> time{};

  ChainPurpose() {}

  explicit ChainPurpose(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extend) {
      res["Extend"] = boost::any(*extend);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (item) {
      res["Item"] = boost::any(*item);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (purposeItem) {
      res["PurposeItem"] = boost::any(*purposeItem);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extend") != m.end() && !m["Extend"].empty()) {
      extend = make_shared<bool>(boost::any_cast<bool>(m["Extend"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      item = make_shared<bool>(boost::any_cast<bool>(m["Item"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PurposeItem") != m.end() && !m["PurposeItem"].empty()) {
      purposeItem = make_shared<string>(boost::any_cast<string>(m["PurposeItem"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
  }


  virtual ~ChainPurpose() = default;
};
class AntChainPurposeResponse : public Darabonba::Model {
public:
  shared_ptr<string> chainPurposeExtend{};
  shared_ptr<string> chainPurposeItem{};
  shared_ptr<string> createTime{};
  shared_ptr<string> purpose{};
  shared_ptr<vector<ChainPurpose>> recordList{};
  shared_ptr<string> status{};

  AntChainPurposeResponse() {}

  explicit AntChainPurposeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chainPurposeExtend) {
      res["ChainPurposeExtend"] = boost::any(*chainPurposeExtend);
    }
    if (chainPurposeItem) {
      res["ChainPurposeItem"] = boost::any(*chainPurposeItem);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (purpose) {
      res["Purpose"] = boost::any(*purpose);
    }
    if (recordList) {
      vector<boost::any> temp1;
      for(auto item1:*recordList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordList"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChainPurposeExtend") != m.end() && !m["ChainPurposeExtend"].empty()) {
      chainPurposeExtend = make_shared<string>(boost::any_cast<string>(m["ChainPurposeExtend"]));
    }
    if (m.find("ChainPurposeItem") != m.end() && !m["ChainPurposeItem"].empty()) {
      chainPurposeItem = make_shared<string>(boost::any_cast<string>(m["ChainPurposeItem"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Purpose") != m.end() && !m["Purpose"].empty()) {
      purpose = make_shared<string>(boost::any_cast<string>(m["Purpose"]));
    }
    if (m.find("RecordList") != m.end() && !m["RecordList"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordList"].type()) {
        vector<ChainPurpose> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ChainPurpose model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordList = make_shared<vector<ChainPurpose>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~AntChainPurposeResponse() = default;
};
class ChainPurposeInfoAli : public Darabonba::Model {
public:
  shared_ptr<string> chainPurposeExtend{};
  shared_ptr<string> chainPurposeItem{};
  shared_ptr<string> id{};
  shared_ptr<string> key{};
  shared_ptr<string> purpose{};
  shared_ptr<string> status{};
  shared_ptr<string> time{};

  ChainPurposeInfoAli() {}

  explicit ChainPurposeInfoAli(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chainPurposeExtend) {
      res["ChainPurposeExtend"] = boost::any(*chainPurposeExtend);
    }
    if (chainPurposeItem) {
      res["ChainPurposeItem"] = boost::any(*chainPurposeItem);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (purpose) {
      res["Purpose"] = boost::any(*purpose);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (time) {
      res["Time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChainPurposeExtend") != m.end() && !m["ChainPurposeExtend"].empty()) {
      chainPurposeExtend = make_shared<string>(boost::any_cast<string>(m["ChainPurposeExtend"]));
    }
    if (m.find("ChainPurposeItem") != m.end() && !m["ChainPurposeItem"].empty()) {
      chainPurposeItem = make_shared<string>(boost::any_cast<string>(m["ChainPurposeItem"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Purpose") != m.end() && !m["Purpose"].empty()) {
      purpose = make_shared<string>(boost::any_cast<string>(m["Purpose"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Time") != m.end() && !m["Time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["Time"]));
    }
  }


  virtual ~ChainPurposeInfoAli() = default;
};
class AntChainPurposeResponseAli : public Darabonba::Model {
public:
  shared_ptr<vector<ChainPurposeInfoAli>> recordList{};
  shared_ptr<string> status{};

  AntChainPurposeResponseAli() {}

  explicit AntChainPurposeResponseAli(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (recordList) {
      vector<boost::any> temp1;
      for(auto item1:*recordList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RecordList"] = boost::any(temp1);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RecordList") != m.end() && !m["RecordList"].empty()) {
      if (typeid(vector<boost::any>) == m["RecordList"].type()) {
        vector<ChainPurposeInfoAli> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RecordList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ChainPurposeInfoAli model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        recordList = make_shared<vector<ChainPurposeInfoAli>>(expect1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~AntChainPurposeResponseAli() = default;
};
class ChainPurposeListAli : public Darabonba::Model {
public:
  shared_ptr<bool> extend{};
  shared_ptr<string> id{};
  shared_ptr<bool> item{};
  shared_ptr<string> key{};
  shared_ptr<string> purpose{};

  ChainPurposeListAli() {}

  explicit ChainPurposeListAli(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extend) {
      res["Extend"] = boost::any(*extend);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (item) {
      res["Item"] = boost::any(*item);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (purpose) {
      res["Purpose"] = boost::any(*purpose);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Extend") != m.end() && !m["Extend"].empty()) {
      extend = make_shared<bool>(boost::any_cast<bool>(m["Extend"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Item") != m.end() && !m["Item"].empty()) {
      item = make_shared<bool>(boost::any_cast<bool>(m["Item"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Purpose") != m.end() && !m["Purpose"].empty()) {
      purpose = make_shared<string>(boost::any_cast<string>(m["Purpose"]));
    }
  }


  virtual ~ChainPurposeListAli() = default;
};
class CheckPointStructBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCount{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lastError{};
  shared_ptr<string> totalCount{};
  shared_ptr<string> type{};

  CheckPointStructBody() {}

  explicit CheckPointStructBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCount) {
      res["ErrorCount"] = boost::any(*errorCount);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lastError) {
      res["LastError"] = boost::any(*lastError);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCount") != m.end() && !m["ErrorCount"].empty()) {
      errorCount = make_shared<string>(boost::any_cast<string>(m["ErrorCount"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("LastError") != m.end() && !m["LastError"].empty()) {
      lastError = make_shared<string>(boost::any_cast<string>(m["LastError"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<string>(boost::any_cast<string>(m["TotalCount"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CheckPointStructBody() = default;
};
class PositionStructBody : public Darabonba::Model {
public:
  shared_ptr<string> errorCount{};
  shared_ptr<string> height{};
  shared_ptr<string> index{};
  shared_ptr<string> lastError{};
  shared_ptr<string> type{};

  PositionStructBody() {}

  explicit PositionStructBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCount) {
      res["ErrorCount"] = boost::any(*errorCount);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (lastError) {
      res["LastError"] = boost::any(*lastError);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCount") != m.end() && !m["ErrorCount"].empty()) {
      errorCount = make_shared<string>(boost::any_cast<string>(m["ErrorCount"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<string>(boost::any_cast<string>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["Index"]));
    }
    if (m.find("LastError") != m.end() && !m["LastError"].empty()) {
      lastError = make_shared<string>(boost::any_cast<string>(m["LastError"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~PositionStructBody() = default;
};
class TriggerLogDTOStructBody : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> modifyTime{};
  shared_ptr<PositionStructBody> position{};
  shared_ptr<string> status{};
  shared_ptr<string> uuid{};

  TriggerLogDTOStructBody() {}

  explicit TriggerLogDTOStructBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (modifyTime) {
      res["ModifyTime"] = boost::any(*modifyTime);
    }
    if (position) {
      res["Position"] = position ? boost::any(position->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (uuid) {
      res["Uuid"] = boost::any(*uuid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ModifyTime") != m.end() && !m["ModifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["ModifyTime"]));
    }
    if (m.find("Position") != m.end() && !m["Position"].empty()) {
      if (typeid(map<string, boost::any>) == m["Position"].type()) {
        PositionStructBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Position"]));
        position = make_shared<PositionStructBody>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Uuid") != m.end() && !m["Uuid"].empty()) {
      uuid = make_shared<string>(boost::any_cast<string>(m["Uuid"]));
    }
  }


  virtual ~TriggerLogDTOStructBody() = default;
};
class CommonResponsePageableStructBody : public Darabonba::Model {
public:
  shared_ptr<string> current{};
  shared_ptr<vector<TriggerLogDTOStructBody>> list{};
  shared_ptr<string> pageSize{};
  shared_ptr<string> total{};

  CommonResponsePageableStructBody() {}

  explicit CommonResponsePageableStructBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (list) {
      vector<boost::any> temp1;
      for(auto item1:*list){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["List"] = boost::any(temp1);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<string>(boost::any_cast<string>(m["Current"]));
    }
    if (m.find("List") != m.end() && !m["List"].empty()) {
      if (typeid(vector<boost::any>) == m["List"].type()) {
        vector<TriggerLogDTOStructBody> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["List"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TriggerLogDTOStructBody model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        list = make_shared<vector<TriggerLogDTOStructBody>>(expect1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<string>(boost::any_cast<string>(m["Total"]));
    }
  }


  virtual ~CommonResponsePageableStructBody() = default;
};
class TriggerDTOStructBody : public Darabonba::Model {
public:
  shared_ptr<CheckPointStructBody> checkpoint{};
  shared_ptr<string> createTime{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> name{};
  shared_ptr<string> option{};
  shared_ptr<string> pendingErrorLogs{};
  shared_ptr<string> source{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  TriggerDTOStructBody() {}

  explicit TriggerDTOStructBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkpoint) {
      res["Checkpoint"] = checkpoint ? boost::any(checkpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (option) {
      res["Option"] = boost::any(*option);
    }
    if (pendingErrorLogs) {
      res["PendingErrorLogs"] = boost::any(*pendingErrorLogs);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Checkpoint") != m.end() && !m["Checkpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["Checkpoint"].type()) {
        CheckPointStructBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Checkpoint"]));
        checkpoint = make_shared<CheckPointStructBody>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Option") != m.end() && !m["Option"].empty()) {
      option = make_shared<string>(boost::any_cast<string>(m["Option"]));
    }
    if (m.find("PendingErrorLogs") != m.end() && !m["PendingErrorLogs"].empty()) {
      pendingErrorLogs = make_shared<string>(boost::any_cast<string>(m["PendingErrorLogs"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~TriggerDTOStructBody() = default;
};
class AcceptEthereumInvitationRequest : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> token{};

  AcceptEthereumInvitationRequest() {}

  explicit AcceptEthereumInvitationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~AcceptEthereumInvitationRequest() = default;
};
class AcceptEthereumInvitationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  AcceptEthereumInvitationResponseBody() {}

  explicit AcceptEthereumInvitationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AcceptEthereumInvitationResponseBody() = default;
};
class AcceptEthereumInvitationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AcceptEthereumInvitationResponseBody> body{};

  AcceptEthereumInvitationResponse() {}

  explicit AcceptEthereumInvitationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AcceptEthereumInvitationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AcceptEthereumInvitationResponseBody>(model1);
      }
    }
  }


  virtual ~AcceptEthereumInvitationResponse() = default;
};
class AcceptInvitationRequest : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> isAccepted{};

  AcceptInvitationRequest() {}

  explicit AcceptInvitationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (isAccepted) {
      res["IsAccepted"] = boost::any(*isAccepted);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("IsAccepted") != m.end() && !m["IsAccepted"].empty()) {
      isAccepted = make_shared<bool>(boost::any_cast<bool>(m["IsAccepted"]));
    }
  }


  virtual ~AcceptInvitationRequest() = default;
};
class AcceptInvitationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AcceptInvitationResponseBody() {}

  explicit AcceptInvitationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AcceptInvitationResponseBody() = default;
};
class AcceptInvitationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AcceptInvitationResponseBody> body{};

  AcceptInvitationResponse() {}

  explicit AcceptInvitationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AcceptInvitationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AcceptInvitationResponseBody>(model1);
      }
    }
  }


  virtual ~AcceptInvitationResponse() = default;
};
class AddAntChainSubnetMemberCheckRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> consortiumId{};

  AddAntChainSubnetMemberCheckRequest() {}

  explicit AddAntChainSubnetMemberCheckRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
  }


  virtual ~AddAntChainSubnetMemberCheckRequest() = default;
};
class AddAntChainSubnetMemberCheckResponseBodyResultConsortiumMemberInfoList : public Darabonba::Model {
public:
  shared_ptr<string> memberId{};
  shared_ptr<string> memberName{};

  AddAntChainSubnetMemberCheckResponseBodyResultConsortiumMemberInfoList() {}

  explicit AddAntChainSubnetMemberCheckResponseBodyResultConsortiumMemberInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memberId) {
      res["MemberId"] = boost::any(*memberId);
    }
    if (memberName) {
      res["MemberName"] = boost::any(*memberName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MemberId") != m.end() && !m["MemberId"].empty()) {
      memberId = make_shared<string>(boost::any_cast<string>(m["MemberId"]));
    }
    if (m.find("MemberName") != m.end() && !m["MemberName"].empty()) {
      memberName = make_shared<string>(boost::any_cast<string>(m["MemberName"]));
    }
  }


  virtual ~AddAntChainSubnetMemberCheckResponseBodyResultConsortiumMemberInfoList() = default;
};
class AddAntChainSubnetMemberCheckResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<AddAntChainSubnetMemberCheckResponseBodyResultConsortiumMemberInfoList>> consortiumMemberInfoList{};

  AddAntChainSubnetMemberCheckResponseBodyResult() {}

  explicit AddAntChainSubnetMemberCheckResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumMemberInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*consortiumMemberInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConsortiumMemberInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumMemberInfoList") != m.end() && !m["ConsortiumMemberInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConsortiumMemberInfoList"].type()) {
        vector<AddAntChainSubnetMemberCheckResponseBodyResultConsortiumMemberInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConsortiumMemberInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddAntChainSubnetMemberCheckResponseBodyResultConsortiumMemberInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        consortiumMemberInfoList = make_shared<vector<AddAntChainSubnetMemberCheckResponseBodyResultConsortiumMemberInfoList>>(expect1);
      }
    }
  }


  virtual ~AddAntChainSubnetMemberCheckResponseBodyResult() = default;
};
class AddAntChainSubnetMemberCheckResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<AddAntChainSubnetMemberCheckResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  AddAntChainSubnetMemberCheckResponseBody() {}

  explicit AddAntChainSubnetMemberCheckResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        AddAntChainSubnetMemberCheckResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<AddAntChainSubnetMemberCheckResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddAntChainSubnetMemberCheckResponseBody() = default;
};
class AddAntChainSubnetMemberCheckResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddAntChainSubnetMemberCheckResponseBody> body{};

  AddAntChainSubnetMemberCheckResponse() {}

  explicit AddAntChainSubnetMemberCheckResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddAntChainSubnetMemberCheckResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddAntChainSubnetMemberCheckResponseBody>(model1);
      }
    }
  }


  virtual ~AddAntChainSubnetMemberCheckResponse() = default;
};
class AddAntChainSubnetNodeCheckRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> consortiumId{};

  AddAntChainSubnetNodeCheckRequest() {}

  explicit AddAntChainSubnetNodeCheckRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
  }


  virtual ~AddAntChainSubnetNodeCheckRequest() = default;
};
class AddAntChainSubnetNodeCheckResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeName{};

  AddAntChainSubnetNodeCheckResponseBodyResult() {}

  explicit AddAntChainSubnetNodeCheckResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
  }


  virtual ~AddAntChainSubnetNodeCheckResponseBodyResult() = default;
};
class AddAntChainSubnetNodeCheckResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<AddAntChainSubnetNodeCheckResponseBodyResult>> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  AddAntChainSubnetNodeCheckResponseBody() {}

  explicit AddAntChainSubnetNodeCheckResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<AddAntChainSubnetNodeCheckResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddAntChainSubnetNodeCheckResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<AddAntChainSubnetNodeCheckResponseBodyResult>>(expect1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddAntChainSubnetNodeCheckResponseBody() = default;
};
class AddAntChainSubnetNodeCheckResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddAntChainSubnetNodeCheckResponseBody> body{};

  AddAntChainSubnetNodeCheckResponse() {}

  explicit AddAntChainSubnetNodeCheckResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddAntChainSubnetNodeCheckResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddAntChainSubnetNodeCheckResponseBody>(model1);
      }
    }
  }


  virtual ~AddAntChainSubnetNodeCheckResponse() = default;
};
class AddEthereumNodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> ethereumId{};
  shared_ptr<bool> externalNode{};
  shared_ptr<string> nodeName{};

  AddEthereumNodeRequest() {}

  explicit AddEthereumNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ethereumId) {
      res["EthereumId"] = boost::any(*ethereumId);
    }
    if (externalNode) {
      res["ExternalNode"] = boost::any(*externalNode);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EthereumId") != m.end() && !m["EthereumId"].empty()) {
      ethereumId = make_shared<string>(boost::any_cast<string>(m["EthereumId"]));
    }
    if (m.find("ExternalNode") != m.end() && !m["ExternalNode"].empty()) {
      externalNode = make_shared<bool>(boost::any_cast<bool>(m["ExternalNode"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
  }


  virtual ~AddEthereumNodeRequest() = default;
};
class AddEthereumNodeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<string> ethereumId{};
  shared_ptr<string> ethereumName{};
  shared_ptr<string> id{};
  shared_ptr<string> networkId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> publicIp{};
  shared_ptr<string> regionId{};
  shared_ptr<long> rpcPort{};
  shared_ptr<string> state{};
  shared_ptr<long> wsPort{};

  AddEthereumNodeResponseBodyResult() {}

  explicit AddEthereumNodeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ethereumId) {
      res["EthereumId"] = boost::any(*ethereumId);
    }
    if (ethereumName) {
      res["EthereumName"] = boost::any(*ethereumName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (publicIp) {
      res["PublicIp"] = boost::any(*publicIp);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (rpcPort) {
      res["RpcPort"] = boost::any(*rpcPort);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (wsPort) {
      res["WsPort"] = boost::any(*wsPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EthereumId") != m.end() && !m["EthereumId"].empty()) {
      ethereumId = make_shared<string>(boost::any_cast<string>(m["EthereumId"]));
    }
    if (m.find("EthereumName") != m.end() && !m["EthereumName"].empty()) {
      ethereumName = make_shared<string>(boost::any_cast<string>(m["EthereumName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("PublicIp") != m.end() && !m["PublicIp"].empty()) {
      publicIp = make_shared<string>(boost::any_cast<string>(m["PublicIp"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RpcPort") != m.end() && !m["RpcPort"].empty()) {
      rpcPort = make_shared<long>(boost::any_cast<long>(m["RpcPort"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("WsPort") != m.end() && !m["WsPort"].empty()) {
      wsPort = make_shared<long>(boost::any_cast<long>(m["WsPort"]));
    }
  }


  virtual ~AddEthereumNodeResponseBodyResult() = default;
};
class AddEthereumNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<AddEthereumNodeResponseBodyResult> result{};
  shared_ptr<bool> success{};

  AddEthereumNodeResponseBody() {}

  explicit AddEthereumNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        AddEthereumNodeResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<AddEthereumNodeResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddEthereumNodeResponseBody() = default;
};
class AddEthereumNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddEthereumNodeResponseBody> body{};

  AddEthereumNodeResponse() {}

  explicit AddEthereumNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddEthereumNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddEthereumNodeResponseBody>(model1);
      }
    }
  }


  virtual ~AddEthereumNodeResponse() = default;
};
class AddFabricExternalOrganizationToChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> description{};
  shared_ptr<string> joinRequest{};
  shared_ptr<string> organizationId{};

  AddFabricExternalOrganizationToChannelRequest() {}

  explicit AddFabricExternalOrganizationToChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (joinRequest) {
      res["JoinRequest"] = boost::any(*joinRequest);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("JoinRequest") != m.end() && !m["JoinRequest"].empty()) {
      joinRequest = make_shared<string>(boost::any_cast<string>(m["JoinRequest"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~AddFabricExternalOrganizationToChannelRequest() = default;
};
class AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizationsAnchorPeers : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<long> port{};

  AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizationsAnchorPeers() {}

  explicit AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizationsAnchorPeers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
  }


  virtual ~AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizationsAnchorPeers() = default;
};
class AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizationsOrdererNodes : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> certificate{};
  shared_ptr<string> key{};
  shared_ptr<string> tlsroot{};

  AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizationsOrdererNodes() {}

  explicit AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizationsOrdererNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (tlsroot) {
      res["Tlsroot"] = boost::any(*tlsroot);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Tlsroot") != m.end() && !m["Tlsroot"].empty()) {
      tlsroot = make_shared<string>(boost::any_cast<string>(m["Tlsroot"]));
    }
  }


  virtual ~AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizationsOrdererNodes() = default;
};
class AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizations : public Darabonba::Model {
public:
  shared_ptr<vector<AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizationsAnchorPeers>> anchorPeers{};
  shared_ptr<string> crls{};
  shared_ptr<string> mspId{};
  shared_ptr<string> mspType{};
  shared_ptr<bool> orderer{};
  shared_ptr<vector<AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizationsOrdererNodes>> ordererNodes{};
  shared_ptr<string> rootCertificates{};
  shared_ptr<string> tlsRootCertificates{};

  AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizations() {}

  explicit AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (anchorPeers) {
      vector<boost::any> temp1;
      for(auto item1:*anchorPeers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnchorPeers"] = boost::any(temp1);
    }
    if (crls) {
      res["Crls"] = boost::any(*crls);
    }
    if (mspId) {
      res["MspId"] = boost::any(*mspId);
    }
    if (mspType) {
      res["MspType"] = boost::any(*mspType);
    }
    if (orderer) {
      res["Orderer"] = boost::any(*orderer);
    }
    if (ordererNodes) {
      vector<boost::any> temp1;
      for(auto item1:*ordererNodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OrdererNodes"] = boost::any(temp1);
    }
    if (rootCertificates) {
      res["RootCertificates"] = boost::any(*rootCertificates);
    }
    if (tlsRootCertificates) {
      res["TlsRootCertificates"] = boost::any(*tlsRootCertificates);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnchorPeers") != m.end() && !m["AnchorPeers"].empty()) {
      if (typeid(vector<boost::any>) == m["AnchorPeers"].type()) {
        vector<AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizationsAnchorPeers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnchorPeers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizationsAnchorPeers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        anchorPeers = make_shared<vector<AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizationsAnchorPeers>>(expect1);
      }
    }
    if (m.find("Crls") != m.end() && !m["Crls"].empty()) {
      crls = make_shared<string>(boost::any_cast<string>(m["Crls"]));
    }
    if (m.find("MspId") != m.end() && !m["MspId"].empty()) {
      mspId = make_shared<string>(boost::any_cast<string>(m["MspId"]));
    }
    if (m.find("MspType") != m.end() && !m["MspType"].empty()) {
      mspType = make_shared<string>(boost::any_cast<string>(m["MspType"]));
    }
    if (m.find("Orderer") != m.end() && !m["Orderer"].empty()) {
      orderer = make_shared<bool>(boost::any_cast<bool>(m["Orderer"]));
    }
    if (m.find("OrdererNodes") != m.end() && !m["OrdererNodes"].empty()) {
      if (typeid(vector<boost::any>) == m["OrdererNodes"].type()) {
        vector<AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizationsOrdererNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OrdererNodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizationsOrdererNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ordererNodes = make_shared<vector<AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizationsOrdererNodes>>(expect1);
      }
    }
    if (m.find("RootCertificates") != m.end() && !m["RootCertificates"].empty()) {
      rootCertificates = make_shared<string>(boost::any_cast<string>(m["RootCertificates"]));
    }
    if (m.find("TlsRootCertificates") != m.end() && !m["TlsRootCertificates"].empty()) {
      tlsRootCertificates = make_shared<string>(boost::any_cast<string>(m["TlsRootCertificates"]));
    }
  }


  virtual ~AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizations() = default;
};
class AddFabricExternalOrganizationToChannelResponseBodyResultContentChaincodeSpecPkgCs : public Darabonba::Model {
public:
  shared_ptr<string> input{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<long> type{};
  shared_ptr<string> version{};

  AddFabricExternalOrganizationToChannelResponseBodyResultContentChaincodeSpecPkgCs() {}

  explicit AddFabricExternalOrganizationToChannelResponseBodyResultContentChaincodeSpecPkgCs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~AddFabricExternalOrganizationToChannelResponseBodyResultContentChaincodeSpecPkgCs() = default;
};
class AddFabricExternalOrganizationToChannelResponseBodyResultContentChaincodeSpecPkg : public Darabonba::Model {
public:
  shared_ptr<AddFabricExternalOrganizationToChannelResponseBodyResultContentChaincodeSpecPkgCs> cs{};
  shared_ptr<string> policy{};
  shared_ptr<string> sha256{};

  AddFabricExternalOrganizationToChannelResponseBodyResultContentChaincodeSpecPkg() {}

  explicit AddFabricExternalOrganizationToChannelResponseBodyResultContentChaincodeSpecPkg(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cs) {
      res["Cs"] = cs ? boost::any(cs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (sha256) {
      res["Sha256"] = boost::any(*sha256);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cs") != m.end() && !m["Cs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cs"].type()) {
        AddFabricExternalOrganizationToChannelResponseBodyResultContentChaincodeSpecPkgCs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cs"]));
        cs = make_shared<AddFabricExternalOrganizationToChannelResponseBodyResultContentChaincodeSpecPkgCs>(model1);
      }
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Sha256") != m.end() && !m["Sha256"].empty()) {
      sha256 = make_shared<string>(boost::any_cast<string>(m["Sha256"]));
    }
  }


  virtual ~AddFabricExternalOrganizationToChannelResponseBodyResultContentChaincodeSpecPkg() = default;
};
class AddFabricExternalOrganizationToChannelResponseBodyResultContentOrdererConfig : public Darabonba::Model {
public:
  shared_ptr<string> batchTimeout{};
  shared_ptr<long> maxMessageCount{};
  shared_ptr<long> preferredMaxBytes{};

  AddFabricExternalOrganizationToChannelResponseBodyResultContentOrdererConfig() {}

  explicit AddFabricExternalOrganizationToChannelResponseBodyResultContentOrdererConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchTimeout) {
      res["BatchTimeout"] = boost::any(*batchTimeout);
    }
    if (maxMessageCount) {
      res["MaxMessageCount"] = boost::any(*maxMessageCount);
    }
    if (preferredMaxBytes) {
      res["PreferredMaxBytes"] = boost::any(*preferredMaxBytes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchTimeout") != m.end() && !m["BatchTimeout"].empty()) {
      batchTimeout = make_shared<string>(boost::any_cast<string>(m["BatchTimeout"]));
    }
    if (m.find("MaxMessageCount") != m.end() && !m["MaxMessageCount"].empty()) {
      maxMessageCount = make_shared<long>(boost::any_cast<long>(m["MaxMessageCount"]));
    }
    if (m.find("PreferredMaxBytes") != m.end() && !m["PreferredMaxBytes"].empty()) {
      preferredMaxBytes = make_shared<long>(boost::any_cast<long>(m["PreferredMaxBytes"]));
    }
  }


  virtual ~AddFabricExternalOrganizationToChannelResponseBodyResultContentOrdererConfig() = default;
};
class AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizationsAnchorPeers : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<long> port{};

  AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizationsAnchorPeers() {}

  explicit AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizationsAnchorPeers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
  }


  virtual ~AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizationsAnchorPeers() = default;
};
class AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizationsOrdererNodes : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> certificate{};
  shared_ptr<string> key{};
  shared_ptr<string> tlsroot{};

  AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizationsOrdererNodes() {}

  explicit AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizationsOrdererNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (tlsroot) {
      res["Tlsroot"] = boost::any(*tlsroot);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Tlsroot") != m.end() && !m["Tlsroot"].empty()) {
      tlsroot = make_shared<string>(boost::any_cast<string>(m["Tlsroot"]));
    }
  }


  virtual ~AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizationsOrdererNodes() = default;
};
class AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizations : public Darabonba::Model {
public:
  shared_ptr<vector<AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizationsAnchorPeers>> anchorPeers{};
  shared_ptr<string> crls{};
  shared_ptr<string> mspId{};
  shared_ptr<string> mspType{};
  shared_ptr<bool> orderer{};
  shared_ptr<vector<AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizationsOrdererNodes>> ordererNodes{};
  shared_ptr<string> rootCertificates{};
  shared_ptr<string> tlsRootCertificates{};

  AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizations() {}

  explicit AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (anchorPeers) {
      vector<boost::any> temp1;
      for(auto item1:*anchorPeers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnchorPeers"] = boost::any(temp1);
    }
    if (crls) {
      res["Crls"] = boost::any(*crls);
    }
    if (mspId) {
      res["MspId"] = boost::any(*mspId);
    }
    if (mspType) {
      res["MspType"] = boost::any(*mspType);
    }
    if (orderer) {
      res["Orderer"] = boost::any(*orderer);
    }
    if (ordererNodes) {
      vector<boost::any> temp1;
      for(auto item1:*ordererNodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OrdererNodes"] = boost::any(temp1);
    }
    if (rootCertificates) {
      res["RootCertificates"] = boost::any(*rootCertificates);
    }
    if (tlsRootCertificates) {
      res["TlsRootCertificates"] = boost::any(*tlsRootCertificates);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnchorPeers") != m.end() && !m["AnchorPeers"].empty()) {
      if (typeid(vector<boost::any>) == m["AnchorPeers"].type()) {
        vector<AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizationsAnchorPeers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnchorPeers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizationsAnchorPeers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        anchorPeers = make_shared<vector<AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizationsAnchorPeers>>(expect1);
      }
    }
    if (m.find("Crls") != m.end() && !m["Crls"].empty()) {
      crls = make_shared<string>(boost::any_cast<string>(m["Crls"]));
    }
    if (m.find("MspId") != m.end() && !m["MspId"].empty()) {
      mspId = make_shared<string>(boost::any_cast<string>(m["MspId"]));
    }
    if (m.find("MspType") != m.end() && !m["MspType"].empty()) {
      mspType = make_shared<string>(boost::any_cast<string>(m["MspType"]));
    }
    if (m.find("Orderer") != m.end() && !m["Orderer"].empty()) {
      orderer = make_shared<bool>(boost::any_cast<bool>(m["Orderer"]));
    }
    if (m.find("OrdererNodes") != m.end() && !m["OrdererNodes"].empty()) {
      if (typeid(vector<boost::any>) == m["OrdererNodes"].type()) {
        vector<AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizationsOrdererNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OrdererNodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizationsOrdererNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ordererNodes = make_shared<vector<AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizationsOrdererNodes>>(expect1);
      }
    }
    if (m.find("RootCertificates") != m.end() && !m["RootCertificates"].empty()) {
      rootCertificates = make_shared<string>(boost::any_cast<string>(m["RootCertificates"]));
    }
    if (m.find("TlsRootCertificates") != m.end() && !m["TlsRootCertificates"].empty()) {
      tlsRootCertificates = make_shared<string>(boost::any_cast<string>(m["TlsRootCertificates"]));
    }
  }


  virtual ~AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizations() = default;
};
class AddFabricExternalOrganizationToChannelResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<vector<AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizations>> addedOrganizations{};
  shared_ptr<AddFabricExternalOrganizationToChannelResponseBodyResultContentChaincodeSpecPkg> chaincodeSpecPkg{};
  shared_ptr<AddFabricExternalOrganizationToChannelResponseBodyResultContentOrdererConfig> ordererConfig{};
  shared_ptr<string> raw{};
  shared_ptr<vector<AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizations>> removedOrganizations{};
  shared_ptr<string> rwSets{};

  AddFabricExternalOrganizationToChannelResponseBodyResultContent() {}

  explicit AddFabricExternalOrganizationToChannelResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addedOrganizations) {
      vector<boost::any> temp1;
      for(auto item1:*addedOrganizations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AddedOrganizations"] = boost::any(temp1);
    }
    if (chaincodeSpecPkg) {
      res["ChaincodeSpecPkg"] = chaincodeSpecPkg ? boost::any(chaincodeSpecPkg->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ordererConfig) {
      res["OrdererConfig"] = ordererConfig ? boost::any(ordererConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (raw) {
      res["Raw"] = boost::any(*raw);
    }
    if (removedOrganizations) {
      vector<boost::any> temp1;
      for(auto item1:*removedOrganizations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RemovedOrganizations"] = boost::any(temp1);
    }
    if (rwSets) {
      res["RwSets"] = boost::any(*rwSets);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddedOrganizations") != m.end() && !m["AddedOrganizations"].empty()) {
      if (typeid(vector<boost::any>) == m["AddedOrganizations"].type()) {
        vector<AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AddedOrganizations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addedOrganizations = make_shared<vector<AddFabricExternalOrganizationToChannelResponseBodyResultContentAddedOrganizations>>(expect1);
      }
    }
    if (m.find("ChaincodeSpecPkg") != m.end() && !m["ChaincodeSpecPkg"].empty()) {
      if (typeid(map<string, boost::any>) == m["ChaincodeSpecPkg"].type()) {
        AddFabricExternalOrganizationToChannelResponseBodyResultContentChaincodeSpecPkg model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ChaincodeSpecPkg"]));
        chaincodeSpecPkg = make_shared<AddFabricExternalOrganizationToChannelResponseBodyResultContentChaincodeSpecPkg>(model1);
      }
    }
    if (m.find("OrdererConfig") != m.end() && !m["OrdererConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OrdererConfig"].type()) {
        AddFabricExternalOrganizationToChannelResponseBodyResultContentOrdererConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OrdererConfig"]));
        ordererConfig = make_shared<AddFabricExternalOrganizationToChannelResponseBodyResultContentOrdererConfig>(model1);
      }
    }
    if (m.find("Raw") != m.end() && !m["Raw"].empty()) {
      raw = make_shared<string>(boost::any_cast<string>(m["Raw"]));
    }
    if (m.find("RemovedOrganizations") != m.end() && !m["RemovedOrganizations"].empty()) {
      if (typeid(vector<boost::any>) == m["RemovedOrganizations"].type()) {
        vector<AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RemovedOrganizations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        removedOrganizations = make_shared<vector<AddFabricExternalOrganizationToChannelResponseBodyResultContentRemovedOrganizations>>(expect1);
      }
    }
    if (m.find("RwSets") != m.end() && !m["RwSets"].empty()) {
      rwSets = make_shared<string>(boost::any_cast<string>(m["RwSets"]));
    }
  }


  virtual ~AddFabricExternalOrganizationToChannelResponseBodyResultContent() = default;
};
class AddFabricExternalOrganizationToChannelResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<AddFabricExternalOrganizationToChannelResponseBodyResultContent> content{};
  shared_ptr<long> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> type{};

  AddFabricExternalOrganizationToChannelResponseBodyResult() {}

  explicit AddFabricExternalOrganizationToChannelResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        AddFabricExternalOrganizationToChannelResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<AddFabricExternalOrganizationToChannelResponseBodyResultContent>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AddFabricExternalOrganizationToChannelResponseBodyResult() = default;
};
class AddFabricExternalOrganizationToChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<AddFabricExternalOrganizationToChannelResponseBodyResult> result{};
  shared_ptr<bool> success{};

  AddFabricExternalOrganizationToChannelResponseBody() {}

  explicit AddFabricExternalOrganizationToChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        AddFabricExternalOrganizationToChannelResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<AddFabricExternalOrganizationToChannelResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddFabricExternalOrganizationToChannelResponseBody() = default;
};
class AddFabricExternalOrganizationToChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddFabricExternalOrganizationToChannelResponseBody> body{};

  AddFabricExternalOrganizationToChannelResponse() {}

  explicit AddFabricExternalOrganizationToChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddFabricExternalOrganizationToChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddFabricExternalOrganizationToChannelResponseBody>(model1);
      }
    }
  }


  virtual ~AddFabricExternalOrganizationToChannelResponse() = default;
};
class AddFabricOrganizationToExternalChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> joinResponse{};
  shared_ptr<string> organizationId{};

  AddFabricOrganizationToExternalChannelRequest() {}

  explicit AddFabricOrganizationToExternalChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (joinResponse) {
      res["JoinResponse"] = boost::any(*joinResponse);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JoinResponse") != m.end() && !m["JoinResponse"].empty()) {
      joinResponse = make_shared<string>(boost::any_cast<string>(m["JoinResponse"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~AddFabricOrganizationToExternalChannelRequest() = default;
};
class AddFabricOrganizationToExternalChannelResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> m{};
  shared_ptr<long> n{};

  AddFabricOrganizationToExternalChannelResponseBodyResult() {}

  explicit AddFabricOrganizationToExternalChannelResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (m) {
      res["M"] = boost::any(*m);
    }
    if (n) {
      res["N"] = boost::any(*n);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("M") != m.end() && !m["M"].empty()) {
      m = make_shared<long>(boost::any_cast<long>(m["M"]));
    }
    if (m.find("N") != m.end() && !m["N"].empty()) {
      n = make_shared<long>(boost::any_cast<long>(m["N"]));
    }
  }


  virtual ~AddFabricOrganizationToExternalChannelResponseBodyResult() = default;
};
class AddFabricOrganizationToExternalChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<AddFabricOrganizationToExternalChannelResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  AddFabricOrganizationToExternalChannelResponseBody() {}

  explicit AddFabricOrganizationToExternalChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<AddFabricOrganizationToExternalChannelResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddFabricOrganizationToExternalChannelResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<AddFabricOrganizationToExternalChannelResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AddFabricOrganizationToExternalChannelResponseBody() = default;
};
class AddFabricOrganizationToExternalChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddFabricOrganizationToExternalChannelResponseBody> body{};

  AddFabricOrganizationToExternalChannelResponse() {}

  explicit AddFabricOrganizationToExternalChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddFabricOrganizationToExternalChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddFabricOrganizationToExternalChannelResponseBody>(model1);
      }
    }
  }


  virtual ~AddFabricOrganizationToExternalChannelResponse() = default;
};
class ApplyAntChainRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> uploadReq{};

  ApplyAntChainRequest() {}

  explicit ApplyAntChainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (uploadReq) {
      res["UploadReq"] = boost::any(*uploadReq);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("UploadReq") != m.end() && !m["UploadReq"].empty()) {
      uploadReq = make_shared<string>(boost::any_cast<string>(m["UploadReq"]));
    }
  }


  virtual ~ApplyAntChainRequest() = default;
};
class ApplyAntChainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  ApplyAntChainResponseBody() {}

  explicit ApplyAntChainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~ApplyAntChainResponseBody() = default;
};
class ApplyAntChainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyAntChainResponseBody> body{};

  ApplyAntChainResponse() {}

  explicit ApplyAntChainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyAntChainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyAntChainResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyAntChainResponse() = default;
};
class ApplyAntChainCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> uploadReq{};

  ApplyAntChainCertificateRequest() {}

  explicit ApplyAntChainCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (uploadReq) {
      res["UploadReq"] = boost::any(*uploadReq);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("UploadReq") != m.end() && !m["UploadReq"].empty()) {
      uploadReq = make_shared<string>(boost::any_cast<string>(m["UploadReq"]));
    }
  }


  virtual ~ApplyAntChainCertificateRequest() = default;
};
class ApplyAntChainCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  ApplyAntChainCertificateResponseBody() {}

  explicit ApplyAntChainCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~ApplyAntChainCertificateResponseBody() = default;
};
class ApplyAntChainCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyAntChainCertificateResponseBody> body{};

  ApplyAntChainCertificateResponse() {}

  explicit ApplyAntChainCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyAntChainCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyAntChainCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyAntChainCertificateResponse() = default;
};
class ApplyAntChainCertificateWithKeyAutoCreationRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> commonName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> countryName{};
  shared_ptr<string> localityName{};
  shared_ptr<string> organizationName{};
  shared_ptr<string> organizationUnitName{};
  shared_ptr<string> password{};
  shared_ptr<string> stateOrProvinceName{};

  ApplyAntChainCertificateWithKeyAutoCreationRequest() {}

  explicit ApplyAntChainCertificateWithKeyAutoCreationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (commonName) {
      res["CommonName"] = boost::any(*commonName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (countryName) {
      res["CountryName"] = boost::any(*countryName);
    }
    if (localityName) {
      res["LocalityName"] = boost::any(*localityName);
    }
    if (organizationName) {
      res["OrganizationName"] = boost::any(*organizationName);
    }
    if (organizationUnitName) {
      res["OrganizationUnitName"] = boost::any(*organizationUnitName);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (stateOrProvinceName) {
      res["StateOrProvinceName"] = boost::any(*stateOrProvinceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("CommonName") != m.end() && !m["CommonName"].empty()) {
      commonName = make_shared<string>(boost::any_cast<string>(m["CommonName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CountryName") != m.end() && !m["CountryName"].empty()) {
      countryName = make_shared<string>(boost::any_cast<string>(m["CountryName"]));
    }
    if (m.find("LocalityName") != m.end() && !m["LocalityName"].empty()) {
      localityName = make_shared<string>(boost::any_cast<string>(m["LocalityName"]));
    }
    if (m.find("OrganizationName") != m.end() && !m["OrganizationName"].empty()) {
      organizationName = make_shared<string>(boost::any_cast<string>(m["OrganizationName"]));
    }
    if (m.find("OrganizationUnitName") != m.end() && !m["OrganizationUnitName"].empty()) {
      organizationUnitName = make_shared<string>(boost::any_cast<string>(m["OrganizationUnitName"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("StateOrProvinceName") != m.end() && !m["StateOrProvinceName"].empty()) {
      stateOrProvinceName = make_shared<string>(boost::any_cast<string>(m["StateOrProvinceName"]));
    }
  }


  virtual ~ApplyAntChainCertificateWithKeyAutoCreationRequest() = default;
};
class ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResultDownloadPath : public Darabonba::Model {
public:
  shared_ptr<string> caCrtUrl{};
  shared_ptr<string> clientCrtUrl{};
  shared_ptr<string> sdkUrl{};
  shared_ptr<string> trustCaUrl{};

  ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResultDownloadPath() {}

  explicit ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResultDownloadPath(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caCrtUrl) {
      res["CaCrtUrl"] = boost::any(*caCrtUrl);
    }
    if (clientCrtUrl) {
      res["ClientCrtUrl"] = boost::any(*clientCrtUrl);
    }
    if (sdkUrl) {
      res["SdkUrl"] = boost::any(*sdkUrl);
    }
    if (trustCaUrl) {
      res["TrustCaUrl"] = boost::any(*trustCaUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaCrtUrl") != m.end() && !m["CaCrtUrl"].empty()) {
      caCrtUrl = make_shared<string>(boost::any_cast<string>(m["CaCrtUrl"]));
    }
    if (m.find("ClientCrtUrl") != m.end() && !m["ClientCrtUrl"].empty()) {
      clientCrtUrl = make_shared<string>(boost::any_cast<string>(m["ClientCrtUrl"]));
    }
    if (m.find("SdkUrl") != m.end() && !m["SdkUrl"].empty()) {
      sdkUrl = make_shared<string>(boost::any_cast<string>(m["SdkUrl"]));
    }
    if (m.find("TrustCaUrl") != m.end() && !m["TrustCaUrl"].empty()) {
      trustCaUrl = make_shared<string>(boost::any_cast<string>(m["TrustCaUrl"]));
    }
  }


  virtual ~ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResultDownloadPath() = default;
};
class ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResultDownloadPath> downloadPath{};
  shared_ptr<string> privateKey{};

  ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResult() {}

  explicit ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadPath) {
      res["DownloadPath"] = downloadPath ? boost::any(downloadPath->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (privateKey) {
      res["PrivateKey"] = boost::any(*privateKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadPath") != m.end() && !m["DownloadPath"].empty()) {
      if (typeid(map<string, boost::any>) == m["DownloadPath"].type()) {
        ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResultDownloadPath model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DownloadPath"]));
        downloadPath = make_shared<ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResultDownloadPath>(model1);
      }
    }
    if (m.find("PrivateKey") != m.end() && !m["PrivateKey"].empty()) {
      privateKey = make_shared<string>(boost::any_cast<string>(m["PrivateKey"]));
    }
  }


  virtual ~ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResult() = default;
};
class ApplyAntChainCertificateWithKeyAutoCreationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResult> result{};

  ApplyAntChainCertificateWithKeyAutoCreationResponseBody() {}

  explicit ApplyAntChainCertificateWithKeyAutoCreationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResult>(model1);
      }
    }
  }


  virtual ~ApplyAntChainCertificateWithKeyAutoCreationResponseBody() = default;
};
class ApplyAntChainCertificateWithKeyAutoCreationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyAntChainCertificateWithKeyAutoCreationResponseBody> body{};

  ApplyAntChainCertificateWithKeyAutoCreationResponse() {}

  explicit ApplyAntChainCertificateWithKeyAutoCreationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyAntChainCertificateWithKeyAutoCreationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyAntChainCertificateWithKeyAutoCreationResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyAntChainCertificateWithKeyAutoCreationResponse() = default;
};
class ApplyAntChainWithKeyAutoCreationRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> commonName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> countryName{};
  shared_ptr<string> localityName{};
  shared_ptr<string> organizationName{};
  shared_ptr<string> organizationUnitName{};
  shared_ptr<string> password{};
  shared_ptr<string> stateOrProvinceName{};

  ApplyAntChainWithKeyAutoCreationRequest() {}

  explicit ApplyAntChainWithKeyAutoCreationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (commonName) {
      res["CommonName"] = boost::any(*commonName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (countryName) {
      res["CountryName"] = boost::any(*countryName);
    }
    if (localityName) {
      res["LocalityName"] = boost::any(*localityName);
    }
    if (organizationName) {
      res["OrganizationName"] = boost::any(*organizationName);
    }
    if (organizationUnitName) {
      res["OrganizationUnitName"] = boost::any(*organizationUnitName);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (stateOrProvinceName) {
      res["StateOrProvinceName"] = boost::any(*stateOrProvinceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("CommonName") != m.end() && !m["CommonName"].empty()) {
      commonName = make_shared<string>(boost::any_cast<string>(m["CommonName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CountryName") != m.end() && !m["CountryName"].empty()) {
      countryName = make_shared<string>(boost::any_cast<string>(m["CountryName"]));
    }
    if (m.find("LocalityName") != m.end() && !m["LocalityName"].empty()) {
      localityName = make_shared<string>(boost::any_cast<string>(m["LocalityName"]));
    }
    if (m.find("OrganizationName") != m.end() && !m["OrganizationName"].empty()) {
      organizationName = make_shared<string>(boost::any_cast<string>(m["OrganizationName"]));
    }
    if (m.find("OrganizationUnitName") != m.end() && !m["OrganizationUnitName"].empty()) {
      organizationUnitName = make_shared<string>(boost::any_cast<string>(m["OrganizationUnitName"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("StateOrProvinceName") != m.end() && !m["StateOrProvinceName"].empty()) {
      stateOrProvinceName = make_shared<string>(boost::any_cast<string>(m["StateOrProvinceName"]));
    }
  }


  virtual ~ApplyAntChainWithKeyAutoCreationRequest() = default;
};
class ApplyAntChainWithKeyAutoCreationResponseBodyResultDownloadPath : public Darabonba::Model {
public:
  shared_ptr<string> caCrtUrl{};
  shared_ptr<string> clientCrtUrl{};
  shared_ptr<string> sdkUrl{};
  shared_ptr<string> trustCaUrl{};

  ApplyAntChainWithKeyAutoCreationResponseBodyResultDownloadPath() {}

  explicit ApplyAntChainWithKeyAutoCreationResponseBodyResultDownloadPath(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caCrtUrl) {
      res["CaCrtUrl"] = boost::any(*caCrtUrl);
    }
    if (clientCrtUrl) {
      res["ClientCrtUrl"] = boost::any(*clientCrtUrl);
    }
    if (sdkUrl) {
      res["SdkUrl"] = boost::any(*sdkUrl);
    }
    if (trustCaUrl) {
      res["TrustCaUrl"] = boost::any(*trustCaUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaCrtUrl") != m.end() && !m["CaCrtUrl"].empty()) {
      caCrtUrl = make_shared<string>(boost::any_cast<string>(m["CaCrtUrl"]));
    }
    if (m.find("ClientCrtUrl") != m.end() && !m["ClientCrtUrl"].empty()) {
      clientCrtUrl = make_shared<string>(boost::any_cast<string>(m["ClientCrtUrl"]));
    }
    if (m.find("SdkUrl") != m.end() && !m["SdkUrl"].empty()) {
      sdkUrl = make_shared<string>(boost::any_cast<string>(m["SdkUrl"]));
    }
    if (m.find("TrustCaUrl") != m.end() && !m["TrustCaUrl"].empty()) {
      trustCaUrl = make_shared<string>(boost::any_cast<string>(m["TrustCaUrl"]));
    }
  }


  virtual ~ApplyAntChainWithKeyAutoCreationResponseBodyResultDownloadPath() = default;
};
class ApplyAntChainWithKeyAutoCreationResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<ApplyAntChainWithKeyAutoCreationResponseBodyResultDownloadPath> downloadPath{};
  shared_ptr<string> privateKey{};

  ApplyAntChainWithKeyAutoCreationResponseBodyResult() {}

  explicit ApplyAntChainWithKeyAutoCreationResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadPath) {
      res["DownloadPath"] = downloadPath ? boost::any(downloadPath->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (privateKey) {
      res["PrivateKey"] = boost::any(*privateKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadPath") != m.end() && !m["DownloadPath"].empty()) {
      if (typeid(map<string, boost::any>) == m["DownloadPath"].type()) {
        ApplyAntChainWithKeyAutoCreationResponseBodyResultDownloadPath model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DownloadPath"]));
        downloadPath = make_shared<ApplyAntChainWithKeyAutoCreationResponseBodyResultDownloadPath>(model1);
      }
    }
    if (m.find("PrivateKey") != m.end() && !m["PrivateKey"].empty()) {
      privateKey = make_shared<string>(boost::any_cast<string>(m["PrivateKey"]));
    }
  }


  virtual ~ApplyAntChainWithKeyAutoCreationResponseBodyResult() = default;
};
class ApplyAntChainWithKeyAutoCreationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ApplyAntChainWithKeyAutoCreationResponseBodyResult> result{};

  ApplyAntChainWithKeyAutoCreationResponseBody() {}

  explicit ApplyAntChainWithKeyAutoCreationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ApplyAntChainWithKeyAutoCreationResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ApplyAntChainWithKeyAutoCreationResponseBodyResult>(model1);
      }
    }
  }


  virtual ~ApplyAntChainWithKeyAutoCreationResponseBody() = default;
};
class ApplyAntChainWithKeyAutoCreationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyAntChainWithKeyAutoCreationResponseBody> body{};

  ApplyAntChainWithKeyAutoCreationResponse() {}

  explicit ApplyAntChainWithKeyAutoCreationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyAntChainWithKeyAutoCreationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyAntChainWithKeyAutoCreationResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyAntChainWithKeyAutoCreationResponse() = default;
};
class ApplyBlockchainRequest : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> accountPubKey{};
  shared_ptr<string> accountRecoverPubKey{};
  shared_ptr<string> blockchain{};
  shared_ptr<string> uploadReq{};

  ApplyBlockchainRequest() {}

  explicit ApplyBlockchainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (accountPubKey) {
      res["AccountPubKey"] = boost::any(*accountPubKey);
    }
    if (accountRecoverPubKey) {
      res["AccountRecoverPubKey"] = boost::any(*accountRecoverPubKey);
    }
    if (blockchain) {
      res["Blockchain"] = boost::any(*blockchain);
    }
    if (uploadReq) {
      res["UploadReq"] = boost::any(*uploadReq);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("AccountPubKey") != m.end() && !m["AccountPubKey"].empty()) {
      accountPubKey = make_shared<string>(boost::any_cast<string>(m["AccountPubKey"]));
    }
    if (m.find("AccountRecoverPubKey") != m.end() && !m["AccountRecoverPubKey"].empty()) {
      accountRecoverPubKey = make_shared<string>(boost::any_cast<string>(m["AccountRecoverPubKey"]));
    }
    if (m.find("Blockchain") != m.end() && !m["Blockchain"].empty()) {
      blockchain = make_shared<string>(boost::any_cast<string>(m["Blockchain"]));
    }
    if (m.find("UploadReq") != m.end() && !m["UploadReq"].empty()) {
      uploadReq = make_shared<string>(boost::any_cast<string>(m["UploadReq"]));
    }
  }


  virtual ~ApplyBlockchainRequest() = default;
};
class ApplyBlockchainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  ApplyBlockchainResponseBody() {}

  explicit ApplyBlockchainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~ApplyBlockchainResponseBody() = default;
};
class ApplyBlockchainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyBlockchainResponseBody> body{};

  ApplyBlockchainResponse() {}

  explicit ApplyBlockchainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyBlockchainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyBlockchainResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyBlockchainResponse() = default;
};
class ApplyBlockchainWithKeyAutoCreationRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<string> commonName{};
  shared_ptr<string> countryName{};
  shared_ptr<string> localityName{};
  shared_ptr<string> organizationName{};
  shared_ptr<string> organizationUnitName{};
  shared_ptr<string> password{};
  shared_ptr<string> stateOrProvinceName{};

  ApplyBlockchainWithKeyAutoCreationRequest() {}

  explicit ApplyBlockchainWithKeyAutoCreationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (commonName) {
      res["CommonName"] = boost::any(*commonName);
    }
    if (countryName) {
      res["CountryName"] = boost::any(*countryName);
    }
    if (localityName) {
      res["LocalityName"] = boost::any(*localityName);
    }
    if (organizationName) {
      res["OrganizationName"] = boost::any(*organizationName);
    }
    if (organizationUnitName) {
      res["OrganizationUnitName"] = boost::any(*organizationUnitName);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (stateOrProvinceName) {
      res["StateOrProvinceName"] = boost::any(*stateOrProvinceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("CommonName") != m.end() && !m["CommonName"].empty()) {
      commonName = make_shared<string>(boost::any_cast<string>(m["CommonName"]));
    }
    if (m.find("CountryName") != m.end() && !m["CountryName"].empty()) {
      countryName = make_shared<string>(boost::any_cast<string>(m["CountryName"]));
    }
    if (m.find("LocalityName") != m.end() && !m["LocalityName"].empty()) {
      localityName = make_shared<string>(boost::any_cast<string>(m["LocalityName"]));
    }
    if (m.find("OrganizationName") != m.end() && !m["OrganizationName"].empty()) {
      organizationName = make_shared<string>(boost::any_cast<string>(m["OrganizationName"]));
    }
    if (m.find("OrganizationUnitName") != m.end() && !m["OrganizationUnitName"].empty()) {
      organizationUnitName = make_shared<string>(boost::any_cast<string>(m["OrganizationUnitName"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("StateOrProvinceName") != m.end() && !m["StateOrProvinceName"].empty()) {
      stateOrProvinceName = make_shared<string>(boost::any_cast<string>(m["StateOrProvinceName"]));
    }
  }


  virtual ~ApplyBlockchainWithKeyAutoCreationRequest() = default;
};
class ApplyBlockchainWithKeyAutoCreationResponseBodyResultDownloadPath : public Darabonba::Model {
public:
  shared_ptr<string> bizviewUrl{};
  shared_ptr<string> certUrl{};
  shared_ptr<string> sdkUrl{};

  ApplyBlockchainWithKeyAutoCreationResponseBodyResultDownloadPath() {}

  explicit ApplyBlockchainWithKeyAutoCreationResponseBodyResultDownloadPath(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizviewUrl) {
      res["BizviewUrl"] = boost::any(*bizviewUrl);
    }
    if (certUrl) {
      res["CertUrl"] = boost::any(*certUrl);
    }
    if (sdkUrl) {
      res["SdkUrl"] = boost::any(*sdkUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizviewUrl") != m.end() && !m["BizviewUrl"].empty()) {
      bizviewUrl = make_shared<string>(boost::any_cast<string>(m["BizviewUrl"]));
    }
    if (m.find("CertUrl") != m.end() && !m["CertUrl"].empty()) {
      certUrl = make_shared<string>(boost::any_cast<string>(m["CertUrl"]));
    }
    if (m.find("SdkUrl") != m.end() && !m["SdkUrl"].empty()) {
      sdkUrl = make_shared<string>(boost::any_cast<string>(m["SdkUrl"]));
    }
  }


  virtual ~ApplyBlockchainWithKeyAutoCreationResponseBodyResultDownloadPath() = default;
};
class ApplyBlockchainWithKeyAutoCreationResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<ApplyBlockchainWithKeyAutoCreationResponseBodyResultDownloadPath> downloadPath{};
  shared_ptr<string> privateKey{};

  ApplyBlockchainWithKeyAutoCreationResponseBodyResult() {}

  explicit ApplyBlockchainWithKeyAutoCreationResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadPath) {
      res["DownloadPath"] = downloadPath ? boost::any(downloadPath->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (privateKey) {
      res["PrivateKey"] = boost::any(*privateKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadPath") != m.end() && !m["DownloadPath"].empty()) {
      if (typeid(map<string, boost::any>) == m["DownloadPath"].type()) {
        ApplyBlockchainWithKeyAutoCreationResponseBodyResultDownloadPath model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DownloadPath"]));
        downloadPath = make_shared<ApplyBlockchainWithKeyAutoCreationResponseBodyResultDownloadPath>(model1);
      }
    }
    if (m.find("PrivateKey") != m.end() && !m["PrivateKey"].empty()) {
      privateKey = make_shared<string>(boost::any_cast<string>(m["PrivateKey"]));
    }
  }


  virtual ~ApplyBlockchainWithKeyAutoCreationResponseBodyResult() = default;
};
class ApplyBlockchainWithKeyAutoCreationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ApplyBlockchainWithKeyAutoCreationResponseBodyResult> result{};

  ApplyBlockchainWithKeyAutoCreationResponseBody() {}

  explicit ApplyBlockchainWithKeyAutoCreationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ApplyBlockchainWithKeyAutoCreationResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ApplyBlockchainWithKeyAutoCreationResponseBodyResult>(model1);
      }
    }
  }


  virtual ~ApplyBlockchainWithKeyAutoCreationResponseBody() = default;
};
class ApplyBlockchainWithKeyAutoCreationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyBlockchainWithKeyAutoCreationResponseBody> body{};

  ApplyBlockchainWithKeyAutoCreationResponse() {}

  explicit ApplyBlockchainWithKeyAutoCreationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyBlockchainWithKeyAutoCreationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyBlockchainWithKeyAutoCreationResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyBlockchainWithKeyAutoCreationResponse() = default;
};
class ApplyPublicAntChainRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> uploadReq{};

  ApplyPublicAntChainRequest() {}

  explicit ApplyPublicAntChainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (uploadReq) {
      res["UploadReq"] = boost::any(*uploadReq);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("UploadReq") != m.end() && !m["UploadReq"].empty()) {
      uploadReq = make_shared<string>(boost::any_cast<string>(m["UploadReq"]));
    }
  }


  virtual ~ApplyPublicAntChainRequest() = default;
};
class ApplyPublicAntChainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  ApplyPublicAntChainResponseBody() {}

  explicit ApplyPublicAntChainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~ApplyPublicAntChainResponseBody() = default;
};
class ApplyPublicAntChainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyPublicAntChainResponseBody> body{};

  ApplyPublicAntChainResponse() {}

  explicit ApplyPublicAntChainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyPublicAntChainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyPublicAntChainResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyPublicAntChainResponse() = default;
};
class ApplyPublicAntChainWithKeyAutoCreationRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<string> commonName{};
  shared_ptr<string> countryName{};
  shared_ptr<string> localityName{};
  shared_ptr<string> organizationName{};
  shared_ptr<string> organizationUnitName{};
  shared_ptr<string> password{};
  shared_ptr<string> stateOrProvinceName{};

  ApplyPublicAntChainWithKeyAutoCreationRequest() {}

  explicit ApplyPublicAntChainWithKeyAutoCreationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (commonName) {
      res["CommonName"] = boost::any(*commonName);
    }
    if (countryName) {
      res["CountryName"] = boost::any(*countryName);
    }
    if (localityName) {
      res["LocalityName"] = boost::any(*localityName);
    }
    if (organizationName) {
      res["OrganizationName"] = boost::any(*organizationName);
    }
    if (organizationUnitName) {
      res["OrganizationUnitName"] = boost::any(*organizationUnitName);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (stateOrProvinceName) {
      res["StateOrProvinceName"] = boost::any(*stateOrProvinceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("CommonName") != m.end() && !m["CommonName"].empty()) {
      commonName = make_shared<string>(boost::any_cast<string>(m["CommonName"]));
    }
    if (m.find("CountryName") != m.end() && !m["CountryName"].empty()) {
      countryName = make_shared<string>(boost::any_cast<string>(m["CountryName"]));
    }
    if (m.find("LocalityName") != m.end() && !m["LocalityName"].empty()) {
      localityName = make_shared<string>(boost::any_cast<string>(m["LocalityName"]));
    }
    if (m.find("OrganizationName") != m.end() && !m["OrganizationName"].empty()) {
      organizationName = make_shared<string>(boost::any_cast<string>(m["OrganizationName"]));
    }
    if (m.find("OrganizationUnitName") != m.end() && !m["OrganizationUnitName"].empty()) {
      organizationUnitName = make_shared<string>(boost::any_cast<string>(m["OrganizationUnitName"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("StateOrProvinceName") != m.end() && !m["StateOrProvinceName"].empty()) {
      stateOrProvinceName = make_shared<string>(boost::any_cast<string>(m["StateOrProvinceName"]));
    }
  }


  virtual ~ApplyPublicAntChainWithKeyAutoCreationRequest() = default;
};
class ApplyPublicAntChainWithKeyAutoCreationResponseBodyResultDownloadPath : public Darabonba::Model {
public:
  shared_ptr<string> caCrtUrl{};
  shared_ptr<string> clientCrtUrl{};
  shared_ptr<string> sdkUrl{};
  shared_ptr<string> trustCaUrl{};

  ApplyPublicAntChainWithKeyAutoCreationResponseBodyResultDownloadPath() {}

  explicit ApplyPublicAntChainWithKeyAutoCreationResponseBodyResultDownloadPath(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caCrtUrl) {
      res["CaCrtUrl"] = boost::any(*caCrtUrl);
    }
    if (clientCrtUrl) {
      res["ClientCrtUrl"] = boost::any(*clientCrtUrl);
    }
    if (sdkUrl) {
      res["SdkUrl"] = boost::any(*sdkUrl);
    }
    if (trustCaUrl) {
      res["TrustCaUrl"] = boost::any(*trustCaUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaCrtUrl") != m.end() && !m["CaCrtUrl"].empty()) {
      caCrtUrl = make_shared<string>(boost::any_cast<string>(m["CaCrtUrl"]));
    }
    if (m.find("ClientCrtUrl") != m.end() && !m["ClientCrtUrl"].empty()) {
      clientCrtUrl = make_shared<string>(boost::any_cast<string>(m["ClientCrtUrl"]));
    }
    if (m.find("SdkUrl") != m.end() && !m["SdkUrl"].empty()) {
      sdkUrl = make_shared<string>(boost::any_cast<string>(m["SdkUrl"]));
    }
    if (m.find("TrustCaUrl") != m.end() && !m["TrustCaUrl"].empty()) {
      trustCaUrl = make_shared<string>(boost::any_cast<string>(m["TrustCaUrl"]));
    }
  }


  virtual ~ApplyPublicAntChainWithKeyAutoCreationResponseBodyResultDownloadPath() = default;
};
class ApplyPublicAntChainWithKeyAutoCreationResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<ApplyPublicAntChainWithKeyAutoCreationResponseBodyResultDownloadPath> downloadPath{};
  shared_ptr<string> privateKey{};

  ApplyPublicAntChainWithKeyAutoCreationResponseBodyResult() {}

  explicit ApplyPublicAntChainWithKeyAutoCreationResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadPath) {
      res["DownloadPath"] = downloadPath ? boost::any(downloadPath->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (privateKey) {
      res["PrivateKey"] = boost::any(*privateKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadPath") != m.end() && !m["DownloadPath"].empty()) {
      if (typeid(map<string, boost::any>) == m["DownloadPath"].type()) {
        ApplyPublicAntChainWithKeyAutoCreationResponseBodyResultDownloadPath model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DownloadPath"]));
        downloadPath = make_shared<ApplyPublicAntChainWithKeyAutoCreationResponseBodyResultDownloadPath>(model1);
      }
    }
    if (m.find("PrivateKey") != m.end() && !m["PrivateKey"].empty()) {
      privateKey = make_shared<string>(boost::any_cast<string>(m["PrivateKey"]));
    }
  }


  virtual ~ApplyPublicAntChainWithKeyAutoCreationResponseBodyResult() = default;
};
class ApplyPublicAntChainWithKeyAutoCreationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ApplyPublicAntChainWithKeyAutoCreationResponseBodyResult> result{};

  ApplyPublicAntChainWithKeyAutoCreationResponseBody() {}

  explicit ApplyPublicAntChainWithKeyAutoCreationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ApplyPublicAntChainWithKeyAutoCreationResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ApplyPublicAntChainWithKeyAutoCreationResponseBodyResult>(model1);
      }
    }
  }


  virtual ~ApplyPublicAntChainWithKeyAutoCreationResponseBody() = default;
};
class ApplyPublicAntChainWithKeyAutoCreationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyPublicAntChainWithKeyAutoCreationResponseBody> body{};

  ApplyPublicAntChainWithKeyAutoCreationResponse() {}

  explicit ApplyPublicAntChainWithKeyAutoCreationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyPublicAntChainWithKeyAutoCreationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyPublicAntChainWithKeyAutoCreationResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyPublicAntChainWithKeyAutoCreationResponse() = default;
};
class ApproveEthereumInviteeRequestInvitee : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  ApproveEthereumInviteeRequestInvitee() {}

  explicit ApproveEthereumInviteeRequestInvitee(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ApproveEthereumInviteeRequestInvitee() = default;
};
class ApproveEthereumInviteeRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<vector<ApproveEthereumInviteeRequestInvitee>> invitee{};

  ApproveEthereumInviteeRequest() {}

  explicit ApproveEthereumInviteeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (invitee) {
      vector<boost::any> temp1;
      for(auto item1:*invitee){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Invitee"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Invitee") != m.end() && !m["Invitee"].empty()) {
      if (typeid(vector<boost::any>) == m["Invitee"].type()) {
        vector<ApproveEthereumInviteeRequestInvitee> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Invitee"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ApproveEthereumInviteeRequestInvitee model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        invitee = make_shared<vector<ApproveEthereumInviteeRequestInvitee>>(expect1);
      }
    }
  }


  virtual ~ApproveEthereumInviteeRequest() = default;
};
class ApproveEthereumInviteeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  ApproveEthereumInviteeResponseBody() {}

  explicit ApproveEthereumInviteeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ApproveEthereumInviteeResponseBody() = default;
};
class ApproveEthereumInviteeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApproveEthereumInviteeResponseBody> body{};

  ApproveEthereumInviteeResponse() {}

  explicit ApproveEthereumInviteeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApproveEthereumInviteeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApproveEthereumInviteeResponseBody>(model1);
      }
    }
  }


  virtual ~ApproveEthereumInviteeResponse() = default;
};
class ApproveFabricChaincodeDefinitionRequest : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> chaincodePackageId{};
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};

  ApproveFabricChaincodeDefinitionRequest() {}

  explicit ApproveFabricChaincodeDefinitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (chaincodePackageId) {
      res["ChaincodePackageId"] = boost::any(*chaincodePackageId);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("ChaincodePackageId") != m.end() && !m["ChaincodePackageId"].empty()) {
      chaincodePackageId = make_shared<string>(boost::any_cast<string>(m["ChaincodePackageId"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~ApproveFabricChaincodeDefinitionRequest() = default;
};
class ApproveFabricChaincodeDefinitionResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> channelName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deployTime{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<string> input{};
  shared_ptr<bool> install{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<string> providerId{};
  shared_ptr<string> providerName{};
  shared_ptr<string> state{};
  shared_ptr<long> type{};
  shared_ptr<string> version{};

  ApproveFabricChaincodeDefinitionResponseBodyResult() {}

  explicit ApproveFabricChaincodeDefinitionResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deployTime) {
      res["DeployTime"] = boost::any(*deployTime);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (install) {
      res["Install"] = boost::any(*install);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (providerId) {
      res["ProviderId"] = boost::any(*providerId);
    }
    if (providerName) {
      res["ProviderName"] = boost::any(*providerName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeployTime") != m.end() && !m["DeployTime"].empty()) {
      deployTime = make_shared<string>(boost::any_cast<string>(m["DeployTime"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Install") != m.end() && !m["Install"].empty()) {
      install = make_shared<bool>(boost::any_cast<bool>(m["Install"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ProviderId") != m.end() && !m["ProviderId"].empty()) {
      providerId = make_shared<string>(boost::any_cast<string>(m["ProviderId"]));
    }
    if (m.find("ProviderName") != m.end() && !m["ProviderName"].empty()) {
      providerName = make_shared<string>(boost::any_cast<string>(m["ProviderName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ApproveFabricChaincodeDefinitionResponseBodyResult() = default;
};
class ApproveFabricChaincodeDefinitionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeDefinitionId{};
  shared_ptr<string> chaincodePackageId{};
  shared_ptr<long> errorCode{};
  shared_ptr<bool> initRequired{};
  shared_ptr<string> requestId{};
  shared_ptr<ApproveFabricChaincodeDefinitionResponseBodyResult> result{};
  shared_ptr<bool> success{};

  ApproveFabricChaincodeDefinitionResponseBody() {}

  explicit ApproveFabricChaincodeDefinitionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeDefinitionId) {
      res["ChaincodeDefinitionId"] = boost::any(*chaincodeDefinitionId);
    }
    if (chaincodePackageId) {
      res["ChaincodePackageId"] = boost::any(*chaincodePackageId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (initRequired) {
      res["InitRequired"] = boost::any(*initRequired);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeDefinitionId") != m.end() && !m["ChaincodeDefinitionId"].empty()) {
      chaincodeDefinitionId = make_shared<string>(boost::any_cast<string>(m["ChaincodeDefinitionId"]));
    }
    if (m.find("ChaincodePackageId") != m.end() && !m["ChaincodePackageId"].empty()) {
      chaincodePackageId = make_shared<string>(boost::any_cast<string>(m["ChaincodePackageId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("InitRequired") != m.end() && !m["InitRequired"].empty()) {
      initRequired = make_shared<bool>(boost::any_cast<bool>(m["InitRequired"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ApproveFabricChaincodeDefinitionResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ApproveFabricChaincodeDefinitionResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ApproveFabricChaincodeDefinitionResponseBody() = default;
};
class ApproveFabricChaincodeDefinitionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApproveFabricChaincodeDefinitionResponseBody> body{};

  ApproveFabricChaincodeDefinitionResponse() {}

  explicit ApproveFabricChaincodeDefinitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApproveFabricChaincodeDefinitionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApproveFabricChaincodeDefinitionResponseBody>(model1);
      }
    }
  }


  virtual ~ApproveFabricChaincodeDefinitionResponse() = default;
};
class BatchAddAntChainMiniAppQRCodeAuthorizedUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<map<string, boost::any>> phoneList{};

  BatchAddAntChainMiniAppQRCodeAuthorizedUsersRequest() {}

  explicit BatchAddAntChainMiniAppQRCodeAuthorizedUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (phoneList) {
      res["PhoneList"] = boost::any(*phoneList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("PhoneList") != m.end() && !m["PhoneList"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["PhoneList"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      phoneList = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~BatchAddAntChainMiniAppQRCodeAuthorizedUsersRequest() = default;
};
class BatchAddAntChainMiniAppQRCodeAuthorizedUsersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> phoneListShrink{};

  BatchAddAntChainMiniAppQRCodeAuthorizedUsersShrinkRequest() {}

  explicit BatchAddAntChainMiniAppQRCodeAuthorizedUsersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (phoneListShrink) {
      res["PhoneList"] = boost::any(*phoneListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("PhoneList") != m.end() && !m["PhoneList"].empty()) {
      phoneListShrink = make_shared<string>(boost::any_cast<string>(m["PhoneList"]));
    }
  }


  virtual ~BatchAddAntChainMiniAppQRCodeAuthorizedUsersShrinkRequest() = default;
};
class BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponseBody() {}

  explicit BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponseBody() = default;
};
class BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponseBody> body{};

  BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponse() {}

  explicit BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponseBody>(model1);
      }
    }
  }


  virtual ~BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponse() = default;
};
class BindFabricManagementChaincodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> organizationId{};

  BindFabricManagementChaincodeRequest() {}

  explicit BindFabricManagementChaincodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~BindFabricManagementChaincodeRequest() = default;
};
class BindFabricManagementChaincodeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> input{};
  shared_ptr<string> name{};
  shared_ptr<long> path{};
  shared_ptr<long> type{};
  shared_ptr<string> version{};

  BindFabricManagementChaincodeResponseBodyResult() {}

  explicit BindFabricManagementChaincodeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<long>(boost::any_cast<long>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~BindFabricManagementChaincodeResponseBodyResult() = default;
};
class BindFabricManagementChaincodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<BindFabricManagementChaincodeResponseBodyResult> result{};
  shared_ptr<bool> success{};

  BindFabricManagementChaincodeResponseBody() {}

  explicit BindFabricManagementChaincodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        BindFabricManagementChaincodeResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<BindFabricManagementChaincodeResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~BindFabricManagementChaincodeResponseBody() = default;
};
class BindFabricManagementChaincodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BindFabricManagementChaincodeResponseBody> body{};

  BindFabricManagementChaincodeResponse() {}

  explicit BindFabricManagementChaincodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindFabricManagementChaincodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindFabricManagementChaincodeResponseBody>(model1);
      }
    }
  }


  virtual ~BindFabricManagementChaincodeResponse() = default;
};
class CheckConsortiumDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainCode{};

  CheckConsortiumDomainRequest() {}

  explicit CheckConsortiumDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainCode) {
      res["DomainCode"] = boost::any(*domainCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainCode") != m.end() && !m["DomainCode"].empty()) {
      domainCode = make_shared<string>(boost::any_cast<string>(m["DomainCode"]));
    }
  }


  virtual ~CheckConsortiumDomainRequest() = default;
};
class CheckConsortiumDomainResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> prompt{};
  shared_ptr<bool> valid{};

  CheckConsortiumDomainResponseBodyResult() {}

  explicit CheckConsortiumDomainResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (valid) {
      res["Valid"] = boost::any(*valid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("Valid") != m.end() && !m["Valid"].empty()) {
      valid = make_shared<bool>(boost::any_cast<bool>(m["Valid"]));
    }
  }


  virtual ~CheckConsortiumDomainResponseBodyResult() = default;
};
class CheckConsortiumDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<CheckConsortiumDomainResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CheckConsortiumDomainResponseBody() {}

  explicit CheckConsortiumDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CheckConsortiumDomainResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CheckConsortiumDomainResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CheckConsortiumDomainResponseBody() = default;
};
class CheckConsortiumDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckConsortiumDomainResponseBody> body{};

  CheckConsortiumDomainResponse() {}

  explicit CheckConsortiumDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckConsortiumDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckConsortiumDomainResponseBody>(model1);
      }
    }
  }


  virtual ~CheckConsortiumDomainResponse() = default;
};
class CheckOrganizationDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> domainCode{};

  CheckOrganizationDomainRequest() {}

  explicit CheckOrganizationDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (domainCode) {
      res["DomainCode"] = boost::any(*domainCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("DomainCode") != m.end() && !m["DomainCode"].empty()) {
      domainCode = make_shared<string>(boost::any_cast<string>(m["DomainCode"]));
    }
  }


  virtual ~CheckOrganizationDomainRequest() = default;
};
class CheckOrganizationDomainResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> prompt{};
  shared_ptr<bool> valid{};

  CheckOrganizationDomainResponseBodyResult() {}

  explicit CheckOrganizationDomainResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (valid) {
      res["Valid"] = boost::any(*valid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("Valid") != m.end() && !m["Valid"].empty()) {
      valid = make_shared<bool>(boost::any_cast<bool>(m["Valid"]));
    }
  }


  virtual ~CheckOrganizationDomainResponseBodyResult() = default;
};
class CheckOrganizationDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<CheckOrganizationDomainResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CheckOrganizationDomainResponseBody() {}

  explicit CheckOrganizationDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CheckOrganizationDomainResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CheckOrganizationDomainResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CheckOrganizationDomainResponseBody() = default;
};
class CheckOrganizationDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckOrganizationDomainResponseBody> body{};

  CheckOrganizationDomainResponse() {}

  explicit CheckOrganizationDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckOrganizationDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckOrganizationDomainResponseBody>(model1);
      }
    }
  }


  virtual ~CheckOrganizationDomainResponse() = default;
};
class ConfirmConsortiumMemberRequestOrganization : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  ConfirmConsortiumMemberRequestOrganization() {}

  explicit ConfirmConsortiumMemberRequestOrganization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~ConfirmConsortiumMemberRequestOrganization() = default;
};
class ConfirmConsortiumMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<vector<ConfirmConsortiumMemberRequestOrganization>> organization{};

  ConfirmConsortiumMemberRequest() {}

  explicit ConfirmConsortiumMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (organization) {
      vector<boost::any> temp1;
      for(auto item1:*organization){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Organization"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Organization") != m.end() && !m["Organization"].empty()) {
      if (typeid(vector<boost::any>) == m["Organization"].type()) {
        vector<ConfirmConsortiumMemberRequestOrganization> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Organization"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ConfirmConsortiumMemberRequestOrganization model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        organization = make_shared<vector<ConfirmConsortiumMemberRequestOrganization>>(expect1);
      }
    }
  }


  virtual ~ConfirmConsortiumMemberRequest() = default;
};
class ConfirmConsortiumMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};
  shared_ptr<bool> success{};

  ConfirmConsortiumMemberResponseBody() {}

  explicit ConfirmConsortiumMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ConfirmConsortiumMemberResponseBody() = default;
};
class ConfirmConsortiumMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfirmConsortiumMemberResponseBody> body{};

  ConfirmConsortiumMemberResponse() {}

  explicit ConfirmConsortiumMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfirmConsortiumMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfirmConsortiumMemberResponseBody>(model1);
      }
    }
  }


  virtual ~ConfirmConsortiumMemberResponse() = default;
};
class CopyAntChainContractProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectDescription{};
  shared_ptr<string> projectId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> projectVersion{};

  CopyAntChainContractProjectRequest() {}

  explicit CopyAntChainContractProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectDescription) {
      res["ProjectDescription"] = boost::any(*projectDescription);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (projectVersion) {
      res["ProjectVersion"] = boost::any(*projectVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectDescription") != m.end() && !m["ProjectDescription"].empty()) {
      projectDescription = make_shared<string>(boost::any_cast<string>(m["ProjectDescription"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProjectVersion") != m.end() && !m["ProjectVersion"].empty()) {
      projectVersion = make_shared<string>(boost::any_cast<string>(m["ProjectVersion"]));
    }
  }


  virtual ~CopyAntChainContractProjectRequest() = default;
};
class CopyAntChainContractProjectResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> projectDescription{};
  shared_ptr<string> projectId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> projectVersion{};
  shared_ptr<long> updateTime{};

  CopyAntChainContractProjectResponseBodyResult() {}

  explicit CopyAntChainContractProjectResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (projectDescription) {
      res["ProjectDescription"] = boost::any(*projectDescription);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (projectVersion) {
      res["ProjectVersion"] = boost::any(*projectVersion);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ProjectDescription") != m.end() && !m["ProjectDescription"].empty()) {
      projectDescription = make_shared<string>(boost::any_cast<string>(m["ProjectDescription"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProjectVersion") != m.end() && !m["ProjectVersion"].empty()) {
      projectVersion = make_shared<string>(boost::any_cast<string>(m["ProjectVersion"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~CopyAntChainContractProjectResponseBodyResult() = default;
};
class CopyAntChainContractProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CopyAntChainContractProjectResponseBodyResult> result{};

  CopyAntChainContractProjectResponseBody() {}

  explicit CopyAntChainContractProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CopyAntChainContractProjectResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CopyAntChainContractProjectResponseBodyResult>(model1);
      }
    }
  }


  virtual ~CopyAntChainContractProjectResponseBody() = default;
};
class CopyAntChainContractProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CopyAntChainContractProjectResponseBody> body{};

  CopyAntChainContractProjectResponse() {}

  explicit CopyAntChainContractProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CopyAntChainContractProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CopyAntChainContractProjectResponseBody>(model1);
      }
    }
  }


  virtual ~CopyAntChainContractProjectResponse() = default;
};
class CreateAccessTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessTokenLifetime{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> refreshTokenLifetime{};
  shared_ptr<string> scope{};

  CreateAccessTokenRequest() {}

  explicit CreateAccessTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessTokenLifetime) {
      res["AccessTokenLifetime"] = boost::any(*accessTokenLifetime);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (refreshTokenLifetime) {
      res["RefreshTokenLifetime"] = boost::any(*refreshTokenLifetime);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessTokenLifetime") != m.end() && !m["AccessTokenLifetime"].empty()) {
      accessTokenLifetime = make_shared<string>(boost::any_cast<string>(m["AccessTokenLifetime"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("RefreshTokenLifetime") != m.end() && !m["RefreshTokenLifetime"].empty()) {
      refreshTokenLifetime = make_shared<string>(boost::any_cast<string>(m["RefreshTokenLifetime"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
  }


  virtual ~CreateAccessTokenRequest() = default;
};
class CreateAccessTokenResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<long> expiresIn{};
  shared_ptr<string> refreshToken{};
  shared_ptr<string> tokenType{};

  CreateAccessTokenResponseBodyResult() {}

  explicit CreateAccessTokenResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["AccessToken"] = boost::any(*accessToken);
    }
    if (expiresIn) {
      res["ExpiresIn"] = boost::any(*expiresIn);
    }
    if (refreshToken) {
      res["RefreshToken"] = boost::any(*refreshToken);
    }
    if (tokenType) {
      res["TokenType"] = boost::any(*tokenType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessToken") != m.end() && !m["AccessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["AccessToken"]));
    }
    if (m.find("ExpiresIn") != m.end() && !m["ExpiresIn"].empty()) {
      expiresIn = make_shared<long>(boost::any_cast<long>(m["ExpiresIn"]));
    }
    if (m.find("RefreshToken") != m.end() && !m["RefreshToken"].empty()) {
      refreshToken = make_shared<string>(boost::any_cast<string>(m["RefreshToken"]));
    }
    if (m.find("TokenType") != m.end() && !m["TokenType"].empty()) {
      tokenType = make_shared<string>(boost::any_cast<string>(m["TokenType"]));
    }
  }


  virtual ~CreateAccessTokenResponseBodyResult() = default;
};
class CreateAccessTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateAccessTokenResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateAccessTokenResponseBody() {}

  explicit CreateAccessTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateAccessTokenResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateAccessTokenResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateAccessTokenResponseBody() = default;
};
class CreateAccessTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAccessTokenResponseBody> body{};

  CreateAccessTokenResponse() {}

  explicit CreateAccessTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAccessTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAccessTokenResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAccessTokenResponse() = default;
};
class CreateAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> accountPubKey{};
  shared_ptr<string> accountRecoverPubKey{};
  shared_ptr<string> bizid{};

  CreateAccountRequest() {}

  explicit CreateAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (accountPubKey) {
      res["AccountPubKey"] = boost::any(*accountPubKey);
    }
    if (accountRecoverPubKey) {
      res["AccountRecoverPubKey"] = boost::any(*accountRecoverPubKey);
    }
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("AccountPubKey") != m.end() && !m["AccountPubKey"].empty()) {
      accountPubKey = make_shared<string>(boost::any_cast<string>(m["AccountPubKey"]));
    }
    if (m.find("AccountRecoverPubKey") != m.end() && !m["AccountRecoverPubKey"].empty()) {
      accountRecoverPubKey = make_shared<string>(boost::any_cast<string>(m["AccountRecoverPubKey"]));
    }
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~CreateAccountRequest() = default;
};
class CreateAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  CreateAccountResponseBody() {}

  explicit CreateAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~CreateAccountResponseBody() = default;
};
class CreateAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAccountResponseBody> body{};

  CreateAccountResponse() {}

  explicit CreateAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAccountResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAccountResponse() = default;
};
class CreateAccountWithKeyPairAutoCreationRequest : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> bizid{};
  shared_ptr<string> password{};

  CreateAccountWithKeyPairAutoCreationRequest() {}

  explicit CreateAccountWithKeyPairAutoCreationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
  }


  virtual ~CreateAccountWithKeyPairAutoCreationRequest() = default;
};
class CreateAccountWithKeyPairAutoCreationResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> accountPrivateKey{};
  shared_ptr<string> accountPublicKey{};
  shared_ptr<string> accountRecoverPrivateKey{};
  shared_ptr<string> accountRecoverPublicKey{};

  CreateAccountWithKeyPairAutoCreationResponseBodyResult() {}

  explicit CreateAccountWithKeyPairAutoCreationResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountPrivateKey) {
      res["AccountPrivateKey"] = boost::any(*accountPrivateKey);
    }
    if (accountPublicKey) {
      res["AccountPublicKey"] = boost::any(*accountPublicKey);
    }
    if (accountRecoverPrivateKey) {
      res["AccountRecoverPrivateKey"] = boost::any(*accountRecoverPrivateKey);
    }
    if (accountRecoverPublicKey) {
      res["AccountRecoverPublicKey"] = boost::any(*accountRecoverPublicKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountPrivateKey") != m.end() && !m["AccountPrivateKey"].empty()) {
      accountPrivateKey = make_shared<string>(boost::any_cast<string>(m["AccountPrivateKey"]));
    }
    if (m.find("AccountPublicKey") != m.end() && !m["AccountPublicKey"].empty()) {
      accountPublicKey = make_shared<string>(boost::any_cast<string>(m["AccountPublicKey"]));
    }
    if (m.find("AccountRecoverPrivateKey") != m.end() && !m["AccountRecoverPrivateKey"].empty()) {
      accountRecoverPrivateKey = make_shared<string>(boost::any_cast<string>(m["AccountRecoverPrivateKey"]));
    }
    if (m.find("AccountRecoverPublicKey") != m.end() && !m["AccountRecoverPublicKey"].empty()) {
      accountRecoverPublicKey = make_shared<string>(boost::any_cast<string>(m["AccountRecoverPublicKey"]));
    }
  }


  virtual ~CreateAccountWithKeyPairAutoCreationResponseBodyResult() = default;
};
class CreateAccountWithKeyPairAutoCreationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateAccountWithKeyPairAutoCreationResponseBodyResult> result{};

  CreateAccountWithKeyPairAutoCreationResponseBody() {}

  explicit CreateAccountWithKeyPairAutoCreationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateAccountWithKeyPairAutoCreationResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateAccountWithKeyPairAutoCreationResponseBodyResult>(model1);
      }
    }
  }


  virtual ~CreateAccountWithKeyPairAutoCreationResponseBody() = default;
};
class CreateAccountWithKeyPairAutoCreationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAccountWithKeyPairAutoCreationResponseBody> body{};

  CreateAccountWithKeyPairAutoCreationResponse() {}

  explicit CreateAccountWithKeyPairAutoCreationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAccountWithKeyPairAutoCreationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAccountWithKeyPairAutoCreationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAccountWithKeyPairAutoCreationResponse() = default;
};
class CreateAntChainRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainName{};
  shared_ptr<string> blockchainRegionId{};
  shared_ptr<string> cipherSuit{};
  shared_ptr<string> consortiumId{};
  shared_ptr<long> liveTime{};
  shared_ptr<string> merkleTreeSuit{};
  shared_ptr<long> nodeNum{};
  shared_ptr<long> resourceSize{};
  shared_ptr<string> tlsAlgo{};

  CreateAntChainRequest() {}

  explicit CreateAntChainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainName) {
      res["AntChainName"] = boost::any(*antChainName);
    }
    if (blockchainRegionId) {
      res["BlockchainRegionId"] = boost::any(*blockchainRegionId);
    }
    if (cipherSuit) {
      res["CipherSuit"] = boost::any(*cipherSuit);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (liveTime) {
      res["LiveTime"] = boost::any(*liveTime);
    }
    if (merkleTreeSuit) {
      res["MerkleTreeSuit"] = boost::any(*merkleTreeSuit);
    }
    if (nodeNum) {
      res["NodeNum"] = boost::any(*nodeNum);
    }
    if (resourceSize) {
      res["ResourceSize"] = boost::any(*resourceSize);
    }
    if (tlsAlgo) {
      res["TlsAlgo"] = boost::any(*tlsAlgo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainName") != m.end() && !m["AntChainName"].empty()) {
      antChainName = make_shared<string>(boost::any_cast<string>(m["AntChainName"]));
    }
    if (m.find("BlockchainRegionId") != m.end() && !m["BlockchainRegionId"].empty()) {
      blockchainRegionId = make_shared<string>(boost::any_cast<string>(m["BlockchainRegionId"]));
    }
    if (m.find("CipherSuit") != m.end() && !m["CipherSuit"].empty()) {
      cipherSuit = make_shared<string>(boost::any_cast<string>(m["CipherSuit"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("LiveTime") != m.end() && !m["LiveTime"].empty()) {
      liveTime = make_shared<long>(boost::any_cast<long>(m["LiveTime"]));
    }
    if (m.find("MerkleTreeSuit") != m.end() && !m["MerkleTreeSuit"].empty()) {
      merkleTreeSuit = make_shared<string>(boost::any_cast<string>(m["MerkleTreeSuit"]));
    }
    if (m.find("NodeNum") != m.end() && !m["NodeNum"].empty()) {
      nodeNum = make_shared<long>(boost::any_cast<long>(m["NodeNum"]));
    }
    if (m.find("ResourceSize") != m.end() && !m["ResourceSize"].empty()) {
      resourceSize = make_shared<long>(boost::any_cast<long>(m["ResourceSize"]));
    }
    if (m.find("TlsAlgo") != m.end() && !m["TlsAlgo"].empty()) {
      tlsAlgo = make_shared<string>(boost::any_cast<string>(m["TlsAlgo"]));
    }
  }


  virtual ~CreateAntChainRequest() = default;
};
class CreateAntChainResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};

  CreateAntChainResponseBodyResult() {}

  explicit CreateAntChainResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
  }


  virtual ~CreateAntChainResponseBodyResult() = default;
};
class CreateAntChainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateAntChainResponseBodyResult> result{};

  CreateAntChainResponseBody() {}

  explicit CreateAntChainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateAntChainResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateAntChainResponseBodyResult>(model1);
      }
    }
  }


  virtual ~CreateAntChainResponseBody() = default;
};
class CreateAntChainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAntChainResponseBody> body{};

  CreateAntChainResponse() {}

  explicit CreateAntChainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAntChainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAntChainResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAntChainResponse() = default;
};
class CreateAntChainAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> accountPubKey{};
  shared_ptr<string> accountRecoverPubKey{};
  shared_ptr<string> antChainId{};

  CreateAntChainAccountRequest() {}

  explicit CreateAntChainAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (accountPubKey) {
      res["AccountPubKey"] = boost::any(*accountPubKey);
    }
    if (accountRecoverPubKey) {
      res["AccountRecoverPubKey"] = boost::any(*accountRecoverPubKey);
    }
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("AccountPubKey") != m.end() && !m["AccountPubKey"].empty()) {
      accountPubKey = make_shared<string>(boost::any_cast<string>(m["AccountPubKey"]));
    }
    if (m.find("AccountRecoverPubKey") != m.end() && !m["AccountRecoverPubKey"].empty()) {
      accountRecoverPubKey = make_shared<string>(boost::any_cast<string>(m["AccountRecoverPubKey"]));
    }
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
  }


  virtual ~CreateAntChainAccountRequest() = default;
};
class CreateAntChainAccountResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> antChainId{};

  CreateAntChainAccountResponseBodyResult() {}

  explicit CreateAntChainAccountResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
  }


  virtual ~CreateAntChainAccountResponseBodyResult() = default;
};
class CreateAntChainAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateAntChainAccountResponseBodyResult> result{};

  CreateAntChainAccountResponseBody() {}

  explicit CreateAntChainAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateAntChainAccountResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateAntChainAccountResponseBodyResult>(model1);
      }
    }
  }


  virtual ~CreateAntChainAccountResponseBody() = default;
};
class CreateAntChainAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAntChainAccountResponseBody> body{};

  CreateAntChainAccountResponse() {}

  explicit CreateAntChainAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAntChainAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAntChainAccountResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAntChainAccountResponse() = default;
};
class CreateAntChainAccountWithKeyPairAutoCreationRequest : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> antChainId{};
  shared_ptr<string> password{};
  shared_ptr<string> recoverPassword{};

  CreateAntChainAccountWithKeyPairAutoCreationRequest() {}

  explicit CreateAntChainAccountWithKeyPairAutoCreationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (recoverPassword) {
      res["RecoverPassword"] = boost::any(*recoverPassword);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("RecoverPassword") != m.end() && !m["RecoverPassword"].empty()) {
      recoverPassword = make_shared<string>(boost::any_cast<string>(m["RecoverPassword"]));
    }
  }


  virtual ~CreateAntChainAccountWithKeyPairAutoCreationRequest() = default;
};
class CreateAntChainAccountWithKeyPairAutoCreationResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> accountPrivateKey{};
  shared_ptr<string> accountPublicKey{};
  shared_ptr<string> accountRecoverPrivateKey{};
  shared_ptr<string> accountRecoverPublicKey{};
  shared_ptr<string> antChainId{};

  CreateAntChainAccountWithKeyPairAutoCreationResponseBodyResult() {}

  explicit CreateAntChainAccountWithKeyPairAutoCreationResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (accountPrivateKey) {
      res["AccountPrivateKey"] = boost::any(*accountPrivateKey);
    }
    if (accountPublicKey) {
      res["AccountPublicKey"] = boost::any(*accountPublicKey);
    }
    if (accountRecoverPrivateKey) {
      res["AccountRecoverPrivateKey"] = boost::any(*accountRecoverPrivateKey);
    }
    if (accountRecoverPublicKey) {
      res["AccountRecoverPublicKey"] = boost::any(*accountRecoverPublicKey);
    }
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("AccountPrivateKey") != m.end() && !m["AccountPrivateKey"].empty()) {
      accountPrivateKey = make_shared<string>(boost::any_cast<string>(m["AccountPrivateKey"]));
    }
    if (m.find("AccountPublicKey") != m.end() && !m["AccountPublicKey"].empty()) {
      accountPublicKey = make_shared<string>(boost::any_cast<string>(m["AccountPublicKey"]));
    }
    if (m.find("AccountRecoverPrivateKey") != m.end() && !m["AccountRecoverPrivateKey"].empty()) {
      accountRecoverPrivateKey = make_shared<string>(boost::any_cast<string>(m["AccountRecoverPrivateKey"]));
    }
    if (m.find("AccountRecoverPublicKey") != m.end() && !m["AccountRecoverPublicKey"].empty()) {
      accountRecoverPublicKey = make_shared<string>(boost::any_cast<string>(m["AccountRecoverPublicKey"]));
    }
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
  }


  virtual ~CreateAntChainAccountWithKeyPairAutoCreationResponseBodyResult() = default;
};
class CreateAntChainAccountWithKeyPairAutoCreationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateAntChainAccountWithKeyPairAutoCreationResponseBodyResult> result{};

  CreateAntChainAccountWithKeyPairAutoCreationResponseBody() {}

  explicit CreateAntChainAccountWithKeyPairAutoCreationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateAntChainAccountWithKeyPairAutoCreationResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateAntChainAccountWithKeyPairAutoCreationResponseBodyResult>(model1);
      }
    }
  }


  virtual ~CreateAntChainAccountWithKeyPairAutoCreationResponseBody() = default;
};
class CreateAntChainAccountWithKeyPairAutoCreationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAntChainAccountWithKeyPairAutoCreationResponseBody> body{};

  CreateAntChainAccountWithKeyPairAutoCreationResponse() {}

  explicit CreateAntChainAccountWithKeyPairAutoCreationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAntChainAccountWithKeyPairAutoCreationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAntChainAccountWithKeyPairAutoCreationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAntChainAccountWithKeyPairAutoCreationResponse() = default;
};
class CreateAntChainConsortiumRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumDescription{};
  shared_ptr<string> consortiumName{};

  CreateAntChainConsortiumRequest() {}

  explicit CreateAntChainConsortiumRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumDescription) {
      res["ConsortiumDescription"] = boost::any(*consortiumDescription);
    }
    if (consortiumName) {
      res["ConsortiumName"] = boost::any(*consortiumName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumDescription") != m.end() && !m["ConsortiumDescription"].empty()) {
      consortiumDescription = make_shared<string>(boost::any_cast<string>(m["ConsortiumDescription"]));
    }
    if (m.find("ConsortiumName") != m.end() && !m["ConsortiumName"].empty()) {
      consortiumName = make_shared<string>(boost::any_cast<string>(m["ConsortiumName"]));
    }
  }


  virtual ~CreateAntChainConsortiumRequest() = default;
};
class CreateAntChainConsortiumResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};

  CreateAntChainConsortiumResponseBodyResult() {}

  explicit CreateAntChainConsortiumResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
  }


  virtual ~CreateAntChainConsortiumResponseBodyResult() = default;
};
class CreateAntChainConsortiumResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateAntChainConsortiumResponseBodyResult> result{};

  CreateAntChainConsortiumResponseBody() {}

  explicit CreateAntChainConsortiumResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateAntChainConsortiumResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateAntChainConsortiumResponseBodyResult>(model1);
      }
    }
  }


  virtual ~CreateAntChainConsortiumResponseBody() = default;
};
class CreateAntChainConsortiumResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAntChainConsortiumResponseBody> body{};

  CreateAntChainConsortiumResponse() {}

  explicit CreateAntChainConsortiumResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAntChainConsortiumResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAntChainConsortiumResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAntChainConsortiumResponse() = default;
};
class CreateAntChainContractContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentName{};
  shared_ptr<bool> isDirectory{};
  shared_ptr<string> parentContentId{};
  shared_ptr<string> projectId{};

  CreateAntChainContractContentRequest() {}

  explicit CreateAntChainContractContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentName) {
      res["ContentName"] = boost::any(*contentName);
    }
    if (isDirectory) {
      res["IsDirectory"] = boost::any(*isDirectory);
    }
    if (parentContentId) {
      res["ParentContentId"] = boost::any(*parentContentId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentName") != m.end() && !m["ContentName"].empty()) {
      contentName = make_shared<string>(boost::any_cast<string>(m["ContentName"]));
    }
    if (m.find("IsDirectory") != m.end() && !m["IsDirectory"].empty()) {
      isDirectory = make_shared<bool>(boost::any_cast<bool>(m["IsDirectory"]));
    }
    if (m.find("ParentContentId") != m.end() && !m["ParentContentId"].empty()) {
      parentContentId = make_shared<string>(boost::any_cast<string>(m["ParentContentId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~CreateAntChainContractContentRequest() = default;
};
class CreateAntChainContractContentResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentId{};
  shared_ptr<string> contentName{};
  shared_ptr<string> createTime{};
  shared_ptr<bool> isDirectory{};
  shared_ptr<string> parentContentId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> updateTime{};

  CreateAntChainContractContentResponseBodyResult() {}

  explicit CreateAntChainContractContentResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentId) {
      res["ContentId"] = boost::any(*contentId);
    }
    if (contentName) {
      res["ContentName"] = boost::any(*contentName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (isDirectory) {
      res["IsDirectory"] = boost::any(*isDirectory);
    }
    if (parentContentId) {
      res["ParentContentId"] = boost::any(*parentContentId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentId") != m.end() && !m["ContentId"].empty()) {
      contentId = make_shared<string>(boost::any_cast<string>(m["ContentId"]));
    }
    if (m.find("ContentName") != m.end() && !m["ContentName"].empty()) {
      contentName = make_shared<string>(boost::any_cast<string>(m["ContentName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("IsDirectory") != m.end() && !m["IsDirectory"].empty()) {
      isDirectory = make_shared<bool>(boost::any_cast<bool>(m["IsDirectory"]));
    }
    if (m.find("ParentContentId") != m.end() && !m["ParentContentId"].empty()) {
      parentContentId = make_shared<string>(boost::any_cast<string>(m["ParentContentId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~CreateAntChainContractContentResponseBodyResult() = default;
};
class CreateAntChainContractContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateAntChainContractContentResponseBodyResult> result{};

  CreateAntChainContractContentResponseBody() {}

  explicit CreateAntChainContractContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateAntChainContractContentResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateAntChainContractContentResponseBodyResult>(model1);
      }
    }
  }


  virtual ~CreateAntChainContractContentResponseBody() = default;
};
class CreateAntChainContractContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAntChainContractContentResponseBody> body{};

  CreateAntChainContractContentResponse() {}

  explicit CreateAntChainContractContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAntChainContractContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAntChainContractContentResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAntChainContractContentResponse() = default;
};
class CreateAntChainContractProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> projectDescription{};
  shared_ptr<string> projectName{};
  shared_ptr<string> projectVersion{};

  CreateAntChainContractProjectRequest() {}

  explicit CreateAntChainContractProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (projectDescription) {
      res["ProjectDescription"] = boost::any(*projectDescription);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (projectVersion) {
      res["ProjectVersion"] = boost::any(*projectVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("ProjectDescription") != m.end() && !m["ProjectDescription"].empty()) {
      projectDescription = make_shared<string>(boost::any_cast<string>(m["ProjectDescription"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProjectVersion") != m.end() && !m["ProjectVersion"].empty()) {
      projectVersion = make_shared<string>(boost::any_cast<string>(m["ProjectVersion"]));
    }
  }


  virtual ~CreateAntChainContractProjectRequest() = default;
};
class CreateAntChainContractProjectResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> projectDescription{};
  shared_ptr<string> projectId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> projectVersion{};
  shared_ptr<long> updateTime{};

  CreateAntChainContractProjectResponseBodyResult() {}

  explicit CreateAntChainContractProjectResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (projectDescription) {
      res["ProjectDescription"] = boost::any(*projectDescription);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (projectVersion) {
      res["ProjectVersion"] = boost::any(*projectVersion);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ProjectDescription") != m.end() && !m["ProjectDescription"].empty()) {
      projectDescription = make_shared<string>(boost::any_cast<string>(m["ProjectDescription"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProjectVersion") != m.end() && !m["ProjectVersion"].empty()) {
      projectVersion = make_shared<string>(boost::any_cast<string>(m["ProjectVersion"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~CreateAntChainContractProjectResponseBodyResult() = default;
};
class CreateAntChainContractProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateAntChainContractProjectResponseBodyResult> result{};

  CreateAntChainContractProjectResponseBody() {}

  explicit CreateAntChainContractProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateAntChainContractProjectResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateAntChainContractProjectResponseBodyResult>(model1);
      }
    }
  }


  virtual ~CreateAntChainContractProjectResponseBody() = default;
};
class CreateAntChainContractProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAntChainContractProjectResponseBody> body{};

  CreateAntChainContractProjectResponse() {}

  explicit CreateAntChainContractProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAntChainContractProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAntChainContractProjectResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAntChainContractProjectResponse() = default;
};
class CreateBlockchainRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<string> blockchainRegionId{};
  shared_ptr<string> blockchainType{};
  shared_ptr<string> cipherSuit{};
  shared_ptr<long> liveTime{};
  shared_ptr<long> machineNum{};
  shared_ptr<string> merkleTreeSuit{};
  shared_ptr<long> size{};
  shared_ptr<string> tlsAlgo{};

  CreateBlockchainRequest() {}

  explicit CreateBlockchainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (blockchainRegionId) {
      res["BlockchainRegionId"] = boost::any(*blockchainRegionId);
    }
    if (blockchainType) {
      res["BlockchainType"] = boost::any(*blockchainType);
    }
    if (cipherSuit) {
      res["CipherSuit"] = boost::any(*cipherSuit);
    }
    if (liveTime) {
      res["LiveTime"] = boost::any(*liveTime);
    }
    if (machineNum) {
      res["MachineNum"] = boost::any(*machineNum);
    }
    if (merkleTreeSuit) {
      res["MerkleTreeSuit"] = boost::any(*merkleTreeSuit);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (tlsAlgo) {
      res["TlsAlgo"] = boost::any(*tlsAlgo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("BlockchainRegionId") != m.end() && !m["BlockchainRegionId"].empty()) {
      blockchainRegionId = make_shared<string>(boost::any_cast<string>(m["BlockchainRegionId"]));
    }
    if (m.find("BlockchainType") != m.end() && !m["BlockchainType"].empty()) {
      blockchainType = make_shared<string>(boost::any_cast<string>(m["BlockchainType"]));
    }
    if (m.find("CipherSuit") != m.end() && !m["CipherSuit"].empty()) {
      cipherSuit = make_shared<string>(boost::any_cast<string>(m["CipherSuit"]));
    }
    if (m.find("LiveTime") != m.end() && !m["LiveTime"].empty()) {
      liveTime = make_shared<long>(boost::any_cast<long>(m["LiveTime"]));
    }
    if (m.find("MachineNum") != m.end() && !m["MachineNum"].empty()) {
      machineNum = make_shared<long>(boost::any_cast<long>(m["MachineNum"]));
    }
    if (m.find("MerkleTreeSuit") != m.end() && !m["MerkleTreeSuit"].empty()) {
      merkleTreeSuit = make_shared<string>(boost::any_cast<string>(m["MerkleTreeSuit"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TlsAlgo") != m.end() && !m["TlsAlgo"].empty()) {
      tlsAlgo = make_shared<string>(boost::any_cast<string>(m["TlsAlgo"]));
    }
  }


  virtual ~CreateBlockchainRequest() = default;
};
class CreateBlockchainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  CreateBlockchainResponseBody() {}

  explicit CreateBlockchainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~CreateBlockchainResponseBody() = default;
};
class CreateBlockchainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBlockchainResponseBody> body{};

  CreateBlockchainResponse() {}

  explicit CreateBlockchainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBlockchainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBlockchainResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBlockchainResponse() = default;
};
class CreateBlockchainApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<string> blockchainRegionId{};
  shared_ptr<string> blockchainType{};
  shared_ptr<string> cipherSuit{};
  shared_ptr<long> liveTime{};
  shared_ptr<long> machineNum{};
  shared_ptr<string> merkleTreeSuit{};
  shared_ptr<long> size{};
  shared_ptr<string> tlsAlgo{};

  CreateBlockchainApplicationRequest() {}

  explicit CreateBlockchainApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (blockchainRegionId) {
      res["BlockchainRegionId"] = boost::any(*blockchainRegionId);
    }
    if (blockchainType) {
      res["BlockchainType"] = boost::any(*blockchainType);
    }
    if (cipherSuit) {
      res["CipherSuit"] = boost::any(*cipherSuit);
    }
    if (liveTime) {
      res["LiveTime"] = boost::any(*liveTime);
    }
    if (machineNum) {
      res["MachineNum"] = boost::any(*machineNum);
    }
    if (merkleTreeSuit) {
      res["MerkleTreeSuit"] = boost::any(*merkleTreeSuit);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (tlsAlgo) {
      res["TlsAlgo"] = boost::any(*tlsAlgo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("BlockchainRegionId") != m.end() && !m["BlockchainRegionId"].empty()) {
      blockchainRegionId = make_shared<string>(boost::any_cast<string>(m["BlockchainRegionId"]));
    }
    if (m.find("BlockchainType") != m.end() && !m["BlockchainType"].empty()) {
      blockchainType = make_shared<string>(boost::any_cast<string>(m["BlockchainType"]));
    }
    if (m.find("CipherSuit") != m.end() && !m["CipherSuit"].empty()) {
      cipherSuit = make_shared<string>(boost::any_cast<string>(m["CipherSuit"]));
    }
    if (m.find("LiveTime") != m.end() && !m["LiveTime"].empty()) {
      liveTime = make_shared<long>(boost::any_cast<long>(m["LiveTime"]));
    }
    if (m.find("MachineNum") != m.end() && !m["MachineNum"].empty()) {
      machineNum = make_shared<long>(boost::any_cast<long>(m["MachineNum"]));
    }
    if (m.find("MerkleTreeSuit") != m.end() && !m["MerkleTreeSuit"].empty()) {
      merkleTreeSuit = make_shared<string>(boost::any_cast<string>(m["MerkleTreeSuit"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TlsAlgo") != m.end() && !m["TlsAlgo"].empty()) {
      tlsAlgo = make_shared<string>(boost::any_cast<string>(m["TlsAlgo"]));
    }
  }


  virtual ~CreateBlockchainApplicationRequest() = default;
};
class CreateBlockchainApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  CreateBlockchainApplicationResponseBody() {}

  explicit CreateBlockchainApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~CreateBlockchainApplicationResponseBody() = default;
};
class CreateBlockchainApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBlockchainApplicationResponseBody> body{};

  CreateBlockchainApplicationResponse() {}

  explicit CreateBlockchainApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBlockchainApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBlockchainApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBlockchainApplicationResponse() = default;
};
class CreateBlockchainApplyRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<long> liveTime{};
  shared_ptr<long> machineNum{};
  shared_ptr<long> size{};

  CreateBlockchainApplyRequest() {}

  explicit CreateBlockchainApplyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (liveTime) {
      res["LiveTime"] = boost::any(*liveTime);
    }
    if (machineNum) {
      res["MachineNum"] = boost::any(*machineNum);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("LiveTime") != m.end() && !m["LiveTime"].empty()) {
      liveTime = make_shared<long>(boost::any_cast<long>(m["LiveTime"]));
    }
    if (m.find("MachineNum") != m.end() && !m["MachineNum"].empty()) {
      machineNum = make_shared<long>(boost::any_cast<long>(m["MachineNum"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~CreateBlockchainApplyRequest() = default;
};
class CreateBlockchainApplyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  CreateBlockchainApplyResponseBody() {}

  explicit CreateBlockchainApplyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~CreateBlockchainApplyResponseBody() = default;
};
class CreateBlockchainApplyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBlockchainApplyResponseBody> body{};

  CreateBlockchainApplyResponse() {}

  explicit CreateBlockchainApplyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBlockchainApplyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBlockchainApplyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBlockchainApplyResponse() = default;
};
class CreateChaincodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossUrl{};

  CreateChaincodeRequest() {}

  explicit CreateChaincodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossUrl) {
      res["OssUrl"] = boost::any(*ossUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssUrl") != m.end() && !m["OssUrl"].empty()) {
      ossUrl = make_shared<string>(boost::any_cast<string>(m["OssUrl"]));
    }
  }


  virtual ~CreateChaincodeRequest() = default;
};
class CreateChaincodeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> channelName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deployTime{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<string> input{};
  shared_ptr<bool> install{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<string> providerId{};
  shared_ptr<string> providerName{};
  shared_ptr<string> state{};
  shared_ptr<long> type{};
  shared_ptr<string> version{};

  CreateChaincodeResponseBodyResult() {}

  explicit CreateChaincodeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deployTime) {
      res["DeployTime"] = boost::any(*deployTime);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (install) {
      res["Install"] = boost::any(*install);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (providerId) {
      res["ProviderId"] = boost::any(*providerId);
    }
    if (providerName) {
      res["ProviderName"] = boost::any(*providerName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeployTime") != m.end() && !m["DeployTime"].empty()) {
      deployTime = make_shared<string>(boost::any_cast<string>(m["DeployTime"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Install") != m.end() && !m["Install"].empty()) {
      install = make_shared<bool>(boost::any_cast<bool>(m["Install"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ProviderId") != m.end() && !m["ProviderId"].empty()) {
      providerId = make_shared<string>(boost::any_cast<string>(m["ProviderId"]));
    }
    if (m.find("ProviderName") != m.end() && !m["ProviderName"].empty()) {
      providerName = make_shared<string>(boost::any_cast<string>(m["ProviderName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~CreateChaincodeResponseBodyResult() = default;
};
class CreateChaincodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateChaincodeResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateChaincodeResponseBody() {}

  explicit CreateChaincodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateChaincodeResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateChaincodeResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateChaincodeResponseBody() = default;
};
class CreateChaincodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateChaincodeResponseBody> body{};

  CreateChaincodeResponse() {}

  explicit CreateChaincodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateChaincodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateChaincodeResponseBody>(model1);
      }
    }
  }


  virtual ~CreateChaincodeResponse() = default;
};
class CreateChannelRequestOrganization : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  CreateChannelRequestOrganization() {}

  explicit CreateChannelRequestOrganization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~CreateChannelRequestOrganization() = default;
};
class CreateChannelRequest : public Darabonba::Model {
public:
  shared_ptr<long> batchTimeout{};
  shared_ptr<string> channelName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<long> maxMessageCount{};
  shared_ptr<vector<CreateChannelRequestOrganization>> organization{};
  shared_ptr<long> preferredMaxBytes{};

  CreateChannelRequest() {}

  explicit CreateChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchTimeout) {
      res["BatchTimeout"] = boost::any(*batchTimeout);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (maxMessageCount) {
      res["MaxMessageCount"] = boost::any(*maxMessageCount);
    }
    if (organization) {
      vector<boost::any> temp1;
      for(auto item1:*organization){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Organization"] = boost::any(temp1);
    }
    if (preferredMaxBytes) {
      res["PreferredMaxBytes"] = boost::any(*preferredMaxBytes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchTimeout") != m.end() && !m["BatchTimeout"].empty()) {
      batchTimeout = make_shared<long>(boost::any_cast<long>(m["BatchTimeout"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("MaxMessageCount") != m.end() && !m["MaxMessageCount"].empty()) {
      maxMessageCount = make_shared<long>(boost::any_cast<long>(m["MaxMessageCount"]));
    }
    if (m.find("Organization") != m.end() && !m["Organization"].empty()) {
      if (typeid(vector<boost::any>) == m["Organization"].type()) {
        vector<CreateChannelRequestOrganization> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Organization"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateChannelRequestOrganization model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        organization = make_shared<vector<CreateChannelRequestOrganization>>(expect1);
      }
    }
    if (m.find("PreferredMaxBytes") != m.end() && !m["PreferredMaxBytes"].empty()) {
      preferredMaxBytes = make_shared<long>(boost::any_cast<long>(m["PreferredMaxBytes"]));
    }
  }


  virtual ~CreateChannelRequest() = default;
};
class CreateChannelResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> batchTimeout{};
  shared_ptr<long> blockCount{};
  shared_ptr<long> chaincodeCount{};
  shared_ptr<string> channelId{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> consortiumName{};
  shared_ptr<string> createTime{};
  shared_ptr<long> maxMessageCount{};
  shared_ptr<long> memberCount{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerBid{};
  shared_ptr<string> ownerName{};
  shared_ptr<long> ownerUid{};
  shared_ptr<long> preferredMaxBytes{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};
  shared_ptr<bool> supportConfig{};
  shared_ptr<string> updateTime{};

  CreateChannelResponseBodyResult() {}

  explicit CreateChannelResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchTimeout) {
      res["BatchTimeout"] = boost::any(*batchTimeout);
    }
    if (blockCount) {
      res["BlockCount"] = boost::any(*blockCount);
    }
    if (chaincodeCount) {
      res["ChaincodeCount"] = boost::any(*chaincodeCount);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (consortiumName) {
      res["ConsortiumName"] = boost::any(*consortiumName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (maxMessageCount) {
      res["MaxMessageCount"] = boost::any(*maxMessageCount);
    }
    if (memberCount) {
      res["MemberCount"] = boost::any(*memberCount);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerBid) {
      res["OwnerBid"] = boost::any(*ownerBid);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUid) {
      res["OwnerUid"] = boost::any(*ownerUid);
    }
    if (preferredMaxBytes) {
      res["PreferredMaxBytes"] = boost::any(*preferredMaxBytes);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (supportConfig) {
      res["SupportConfig"] = boost::any(*supportConfig);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchTimeout") != m.end() && !m["BatchTimeout"].empty()) {
      batchTimeout = make_shared<long>(boost::any_cast<long>(m["BatchTimeout"]));
    }
    if (m.find("BlockCount") != m.end() && !m["BlockCount"].empty()) {
      blockCount = make_shared<long>(boost::any_cast<long>(m["BlockCount"]));
    }
    if (m.find("ChaincodeCount") != m.end() && !m["ChaincodeCount"].empty()) {
      chaincodeCount = make_shared<long>(boost::any_cast<long>(m["ChaincodeCount"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("ConsortiumName") != m.end() && !m["ConsortiumName"].empty()) {
      consortiumName = make_shared<string>(boost::any_cast<string>(m["ConsortiumName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("MaxMessageCount") != m.end() && !m["MaxMessageCount"].empty()) {
      maxMessageCount = make_shared<long>(boost::any_cast<long>(m["MaxMessageCount"]));
    }
    if (m.find("MemberCount") != m.end() && !m["MemberCount"].empty()) {
      memberCount = make_shared<long>(boost::any_cast<long>(m["MemberCount"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerBid") != m.end() && !m["OwnerBid"].empty()) {
      ownerBid = make_shared<string>(boost::any_cast<string>(m["OwnerBid"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUid") != m.end() && !m["OwnerUid"].empty()) {
      ownerUid = make_shared<long>(boost::any_cast<long>(m["OwnerUid"]));
    }
    if (m.find("PreferredMaxBytes") != m.end() && !m["PreferredMaxBytes"].empty()) {
      preferredMaxBytes = make_shared<long>(boost::any_cast<long>(m["PreferredMaxBytes"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("SupportConfig") != m.end() && !m["SupportConfig"].empty()) {
      supportConfig = make_shared<bool>(boost::any_cast<bool>(m["SupportConfig"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~CreateChannelResponseBodyResult() = default;
};
class CreateChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateChannelResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateChannelResponseBody() {}

  explicit CreateChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateChannelResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateChannelResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateChannelResponseBody() = default;
};
class CreateChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateChannelResponseBody> body{};

  CreateChannelResponse() {}

  explicit CreateChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateChannelResponseBody>(model1);
      }
    }
  }


  virtual ~CreateChannelResponse() = default;
};
class CreateChannelMemberRequestOrganization : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  CreateChannelMemberRequestOrganization() {}

  explicit CreateChannelMemberRequestOrganization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~CreateChannelMemberRequestOrganization() = default;
};
class CreateChannelMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<vector<CreateChannelMemberRequestOrganization>> organization{};

  CreateChannelMemberRequest() {}

  explicit CreateChannelMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (organization) {
      vector<boost::any> temp1;
      for(auto item1:*organization){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Organization"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Organization") != m.end() && !m["Organization"].empty()) {
      if (typeid(vector<boost::any>) == m["Organization"].type()) {
        vector<CreateChannelMemberRequestOrganization> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Organization"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateChannelMemberRequestOrganization model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        organization = make_shared<vector<CreateChannelMemberRequestOrganization>>(expect1);
      }
    }
  }


  virtual ~CreateChannelMemberRequest() = default;
};
class CreateChannelMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};
  shared_ptr<bool> success{};

  CreateChannelMemberResponseBody() {}

  explicit CreateChannelMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateChannelMemberResponseBody() = default;
};
class CreateChannelMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateChannelMemberResponseBody> body{};

  CreateChannelMemberResponse() {}

  explicit CreateChannelMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateChannelMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateChannelMemberResponseBody>(model1);
      }
    }
  }


  virtual ~CreateChannelMemberResponse() = default;
};
class CreateCloudIntegrationServiceTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};
  shared_ptr<string> service{};

  CreateCloudIntegrationServiceTokenRequest() {}

  explicit CreateCloudIntegrationServiceTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (service) {
      res["Service"] = boost::any(*service);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("Service") != m.end() && !m["Service"].empty()) {
      service = make_shared<string>(boost::any_cast<string>(m["Service"]));
    }
  }


  virtual ~CreateCloudIntegrationServiceTokenRequest() = default;
};
class CreateCloudIntegrationServiceTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  CreateCloudIntegrationServiceTokenResponseBody() {}

  explicit CreateCloudIntegrationServiceTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateCloudIntegrationServiceTokenResponseBody() = default;
};
class CreateCloudIntegrationServiceTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCloudIntegrationServiceTokenResponseBody> body{};

  CreateCloudIntegrationServiceTokenResponse() {}

  explicit CreateCloudIntegrationServiceTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCloudIntegrationServiceTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCloudIntegrationServiceTokenResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCloudIntegrationServiceTokenResponse() = default;
};
class CreateCloudServiceIntegrationRequest : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};

  CreateCloudServiceIntegrationRequest() {}

  explicit CreateCloudServiceIntegrationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~CreateCloudServiceIntegrationRequest() = default;
};
class CreateCloudServiceIntegrationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};
  shared_ptr<bool> success{};

  CreateCloudServiceIntegrationResponseBody() {}

  explicit CreateCloudServiceIntegrationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateCloudServiceIntegrationResponseBody() = default;
};
class CreateCloudServiceIntegrationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCloudServiceIntegrationResponseBody> body{};

  CreateCloudServiceIntegrationResponse() {}

  explicit CreateCloudServiceIntegrationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCloudServiceIntegrationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCloudServiceIntegrationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCloudServiceIntegrationResponse() = default;
};
class CreateCloudServiceSessionRequest : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};

  CreateCloudServiceSessionRequest() {}

  explicit CreateCloudServiceSessionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~CreateCloudServiceSessionRequest() = default;
};
class CreateCloudServiceSessionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  CreateCloudServiceSessionResponseBody() {}

  explicit CreateCloudServiceSessionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateCloudServiceSessionResponseBody() = default;
};
class CreateCloudServiceSessionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCloudServiceSessionResponseBody> body{};

  CreateCloudServiceSessionResponse() {}

  explicit CreateCloudServiceSessionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCloudServiceSessionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCloudServiceSessionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCloudServiceSessionResponse() = default;
};
class CreateConsortiumRequestOrganization : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  CreateConsortiumRequestOrganization() {}

  explicit CreateConsortiumRequestOrganization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~CreateConsortiumRequestOrganization() = default;
};
class CreateConsortiumRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelPolicy{};
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<long> duration{};
  shared_ptr<string> location{};
  shared_ptr<string> majorVersion{};
  shared_ptr<string> name{};
  shared_ptr<string> ordererType{};
  shared_ptr<long> orderersCount{};
  shared_ptr<vector<CreateConsortiumRequestOrganization>> organization{};
  shared_ptr<long> peersCount{};
  shared_ptr<string> pricingCycle{};
  shared_ptr<string> specName{};
  shared_ptr<string> zoneId{};

  CreateConsortiumRequest() {}

  explicit CreateConsortiumRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelPolicy) {
      res["ChannelPolicy"] = boost::any(*channelPolicy);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (majorVersion) {
      res["MajorVersion"] = boost::any(*majorVersion);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ordererType) {
      res["OrdererType"] = boost::any(*ordererType);
    }
    if (orderersCount) {
      res["OrderersCount"] = boost::any(*orderersCount);
    }
    if (organization) {
      vector<boost::any> temp1;
      for(auto item1:*organization){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Organization"] = boost::any(temp1);
    }
    if (peersCount) {
      res["PeersCount"] = boost::any(*peersCount);
    }
    if (pricingCycle) {
      res["PricingCycle"] = boost::any(*pricingCycle);
    }
    if (specName) {
      res["SpecName"] = boost::any(*specName);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelPolicy") != m.end() && !m["ChannelPolicy"].empty()) {
      channelPolicy = make_shared<string>(boost::any_cast<string>(m["ChannelPolicy"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("MajorVersion") != m.end() && !m["MajorVersion"].empty()) {
      majorVersion = make_shared<string>(boost::any_cast<string>(m["MajorVersion"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrdererType") != m.end() && !m["OrdererType"].empty()) {
      ordererType = make_shared<string>(boost::any_cast<string>(m["OrdererType"]));
    }
    if (m.find("OrderersCount") != m.end() && !m["OrderersCount"].empty()) {
      orderersCount = make_shared<long>(boost::any_cast<long>(m["OrderersCount"]));
    }
    if (m.find("Organization") != m.end() && !m["Organization"].empty()) {
      if (typeid(vector<boost::any>) == m["Organization"].type()) {
        vector<CreateConsortiumRequestOrganization> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Organization"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateConsortiumRequestOrganization model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        organization = make_shared<vector<CreateConsortiumRequestOrganization>>(expect1);
      }
    }
    if (m.find("PeersCount") != m.end() && !m["PeersCount"].empty()) {
      peersCount = make_shared<long>(boost::any_cast<long>(m["PeersCount"]));
    }
    if (m.find("PricingCycle") != m.end() && !m["PricingCycle"].empty()) {
      pricingCycle = make_shared<string>(boost::any_cast<string>(m["PricingCycle"]));
    }
    if (m.find("SpecName") != m.end() && !m["SpecName"].empty()) {
      specName = make_shared<string>(boost::any_cast<string>(m["SpecName"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateConsortiumRequest() = default;
};
class CreateConsortiumResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> channelCount{};
  shared_ptr<string> channelPolicy{};
  shared_ptr<string> clusterState{};
  shared_ptr<string> codeName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<long> memberCount{};
  shared_ptr<string> name{};
  shared_ptr<long> ordererCount{};
  shared_ptr<string> ordererType{};
  shared_ptr<string> ownerBid{};
  shared_ptr<long> ownerUid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> serviceState{};
  shared_ptr<string> specName{};
  shared_ptr<string> zoneId{};

  CreateConsortiumResponseBodyResult() {}

  explicit CreateConsortiumResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelCount) {
      res["ChannelCount"] = boost::any(*channelCount);
    }
    if (channelPolicy) {
      res["ChannelPolicy"] = boost::any(*channelPolicy);
    }
    if (clusterState) {
      res["ClusterState"] = boost::any(*clusterState);
    }
    if (codeName) {
      res["CodeName"] = boost::any(*codeName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (memberCount) {
      res["MemberCount"] = boost::any(*memberCount);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ordererCount) {
      res["OrdererCount"] = boost::any(*ordererCount);
    }
    if (ordererType) {
      res["OrdererType"] = boost::any(*ordererType);
    }
    if (ownerBid) {
      res["OwnerBid"] = boost::any(*ownerBid);
    }
    if (ownerUid) {
      res["OwnerUid"] = boost::any(*ownerUid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (serviceState) {
      res["ServiceState"] = boost::any(*serviceState);
    }
    if (specName) {
      res["SpecName"] = boost::any(*specName);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelCount") != m.end() && !m["ChannelCount"].empty()) {
      channelCount = make_shared<long>(boost::any_cast<long>(m["ChannelCount"]));
    }
    if (m.find("ChannelPolicy") != m.end() && !m["ChannelPolicy"].empty()) {
      channelPolicy = make_shared<string>(boost::any_cast<string>(m["ChannelPolicy"]));
    }
    if (m.find("ClusterState") != m.end() && !m["ClusterState"].empty()) {
      clusterState = make_shared<string>(boost::any_cast<string>(m["ClusterState"]));
    }
    if (m.find("CodeName") != m.end() && !m["CodeName"].empty()) {
      codeName = make_shared<string>(boost::any_cast<string>(m["CodeName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("MemberCount") != m.end() && !m["MemberCount"].empty()) {
      memberCount = make_shared<long>(boost::any_cast<long>(m["MemberCount"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrdererCount") != m.end() && !m["OrdererCount"].empty()) {
      ordererCount = make_shared<long>(boost::any_cast<long>(m["OrdererCount"]));
    }
    if (m.find("OrdererType") != m.end() && !m["OrdererType"].empty()) {
      ordererType = make_shared<string>(boost::any_cast<string>(m["OrdererType"]));
    }
    if (m.find("OwnerBid") != m.end() && !m["OwnerBid"].empty()) {
      ownerBid = make_shared<string>(boost::any_cast<string>(m["OwnerBid"]));
    }
    if (m.find("OwnerUid") != m.end() && !m["OwnerUid"].empty()) {
      ownerUid = make_shared<long>(boost::any_cast<long>(m["OwnerUid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ServiceState") != m.end() && !m["ServiceState"].empty()) {
      serviceState = make_shared<string>(boost::any_cast<string>(m["ServiceState"]));
    }
    if (m.find("SpecName") != m.end() && !m["SpecName"].empty()) {
      specName = make_shared<string>(boost::any_cast<string>(m["SpecName"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateConsortiumResponseBodyResult() = default;
};
class CreateConsortiumResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateConsortiumResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateConsortiumResponseBody() {}

  explicit CreateConsortiumResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateConsortiumResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateConsortiumResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateConsortiumResponseBody() = default;
};
class CreateConsortiumResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateConsortiumResponseBody> body{};

  CreateConsortiumResponse() {}

  explicit CreateConsortiumResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateConsortiumResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateConsortiumResponseBody>(model1);
      }
    }
  }


  virtual ~CreateConsortiumResponse() = default;
};
class CreateConsortiumMemberRequestOrganization : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  CreateConsortiumMemberRequestOrganization() {}

  explicit CreateConsortiumMemberRequestOrganization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~CreateConsortiumMemberRequestOrganization() = default;
};
class CreateConsortiumMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> consortiumId{};
  shared_ptr<vector<CreateConsortiumMemberRequestOrganization>> organization{};

  CreateConsortiumMemberRequest() {}

  explicit CreateConsortiumMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (organization) {
      vector<boost::any> temp1;
      for(auto item1:*organization){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Organization"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Organization") != m.end() && !m["Organization"].empty()) {
      if (typeid(vector<boost::any>) == m["Organization"].type()) {
        vector<CreateConsortiumMemberRequestOrganization> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Organization"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateConsortiumMemberRequestOrganization model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        organization = make_shared<vector<CreateConsortiumMemberRequestOrganization>>(expect1);
      }
    }
  }


  virtual ~CreateConsortiumMemberRequest() = default;
};
class CreateConsortiumMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};
  shared_ptr<bool> success{};

  CreateConsortiumMemberResponseBody() {}

  explicit CreateConsortiumMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateConsortiumMemberResponseBody() = default;
};
class CreateConsortiumMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateConsortiumMemberResponseBody> body{};

  CreateConsortiumMemberResponse() {}

  explicit CreateConsortiumMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateConsortiumMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateConsortiumMemberResponseBody>(model1);
      }
    }
  }


  virtual ~CreateConsortiumMemberResponse() = default;
};
class CreateEcosphereRequestOrganization : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<string> name{};

  CreateEcosphereRequestOrganization() {}

  explicit CreateEcosphereRequestOrganization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreateEcosphereRequestOrganization() = default;
};
class CreateEcosphereRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelPolicy{};
  shared_ptr<string> consortiumName{};
  shared_ptr<string> description{};
  shared_ptr<long> duration{};
  shared_ptr<string> location{};
  shared_ptr<string> majorVersion{};
  shared_ptr<string> ordererDomain{};
  shared_ptr<string> ordererType{};
  shared_ptr<long> orderersCount{};
  shared_ptr<vector<CreateEcosphereRequestOrganization>> organization{};
  shared_ptr<long> peersCount{};
  shared_ptr<string> pricingCycle{};
  shared_ptr<string> specName{};
  shared_ptr<string> zoneId{};

  CreateEcosphereRequest() {}

  explicit CreateEcosphereRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelPolicy) {
      res["ChannelPolicy"] = boost::any(*channelPolicy);
    }
    if (consortiumName) {
      res["ConsortiumName"] = boost::any(*consortiumName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (majorVersion) {
      res["MajorVersion"] = boost::any(*majorVersion);
    }
    if (ordererDomain) {
      res["OrdererDomain"] = boost::any(*ordererDomain);
    }
    if (ordererType) {
      res["OrdererType"] = boost::any(*ordererType);
    }
    if (orderersCount) {
      res["OrderersCount"] = boost::any(*orderersCount);
    }
    if (organization) {
      vector<boost::any> temp1;
      for(auto item1:*organization){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Organization"] = boost::any(temp1);
    }
    if (peersCount) {
      res["PeersCount"] = boost::any(*peersCount);
    }
    if (pricingCycle) {
      res["PricingCycle"] = boost::any(*pricingCycle);
    }
    if (specName) {
      res["SpecName"] = boost::any(*specName);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelPolicy") != m.end() && !m["ChannelPolicy"].empty()) {
      channelPolicy = make_shared<string>(boost::any_cast<string>(m["ChannelPolicy"]));
    }
    if (m.find("ConsortiumName") != m.end() && !m["ConsortiumName"].empty()) {
      consortiumName = make_shared<string>(boost::any_cast<string>(m["ConsortiumName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("MajorVersion") != m.end() && !m["MajorVersion"].empty()) {
      majorVersion = make_shared<string>(boost::any_cast<string>(m["MajorVersion"]));
    }
    if (m.find("OrdererDomain") != m.end() && !m["OrdererDomain"].empty()) {
      ordererDomain = make_shared<string>(boost::any_cast<string>(m["OrdererDomain"]));
    }
    if (m.find("OrdererType") != m.end() && !m["OrdererType"].empty()) {
      ordererType = make_shared<string>(boost::any_cast<string>(m["OrdererType"]));
    }
    if (m.find("OrderersCount") != m.end() && !m["OrderersCount"].empty()) {
      orderersCount = make_shared<long>(boost::any_cast<long>(m["OrderersCount"]));
    }
    if (m.find("Organization") != m.end() && !m["Organization"].empty()) {
      if (typeid(vector<boost::any>) == m["Organization"].type()) {
        vector<CreateEcosphereRequestOrganization> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Organization"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEcosphereRequestOrganization model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        organization = make_shared<vector<CreateEcosphereRequestOrganization>>(expect1);
      }
    }
    if (m.find("PeersCount") != m.end() && !m["PeersCount"].empty()) {
      peersCount = make_shared<long>(boost::any_cast<long>(m["PeersCount"]));
    }
    if (m.find("PricingCycle") != m.end() && !m["PricingCycle"].empty()) {
      pricingCycle = make_shared<string>(boost::any_cast<string>(m["PricingCycle"]));
    }
    if (m.find("SpecName") != m.end() && !m["SpecName"].empty()) {
      specName = make_shared<string>(boost::any_cast<string>(m["SpecName"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateEcosphereRequest() = default;
};
class CreateEcosphereResponseBodyResultOrganizations : public Darabonba::Model {
public:
  shared_ptr<string> clusterState{};
  shared_ptr<string> code{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<string> name{};
  shared_ptr<string> serviceState{};

  CreateEcosphereResponseBodyResultOrganizations() {}

  explicit CreateEcosphereResponseBodyResultOrganizations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterState) {
      res["ClusterState"] = boost::any(*clusterState);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (serviceState) {
      res["ServiceState"] = boost::any(*serviceState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterState") != m.end() && !m["ClusterState"].empty()) {
      clusterState = make_shared<string>(boost::any_cast<string>(m["ClusterState"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ServiceState") != m.end() && !m["ServiceState"].empty()) {
      serviceState = make_shared<string>(boost::any_cast<string>(m["ServiceState"]));
    }
  }


  virtual ~CreateEcosphereResponseBodyResultOrganizations() = default;
};
class CreateEcosphereResponseBodyResultSpecification : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> numOfNodes{};
  shared_ptr<string> title{};

  CreateEcosphereResponseBodyResultSpecification() {}

  explicit CreateEcosphereResponseBodyResultSpecification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (numOfNodes) {
      res["NumOfNodes"] = boost::any(*numOfNodes);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NumOfNodes") != m.end() && !m["NumOfNodes"].empty()) {
      numOfNodes = make_shared<long>(boost::any_cast<long>(m["NumOfNodes"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~CreateEcosphereResponseBodyResultSpecification() = default;
};
class CreateEcosphereResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> channelCount{};
  shared_ptr<string> channelPolicy{};
  shared_ptr<string> clusterState{};
  shared_ptr<string> code{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<long> memberCount{};
  shared_ptr<string> name{};
  shared_ptr<long> ordererCount{};
  shared_ptr<string> ordererType{};
  shared_ptr<vector<CreateEcosphereResponseBodyResultOrganizations>> organizations{};
  shared_ptr<string> ownerBid{};
  shared_ptr<long> ownerUid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> serviceState{};
  shared_ptr<string> specName{};
  shared_ptr<CreateEcosphereResponseBodyResultSpecification> specification{};
  shared_ptr<string> zoneId{};

  CreateEcosphereResponseBodyResult() {}

  explicit CreateEcosphereResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelCount) {
      res["ChannelCount"] = boost::any(*channelCount);
    }
    if (channelPolicy) {
      res["ChannelPolicy"] = boost::any(*channelPolicy);
    }
    if (clusterState) {
      res["ClusterState"] = boost::any(*clusterState);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (memberCount) {
      res["MemberCount"] = boost::any(*memberCount);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ordererCount) {
      res["OrdererCount"] = boost::any(*ordererCount);
    }
    if (ordererType) {
      res["OrdererType"] = boost::any(*ordererType);
    }
    if (organizations) {
      vector<boost::any> temp1;
      for(auto item1:*organizations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Organizations"] = boost::any(temp1);
    }
    if (ownerBid) {
      res["OwnerBid"] = boost::any(*ownerBid);
    }
    if (ownerUid) {
      res["OwnerUid"] = boost::any(*ownerUid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (serviceState) {
      res["ServiceState"] = boost::any(*serviceState);
    }
    if (specName) {
      res["SpecName"] = boost::any(*specName);
    }
    if (specification) {
      res["Specification"] = specification ? boost::any(specification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelCount") != m.end() && !m["ChannelCount"].empty()) {
      channelCount = make_shared<long>(boost::any_cast<long>(m["ChannelCount"]));
    }
    if (m.find("ChannelPolicy") != m.end() && !m["ChannelPolicy"].empty()) {
      channelPolicy = make_shared<string>(boost::any_cast<string>(m["ChannelPolicy"]));
    }
    if (m.find("ClusterState") != m.end() && !m["ClusterState"].empty()) {
      clusterState = make_shared<string>(boost::any_cast<string>(m["ClusterState"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("MemberCount") != m.end() && !m["MemberCount"].empty()) {
      memberCount = make_shared<long>(boost::any_cast<long>(m["MemberCount"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrdererCount") != m.end() && !m["OrdererCount"].empty()) {
      ordererCount = make_shared<long>(boost::any_cast<long>(m["OrdererCount"]));
    }
    if (m.find("OrdererType") != m.end() && !m["OrdererType"].empty()) {
      ordererType = make_shared<string>(boost::any_cast<string>(m["OrdererType"]));
    }
    if (m.find("Organizations") != m.end() && !m["Organizations"].empty()) {
      if (typeid(vector<boost::any>) == m["Organizations"].type()) {
        vector<CreateEcosphereResponseBodyResultOrganizations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Organizations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEcosphereResponseBodyResultOrganizations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        organizations = make_shared<vector<CreateEcosphereResponseBodyResultOrganizations>>(expect1);
      }
    }
    if (m.find("OwnerBid") != m.end() && !m["OwnerBid"].empty()) {
      ownerBid = make_shared<string>(boost::any_cast<string>(m["OwnerBid"]));
    }
    if (m.find("OwnerUid") != m.end() && !m["OwnerUid"].empty()) {
      ownerUid = make_shared<long>(boost::any_cast<long>(m["OwnerUid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ServiceState") != m.end() && !m["ServiceState"].empty()) {
      serviceState = make_shared<string>(boost::any_cast<string>(m["ServiceState"]));
    }
    if (m.find("SpecName") != m.end() && !m["SpecName"].empty()) {
      specName = make_shared<string>(boost::any_cast<string>(m["SpecName"]));
    }
    if (m.find("Specification") != m.end() && !m["Specification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Specification"].type()) {
        CreateEcosphereResponseBodyResultSpecification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Specification"]));
        specification = make_shared<CreateEcosphereResponseBodyResultSpecification>(model1);
      }
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateEcosphereResponseBodyResult() = default;
};
class CreateEcosphereResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateEcosphereResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateEcosphereResponseBody() {}

  explicit CreateEcosphereResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateEcosphereResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateEcosphereResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateEcosphereResponseBody() = default;
};
class CreateEcosphereResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEcosphereResponseBody> body{};

  CreateEcosphereResponse() {}

  explicit CreateEcosphereResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEcosphereResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEcosphereResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEcosphereResponse() = default;
};
class CreateEthereumRequestNode : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  CreateEthereumRequestNode() {}

  explicit CreateEthereumRequestNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreateEthereumRequestNode() = default;
};
class CreateEthereumRequest : public Darabonba::Model {
public:
  shared_ptr<string> consensus{};
  shared_ptr<string> description{};
  shared_ptr<string> difficulty{};
  shared_ptr<string> gas{};
  shared_ptr<string> name{};
  shared_ptr<string> networkId{};
  shared_ptr<vector<CreateEthereumRequestNode>> node{};
  shared_ptr<string> region{};

  CreateEthereumRequest() {}

  explicit CreateEthereumRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consensus) {
      res["Consensus"] = boost::any(*consensus);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (difficulty) {
      res["Difficulty"] = boost::any(*difficulty);
    }
    if (gas) {
      res["Gas"] = boost::any(*gas);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (node) {
      vector<boost::any> temp1;
      for(auto item1:*node){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Node"] = boost::any(temp1);
    }
    if (region) {
      res["Region"] = boost::any(*region);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Consensus") != m.end() && !m["Consensus"].empty()) {
      consensus = make_shared<string>(boost::any_cast<string>(m["Consensus"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Difficulty") != m.end() && !m["Difficulty"].empty()) {
      difficulty = make_shared<string>(boost::any_cast<string>(m["Difficulty"]));
    }
    if (m.find("Gas") != m.end() && !m["Gas"].empty()) {
      gas = make_shared<string>(boost::any_cast<string>(m["Gas"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("Node") != m.end() && !m["Node"].empty()) {
      if (typeid(vector<boost::any>) == m["Node"].type()) {
        vector<CreateEthereumRequestNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Node"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEthereumRequestNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        node = make_shared<vector<CreateEthereumRequestNode>>(expect1);
      }
    }
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["Region"]));
    }
  }


  virtual ~CreateEthereumRequest() = default;
};
class CreateEthereumResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> consensus{};
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> networkId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> state{};

  CreateEthereumResponseBodyResult() {}

  explicit CreateEthereumResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consensus) {
      res["Consensus"] = boost::any(*consensus);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Consensus") != m.end() && !m["Consensus"].empty()) {
      consensus = make_shared<string>(boost::any_cast<string>(m["Consensus"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~CreateEthereumResponseBodyResult() = default;
};
class CreateEthereumResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateEthereumResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateEthereumResponseBody() {}

  explicit CreateEthereumResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateEthereumResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateEthereumResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateEthereumResponseBody() = default;
};
class CreateEthereumResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEthereumResponseBody> body{};

  CreateEthereumResponse() {}

  explicit CreateEthereumResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEthereumResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEthereumResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEthereumResponse() = default;
};
class CreateEthereumInvitationRequest : public Darabonba::Model {
public:
  shared_ptr<string> ethereumId{};

  CreateEthereumInvitationRequest() {}

  explicit CreateEthereumInvitationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ethereumId) {
      res["EthereumId"] = boost::any(*ethereumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EthereumId") != m.end() && !m["EthereumId"].empty()) {
      ethereumId = make_shared<string>(boost::any_cast<string>(m["EthereumId"]));
    }
  }


  virtual ~CreateEthereumInvitationRequest() = default;
};
class CreateEthereumInvitationResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> createTime{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> token{};

  CreateEthereumInvitationResponseBodyResult() {}

  explicit CreateEthereumInvitationResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~CreateEthereumInvitationResponseBodyResult() = default;
};
class CreateEthereumInvitationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateEthereumInvitationResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateEthereumInvitationResponseBody() {}

  explicit CreateEthereumInvitationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateEthereumInvitationResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateEthereumInvitationResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateEthereumInvitationResponseBody() = default;
};
class CreateEthereumInvitationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEthereumInvitationResponseBody> body{};

  CreateEthereumInvitationResponse() {}

  explicit CreateEthereumInvitationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEthereumInvitationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEthereumInvitationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEthereumInvitationResponse() = default;
};
class CreateFabricChaincodePackageRequest : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossUrl{};

  CreateFabricChaincodePackageRequest() {}

  explicit CreateFabricChaincodePackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossUrl) {
      res["OssUrl"] = boost::any(*ossUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssUrl") != m.end() && !m["OssUrl"].empty()) {
      ossUrl = make_shared<string>(boost::any_cast<string>(m["OssUrl"]));
    }
  }


  virtual ~CreateFabricChaincodePackageRequest() = default;
};
class CreateFabricChaincodePackageResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> chaincodePackageId{};
  shared_ptr<string> checksum{};
  shared_ptr<long> deleteTime{};
  shared_ptr<bool> deleted{};
  shared_ptr<long> installTime{};
  shared_ptr<string> label{};
  shared_ptr<string> md5sum{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossURL{};
  shared_ptr<string> providerBid{};
  shared_ptr<long> providerUid{};
  shared_ptr<string> state{};
  shared_ptr<string> type{};
  shared_ptr<bool> typeString{};
  shared_ptr<long> uploadTime{};

  CreateFabricChaincodePackageResponseBodyResult() {}

  explicit CreateFabricChaincodePackageResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodePackageId) {
      res["ChaincodePackageId"] = boost::any(*chaincodePackageId);
    }
    if (checksum) {
      res["Checksum"] = boost::any(*checksum);
    }
    if (deleteTime) {
      res["DeleteTime"] = boost::any(*deleteTime);
    }
    if (deleted) {
      res["Deleted"] = boost::any(*deleted);
    }
    if (installTime) {
      res["InstallTime"] = boost::any(*installTime);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (md5sum) {
      res["Md5sum"] = boost::any(*md5sum);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossURL) {
      res["OssURL"] = boost::any(*ossURL);
    }
    if (providerBid) {
      res["ProviderBid"] = boost::any(*providerBid);
    }
    if (providerUid) {
      res["ProviderUid"] = boost::any(*providerUid);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (typeString) {
      res["TypeString"] = boost::any(*typeString);
    }
    if (uploadTime) {
      res["UploadTime"] = boost::any(*uploadTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodePackageId") != m.end() && !m["ChaincodePackageId"].empty()) {
      chaincodePackageId = make_shared<long>(boost::any_cast<long>(m["ChaincodePackageId"]));
    }
    if (m.find("Checksum") != m.end() && !m["Checksum"].empty()) {
      checksum = make_shared<string>(boost::any_cast<string>(m["Checksum"]));
    }
    if (m.find("DeleteTime") != m.end() && !m["DeleteTime"].empty()) {
      deleteTime = make_shared<long>(boost::any_cast<long>(m["DeleteTime"]));
    }
    if (m.find("Deleted") != m.end() && !m["Deleted"].empty()) {
      deleted = make_shared<bool>(boost::any_cast<bool>(m["Deleted"]));
    }
    if (m.find("InstallTime") != m.end() && !m["InstallTime"].empty()) {
      installTime = make_shared<long>(boost::any_cast<long>(m["InstallTime"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Md5sum") != m.end() && !m["Md5sum"].empty()) {
      md5sum = make_shared<string>(boost::any_cast<string>(m["Md5sum"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssURL") != m.end() && !m["OssURL"].empty()) {
      ossURL = make_shared<string>(boost::any_cast<string>(m["OssURL"]));
    }
    if (m.find("ProviderBid") != m.end() && !m["ProviderBid"].empty()) {
      providerBid = make_shared<string>(boost::any_cast<string>(m["ProviderBid"]));
    }
    if (m.find("ProviderUid") != m.end() && !m["ProviderUid"].empty()) {
      providerUid = make_shared<long>(boost::any_cast<long>(m["ProviderUid"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("TypeString") != m.end() && !m["TypeString"].empty()) {
      typeString = make_shared<bool>(boost::any_cast<bool>(m["TypeString"]));
    }
    if (m.find("UploadTime") != m.end() && !m["UploadTime"].empty()) {
      uploadTime = make_shared<long>(boost::any_cast<long>(m["UploadTime"]));
    }
  }


  virtual ~CreateFabricChaincodePackageResponseBodyResult() = default;
};
class CreateFabricChaincodePackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateFabricChaincodePackageResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateFabricChaincodePackageResponseBody() {}

  explicit CreateFabricChaincodePackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateFabricChaincodePackageResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateFabricChaincodePackageResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateFabricChaincodePackageResponseBody() = default;
};
class CreateFabricChaincodePackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFabricChaincodePackageResponseBody> body{};

  CreateFabricChaincodePackageResponse() {}

  explicit CreateFabricChaincodePackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFabricChaincodePackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFabricChaincodePackageResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFabricChaincodePackageResponse() = default;
};
class CreateOrganizationRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<long> duration{};
  shared_ptr<string> location{};
  shared_ptr<string> majorVersion{};
  shared_ptr<string> name{};
  shared_ptr<long> peersCount{};
  shared_ptr<string> pricingCycle{};
  shared_ptr<string> specName{};

  CreateOrganizationRequest() {}

  explicit CreateOrganizationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (majorVersion) {
      res["MajorVersion"] = boost::any(*majorVersion);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (peersCount) {
      res["PeersCount"] = boost::any(*peersCount);
    }
    if (pricingCycle) {
      res["PricingCycle"] = boost::any(*pricingCycle);
    }
    if (specName) {
      res["SpecName"] = boost::any(*specName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("MajorVersion") != m.end() && !m["MajorVersion"].empty()) {
      majorVersion = make_shared<string>(boost::any_cast<string>(m["MajorVersion"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PeersCount") != m.end() && !m["PeersCount"].empty()) {
      peersCount = make_shared<long>(boost::any_cast<long>(m["PeersCount"]));
    }
    if (m.find("PricingCycle") != m.end() && !m["PricingCycle"].empty()) {
      pricingCycle = make_shared<string>(boost::any_cast<string>(m["PricingCycle"]));
    }
    if (m.find("SpecName") != m.end() && !m["SpecName"].empty()) {
      specName = make_shared<string>(boost::any_cast<string>(m["SpecName"]));
    }
  }


  virtual ~CreateOrganizationRequest() = default;
};
class CreateOrganizationResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> clusterState{};
  shared_ptr<string> codeName{};
  shared_ptr<long> consortiumCount{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<string> name{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> ownerBid{};
  shared_ptr<string> ownerName{};
  shared_ptr<long> ownerUid{};
  shared_ptr<long> peerCount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> serviceState{};
  shared_ptr<string> specName{};
  shared_ptr<long> userCount{};
  shared_ptr<string> zoneId{};

  CreateOrganizationResponseBodyResult() {}

  explicit CreateOrganizationResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterState) {
      res["ClusterState"] = boost::any(*clusterState);
    }
    if (codeName) {
      res["CodeName"] = boost::any(*codeName);
    }
    if (consortiumCount) {
      res["ConsortiumCount"] = boost::any(*consortiumCount);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (ownerBid) {
      res["OwnerBid"] = boost::any(*ownerBid);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUid) {
      res["OwnerUid"] = boost::any(*ownerUid);
    }
    if (peerCount) {
      res["PeerCount"] = boost::any(*peerCount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (serviceState) {
      res["ServiceState"] = boost::any(*serviceState);
    }
    if (specName) {
      res["SpecName"] = boost::any(*specName);
    }
    if (userCount) {
      res["UserCount"] = boost::any(*userCount);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterState") != m.end() && !m["ClusterState"].empty()) {
      clusterState = make_shared<string>(boost::any_cast<string>(m["ClusterState"]));
    }
    if (m.find("CodeName") != m.end() && !m["CodeName"].empty()) {
      codeName = make_shared<string>(boost::any_cast<string>(m["CodeName"]));
    }
    if (m.find("ConsortiumCount") != m.end() && !m["ConsortiumCount"].empty()) {
      consortiumCount = make_shared<long>(boost::any_cast<long>(m["ConsortiumCount"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("OwnerBid") != m.end() && !m["OwnerBid"].empty()) {
      ownerBid = make_shared<string>(boost::any_cast<string>(m["OwnerBid"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUid") != m.end() && !m["OwnerUid"].empty()) {
      ownerUid = make_shared<long>(boost::any_cast<long>(m["OwnerUid"]));
    }
    if (m.find("PeerCount") != m.end() && !m["PeerCount"].empty()) {
      peerCount = make_shared<long>(boost::any_cast<long>(m["PeerCount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ServiceState") != m.end() && !m["ServiceState"].empty()) {
      serviceState = make_shared<string>(boost::any_cast<string>(m["ServiceState"]));
    }
    if (m.find("SpecName") != m.end() && !m["SpecName"].empty()) {
      specName = make_shared<string>(boost::any_cast<string>(m["SpecName"]));
    }
    if (m.find("UserCount") != m.end() && !m["UserCount"].empty()) {
      userCount = make_shared<long>(boost::any_cast<long>(m["UserCount"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateOrganizationResponseBodyResult() = default;
};
class CreateOrganizationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateOrganizationResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateOrganizationResponseBody() {}

  explicit CreateOrganizationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateOrganizationResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateOrganizationResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateOrganizationResponseBody() = default;
};
class CreateOrganizationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrganizationResponseBody> body{};

  CreateOrganizationResponse() {}

  explicit CreateOrganizationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrganizationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrganizationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrganizationResponse() = default;
};
class CreateOrganizationUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> attrs{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> password{};
  shared_ptr<string> username{};

  CreateOrganizationUserRequest() {}

  explicit CreateOrganizationUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attrs) {
      res["Attrs"] = boost::any(*attrs);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attrs") != m.end() && !m["Attrs"].empty()) {
      attrs = make_shared<string>(boost::any_cast<string>(m["Attrs"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~CreateOrganizationUserRequest() = default;
};
class CreateOrganizationUserResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> fullname{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> password{};
  shared_ptr<string> username{};

  CreateOrganizationUserResponseBodyResult() {}

  explicit CreateOrganizationUserResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (fullname) {
      res["Fullname"] = boost::any(*fullname);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("Fullname") != m.end() && !m["Fullname"].empty()) {
      fullname = make_shared<string>(boost::any_cast<string>(m["Fullname"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~CreateOrganizationUserResponseBodyResult() = default;
};
class CreateOrganizationUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateOrganizationUserResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateOrganizationUserResponseBody() {}

  explicit CreateOrganizationUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateOrganizationUserResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateOrganizationUserResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateOrganizationUserResponseBody() = default;
};
class CreateOrganizationUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOrganizationUserResponseBody> body{};

  CreateOrganizationUserResponse() {}

  explicit CreateOrganizationUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOrganizationUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOrganizationUserResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOrganizationUserResponse() = default;
};
class CreateOwnAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<string> identity{};
  shared_ptr<string> publicKey{};
  shared_ptr<string> recoveryKey{};

  CreateOwnAccountRequest() {}

  explicit CreateOwnAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (identity) {
      res["Identity"] = boost::any(*identity);
    }
    if (publicKey) {
      res["PublicKey"] = boost::any(*publicKey);
    }
    if (recoveryKey) {
      res["RecoveryKey"] = boost::any(*recoveryKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Identity") != m.end() && !m["Identity"].empty()) {
      identity = make_shared<string>(boost::any_cast<string>(m["Identity"]));
    }
    if (m.find("PublicKey") != m.end() && !m["PublicKey"].empty()) {
      publicKey = make_shared<string>(boost::any_cast<string>(m["PublicKey"]));
    }
    if (m.find("RecoveryKey") != m.end() && !m["RecoveryKey"].empty()) {
      recoveryKey = make_shared<string>(boost::any_cast<string>(m["RecoveryKey"]));
    }
  }


  virtual ~CreateOwnAccountRequest() = default;
};
class CreateOwnAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  CreateOwnAccountResponseBody() {}

  explicit CreateOwnAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~CreateOwnAccountResponseBody() = default;
};
class CreateOwnAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOwnAccountResponseBody> body{};

  CreateOwnAccountResponse() {}

  explicit CreateOwnAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOwnAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOwnAccountResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOwnAccountResponse() = default;
};
class CreatePublicAccountWithKeyPairAutoCreationRequest : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> bizid{};
  shared_ptr<string> password{};
  shared_ptr<string> recoverPassword{};

  CreatePublicAccountWithKeyPairAutoCreationRequest() {}

  explicit CreatePublicAccountWithKeyPairAutoCreationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (recoverPassword) {
      res["RecoverPassword"] = boost::any(*recoverPassword);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("RecoverPassword") != m.end() && !m["RecoverPassword"].empty()) {
      recoverPassword = make_shared<string>(boost::any_cast<string>(m["RecoverPassword"]));
    }
  }


  virtual ~CreatePublicAccountWithKeyPairAutoCreationRequest() = default;
};
class CreatePublicAccountWithKeyPairAutoCreationResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> accountPrivateKey{};
  shared_ptr<string> accountPublicKey{};
  shared_ptr<string> accountRecoverPrivateKey{};
  shared_ptr<string> accountRecoverPublicKey{};

  CreatePublicAccountWithKeyPairAutoCreationResponseBodyResult() {}

  explicit CreatePublicAccountWithKeyPairAutoCreationResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountPrivateKey) {
      res["AccountPrivateKey"] = boost::any(*accountPrivateKey);
    }
    if (accountPublicKey) {
      res["AccountPublicKey"] = boost::any(*accountPublicKey);
    }
    if (accountRecoverPrivateKey) {
      res["AccountRecoverPrivateKey"] = boost::any(*accountRecoverPrivateKey);
    }
    if (accountRecoverPublicKey) {
      res["AccountRecoverPublicKey"] = boost::any(*accountRecoverPublicKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccountPrivateKey") != m.end() && !m["AccountPrivateKey"].empty()) {
      accountPrivateKey = make_shared<string>(boost::any_cast<string>(m["AccountPrivateKey"]));
    }
    if (m.find("AccountPublicKey") != m.end() && !m["AccountPublicKey"].empty()) {
      accountPublicKey = make_shared<string>(boost::any_cast<string>(m["AccountPublicKey"]));
    }
    if (m.find("AccountRecoverPrivateKey") != m.end() && !m["AccountRecoverPrivateKey"].empty()) {
      accountRecoverPrivateKey = make_shared<string>(boost::any_cast<string>(m["AccountRecoverPrivateKey"]));
    }
    if (m.find("AccountRecoverPublicKey") != m.end() && !m["AccountRecoverPublicKey"].empty()) {
      accountRecoverPublicKey = make_shared<string>(boost::any_cast<string>(m["AccountRecoverPublicKey"]));
    }
  }


  virtual ~CreatePublicAccountWithKeyPairAutoCreationResponseBodyResult() = default;
};
class CreatePublicAccountWithKeyPairAutoCreationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreatePublicAccountWithKeyPairAutoCreationResponseBodyResult> result{};

  CreatePublicAccountWithKeyPairAutoCreationResponseBody() {}

  explicit CreatePublicAccountWithKeyPairAutoCreationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreatePublicAccountWithKeyPairAutoCreationResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreatePublicAccountWithKeyPairAutoCreationResponseBodyResult>(model1);
      }
    }
  }


  virtual ~CreatePublicAccountWithKeyPairAutoCreationResponseBody() = default;
};
class CreatePublicAccountWithKeyPairAutoCreationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePublicAccountWithKeyPairAutoCreationResponseBody> body{};

  CreatePublicAccountWithKeyPairAutoCreationResponse() {}

  explicit CreatePublicAccountWithKeyPairAutoCreationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePublicAccountWithKeyPairAutoCreationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePublicAccountWithKeyPairAutoCreationResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePublicAccountWithKeyPairAutoCreationResponse() = default;
};
class CreatePublicAntChainAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> accountPubKey{};
  shared_ptr<string> accountRecoverPubKey{};
  shared_ptr<string> bizid{};

  CreatePublicAntChainAccountRequest() {}

  explicit CreatePublicAntChainAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (accountPubKey) {
      res["AccountPubKey"] = boost::any(*accountPubKey);
    }
    if (accountRecoverPubKey) {
      res["AccountRecoverPubKey"] = boost::any(*accountRecoverPubKey);
    }
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("AccountPubKey") != m.end() && !m["AccountPubKey"].empty()) {
      accountPubKey = make_shared<string>(boost::any_cast<string>(m["AccountPubKey"]));
    }
    if (m.find("AccountRecoverPubKey") != m.end() && !m["AccountRecoverPubKey"].empty()) {
      accountRecoverPubKey = make_shared<string>(boost::any_cast<string>(m["AccountRecoverPubKey"]));
    }
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~CreatePublicAntChainAccountRequest() = default;
};
class CreatePublicAntChainAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  CreatePublicAntChainAccountResponseBody() {}

  explicit CreatePublicAntChainAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~CreatePublicAntChainAccountResponseBody() = default;
};
class CreatePublicAntChainAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePublicAntChainAccountResponseBody> body{};

  CreatePublicAntChainAccountResponse() {}

  explicit CreatePublicAntChainAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePublicAntChainAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePublicAntChainAccountResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePublicAntChainAccountResponse() = default;
};
class CreateSmartContractJobResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> accessId{};
  shared_ptr<long> dir{};
  shared_ptr<long> expire{};
  shared_ptr<string> host{};
  shared_ptr<string> jobID{};
  shared_ptr<string> policy{};
  shared_ptr<string> signature{};

  CreateSmartContractJobResponseBodyResult() {}

  explicit CreateSmartContractJobResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessId) {
      res["AccessId"] = boost::any(*accessId);
    }
    if (dir) {
      res["Dir"] = boost::any(*dir);
    }
    if (expire) {
      res["Expire"] = boost::any(*expire);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (jobID) {
      res["JobID"] = boost::any(*jobID);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessId") != m.end() && !m["AccessId"].empty()) {
      accessId = make_shared<string>(boost::any_cast<string>(m["AccessId"]));
    }
    if (m.find("Dir") != m.end() && !m["Dir"].empty()) {
      dir = make_shared<long>(boost::any_cast<long>(m["Dir"]));
    }
    if (m.find("Expire") != m.end() && !m["Expire"].empty()) {
      expire = make_shared<long>(boost::any_cast<long>(m["Expire"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("JobID") != m.end() && !m["JobID"].empty()) {
      jobID = make_shared<string>(boost::any_cast<string>(m["JobID"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
  }


  virtual ~CreateSmartContractJobResponseBodyResult() = default;
};
class CreateSmartContractJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateSmartContractJobResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateSmartContractJobResponseBody() {}

  explicit CreateSmartContractJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateSmartContractJobResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateSmartContractJobResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateSmartContractJobResponseBody() = default;
};
class CreateSmartContractJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSmartContractJobResponseBody> body{};

  CreateSmartContractJobResponse() {}

  explicit CreateSmartContractJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSmartContractJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSmartContractJobResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSmartContractJobResponse() = default;
};
class CreateTriggerRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> name{};
  shared_ptr<string> options{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> source{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};

  CreateTriggerRequest() {}

  explicit CreateTriggerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (options) {
      res["Options"] = boost::any(*options);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Options") != m.end() && !m["Options"].empty()) {
      options = make_shared<string>(boost::any_cast<string>(m["Options"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateTriggerRequest() = default;
};
class CreateTriggerResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> channelName{};
  shared_ptr<long> createTime{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> name{};
  shared_ptr<string> options{};
  shared_ptr<string> source{};
  shared_ptr<long> status{};
  shared_ptr<string> type{};

  CreateTriggerResponseBodyResult() {}

  explicit CreateTriggerResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (options) {
      res["Options"] = boost::any(*options);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Options") != m.end() && !m["Options"].empty()) {
      options = make_shared<string>(boost::any_cast<string>(m["Options"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~CreateTriggerResponseBodyResult() = default;
};
class CreateTriggerResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateTriggerResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateTriggerResponseBody() {}

  explicit CreateTriggerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateTriggerResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateTriggerResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateTriggerResponseBody() = default;
};
class CreateTriggerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTriggerResponseBody> body{};

  CreateTriggerResponse() {}

  explicit CreateTriggerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTriggerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTriggerResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTriggerResponse() = default;
};
class DeleteAntChainConsortiumRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};

  DeleteAntChainConsortiumRequest() {}

  explicit DeleteAntChainConsortiumRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
  }


  virtual ~DeleteAntChainConsortiumRequest() = default;
};
class DeleteAntChainConsortiumResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  DeleteAntChainConsortiumResponseBody() {}

  explicit DeleteAntChainConsortiumResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~DeleteAntChainConsortiumResponseBody() = default;
};
class DeleteAntChainConsortiumResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAntChainConsortiumResponseBody> body{};

  DeleteAntChainConsortiumResponse() {}

  explicit DeleteAntChainConsortiumResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAntChainConsortiumResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAntChainConsortiumResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAntChainConsortiumResponse() = default;
};
class DeleteAntChainContractContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> contentId{};

  DeleteAntChainContractContentRequest() {}

  explicit DeleteAntChainContractContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentId) {
      res["ContentId"] = boost::any(*contentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentId") != m.end() && !m["ContentId"].empty()) {
      contentId = make_shared<string>(boost::any_cast<string>(m["ContentId"]));
    }
  }


  virtual ~DeleteAntChainContractContentRequest() = default;
};
class DeleteAntChainContractContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  DeleteAntChainContractContentResponseBody() {}

  explicit DeleteAntChainContractContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~DeleteAntChainContractContentResponseBody() = default;
};
class DeleteAntChainContractContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAntChainContractContentResponseBody> body{};

  DeleteAntChainContractContentResponse() {}

  explicit DeleteAntChainContractContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAntChainContractContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAntChainContractContentResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAntChainContractContentResponse() = default;
};
class DeleteAntChainContractProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};

  DeleteAntChainContractProjectRequest() {}

  explicit DeleteAntChainContractProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~DeleteAntChainContractProjectRequest() = default;
};
class DeleteAntChainContractProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  DeleteAntChainContractProjectResponseBody() {}

  explicit DeleteAntChainContractProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~DeleteAntChainContractProjectResponseBody() = default;
};
class DeleteAntChainContractProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAntChainContractProjectResponseBody> body{};

  DeleteAntChainContractProjectResponse() {}

  explicit DeleteAntChainContractProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAntChainContractProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAntChainContractProjectResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAntChainContractProjectResponse() = default;
};
class DeleteAntChainMiniAppQRCodeAuthorizedUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> phone{};

  DeleteAntChainMiniAppQRCodeAuthorizedUserRequest() {}

  explicit DeleteAntChainMiniAppQRCodeAuthorizedUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
  }


  virtual ~DeleteAntChainMiniAppQRCodeAuthorizedUserRequest() = default;
};
class DeleteAntChainMiniAppQRCodeAuthorizedUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  DeleteAntChainMiniAppQRCodeAuthorizedUserResponseBody() {}

  explicit DeleteAntChainMiniAppQRCodeAuthorizedUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~DeleteAntChainMiniAppQRCodeAuthorizedUserResponseBody() = default;
};
class DeleteAntChainMiniAppQRCodeAuthorizedUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAntChainMiniAppQRCodeAuthorizedUserResponseBody> body{};

  DeleteAntChainMiniAppQRCodeAuthorizedUserResponse() {}

  explicit DeleteAntChainMiniAppQRCodeAuthorizedUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAntChainMiniAppQRCodeAuthorizedUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAntChainMiniAppQRCodeAuthorizedUserResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAntChainMiniAppQRCodeAuthorizedUserResponse() = default;
};
class DeleteChaincodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};

  DeleteChaincodeRequest() {}

  explicit DeleteChaincodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
  }


  virtual ~DeleteChaincodeRequest() = default;
};
class DeleteChaincodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteChaincodeResponseBody() {}

  explicit DeleteChaincodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteChaincodeResponseBody() = default;
};
class DeleteChaincodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteChaincodeResponseBody> body{};

  DeleteChaincodeResponse() {}

  explicit DeleteChaincodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteChaincodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteChaincodeResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteChaincodeResponse() = default;
};
class DeleteGovernanceTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> taskId{};

  DeleteGovernanceTaskRequest() {}

  explicit DeleteGovernanceTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DeleteGovernanceTaskRequest() = default;
};
class DeleteGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<long> port{};

  DeleteGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers() {}

  explicit DeleteGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
  }


  virtual ~DeleteGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers() = default;
};
class DeleteGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> certificate{};
  shared_ptr<string> key{};
  shared_ptr<string> tlsroot{};

  DeleteGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes() {}

  explicit DeleteGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (tlsroot) {
      res["Tlsroot"] = boost::any(*tlsroot);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Tlsroot") != m.end() && !m["Tlsroot"].empty()) {
      tlsroot = make_shared<string>(boost::any_cast<string>(m["Tlsroot"]));
    }
  }


  virtual ~DeleteGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes() = default;
};
class DeleteGovernanceTaskResponseBodyResultContentAddedOrganizations : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers>> anchorPeers{};
  shared_ptr<string> crls{};
  shared_ptr<string> mspId{};
  shared_ptr<string> mspType{};
  shared_ptr<bool> orderer{};
  shared_ptr<vector<DeleteGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes>> ordererNodes{};
  shared_ptr<string> rootCertificates{};
  shared_ptr<string> tlsRootCertificates{};

  DeleteGovernanceTaskResponseBodyResultContentAddedOrganizations() {}

  explicit DeleteGovernanceTaskResponseBodyResultContentAddedOrganizations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (anchorPeers) {
      vector<boost::any> temp1;
      for(auto item1:*anchorPeers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnchorPeers"] = boost::any(temp1);
    }
    if (crls) {
      res["Crls"] = boost::any(*crls);
    }
    if (mspId) {
      res["MspId"] = boost::any(*mspId);
    }
    if (mspType) {
      res["MspType"] = boost::any(*mspType);
    }
    if (orderer) {
      res["Orderer"] = boost::any(*orderer);
    }
    if (ordererNodes) {
      vector<boost::any> temp1;
      for(auto item1:*ordererNodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OrdererNodes"] = boost::any(temp1);
    }
    if (rootCertificates) {
      res["RootCertificates"] = boost::any(*rootCertificates);
    }
    if (tlsRootCertificates) {
      res["TlsRootCertificates"] = boost::any(*tlsRootCertificates);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnchorPeers") != m.end() && !m["AnchorPeers"].empty()) {
      if (typeid(vector<boost::any>) == m["AnchorPeers"].type()) {
        vector<DeleteGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnchorPeers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        anchorPeers = make_shared<vector<DeleteGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers>>(expect1);
      }
    }
    if (m.find("Crls") != m.end() && !m["Crls"].empty()) {
      crls = make_shared<string>(boost::any_cast<string>(m["Crls"]));
    }
    if (m.find("MspId") != m.end() && !m["MspId"].empty()) {
      mspId = make_shared<string>(boost::any_cast<string>(m["MspId"]));
    }
    if (m.find("MspType") != m.end() && !m["MspType"].empty()) {
      mspType = make_shared<string>(boost::any_cast<string>(m["MspType"]));
    }
    if (m.find("Orderer") != m.end() && !m["Orderer"].empty()) {
      orderer = make_shared<bool>(boost::any_cast<bool>(m["Orderer"]));
    }
    if (m.find("OrdererNodes") != m.end() && !m["OrdererNodes"].empty()) {
      if (typeid(vector<boost::any>) == m["OrdererNodes"].type()) {
        vector<DeleteGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OrdererNodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ordererNodes = make_shared<vector<DeleteGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes>>(expect1);
      }
    }
    if (m.find("RootCertificates") != m.end() && !m["RootCertificates"].empty()) {
      rootCertificates = make_shared<string>(boost::any_cast<string>(m["RootCertificates"]));
    }
    if (m.find("TlsRootCertificates") != m.end() && !m["TlsRootCertificates"].empty()) {
      tlsRootCertificates = make_shared<string>(boost::any_cast<string>(m["TlsRootCertificates"]));
    }
  }


  virtual ~DeleteGovernanceTaskResponseBodyResultContentAddedOrganizations() = default;
};
class DeleteGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs : public Darabonba::Model {
public:
  shared_ptr<string> input{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<long> type{};
  shared_ptr<string> version{};

  DeleteGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs() {}

  explicit DeleteGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DeleteGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs() = default;
};
class DeleteGovernanceTaskResponseBodyResultContentChaincodeSpecPkg : public Darabonba::Model {
public:
  shared_ptr<DeleteGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs> cs{};
  shared_ptr<string> policy{};
  shared_ptr<string> sha256{};

  DeleteGovernanceTaskResponseBodyResultContentChaincodeSpecPkg() {}

  explicit DeleteGovernanceTaskResponseBodyResultContentChaincodeSpecPkg(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cs) {
      res["Cs"] = cs ? boost::any(cs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (sha256) {
      res["Sha256"] = boost::any(*sha256);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cs") != m.end() && !m["Cs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cs"].type()) {
        DeleteGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cs"]));
        cs = make_shared<DeleteGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs>(model1);
      }
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Sha256") != m.end() && !m["Sha256"].empty()) {
      sha256 = make_shared<string>(boost::any_cast<string>(m["Sha256"]));
    }
  }


  virtual ~DeleteGovernanceTaskResponseBodyResultContentChaincodeSpecPkg() = default;
};
class DeleteGovernanceTaskResponseBodyResultContentOrdererConfig : public Darabonba::Model {
public:
  shared_ptr<string> batchTimeout{};
  shared_ptr<long> maxMessageCount{};
  shared_ptr<long> preferredMaxBytes{};

  DeleteGovernanceTaskResponseBodyResultContentOrdererConfig() {}

  explicit DeleteGovernanceTaskResponseBodyResultContentOrdererConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchTimeout) {
      res["BatchTimeout"] = boost::any(*batchTimeout);
    }
    if (maxMessageCount) {
      res["MaxMessageCount"] = boost::any(*maxMessageCount);
    }
    if (preferredMaxBytes) {
      res["PreferredMaxBytes"] = boost::any(*preferredMaxBytes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchTimeout") != m.end() && !m["BatchTimeout"].empty()) {
      batchTimeout = make_shared<string>(boost::any_cast<string>(m["BatchTimeout"]));
    }
    if (m.find("MaxMessageCount") != m.end() && !m["MaxMessageCount"].empty()) {
      maxMessageCount = make_shared<long>(boost::any_cast<long>(m["MaxMessageCount"]));
    }
    if (m.find("PreferredMaxBytes") != m.end() && !m["PreferredMaxBytes"].empty()) {
      preferredMaxBytes = make_shared<long>(boost::any_cast<long>(m["PreferredMaxBytes"]));
    }
  }


  virtual ~DeleteGovernanceTaskResponseBodyResultContentOrdererConfig() = default;
};
class DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<long> port{};

  DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers() {}

  explicit DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
  }


  virtual ~DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers() = default;
};
class DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> certificate{};
  shared_ptr<string> key{};
  shared_ptr<string> tlsroot{};

  DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes() {}

  explicit DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (tlsroot) {
      res["Tlsroot"] = boost::any(*tlsroot);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Tlsroot") != m.end() && !m["Tlsroot"].empty()) {
      tlsroot = make_shared<string>(boost::any_cast<string>(m["Tlsroot"]));
    }
  }


  virtual ~DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes() = default;
};
class DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizations : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers>> anchorPeers{};
  shared_ptr<string> crls{};
  shared_ptr<string> mspId{};
  shared_ptr<string> mspType{};
  shared_ptr<bool> orderer{};
  shared_ptr<vector<DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes>> ordererNodes{};
  shared_ptr<string> rootCertificates{};
  shared_ptr<string> tlsRootCertificates{};

  DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizations() {}

  explicit DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (anchorPeers) {
      vector<boost::any> temp1;
      for(auto item1:*anchorPeers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnchorPeers"] = boost::any(temp1);
    }
    if (crls) {
      res["Crls"] = boost::any(*crls);
    }
    if (mspId) {
      res["MspId"] = boost::any(*mspId);
    }
    if (mspType) {
      res["MspType"] = boost::any(*mspType);
    }
    if (orderer) {
      res["Orderer"] = boost::any(*orderer);
    }
    if (ordererNodes) {
      vector<boost::any> temp1;
      for(auto item1:*ordererNodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OrdererNodes"] = boost::any(temp1);
    }
    if (rootCertificates) {
      res["RootCertificates"] = boost::any(*rootCertificates);
    }
    if (tlsRootCertificates) {
      res["TlsRootCertificates"] = boost::any(*tlsRootCertificates);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnchorPeers") != m.end() && !m["AnchorPeers"].empty()) {
      if (typeid(vector<boost::any>) == m["AnchorPeers"].type()) {
        vector<DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnchorPeers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        anchorPeers = make_shared<vector<DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers>>(expect1);
      }
    }
    if (m.find("Crls") != m.end() && !m["Crls"].empty()) {
      crls = make_shared<string>(boost::any_cast<string>(m["Crls"]));
    }
    if (m.find("MspId") != m.end() && !m["MspId"].empty()) {
      mspId = make_shared<string>(boost::any_cast<string>(m["MspId"]));
    }
    if (m.find("MspType") != m.end() && !m["MspType"].empty()) {
      mspType = make_shared<string>(boost::any_cast<string>(m["MspType"]));
    }
    if (m.find("Orderer") != m.end() && !m["Orderer"].empty()) {
      orderer = make_shared<bool>(boost::any_cast<bool>(m["Orderer"]));
    }
    if (m.find("OrdererNodes") != m.end() && !m["OrdererNodes"].empty()) {
      if (typeid(vector<boost::any>) == m["OrdererNodes"].type()) {
        vector<DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OrdererNodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ordererNodes = make_shared<vector<DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes>>(expect1);
      }
    }
    if (m.find("RootCertificates") != m.end() && !m["RootCertificates"].empty()) {
      rootCertificates = make_shared<string>(boost::any_cast<string>(m["RootCertificates"]));
    }
    if (m.find("TlsRootCertificates") != m.end() && !m["TlsRootCertificates"].empty()) {
      tlsRootCertificates = make_shared<string>(boost::any_cast<string>(m["TlsRootCertificates"]));
    }
  }


  virtual ~DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizations() = default;
};
class DeleteGovernanceTaskResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<vector<DeleteGovernanceTaskResponseBodyResultContentAddedOrganizations>> addedOrganizations{};
  shared_ptr<DeleteGovernanceTaskResponseBodyResultContentChaincodeSpecPkg> chaincodeSpecPkg{};
  shared_ptr<DeleteGovernanceTaskResponseBodyResultContentOrdererConfig> ordererConfig{};
  shared_ptr<string> raw{};
  shared_ptr<vector<DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizations>> removedOrganizations{};
  shared_ptr<string> rwSets{};

  DeleteGovernanceTaskResponseBodyResultContent() {}

  explicit DeleteGovernanceTaskResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addedOrganizations) {
      vector<boost::any> temp1;
      for(auto item1:*addedOrganizations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AddedOrganizations"] = boost::any(temp1);
    }
    if (chaincodeSpecPkg) {
      res["ChaincodeSpecPkg"] = chaincodeSpecPkg ? boost::any(chaincodeSpecPkg->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ordererConfig) {
      res["OrdererConfig"] = ordererConfig ? boost::any(ordererConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (raw) {
      res["Raw"] = boost::any(*raw);
    }
    if (removedOrganizations) {
      vector<boost::any> temp1;
      for(auto item1:*removedOrganizations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RemovedOrganizations"] = boost::any(temp1);
    }
    if (rwSets) {
      res["RwSets"] = boost::any(*rwSets);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddedOrganizations") != m.end() && !m["AddedOrganizations"].empty()) {
      if (typeid(vector<boost::any>) == m["AddedOrganizations"].type()) {
        vector<DeleteGovernanceTaskResponseBodyResultContentAddedOrganizations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AddedOrganizations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteGovernanceTaskResponseBodyResultContentAddedOrganizations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addedOrganizations = make_shared<vector<DeleteGovernanceTaskResponseBodyResultContentAddedOrganizations>>(expect1);
      }
    }
    if (m.find("ChaincodeSpecPkg") != m.end() && !m["ChaincodeSpecPkg"].empty()) {
      if (typeid(map<string, boost::any>) == m["ChaincodeSpecPkg"].type()) {
        DeleteGovernanceTaskResponseBodyResultContentChaincodeSpecPkg model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ChaincodeSpecPkg"]));
        chaincodeSpecPkg = make_shared<DeleteGovernanceTaskResponseBodyResultContentChaincodeSpecPkg>(model1);
      }
    }
    if (m.find("OrdererConfig") != m.end() && !m["OrdererConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OrdererConfig"].type()) {
        DeleteGovernanceTaskResponseBodyResultContentOrdererConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OrdererConfig"]));
        ordererConfig = make_shared<DeleteGovernanceTaskResponseBodyResultContentOrdererConfig>(model1);
      }
    }
    if (m.find("Raw") != m.end() && !m["Raw"].empty()) {
      raw = make_shared<string>(boost::any_cast<string>(m["Raw"]));
    }
    if (m.find("RemovedOrganizations") != m.end() && !m["RemovedOrganizations"].empty()) {
      if (typeid(vector<boost::any>) == m["RemovedOrganizations"].type()) {
        vector<DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RemovedOrganizations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        removedOrganizations = make_shared<vector<DeleteGovernanceTaskResponseBodyResultContentRemovedOrganizations>>(expect1);
      }
    }
    if (m.find("RwSets") != m.end() && !m["RwSets"].empty()) {
      rwSets = make_shared<string>(boost::any_cast<string>(m["RwSets"]));
    }
  }


  virtual ~DeleteGovernanceTaskResponseBodyResultContent() = default;
};
class DeleteGovernanceTaskResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<DeleteGovernanceTaskResponseBodyResultContent> content{};
  shared_ptr<long> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> type{};

  DeleteGovernanceTaskResponseBodyResult() {}

  explicit DeleteGovernanceTaskResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        DeleteGovernanceTaskResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<DeleteGovernanceTaskResponseBodyResultContent>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DeleteGovernanceTaskResponseBodyResult() = default;
};
class DeleteGovernanceTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DeleteGovernanceTaskResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DeleteGovernanceTaskResponseBody() {}

  explicit DeleteGovernanceTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DeleteGovernanceTaskResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DeleteGovernanceTaskResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteGovernanceTaskResponseBody() = default;
};
class DeleteGovernanceTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteGovernanceTaskResponseBody> body{};

  DeleteGovernanceTaskResponse() {}

  explicit DeleteGovernanceTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteGovernanceTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteGovernanceTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteGovernanceTaskResponse() = default;
};
class DeleteTriggerRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> name{};
  shared_ptr<string> organizationId{};

  DeleteTriggerRequest() {}

  explicit DeleteTriggerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DeleteTriggerRequest() = default;
};
class DeleteTriggerResponseBodyResultCheckpoint : public Darabonba::Model {
public:
  shared_ptr<long> errorCount{};
  shared_ptr<long> height{};
  shared_ptr<long> index{};
  shared_ptr<string> type{};

  DeleteTriggerResponseBodyResultCheckpoint() {}

  explicit DeleteTriggerResponseBodyResultCheckpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCount) {
      res["ErrorCount"] = boost::any(*errorCount);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCount") != m.end() && !m["ErrorCount"].empty()) {
      errorCount = make_shared<long>(boost::any_cast<long>(m["ErrorCount"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DeleteTriggerResponseBodyResultCheckpoint() = default;
};
class DeleteTriggerResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> channelName{};
  shared_ptr<DeleteTriggerResponseBodyResultCheckpoint> checkpoint{};
  shared_ptr<long> createTime{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> name{};
  shared_ptr<string> options{};
  shared_ptr<string> source{};
  shared_ptr<long> status{};
  shared_ptr<string> type{};

  DeleteTriggerResponseBodyResult() {}

  explicit DeleteTriggerResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (checkpoint) {
      res["Checkpoint"] = checkpoint ? boost::any(checkpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (options) {
      res["Options"] = boost::any(*options);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("Checkpoint") != m.end() && !m["Checkpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["Checkpoint"].type()) {
        DeleteTriggerResponseBodyResultCheckpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Checkpoint"]));
        checkpoint = make_shared<DeleteTriggerResponseBodyResultCheckpoint>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Options") != m.end() && !m["Options"].empty()) {
      options = make_shared<string>(boost::any_cast<string>(m["Options"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DeleteTriggerResponseBodyResult() = default;
};
class DeleteTriggerResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DeleteTriggerResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DeleteTriggerResponseBody() {}

  explicit DeleteTriggerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DeleteTriggerResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DeleteTriggerResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteTriggerResponseBody() = default;
};
class DeleteTriggerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTriggerResponseBody> body{};

  DeleteTriggerResponse() {}

  explicit DeleteTriggerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTriggerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTriggerResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTriggerResponse() = default;
};
class DescribeAntChainAccountsRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeAntChainAccountsRequest() {}

  explicit DescribeAntChainAccountsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeAntChainAccountsRequest() = default;
};
class DescribeAntChainAccountsResponseBodyResultAccounts : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> accountPublicKey{};
  shared_ptr<string> accountRecoveryKey{};
  shared_ptr<string> accountStatus{};
  shared_ptr<string> antChainId{};

  DescribeAntChainAccountsResponseBodyResultAccounts() {}

  explicit DescribeAntChainAccountsResponseBodyResultAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (accountPublicKey) {
      res["AccountPublicKey"] = boost::any(*accountPublicKey);
    }
    if (accountRecoveryKey) {
      res["AccountRecoveryKey"] = boost::any(*accountRecoveryKey);
    }
    if (accountStatus) {
      res["AccountStatus"] = boost::any(*accountStatus);
    }
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("AccountPublicKey") != m.end() && !m["AccountPublicKey"].empty()) {
      accountPublicKey = make_shared<string>(boost::any_cast<string>(m["AccountPublicKey"]));
    }
    if (m.find("AccountRecoveryKey") != m.end() && !m["AccountRecoveryKey"].empty()) {
      accountRecoveryKey = make_shared<string>(boost::any_cast<string>(m["AccountRecoveryKey"]));
    }
    if (m.find("AccountStatus") != m.end() && !m["AccountStatus"].empty()) {
      accountStatus = make_shared<string>(boost::any_cast<string>(m["AccountStatus"]));
    }
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
  }


  virtual ~DescribeAntChainAccountsResponseBodyResultAccounts() = default;
};
class DescribeAntChainAccountsResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainAccountsResponseBodyResultPagination() {}

  explicit DescribeAntChainAccountsResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainAccountsResponseBodyResultPagination() = default;
};
class DescribeAntChainAccountsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAntChainAccountsResponseBodyResultAccounts>> accounts{};
  shared_ptr<DescribeAntChainAccountsResponseBodyResultPagination> pagination{};

  DescribeAntChainAccountsResponseBodyResult() {}

  explicit DescribeAntChainAccountsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accounts) {
      vector<boost::any> temp1;
      for(auto item1:*accounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Accounts"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Accounts") != m.end() && !m["Accounts"].empty()) {
      if (typeid(vector<boost::any>) == m["Accounts"].type()) {
        vector<DescribeAntChainAccountsResponseBodyResultAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Accounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainAccountsResponseBodyResultAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accounts = make_shared<vector<DescribeAntChainAccountsResponseBodyResultAccounts>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainAccountsResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainAccountsResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeAntChainAccountsResponseBodyResult() = default;
};
class DescribeAntChainAccountsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainAccountsResponseBodyResult> result{};

  DescribeAntChainAccountsResponseBody() {}

  explicit DescribeAntChainAccountsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainAccountsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainAccountsResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainAccountsResponseBody() = default;
};
class DescribeAntChainAccountsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainAccountsResponseBody> body{};

  DescribeAntChainAccountsResponse() {}

  explicit DescribeAntChainAccountsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainAccountsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainAccountsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainAccountsResponse() = default;
};
class DescribeAntChainAccountsNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> consortiumId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeAntChainAccountsNewRequest() {}

  explicit DescribeAntChainAccountsNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeAntChainAccountsNewRequest() = default;
};
class DescribeAntChainAccountsNewResponseBodyResultAccounts : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> accountPublicKey{};
  shared_ptr<string> accountRecoveryKey{};
  shared_ptr<string> accountStatus{};
  shared_ptr<string> antChainId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> memberName{};

  DescribeAntChainAccountsNewResponseBodyResultAccounts() {}

  explicit DescribeAntChainAccountsNewResponseBodyResultAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (accountPublicKey) {
      res["AccountPublicKey"] = boost::any(*accountPublicKey);
    }
    if (accountRecoveryKey) {
      res["AccountRecoveryKey"] = boost::any(*accountRecoveryKey);
    }
    if (accountStatus) {
      res["AccountStatus"] = boost::any(*accountStatus);
    }
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (memberName) {
      res["MemberName"] = boost::any(*memberName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("AccountPublicKey") != m.end() && !m["AccountPublicKey"].empty()) {
      accountPublicKey = make_shared<string>(boost::any_cast<string>(m["AccountPublicKey"]));
    }
    if (m.find("AccountRecoveryKey") != m.end() && !m["AccountRecoveryKey"].empty()) {
      accountRecoveryKey = make_shared<string>(boost::any_cast<string>(m["AccountRecoveryKey"]));
    }
    if (m.find("AccountStatus") != m.end() && !m["AccountStatus"].empty()) {
      accountStatus = make_shared<string>(boost::any_cast<string>(m["AccountStatus"]));
    }
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("MemberName") != m.end() && !m["MemberName"].empty()) {
      memberName = make_shared<string>(boost::any_cast<string>(m["MemberName"]));
    }
  }


  virtual ~DescribeAntChainAccountsNewResponseBodyResultAccounts() = default;
};
class DescribeAntChainAccountsNewResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainAccountsNewResponseBodyResultPagination() {}

  explicit DescribeAntChainAccountsNewResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainAccountsNewResponseBodyResultPagination() = default;
};
class DescribeAntChainAccountsNewResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAntChainAccountsNewResponseBodyResultAccounts>> accounts{};
  shared_ptr<bool> consortiumAdmin{};
  shared_ptr<DescribeAntChainAccountsNewResponseBodyResultPagination> pagination{};

  DescribeAntChainAccountsNewResponseBodyResult() {}

  explicit DescribeAntChainAccountsNewResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accounts) {
      vector<boost::any> temp1;
      for(auto item1:*accounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Accounts"] = boost::any(temp1);
    }
    if (consortiumAdmin) {
      res["ConsortiumAdmin"] = boost::any(*consortiumAdmin);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Accounts") != m.end() && !m["Accounts"].empty()) {
      if (typeid(vector<boost::any>) == m["Accounts"].type()) {
        vector<DescribeAntChainAccountsNewResponseBodyResultAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Accounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainAccountsNewResponseBodyResultAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accounts = make_shared<vector<DescribeAntChainAccountsNewResponseBodyResultAccounts>>(expect1);
      }
    }
    if (m.find("ConsortiumAdmin") != m.end() && !m["ConsortiumAdmin"].empty()) {
      consortiumAdmin = make_shared<bool>(boost::any_cast<bool>(m["ConsortiumAdmin"]));
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainAccountsNewResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainAccountsNewResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeAntChainAccountsNewResponseBodyResult() = default;
};
class DescribeAntChainAccountsNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainAccountsNewResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainAccountsNewResponseBody() {}

  explicit DescribeAntChainAccountsNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainAccountsNewResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainAccountsNewResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainAccountsNewResponseBody() = default;
};
class DescribeAntChainAccountsNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainAccountsNewResponseBody> body{};

  DescribeAntChainAccountsNewResponse() {}

  explicit DescribeAntChainAccountsNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainAccountsNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainAccountsNewResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainAccountsNewResponse() = default;
};
class DescribeAntChainApplicationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<long> current{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> status{};

  DescribeAntChainApplicationsRequest() {}

  explicit DescribeAntChainApplicationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeAntChainApplicationsRequest() = default;
};
class DescribeAntChainApplicationsResponseBodyResultApplyHistoryList : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<long> createtime{};
  shared_ptr<long> id{};
  shared_ptr<string> rejectReason{};
  shared_ptr<string> reqAddr{};
  shared_ptr<string> signedAddr{};
  shared_ptr<long> status{};
  shared_ptr<long> updatetime{};
  shared_ptr<string> username{};

  DescribeAntChainApplicationsResponseBodyResultApplyHistoryList() {}

  explicit DescribeAntChainApplicationsResponseBodyResultApplyHistoryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (createtime) {
      res["Createtime"] = boost::any(*createtime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (rejectReason) {
      res["RejectReason"] = boost::any(*rejectReason);
    }
    if (reqAddr) {
      res["ReqAddr"] = boost::any(*reqAddr);
    }
    if (signedAddr) {
      res["SignedAddr"] = boost::any(*signedAddr);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updatetime) {
      res["Updatetime"] = boost::any(*updatetime);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Createtime") != m.end() && !m["Createtime"].empty()) {
      createtime = make_shared<long>(boost::any_cast<long>(m["Createtime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RejectReason") != m.end() && !m["RejectReason"].empty()) {
      rejectReason = make_shared<string>(boost::any_cast<string>(m["RejectReason"]));
    }
    if (m.find("ReqAddr") != m.end() && !m["ReqAddr"].empty()) {
      reqAddr = make_shared<string>(boost::any_cast<string>(m["ReqAddr"]));
    }
    if (m.find("SignedAddr") != m.end() && !m["SignedAddr"].empty()) {
      signedAddr = make_shared<string>(boost::any_cast<string>(m["SignedAddr"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Updatetime") != m.end() && !m["Updatetime"].empty()) {
      updatetime = make_shared<long>(boost::any_cast<long>(m["Updatetime"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~DescribeAntChainApplicationsResponseBodyResultApplyHistoryList() = default;
};
class DescribeAntChainApplicationsResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> current{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  DescribeAntChainApplicationsResponseBodyResultPagination() {}

  explicit DescribeAntChainApplicationsResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeAntChainApplicationsResponseBodyResultPagination() = default;
};
class DescribeAntChainApplicationsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAntChainApplicationsResponseBodyResultApplyHistoryList>> applyHistoryList{};
  shared_ptr<DescribeAntChainApplicationsResponseBodyResultPagination> pagination{};

  DescribeAntChainApplicationsResponseBodyResult() {}

  explicit DescribeAntChainApplicationsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyHistoryList) {
      vector<boost::any> temp1;
      for(auto item1:*applyHistoryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApplyHistoryList"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyHistoryList") != m.end() && !m["ApplyHistoryList"].empty()) {
      if (typeid(vector<boost::any>) == m["ApplyHistoryList"].type()) {
        vector<DescribeAntChainApplicationsResponseBodyResultApplyHistoryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApplyHistoryList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainApplicationsResponseBodyResultApplyHistoryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applyHistoryList = make_shared<vector<DescribeAntChainApplicationsResponseBodyResultApplyHistoryList>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainApplicationsResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainApplicationsResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeAntChainApplicationsResponseBodyResult() = default;
};
class DescribeAntChainApplicationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainApplicationsResponseBodyResult> result{};

  DescribeAntChainApplicationsResponseBody() {}

  explicit DescribeAntChainApplicationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainApplicationsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainApplicationsResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainApplicationsResponseBody() = default;
};
class DescribeAntChainApplicationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainApplicationsResponseBody> body{};

  DescribeAntChainApplicationsResponse() {}

  explicit DescribeAntChainApplicationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainApplicationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainApplicationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainApplicationsResponse() = default;
};
class DescribeAntChainBlockRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<long> height{};

  DescribeAntChainBlockRequest() {}

  explicit DescribeAntChainBlockRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
  }


  virtual ~DescribeAntChainBlockRequest() = default;
};
class DescribeAntChainBlockResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> blockHash{};
  shared_ptr<long> createTime{};
  shared_ptr<long> height{};
  shared_ptr<string> previousHash{};
  shared_ptr<string> rootTxHash{};
  shared_ptr<string> transSummaryList{};
  shared_ptr<long> transactionSize{};
  shared_ptr<long> version{};

  DescribeAntChainBlockResponseBodyResult() {}

  explicit DescribeAntChainBlockResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (blockHash) {
      res["BlockHash"] = boost::any(*blockHash);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (previousHash) {
      res["PreviousHash"] = boost::any(*previousHash);
    }
    if (rootTxHash) {
      res["RootTxHash"] = boost::any(*rootTxHash);
    }
    if (transSummaryList) {
      res["TransSummaryList"] = boost::any(*transSummaryList);
    }
    if (transactionSize) {
      res["TransactionSize"] = boost::any(*transactionSize);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("BlockHash") != m.end() && !m["BlockHash"].empty()) {
      blockHash = make_shared<string>(boost::any_cast<string>(m["BlockHash"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("PreviousHash") != m.end() && !m["PreviousHash"].empty()) {
      previousHash = make_shared<string>(boost::any_cast<string>(m["PreviousHash"]));
    }
    if (m.find("RootTxHash") != m.end() && !m["RootTxHash"].empty()) {
      rootTxHash = make_shared<string>(boost::any_cast<string>(m["RootTxHash"]));
    }
    if (m.find("TransSummaryList") != m.end() && !m["TransSummaryList"].empty()) {
      transSummaryList = make_shared<string>(boost::any_cast<string>(m["TransSummaryList"]));
    }
    if (m.find("TransactionSize") != m.end() && !m["TransactionSize"].empty()) {
      transactionSize = make_shared<long>(boost::any_cast<long>(m["TransactionSize"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~DescribeAntChainBlockResponseBodyResult() = default;
};
class DescribeAntChainBlockResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainBlockResponseBodyResult> result{};

  DescribeAntChainBlockResponseBody() {}

  explicit DescribeAntChainBlockResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainBlockResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainBlockResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainBlockResponseBody() = default;
};
class DescribeAntChainBlockResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainBlockResponseBody> body{};

  DescribeAntChainBlockResponse() {}

  explicit DescribeAntChainBlockResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainBlockResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainBlockResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainBlockResponse() = default;
};
class DescribeAntChainBlockNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> consortiumId{};
  shared_ptr<long> height{};

  DescribeAntChainBlockNewRequest() {}

  explicit DescribeAntChainBlockNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
  }


  virtual ~DescribeAntChainBlockNewRequest() = default;
};
class DescribeAntChainBlockNewResponseBodyResultTransSummaryList : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> blockHash{};
  shared_ptr<long> category{};
  shared_ptr<long> createTime{};
  shared_ptr<string> from{};
  shared_ptr<long> gasUsed{};
  shared_ptr<string> hash{};
  shared_ptr<long> height{};
  shared_ptr<long> referenceCount{};
  shared_ptr<string> to{};
  shared_ptr<string> transTypeV10{};
  shared_ptr<string> transTypeV6{};

  DescribeAntChainBlockNewResponseBodyResultTransSummaryList() {}

  explicit DescribeAntChainBlockNewResponseBodyResultTransSummaryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (blockHash) {
      res["BlockHash"] = boost::any(*blockHash);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (gasUsed) {
      res["GasUsed"] = boost::any(*gasUsed);
    }
    if (hash) {
      res["Hash"] = boost::any(*hash);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (referenceCount) {
      res["ReferenceCount"] = boost::any(*referenceCount);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    if (transTypeV10) {
      res["TransTypeV10"] = boost::any(*transTypeV10);
    }
    if (transTypeV6) {
      res["TransTypeV6"] = boost::any(*transTypeV6);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("BlockHash") != m.end() && !m["BlockHash"].empty()) {
      blockHash = make_shared<string>(boost::any_cast<string>(m["BlockHash"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<long>(boost::any_cast<long>(m["Category"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("GasUsed") != m.end() && !m["GasUsed"].empty()) {
      gasUsed = make_shared<long>(boost::any_cast<long>(m["GasUsed"]));
    }
    if (m.find("Hash") != m.end() && !m["Hash"].empty()) {
      hash = make_shared<string>(boost::any_cast<string>(m["Hash"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("ReferenceCount") != m.end() && !m["ReferenceCount"].empty()) {
      referenceCount = make_shared<long>(boost::any_cast<long>(m["ReferenceCount"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<string>(boost::any_cast<string>(m["To"]));
    }
    if (m.find("TransTypeV10") != m.end() && !m["TransTypeV10"].empty()) {
      transTypeV10 = make_shared<string>(boost::any_cast<string>(m["TransTypeV10"]));
    }
    if (m.find("TransTypeV6") != m.end() && !m["TransTypeV6"].empty()) {
      transTypeV6 = make_shared<string>(boost::any_cast<string>(m["TransTypeV6"]));
    }
  }


  virtual ~DescribeAntChainBlockNewResponseBodyResultTransSummaryList() = default;
};
class DescribeAntChainBlockNewResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> blockHash{};
  shared_ptr<long> createTime{};
  shared_ptr<long> height{};
  shared_ptr<string> previousHash{};
  shared_ptr<string> rootTxHash{};
  shared_ptr<vector<DescribeAntChainBlockNewResponseBodyResultTransSummaryList>> transSummaryList{};
  shared_ptr<long> transactionSize{};
  shared_ptr<long> version{};

  DescribeAntChainBlockNewResponseBodyResult() {}

  explicit DescribeAntChainBlockNewResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (blockHash) {
      res["BlockHash"] = boost::any(*blockHash);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (previousHash) {
      res["PreviousHash"] = boost::any(*previousHash);
    }
    if (rootTxHash) {
      res["RootTxHash"] = boost::any(*rootTxHash);
    }
    if (transSummaryList) {
      vector<boost::any> temp1;
      for(auto item1:*transSummaryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TransSummaryList"] = boost::any(temp1);
    }
    if (transactionSize) {
      res["TransactionSize"] = boost::any(*transactionSize);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("BlockHash") != m.end() && !m["BlockHash"].empty()) {
      blockHash = make_shared<string>(boost::any_cast<string>(m["BlockHash"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("PreviousHash") != m.end() && !m["PreviousHash"].empty()) {
      previousHash = make_shared<string>(boost::any_cast<string>(m["PreviousHash"]));
    }
    if (m.find("RootTxHash") != m.end() && !m["RootTxHash"].empty()) {
      rootTxHash = make_shared<string>(boost::any_cast<string>(m["RootTxHash"]));
    }
    if (m.find("TransSummaryList") != m.end() && !m["TransSummaryList"].empty()) {
      if (typeid(vector<boost::any>) == m["TransSummaryList"].type()) {
        vector<DescribeAntChainBlockNewResponseBodyResultTransSummaryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TransSummaryList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainBlockNewResponseBodyResultTransSummaryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transSummaryList = make_shared<vector<DescribeAntChainBlockNewResponseBodyResultTransSummaryList>>(expect1);
      }
    }
    if (m.find("TransactionSize") != m.end() && !m["TransactionSize"].empty()) {
      transactionSize = make_shared<long>(boost::any_cast<long>(m["TransactionSize"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~DescribeAntChainBlockNewResponseBodyResult() = default;
};
class DescribeAntChainBlockNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainBlockNewResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainBlockNewResponseBody() {}

  explicit DescribeAntChainBlockNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainBlockNewResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainBlockNewResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainBlockNewResponseBody() = default;
};
class DescribeAntChainBlockNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainBlockNewResponseBody> body{};

  DescribeAntChainBlockNewResponse() {}

  explicit DescribeAntChainBlockNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainBlockNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainBlockNewResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainBlockNewResponse() = default;
};
class DescribeAntChainCertificateApplicationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> status{};

  DescribeAntChainCertificateApplicationsRequest() {}

  explicit DescribeAntChainCertificateApplicationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeAntChainCertificateApplicationsRequest() = default;
};
class DescribeAntChainCertificateApplicationsResponseBodyResultCertificateApplications : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> bid{};
  shared_ptr<long> createtime{};
  shared_ptr<string> status{};
  shared_ptr<long> updatetime{};
  shared_ptr<string> username{};

  DescribeAntChainCertificateApplicationsResponseBodyResultCertificateApplications() {}

  explicit DescribeAntChainCertificateApplicationsResponseBodyResultCertificateApplications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (bid) {
      res["Bid"] = boost::any(*bid);
    }
    if (createtime) {
      res["Createtime"] = boost::any(*createtime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updatetime) {
      res["Updatetime"] = boost::any(*updatetime);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("Bid") != m.end() && !m["Bid"].empty()) {
      bid = make_shared<string>(boost::any_cast<string>(m["Bid"]));
    }
    if (m.find("Createtime") != m.end() && !m["Createtime"].empty()) {
      createtime = make_shared<long>(boost::any_cast<long>(m["Createtime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Updatetime") != m.end() && !m["Updatetime"].empty()) {
      updatetime = make_shared<long>(boost::any_cast<long>(m["Updatetime"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~DescribeAntChainCertificateApplicationsResponseBodyResultCertificateApplications() = default;
};
class DescribeAntChainCertificateApplicationsResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainCertificateApplicationsResponseBodyResultPagination() {}

  explicit DescribeAntChainCertificateApplicationsResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainCertificateApplicationsResponseBodyResultPagination() = default;
};
class DescribeAntChainCertificateApplicationsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAntChainCertificateApplicationsResponseBodyResultCertificateApplications>> certificateApplications{};
  shared_ptr<DescribeAntChainCertificateApplicationsResponseBodyResultPagination> pagination{};

  DescribeAntChainCertificateApplicationsResponseBodyResult() {}

  explicit DescribeAntChainCertificateApplicationsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateApplications) {
      vector<boost::any> temp1;
      for(auto item1:*certificateApplications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CertificateApplications"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateApplications") != m.end() && !m["CertificateApplications"].empty()) {
      if (typeid(vector<boost::any>) == m["CertificateApplications"].type()) {
        vector<DescribeAntChainCertificateApplicationsResponseBodyResultCertificateApplications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CertificateApplications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainCertificateApplicationsResponseBodyResultCertificateApplications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certificateApplications = make_shared<vector<DescribeAntChainCertificateApplicationsResponseBodyResultCertificateApplications>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainCertificateApplicationsResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainCertificateApplicationsResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeAntChainCertificateApplicationsResponseBodyResult() = default;
};
class DescribeAntChainCertificateApplicationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainCertificateApplicationsResponseBodyResult> result{};

  DescribeAntChainCertificateApplicationsResponseBody() {}

  explicit DescribeAntChainCertificateApplicationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainCertificateApplicationsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainCertificateApplicationsResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainCertificateApplicationsResponseBody() = default;
};
class DescribeAntChainCertificateApplicationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainCertificateApplicationsResponseBody> body{};

  DescribeAntChainCertificateApplicationsResponse() {}

  explicit DescribeAntChainCertificateApplicationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainCertificateApplicationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainCertificateApplicationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainCertificateApplicationsResponse() = default;
};
class DescribeAntChainCertificateApplicationsNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> consortiumId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> status{};

  DescribeAntChainCertificateApplicationsNewRequest() {}

  explicit DescribeAntChainCertificateApplicationsNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeAntChainCertificateApplicationsNewRequest() = default;
};
class DescribeAntChainCertificateApplicationsNewResponseBodyResultCertificateApplications : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> bid{};
  shared_ptr<long> createtime{};
  shared_ptr<string> status{};
  shared_ptr<long> updatetime{};
  shared_ptr<string> username{};

  DescribeAntChainCertificateApplicationsNewResponseBodyResultCertificateApplications() {}

  explicit DescribeAntChainCertificateApplicationsNewResponseBodyResultCertificateApplications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (bid) {
      res["Bid"] = boost::any(*bid);
    }
    if (createtime) {
      res["Createtime"] = boost::any(*createtime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updatetime) {
      res["Updatetime"] = boost::any(*updatetime);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("Bid") != m.end() && !m["Bid"].empty()) {
      bid = make_shared<string>(boost::any_cast<string>(m["Bid"]));
    }
    if (m.find("Createtime") != m.end() && !m["Createtime"].empty()) {
      createtime = make_shared<long>(boost::any_cast<long>(m["Createtime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Updatetime") != m.end() && !m["Updatetime"].empty()) {
      updatetime = make_shared<long>(boost::any_cast<long>(m["Updatetime"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~DescribeAntChainCertificateApplicationsNewResponseBodyResultCertificateApplications() = default;
};
class DescribeAntChainCertificateApplicationsNewResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainCertificateApplicationsNewResponseBodyResultPagination() {}

  explicit DescribeAntChainCertificateApplicationsNewResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainCertificateApplicationsNewResponseBodyResultPagination() = default;
};
class DescribeAntChainCertificateApplicationsNewResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAntChainCertificateApplicationsNewResponseBodyResultCertificateApplications>> certificateApplications{};
  shared_ptr<DescribeAntChainCertificateApplicationsNewResponseBodyResultPagination> pagination{};

  DescribeAntChainCertificateApplicationsNewResponseBodyResult() {}

  explicit DescribeAntChainCertificateApplicationsNewResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateApplications) {
      vector<boost::any> temp1;
      for(auto item1:*certificateApplications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CertificateApplications"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateApplications") != m.end() && !m["CertificateApplications"].empty()) {
      if (typeid(vector<boost::any>) == m["CertificateApplications"].type()) {
        vector<DescribeAntChainCertificateApplicationsNewResponseBodyResultCertificateApplications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CertificateApplications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainCertificateApplicationsNewResponseBodyResultCertificateApplications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certificateApplications = make_shared<vector<DescribeAntChainCertificateApplicationsNewResponseBodyResultCertificateApplications>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainCertificateApplicationsNewResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainCertificateApplicationsNewResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeAntChainCertificateApplicationsNewResponseBodyResult() = default;
};
class DescribeAntChainCertificateApplicationsNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainCertificateApplicationsNewResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainCertificateApplicationsNewResponseBody() {}

  explicit DescribeAntChainCertificateApplicationsNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainCertificateApplicationsNewResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainCertificateApplicationsNewResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainCertificateApplicationsNewResponseBody() = default;
};
class DescribeAntChainCertificateApplicationsNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainCertificateApplicationsNewResponseBody> body{};

  DescribeAntChainCertificateApplicationsNewResponse() {}

  explicit DescribeAntChainCertificateApplicationsNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainCertificateApplicationsNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainCertificateApplicationsNewResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainCertificateApplicationsNewResponse() = default;
};
class DescribeAntChainConfigOptionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> purpose{};

  DescribeAntChainConfigOptionsRequest() {}

  explicit DescribeAntChainConfigOptionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (purpose) {
      res["Purpose"] = boost::any(*purpose);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Purpose") != m.end() && !m["Purpose"].empty()) {
      purpose = make_shared<string>(boost::any_cast<string>(m["Purpose"]));
    }
  }


  virtual ~DescribeAntChainConfigOptionsRequest() = default;
};
class DescribeAntChainConfigOptionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<map<string, boost::any>> result{};

  DescribeAntChainConfigOptionsResponseBody() {}

  explicit DescribeAntChainConfigOptionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Result"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      result = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~DescribeAntChainConfigOptionsResponseBody() = default;
};
class DescribeAntChainConfigOptionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainConfigOptionsResponseBody> body{};

  DescribeAntChainConfigOptionsResponse() {}

  explicit DescribeAntChainConfigOptionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainConfigOptionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainConfigOptionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainConfigOptionsResponse() = default;
};
class DescribeAntChainConsortiumsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeAntChainConsortiumsRequest() {}

  explicit DescribeAntChainConsortiumsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeAntChainConsortiumsRequest() = default;
};
class DescribeAntChainConsortiumsResponseBodyResultAntConsortiums : public Darabonba::Model {
public:
  shared_ptr<long> chainNum{};
  shared_ptr<string> consortiumDescription{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> consortiumName{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> isEmptyConsortium{};
  shared_ptr<long> memberNum{};
  shared_ptr<string> role{};
  shared_ptr<string> status{};

  DescribeAntChainConsortiumsResponseBodyResultAntConsortiums() {}

  explicit DescribeAntChainConsortiumsResponseBodyResultAntConsortiums(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chainNum) {
      res["ChainNum"] = boost::any(*chainNum);
    }
    if (consortiumDescription) {
      res["ConsortiumDescription"] = boost::any(*consortiumDescription);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (consortiumName) {
      res["ConsortiumName"] = boost::any(*consortiumName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (isEmptyConsortium) {
      res["IsEmptyConsortium"] = boost::any(*isEmptyConsortium);
    }
    if (memberNum) {
      res["MemberNum"] = boost::any(*memberNum);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChainNum") != m.end() && !m["ChainNum"].empty()) {
      chainNum = make_shared<long>(boost::any_cast<long>(m["ChainNum"]));
    }
    if (m.find("ConsortiumDescription") != m.end() && !m["ConsortiumDescription"].empty()) {
      consortiumDescription = make_shared<string>(boost::any_cast<string>(m["ConsortiumDescription"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("ConsortiumName") != m.end() && !m["ConsortiumName"].empty()) {
      consortiumName = make_shared<string>(boost::any_cast<string>(m["ConsortiumName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("IsEmptyConsortium") != m.end() && !m["IsEmptyConsortium"].empty()) {
      isEmptyConsortium = make_shared<bool>(boost::any_cast<bool>(m["IsEmptyConsortium"]));
    }
    if (m.find("MemberNum") != m.end() && !m["MemberNum"].empty()) {
      memberNum = make_shared<long>(boost::any_cast<long>(m["MemberNum"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeAntChainConsortiumsResponseBodyResultAntConsortiums() = default;
};
class DescribeAntChainConsortiumsResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainConsortiumsResponseBodyResultPagination() {}

  explicit DescribeAntChainConsortiumsResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainConsortiumsResponseBodyResultPagination() = default;
};
class DescribeAntChainConsortiumsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAntChainConsortiumsResponseBodyResultAntConsortiums>> antConsortiums{};
  shared_ptr<DescribeAntChainConsortiumsResponseBodyResultPagination> pagination{};

  DescribeAntChainConsortiumsResponseBodyResult() {}

  explicit DescribeAntChainConsortiumsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antConsortiums) {
      vector<boost::any> temp1;
      for(auto item1:*antConsortiums){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AntConsortiums"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntConsortiums") != m.end() && !m["AntConsortiums"].empty()) {
      if (typeid(vector<boost::any>) == m["AntConsortiums"].type()) {
        vector<DescribeAntChainConsortiumsResponseBodyResultAntConsortiums> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AntConsortiums"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainConsortiumsResponseBodyResultAntConsortiums model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        antConsortiums = make_shared<vector<DescribeAntChainConsortiumsResponseBodyResultAntConsortiums>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainConsortiumsResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainConsortiumsResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeAntChainConsortiumsResponseBodyResult() = default;
};
class DescribeAntChainConsortiumsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainConsortiumsResponseBodyResult> result{};

  DescribeAntChainConsortiumsResponseBody() {}

  explicit DescribeAntChainConsortiumsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainConsortiumsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainConsortiumsResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainConsortiumsResponseBody() = default;
};
class DescribeAntChainConsortiumsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainConsortiumsResponseBody> body{};

  DescribeAntChainConsortiumsResponse() {}

  explicit DescribeAntChainConsortiumsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainConsortiumsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainConsortiumsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainConsortiumsResponse() = default;
};
class DescribeAntChainConsortiumsNewRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeAntChainConsortiumsNewRequest() {}

  explicit DescribeAntChainConsortiumsNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeAntChainConsortiumsNewRequest() = default;
};
class DescribeAntChainConsortiumsNewResponseBodyResultAntConsortiums : public Darabonba::Model {
public:
  shared_ptr<long> chainNum{};
  shared_ptr<string> consortiumDescription{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> consortiumName{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> isEmptyConsortium{};
  shared_ptr<long> memberNum{};
  shared_ptr<string> role{};
  shared_ptr<string> status{};

  DescribeAntChainConsortiumsNewResponseBodyResultAntConsortiums() {}

  explicit DescribeAntChainConsortiumsNewResponseBodyResultAntConsortiums(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chainNum) {
      res["ChainNum"] = boost::any(*chainNum);
    }
    if (consortiumDescription) {
      res["ConsortiumDescription"] = boost::any(*consortiumDescription);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (consortiumName) {
      res["ConsortiumName"] = boost::any(*consortiumName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (isEmptyConsortium) {
      res["IsEmptyConsortium"] = boost::any(*isEmptyConsortium);
    }
    if (memberNum) {
      res["MemberNum"] = boost::any(*memberNum);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChainNum") != m.end() && !m["ChainNum"].empty()) {
      chainNum = make_shared<long>(boost::any_cast<long>(m["ChainNum"]));
    }
    if (m.find("ConsortiumDescription") != m.end() && !m["ConsortiumDescription"].empty()) {
      consortiumDescription = make_shared<string>(boost::any_cast<string>(m["ConsortiumDescription"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("ConsortiumName") != m.end() && !m["ConsortiumName"].empty()) {
      consortiumName = make_shared<string>(boost::any_cast<string>(m["ConsortiumName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("IsEmptyConsortium") != m.end() && !m["IsEmptyConsortium"].empty()) {
      isEmptyConsortium = make_shared<bool>(boost::any_cast<bool>(m["IsEmptyConsortium"]));
    }
    if (m.find("MemberNum") != m.end() && !m["MemberNum"].empty()) {
      memberNum = make_shared<long>(boost::any_cast<long>(m["MemberNum"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeAntChainConsortiumsNewResponseBodyResultAntConsortiums() = default;
};
class DescribeAntChainConsortiumsNewResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainConsortiumsNewResponseBodyResultPagination() {}

  explicit DescribeAntChainConsortiumsNewResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainConsortiumsNewResponseBodyResultPagination() = default;
};
class DescribeAntChainConsortiumsNewResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAntChainConsortiumsNewResponseBodyResultAntConsortiums>> antConsortiums{};
  shared_ptr<DescribeAntChainConsortiumsNewResponseBodyResultPagination> pagination{};

  DescribeAntChainConsortiumsNewResponseBodyResult() {}

  explicit DescribeAntChainConsortiumsNewResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antConsortiums) {
      vector<boost::any> temp1;
      for(auto item1:*antConsortiums){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AntConsortiums"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntConsortiums") != m.end() && !m["AntConsortiums"].empty()) {
      if (typeid(vector<boost::any>) == m["AntConsortiums"].type()) {
        vector<DescribeAntChainConsortiumsNewResponseBodyResultAntConsortiums> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AntConsortiums"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainConsortiumsNewResponseBodyResultAntConsortiums model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        antConsortiums = make_shared<vector<DescribeAntChainConsortiumsNewResponseBodyResultAntConsortiums>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainConsortiumsNewResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainConsortiumsNewResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeAntChainConsortiumsNewResponseBodyResult() = default;
};
class DescribeAntChainConsortiumsNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainConsortiumsNewResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainConsortiumsNewResponseBody() {}

  explicit DescribeAntChainConsortiumsNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainConsortiumsNewResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainConsortiumsNewResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainConsortiumsNewResponseBody() = default;
};
class DescribeAntChainConsortiumsNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainConsortiumsNewResponseBody> body{};

  DescribeAntChainConsortiumsNewResponse() {}

  explicit DescribeAntChainConsortiumsNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainConsortiumsNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainConsortiumsNewResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainConsortiumsNewResponse() = default;
};
class DescribeAntChainContractProjectContentTreeRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};

  DescribeAntChainContractProjectContentTreeRequest() {}

  explicit DescribeAntChainContractProjectContentTreeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~DescribeAntChainContractProjectContentTreeRequest() = default;
};
class DescribeAntChainContractProjectContentTreeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<map<string, boost::any>>> children{};
  shared_ptr<string> projectDescription{};
  shared_ptr<string> projectId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> projectVersion{};

  DescribeAntChainContractProjectContentTreeResponseBodyResult() {}

  explicit DescribeAntChainContractProjectContentTreeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (children) {
      res["Children"] = boost::any(*children);
    }
    if (projectDescription) {
      res["ProjectDescription"] = boost::any(*projectDescription);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (projectVersion) {
      res["ProjectVersion"] = boost::any(*projectVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Children") != m.end() && !m["Children"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Children"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Children"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      children = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("ProjectDescription") != m.end() && !m["ProjectDescription"].empty()) {
      projectDescription = make_shared<string>(boost::any_cast<string>(m["ProjectDescription"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProjectVersion") != m.end() && !m["ProjectVersion"].empty()) {
      projectVersion = make_shared<string>(boost::any_cast<string>(m["ProjectVersion"]));
    }
  }


  virtual ~DescribeAntChainContractProjectContentTreeResponseBodyResult() = default;
};
class DescribeAntChainContractProjectContentTreeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainContractProjectContentTreeResponseBodyResult> result{};

  DescribeAntChainContractProjectContentTreeResponseBody() {}

  explicit DescribeAntChainContractProjectContentTreeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainContractProjectContentTreeResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainContractProjectContentTreeResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainContractProjectContentTreeResponseBody() = default;
};
class DescribeAntChainContractProjectContentTreeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainContractProjectContentTreeResponseBody> body{};

  DescribeAntChainContractProjectContentTreeResponse() {}

  explicit DescribeAntChainContractProjectContentTreeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainContractProjectContentTreeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainContractProjectContentTreeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainContractProjectContentTreeResponse() = default;
};
class DescribeAntChainContractProjectContentTreeNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> projectId{};

  DescribeAntChainContractProjectContentTreeNewRequest() {}

  explicit DescribeAntChainContractProjectContentTreeNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~DescribeAntChainContractProjectContentTreeNewRequest() = default;
};
class DescribeAntChainContractProjectContentTreeNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainContractProjectContentTreeNewResponseBody() {}

  explicit DescribeAntChainContractProjectContentTreeNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainContractProjectContentTreeNewResponseBody() = default;
};
class DescribeAntChainContractProjectContentTreeNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainContractProjectContentTreeNewResponseBody> body{};

  DescribeAntChainContractProjectContentTreeNewResponse() {}

  explicit DescribeAntChainContractProjectContentTreeNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainContractProjectContentTreeNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainContractProjectContentTreeNewResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainContractProjectContentTreeNewResponse() = default;
};
class DescribeAntChainContractProjectsRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeAntChainContractProjectsRequest() {}

  explicit DescribeAntChainContractProjectsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeAntChainContractProjectsRequest() = default;
};
class DescribeAntChainContractProjectsResponseBodyResultContractProjects : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> projectDescription{};
  shared_ptr<string> projectId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> projectVersion{};
  shared_ptr<long> updateTime{};

  DescribeAntChainContractProjectsResponseBodyResultContractProjects() {}

  explicit DescribeAntChainContractProjectsResponseBodyResultContractProjects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (projectDescription) {
      res["ProjectDescription"] = boost::any(*projectDescription);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (projectVersion) {
      res["ProjectVersion"] = boost::any(*projectVersion);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ProjectDescription") != m.end() && !m["ProjectDescription"].empty()) {
      projectDescription = make_shared<string>(boost::any_cast<string>(m["ProjectDescription"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProjectVersion") != m.end() && !m["ProjectVersion"].empty()) {
      projectVersion = make_shared<string>(boost::any_cast<string>(m["ProjectVersion"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeAntChainContractProjectsResponseBodyResultContractProjects() = default;
};
class DescribeAntChainContractProjectsResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainContractProjectsResponseBodyResultPagination() {}

  explicit DescribeAntChainContractProjectsResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainContractProjectsResponseBodyResultPagination() = default;
};
class DescribeAntChainContractProjectsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAntChainContractProjectsResponseBodyResultContractProjects>> contractProjects{};
  shared_ptr<DescribeAntChainContractProjectsResponseBodyResultPagination> pagination{};

  DescribeAntChainContractProjectsResponseBodyResult() {}

  explicit DescribeAntChainContractProjectsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contractProjects) {
      vector<boost::any> temp1;
      for(auto item1:*contractProjects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ContractProjects"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContractProjects") != m.end() && !m["ContractProjects"].empty()) {
      if (typeid(vector<boost::any>) == m["ContractProjects"].type()) {
        vector<DescribeAntChainContractProjectsResponseBodyResultContractProjects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ContractProjects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainContractProjectsResponseBodyResultContractProjects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contractProjects = make_shared<vector<DescribeAntChainContractProjectsResponseBodyResultContractProjects>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainContractProjectsResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainContractProjectsResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeAntChainContractProjectsResponseBodyResult() = default;
};
class DescribeAntChainContractProjectsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainContractProjectsResponseBodyResult> result{};

  DescribeAntChainContractProjectsResponseBody() {}

  explicit DescribeAntChainContractProjectsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainContractProjectsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainContractProjectsResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainContractProjectsResponseBody() = default;
};
class DescribeAntChainContractProjectsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainContractProjectsResponseBody> body{};

  DescribeAntChainContractProjectsResponse() {}

  explicit DescribeAntChainContractProjectsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainContractProjectsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainContractProjectsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainContractProjectsResponse() = default;
};
class DescribeAntChainContractProjectsNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeAntChainContractProjectsNewRequest() {}

  explicit DescribeAntChainContractProjectsNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeAntChainContractProjectsNewRequest() = default;
};
class DescribeAntChainContractProjectsNewResponseBodyResultContractProjects : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> projectDescription{};
  shared_ptr<string> projectId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> projectVersion{};
  shared_ptr<long> updateTime{};

  DescribeAntChainContractProjectsNewResponseBodyResultContractProjects() {}

  explicit DescribeAntChainContractProjectsNewResponseBodyResultContractProjects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (projectDescription) {
      res["ProjectDescription"] = boost::any(*projectDescription);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (projectVersion) {
      res["ProjectVersion"] = boost::any(*projectVersion);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ProjectDescription") != m.end() && !m["ProjectDescription"].empty()) {
      projectDescription = make_shared<string>(boost::any_cast<string>(m["ProjectDescription"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProjectVersion") != m.end() && !m["ProjectVersion"].empty()) {
      projectVersion = make_shared<string>(boost::any_cast<string>(m["ProjectVersion"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeAntChainContractProjectsNewResponseBodyResultContractProjects() = default;
};
class DescribeAntChainContractProjectsNewResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainContractProjectsNewResponseBodyResultPagination() {}

  explicit DescribeAntChainContractProjectsNewResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainContractProjectsNewResponseBodyResultPagination() = default;
};
class DescribeAntChainContractProjectsNewResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAntChainContractProjectsNewResponseBodyResultContractProjects>> contractProjects{};
  shared_ptr<DescribeAntChainContractProjectsNewResponseBodyResultPagination> pagination{};

  DescribeAntChainContractProjectsNewResponseBodyResult() {}

  explicit DescribeAntChainContractProjectsNewResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contractProjects) {
      vector<boost::any> temp1;
      for(auto item1:*contractProjects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ContractProjects"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContractProjects") != m.end() && !m["ContractProjects"].empty()) {
      if (typeid(vector<boost::any>) == m["ContractProjects"].type()) {
        vector<DescribeAntChainContractProjectsNewResponseBodyResultContractProjects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ContractProjects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainContractProjectsNewResponseBodyResultContractProjects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contractProjects = make_shared<vector<DescribeAntChainContractProjectsNewResponseBodyResultContractProjects>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainContractProjectsNewResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainContractProjectsNewResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeAntChainContractProjectsNewResponseBodyResult() = default;
};
class DescribeAntChainContractProjectsNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainContractProjectsNewResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainContractProjectsNewResponseBody() {}

  explicit DescribeAntChainContractProjectsNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainContractProjectsNewResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainContractProjectsNewResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainContractProjectsNewResponseBody() = default;
};
class DescribeAntChainContractProjectsNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainContractProjectsNewResponseBody> body{};

  DescribeAntChainContractProjectsNewResponse() {}

  explicit DescribeAntChainContractProjectsNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainContractProjectsNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainContractProjectsNewResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainContractProjectsNewResponse() = default;
};
class DescribeAntChainDownloadPathsRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};

  DescribeAntChainDownloadPathsRequest() {}

  explicit DescribeAntChainDownloadPathsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
  }


  virtual ~DescribeAntChainDownloadPathsRequest() = default;
};
class DescribeAntChainDownloadPathsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> caCrtUrl{};
  shared_ptr<string> clientCrtUrl{};
  shared_ptr<string> sdkUrl{};
  shared_ptr<string> trustCaUrl{};

  DescribeAntChainDownloadPathsResponseBodyResult() {}

  explicit DescribeAntChainDownloadPathsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caCrtUrl) {
      res["CaCrtUrl"] = boost::any(*caCrtUrl);
    }
    if (clientCrtUrl) {
      res["ClientCrtUrl"] = boost::any(*clientCrtUrl);
    }
    if (sdkUrl) {
      res["SdkUrl"] = boost::any(*sdkUrl);
    }
    if (trustCaUrl) {
      res["TrustCaUrl"] = boost::any(*trustCaUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaCrtUrl") != m.end() && !m["CaCrtUrl"].empty()) {
      caCrtUrl = make_shared<string>(boost::any_cast<string>(m["CaCrtUrl"]));
    }
    if (m.find("ClientCrtUrl") != m.end() && !m["ClientCrtUrl"].empty()) {
      clientCrtUrl = make_shared<string>(boost::any_cast<string>(m["ClientCrtUrl"]));
    }
    if (m.find("SdkUrl") != m.end() && !m["SdkUrl"].empty()) {
      sdkUrl = make_shared<string>(boost::any_cast<string>(m["SdkUrl"]));
    }
    if (m.find("TrustCaUrl") != m.end() && !m["TrustCaUrl"].empty()) {
      trustCaUrl = make_shared<string>(boost::any_cast<string>(m["TrustCaUrl"]));
    }
  }


  virtual ~DescribeAntChainDownloadPathsResponseBodyResult() = default;
};
class DescribeAntChainDownloadPathsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainDownloadPathsResponseBodyResult> result{};

  DescribeAntChainDownloadPathsResponseBody() {}

  explicit DescribeAntChainDownloadPathsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainDownloadPathsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainDownloadPathsResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainDownloadPathsResponseBody() = default;
};
class DescribeAntChainDownloadPathsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainDownloadPathsResponseBody> body{};

  DescribeAntChainDownloadPathsResponse() {}

  explicit DescribeAntChainDownloadPathsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainDownloadPathsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainDownloadPathsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainDownloadPathsResponse() = default;
};
class DescribeAntChainDownloadPathsNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> consortiumId{};

  DescribeAntChainDownloadPathsNewRequest() {}

  explicit DescribeAntChainDownloadPathsNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
  }


  virtual ~DescribeAntChainDownloadPathsNewRequest() = default;
};
class DescribeAntChainDownloadPathsNewResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> caCrtUrl{};
  shared_ptr<string> clientCrtUrl{};
  shared_ptr<string> sdkUrl{};
  shared_ptr<string> trustCaUrl{};

  DescribeAntChainDownloadPathsNewResponseBodyResult() {}

  explicit DescribeAntChainDownloadPathsNewResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caCrtUrl) {
      res["CaCrtUrl"] = boost::any(*caCrtUrl);
    }
    if (clientCrtUrl) {
      res["ClientCrtUrl"] = boost::any(*clientCrtUrl);
    }
    if (sdkUrl) {
      res["SdkUrl"] = boost::any(*sdkUrl);
    }
    if (trustCaUrl) {
      res["TrustCaUrl"] = boost::any(*trustCaUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaCrtUrl") != m.end() && !m["CaCrtUrl"].empty()) {
      caCrtUrl = make_shared<string>(boost::any_cast<string>(m["CaCrtUrl"]));
    }
    if (m.find("ClientCrtUrl") != m.end() && !m["ClientCrtUrl"].empty()) {
      clientCrtUrl = make_shared<string>(boost::any_cast<string>(m["ClientCrtUrl"]));
    }
    if (m.find("SdkUrl") != m.end() && !m["SdkUrl"].empty()) {
      sdkUrl = make_shared<string>(boost::any_cast<string>(m["SdkUrl"]));
    }
    if (m.find("TrustCaUrl") != m.end() && !m["TrustCaUrl"].empty()) {
      trustCaUrl = make_shared<string>(boost::any_cast<string>(m["TrustCaUrl"]));
    }
  }


  virtual ~DescribeAntChainDownloadPathsNewResponseBodyResult() = default;
};
class DescribeAntChainDownloadPathsNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainDownloadPathsNewResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainDownloadPathsNewResponseBody() {}

  explicit DescribeAntChainDownloadPathsNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainDownloadPathsNewResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainDownloadPathsNewResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainDownloadPathsNewResponseBody() = default;
};
class DescribeAntChainDownloadPathsNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainDownloadPathsNewResponseBody> body{};

  DescribeAntChainDownloadPathsNewResponse() {}

  explicit DescribeAntChainDownloadPathsNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainDownloadPathsNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainDownloadPathsNewResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainDownloadPathsNewResponse() = default;
};
class DescribeAntChainInformationRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};

  DescribeAntChainInformationRequest() {}

  explicit DescribeAntChainInformationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
  }


  virtual ~DescribeAntChainInformationRequest() = default;
};
class DescribeAntChainInformationResponseBodyResultNodeInfos : public Darabonba::Model {
public:
  shared_ptr<long> blockHeight{};
  shared_ptr<string> nodeName{};
  shared_ptr<bool> status{};
  shared_ptr<string> version{};

  DescribeAntChainInformationResponseBodyResultNodeInfos() {}

  explicit DescribeAntChainInformationResponseBodyResultNodeInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockHeight) {
      res["BlockHeight"] = boost::any(*blockHeight);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockHeight") != m.end() && !m["BlockHeight"].empty()) {
      blockHeight = make_shared<long>(boost::any_cast<long>(m["BlockHeight"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeAntChainInformationResponseBodyResultNodeInfos() = default;
};
class DescribeAntChainInformationResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> abnormalNodes{};
  shared_ptr<string> antChainId{};
  shared_ptr<long> blockHeight{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> isRole{};
  shared_ptr<vector<DescribeAntChainInformationResponseBodyResultNodeInfos>> nodeInfos{};
  shared_ptr<long> nodeNumber{};
  shared_ptr<bool> normal{};
  shared_ptr<long> transactionSum{};
  shared_ptr<string> version{};

  DescribeAntChainInformationResponseBodyResult() {}

  explicit DescribeAntChainInformationResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnormalNodes) {
      res["AbnormalNodes"] = boost::any(*abnormalNodes);
    }
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (blockHeight) {
      res["BlockHeight"] = boost::any(*blockHeight);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (isRole) {
      res["IsRole"] = boost::any(*isRole);
    }
    if (nodeInfos) {
      vector<boost::any> temp1;
      for(auto item1:*nodeInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeInfos"] = boost::any(temp1);
    }
    if (nodeNumber) {
      res["NodeNumber"] = boost::any(*nodeNumber);
    }
    if (normal) {
      res["Normal"] = boost::any(*normal);
    }
    if (transactionSum) {
      res["TransactionSum"] = boost::any(*transactionSum);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbnormalNodes") != m.end() && !m["AbnormalNodes"].empty()) {
      abnormalNodes = make_shared<long>(boost::any_cast<long>(m["AbnormalNodes"]));
    }
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("BlockHeight") != m.end() && !m["BlockHeight"].empty()) {
      blockHeight = make_shared<long>(boost::any_cast<long>(m["BlockHeight"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("IsRole") != m.end() && !m["IsRole"].empty()) {
      isRole = make_shared<bool>(boost::any_cast<bool>(m["IsRole"]));
    }
    if (m.find("NodeInfos") != m.end() && !m["NodeInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeInfos"].type()) {
        vector<DescribeAntChainInformationResponseBodyResultNodeInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainInformationResponseBodyResultNodeInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeInfos = make_shared<vector<DescribeAntChainInformationResponseBodyResultNodeInfos>>(expect1);
      }
    }
    if (m.find("NodeNumber") != m.end() && !m["NodeNumber"].empty()) {
      nodeNumber = make_shared<long>(boost::any_cast<long>(m["NodeNumber"]));
    }
    if (m.find("Normal") != m.end() && !m["Normal"].empty()) {
      normal = make_shared<bool>(boost::any_cast<bool>(m["Normal"]));
    }
    if (m.find("TransactionSum") != m.end() && !m["TransactionSum"].empty()) {
      transactionSum = make_shared<long>(boost::any_cast<long>(m["TransactionSum"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeAntChainInformationResponseBodyResult() = default;
};
class DescribeAntChainInformationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainInformationResponseBodyResult> result{};

  DescribeAntChainInformationResponseBody() {}

  explicit DescribeAntChainInformationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainInformationResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainInformationResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainInformationResponseBody() = default;
};
class DescribeAntChainInformationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainInformationResponseBody> body{};

  DescribeAntChainInformationResponse() {}

  explicit DescribeAntChainInformationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainInformationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainInformationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainInformationResponse() = default;
};
class DescribeAntChainInformationNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> consortiumId{};

  DescribeAntChainInformationNewRequest() {}

  explicit DescribeAntChainInformationNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
  }


  virtual ~DescribeAntChainInformationNewRequest() = default;
};
class DescribeAntChainInformationNewResponseBodyResultNodeInfos : public Darabonba::Model {
public:
  shared_ptr<long> blockHeight{};
  shared_ptr<string> nodeName{};
  shared_ptr<bool> status{};
  shared_ptr<string> version{};

  DescribeAntChainInformationNewResponseBodyResultNodeInfos() {}

  explicit DescribeAntChainInformationNewResponseBodyResultNodeInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockHeight) {
      res["BlockHeight"] = boost::any(*blockHeight);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockHeight") != m.end() && !m["BlockHeight"].empty()) {
      blockHeight = make_shared<long>(boost::any_cast<long>(m["BlockHeight"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeAntChainInformationNewResponseBodyResultNodeInfos() = default;
};
class DescribeAntChainInformationNewResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> abnormalNodes{};
  shared_ptr<string> antChainId{};
  shared_ptr<long> blockHeight{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> isRole{};
  shared_ptr<vector<DescribeAntChainInformationNewResponseBodyResultNodeInfos>> nodeInfos{};
  shared_ptr<long> nodeNumber{};
  shared_ptr<bool> normal{};
  shared_ptr<long> transactionSum{};
  shared_ptr<string> version{};

  DescribeAntChainInformationNewResponseBodyResult() {}

  explicit DescribeAntChainInformationNewResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnormalNodes) {
      res["AbnormalNodes"] = boost::any(*abnormalNodes);
    }
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (blockHeight) {
      res["BlockHeight"] = boost::any(*blockHeight);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (isRole) {
      res["IsRole"] = boost::any(*isRole);
    }
    if (nodeInfos) {
      vector<boost::any> temp1;
      for(auto item1:*nodeInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeInfos"] = boost::any(temp1);
    }
    if (nodeNumber) {
      res["NodeNumber"] = boost::any(*nodeNumber);
    }
    if (normal) {
      res["Normal"] = boost::any(*normal);
    }
    if (transactionSum) {
      res["TransactionSum"] = boost::any(*transactionSum);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbnormalNodes") != m.end() && !m["AbnormalNodes"].empty()) {
      abnormalNodes = make_shared<long>(boost::any_cast<long>(m["AbnormalNodes"]));
    }
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("BlockHeight") != m.end() && !m["BlockHeight"].empty()) {
      blockHeight = make_shared<long>(boost::any_cast<long>(m["BlockHeight"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("IsRole") != m.end() && !m["IsRole"].empty()) {
      isRole = make_shared<bool>(boost::any_cast<bool>(m["IsRole"]));
    }
    if (m.find("NodeInfos") != m.end() && !m["NodeInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeInfos"].type()) {
        vector<DescribeAntChainInformationNewResponseBodyResultNodeInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainInformationNewResponseBodyResultNodeInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeInfos = make_shared<vector<DescribeAntChainInformationNewResponseBodyResultNodeInfos>>(expect1);
      }
    }
    if (m.find("NodeNumber") != m.end() && !m["NodeNumber"].empty()) {
      nodeNumber = make_shared<long>(boost::any_cast<long>(m["NodeNumber"]));
    }
    if (m.find("Normal") != m.end() && !m["Normal"].empty()) {
      normal = make_shared<bool>(boost::any_cast<bool>(m["Normal"]));
    }
    if (m.find("TransactionSum") != m.end() && !m["TransactionSum"].empty()) {
      transactionSum = make_shared<long>(boost::any_cast<long>(m["TransactionSum"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeAntChainInformationNewResponseBodyResult() = default;
};
class DescribeAntChainInformationNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainInformationNewResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainInformationNewResponseBody() {}

  explicit DescribeAntChainInformationNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainInformationNewResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainInformationNewResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainInformationNewResponseBody() = default;
};
class DescribeAntChainInformationNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainInformationNewResponseBody> body{};

  DescribeAntChainInformationNewResponse() {}

  explicit DescribeAntChainInformationNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainInformationNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainInformationNewResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainInformationNewResponse() = default;
};
class DescribeAntChainLatestBlocksRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};

  DescribeAntChainLatestBlocksRequest() {}

  explicit DescribeAntChainLatestBlocksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
  }


  virtual ~DescribeAntChainLatestBlocksRequest() = default;
};
class DescribeAntChainLatestBlocksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<map<string, boost::any>>> result{};

  DescribeAntChainLatestBlocksResponseBody() {}

  explicit DescribeAntChainLatestBlocksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Result"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      result = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
  }


  virtual ~DescribeAntChainLatestBlocksResponseBody() = default;
};
class DescribeAntChainLatestBlocksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainLatestBlocksResponseBody> body{};

  DescribeAntChainLatestBlocksResponse() {}

  explicit DescribeAntChainLatestBlocksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainLatestBlocksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainLatestBlocksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainLatestBlocksResponse() = default;
};
class DescribeAntChainLatestBlocksNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> consortiumId{};

  DescribeAntChainLatestBlocksNewRequest() {}

  explicit DescribeAntChainLatestBlocksNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
  }


  virtual ~DescribeAntChainLatestBlocksNewRequest() = default;
};
class DescribeAntChainLatestBlocksNewResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> bizData{};
  shared_ptr<string> blockHash{};
  shared_ptr<long> createTime{};
  shared_ptr<long> height{};
  shared_ptr<string> previousHash{};
  shared_ptr<string> rootTxHash{};
  shared_ptr<long> size{};
  shared_ptr<long> transactionSize{};
  shared_ptr<long> version{};

  DescribeAntChainLatestBlocksNewResponseBodyResult() {}

  explicit DescribeAntChainLatestBlocksNewResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (bizData) {
      res["BizData"] = boost::any(*bizData);
    }
    if (blockHash) {
      res["BlockHash"] = boost::any(*blockHash);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (previousHash) {
      res["PreviousHash"] = boost::any(*previousHash);
    }
    if (rootTxHash) {
      res["RootTxHash"] = boost::any(*rootTxHash);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (transactionSize) {
      res["TransactionSize"] = boost::any(*transactionSize);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("BizData") != m.end() && !m["BizData"].empty()) {
      bizData = make_shared<string>(boost::any_cast<string>(m["BizData"]));
    }
    if (m.find("BlockHash") != m.end() && !m["BlockHash"].empty()) {
      blockHash = make_shared<string>(boost::any_cast<string>(m["BlockHash"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("PreviousHash") != m.end() && !m["PreviousHash"].empty()) {
      previousHash = make_shared<string>(boost::any_cast<string>(m["PreviousHash"]));
    }
    if (m.find("RootTxHash") != m.end() && !m["RootTxHash"].empty()) {
      rootTxHash = make_shared<string>(boost::any_cast<string>(m["RootTxHash"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TransactionSize") != m.end() && !m["TransactionSize"].empty()) {
      transactionSize = make_shared<long>(boost::any_cast<long>(m["TransactionSize"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~DescribeAntChainLatestBlocksNewResponseBodyResult() = default;
};
class DescribeAntChainLatestBlocksNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeAntChainLatestBlocksNewResponseBodyResult>> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainLatestBlocksNewResponseBody() {}

  explicit DescribeAntChainLatestBlocksNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeAntChainLatestBlocksNewResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainLatestBlocksNewResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeAntChainLatestBlocksNewResponseBodyResult>>(expect1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainLatestBlocksNewResponseBody() = default;
};
class DescribeAntChainLatestBlocksNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainLatestBlocksNewResponseBody> body{};

  DescribeAntChainLatestBlocksNewResponse() {}

  explicit DescribeAntChainLatestBlocksNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainLatestBlocksNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainLatestBlocksNewResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainLatestBlocksNewResponse() = default;
};
class DescribeAntChainLatestTransactionDigestsRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};

  DescribeAntChainLatestTransactionDigestsRequest() {}

  explicit DescribeAntChainLatestTransactionDigestsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
  }


  virtual ~DescribeAntChainLatestTransactionDigestsRequest() = default;
};
class DescribeAntChainLatestTransactionDigestsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<map<string, boost::any>>> result{};

  DescribeAntChainLatestTransactionDigestsResponseBody() {}

  explicit DescribeAntChainLatestTransactionDigestsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Result"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      result = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
  }


  virtual ~DescribeAntChainLatestTransactionDigestsResponseBody() = default;
};
class DescribeAntChainLatestTransactionDigestsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainLatestTransactionDigestsResponseBody> body{};

  DescribeAntChainLatestTransactionDigestsResponse() {}

  explicit DescribeAntChainLatestTransactionDigestsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainLatestTransactionDigestsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainLatestTransactionDigestsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainLatestTransactionDigestsResponse() = default;
};
class DescribeAntChainLatestTransactionDigestsNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> consortiumId{};

  DescribeAntChainLatestTransactionDigestsNewRequest() {}

  explicit DescribeAntChainLatestTransactionDigestsNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
  }


  virtual ~DescribeAntChainLatestTransactionDigestsNewRequest() = default;
};
class DescribeAntChainLatestTransactionDigestsNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainLatestTransactionDigestsNewResponseBody() {}

  explicit DescribeAntChainLatestTransactionDigestsNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Result"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      result = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainLatestTransactionDigestsNewResponseBody() = default;
};
class DescribeAntChainLatestTransactionDigestsNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainLatestTransactionDigestsNewResponseBody> body{};

  DescribeAntChainLatestTransactionDigestsNewResponse() {}

  explicit DescribeAntChainLatestTransactionDigestsNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainLatestTransactionDigestsNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainLatestTransactionDigestsNewResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainLatestTransactionDigestsNewResponse() = default;
};
class DescribeAntChainMembersRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeAntChainMembersRequest() {}

  explicit DescribeAntChainMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeAntChainMembersRequest() = default;
};
class DescribeAntChainMembersResponseBodyResultMembers : public Darabonba::Model {
public:
  shared_ptr<long> joinTime{};
  shared_ptr<string> memberId{};
  shared_ptr<string> memberName{};
  shared_ptr<string> role{};
  shared_ptr<string> status{};

  DescribeAntChainMembersResponseBodyResultMembers() {}

  explicit DescribeAntChainMembersResponseBodyResultMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (joinTime) {
      res["JoinTime"] = boost::any(*joinTime);
    }
    if (memberId) {
      res["MemberId"] = boost::any(*memberId);
    }
    if (memberName) {
      res["MemberName"] = boost::any(*memberName);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JoinTime") != m.end() && !m["JoinTime"].empty()) {
      joinTime = make_shared<long>(boost::any_cast<long>(m["JoinTime"]));
    }
    if (m.find("MemberId") != m.end() && !m["MemberId"].empty()) {
      memberId = make_shared<string>(boost::any_cast<string>(m["MemberId"]));
    }
    if (m.find("MemberName") != m.end() && !m["MemberName"].empty()) {
      memberName = make_shared<string>(boost::any_cast<string>(m["MemberName"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeAntChainMembersResponseBodyResultMembers() = default;
};
class DescribeAntChainMembersResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainMembersResponseBodyResultPagination() {}

  explicit DescribeAntChainMembersResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainMembersResponseBodyResultPagination() = default;
};
class DescribeAntChainMembersResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAntChainMembersResponseBodyResultMembers>> members{};
  shared_ptr<DescribeAntChainMembersResponseBodyResultPagination> pagination{};

  DescribeAntChainMembersResponseBodyResult() {}

  explicit DescribeAntChainMembersResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (members) {
      vector<boost::any> temp1;
      for(auto item1:*members){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Members"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      if (typeid(vector<boost::any>) == m["Members"].type()) {
        vector<DescribeAntChainMembersResponseBodyResultMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Members"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainMembersResponseBodyResultMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        members = make_shared<vector<DescribeAntChainMembersResponseBodyResultMembers>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainMembersResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainMembersResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeAntChainMembersResponseBodyResult() = default;
};
class DescribeAntChainMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainMembersResponseBodyResult> result{};

  DescribeAntChainMembersResponseBody() {}

  explicit DescribeAntChainMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainMembersResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainMembersResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainMembersResponseBody() = default;
};
class DescribeAntChainMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainMembersResponseBody> body{};

  DescribeAntChainMembersResponse() {}

  explicit DescribeAntChainMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainMembersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainMembersResponse() = default;
};
class DescribeAntChainMembersNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeAntChainMembersNewRequest() {}

  explicit DescribeAntChainMembersNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeAntChainMembersNewRequest() = default;
};
class DescribeAntChainMembersNewResponseBodyResultMembers : public Darabonba::Model {
public:
  shared_ptr<long> joinTime{};
  shared_ptr<string> memberId{};
  shared_ptr<string> memberName{};
  shared_ptr<string> role{};
  shared_ptr<string> status{};

  DescribeAntChainMembersNewResponseBodyResultMembers() {}

  explicit DescribeAntChainMembersNewResponseBodyResultMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (joinTime) {
      res["JoinTime"] = boost::any(*joinTime);
    }
    if (memberId) {
      res["MemberId"] = boost::any(*memberId);
    }
    if (memberName) {
      res["MemberName"] = boost::any(*memberName);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JoinTime") != m.end() && !m["JoinTime"].empty()) {
      joinTime = make_shared<long>(boost::any_cast<long>(m["JoinTime"]));
    }
    if (m.find("MemberId") != m.end() && !m["MemberId"].empty()) {
      memberId = make_shared<string>(boost::any_cast<string>(m["MemberId"]));
    }
    if (m.find("MemberName") != m.end() && !m["MemberName"].empty()) {
      memberName = make_shared<string>(boost::any_cast<string>(m["MemberName"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeAntChainMembersNewResponseBodyResultMembers() = default;
};
class DescribeAntChainMembersNewResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainMembersNewResponseBodyResultPagination() {}

  explicit DescribeAntChainMembersNewResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainMembersNewResponseBodyResultPagination() = default;
};
class DescribeAntChainMembersNewResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAntChainMembersNewResponseBodyResultMembers>> members{};
  shared_ptr<DescribeAntChainMembersNewResponseBodyResultPagination> pagination{};

  DescribeAntChainMembersNewResponseBodyResult() {}

  explicit DescribeAntChainMembersNewResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (members) {
      vector<boost::any> temp1;
      for(auto item1:*members){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Members"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      if (typeid(vector<boost::any>) == m["Members"].type()) {
        vector<DescribeAntChainMembersNewResponseBodyResultMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Members"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainMembersNewResponseBodyResultMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        members = make_shared<vector<DescribeAntChainMembersNewResponseBodyResultMembers>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainMembersNewResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainMembersNewResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeAntChainMembersNewResponseBodyResult() = default;
};
class DescribeAntChainMembersNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainMembersNewResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainMembersNewResponseBody() {}

  explicit DescribeAntChainMembersNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainMembersNewResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainMembersNewResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainMembersNewResponseBody() = default;
};
class DescribeAntChainMembersNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainMembersNewResponseBody> body{};

  DescribeAntChainMembersNewResponse() {}

  explicit DescribeAntChainMembersNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainMembersNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainMembersNewResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainMembersNewResponse() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAccessLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> QRCodeType{};

  DescribeAntChainMiniAppBrowserQRCodeAccessLogRequest() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAccessLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (QRCodeType) {
      res["QRCodeType"] = boost::any(*QRCodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("QRCodeType") != m.end() && !m["QRCodeType"].empty()) {
      QRCodeType = make_shared<string>(boost::any_cast<string>(m["QRCodeType"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAccessLogRequest() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> accessAlipayAccountCount{};
  shared_ptr<long> accessCount{};

  DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBodyResult() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessAlipayAccountCount) {
      res["AccessAlipayAccountCount"] = boost::any(*accessAlipayAccountCount);
    }
    if (accessCount) {
      res["AccessCount"] = boost::any(*accessCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessAlipayAccountCount") != m.end() && !m["AccessAlipayAccountCount"].empty()) {
      accessAlipayAccountCount = make_shared<long>(boost::any_cast<long>(m["AccessAlipayAccountCount"]));
    }
    if (m.find("AccessCount") != m.end() && !m["AccessCount"].empty()) {
      accessCount = make_shared<long>(boost::any_cast<long>(m["AccessCount"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBodyResult() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBodyResult> result{};

  DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBody() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBody() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAccessLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBody> body{};

  DescribeAntChainMiniAppBrowserQRCodeAccessLogResponse() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAccessLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAccessLogResponse() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAccessLogNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> QRCodeType{};

  DescribeAntChainMiniAppBrowserQRCodeAccessLogNewRequest() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAccessLogNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (QRCodeType) {
      res["QRCodeType"] = boost::any(*QRCodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("QRCodeType") != m.end() && !m["QRCodeType"].empty()) {
      QRCodeType = make_shared<string>(boost::any_cast<string>(m["QRCodeType"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAccessLogNewRequest() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> accessAlipayAccountCount{};
  shared_ptr<long> accessCount{};

  DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponseBodyResult() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessAlipayAccountCount) {
      res["AccessAlipayAccountCount"] = boost::any(*accessAlipayAccountCount);
    }
    if (accessCount) {
      res["AccessCount"] = boost::any(*accessCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessAlipayAccountCount") != m.end() && !m["AccessAlipayAccountCount"].empty()) {
      accessAlipayAccountCount = make_shared<long>(boost::any_cast<long>(m["AccessAlipayAccountCount"]));
    }
    if (m.find("AccessCount") != m.end() && !m["AccessCount"].empty()) {
      accessCount = make_shared<long>(boost::any_cast<long>(m["AccessCount"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponseBodyResult() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponseBody() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponseBody() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponseBody> body{};

  DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponse() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponse() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> QRCodeType{};

  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersRequest() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (QRCodeType) {
      res["QRCodeType"] = boost::any(*QRCodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QRCodeType") != m.end() && !m["QRCodeType"].empty()) {
      QRCodeType = make_shared<string>(boost::any_cast<string>(m["QRCodeType"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersRequest() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultAuthorizedUserList : public Darabonba::Model {
public:
  shared_ptr<string> gmtAuthorized{};
  shared_ptr<string> phone{};

  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultAuthorizedUserList() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultAuthorizedUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtAuthorized) {
      res["GmtAuthorized"] = boost::any(*gmtAuthorized);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtAuthorized") != m.end() && !m["GmtAuthorized"].empty()) {
      gmtAuthorized = make_shared<string>(boost::any_cast<string>(m["GmtAuthorized"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultAuthorizedUserList() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultPagination() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultPagination() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> authorizationType{};
  shared_ptr<vector<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultAuthorizedUserList>> authorizedUserList{};
  shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultPagination> pagination{};
  shared_ptr<string> QRCodeType{};

  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResult() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (authorizationType) {
      res["AuthorizationType"] = boost::any(*authorizationType);
    }
    if (authorizedUserList) {
      vector<boost::any> temp1;
      for(auto item1:*authorizedUserList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizedUserList"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (QRCodeType) {
      res["QRCodeType"] = boost::any(*QRCodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("AuthorizationType") != m.end() && !m["AuthorizationType"].empty()) {
      authorizationType = make_shared<string>(boost::any_cast<string>(m["AuthorizationType"]));
    }
    if (m.find("AuthorizedUserList") != m.end() && !m["AuthorizedUserList"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizedUserList"].type()) {
        vector<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultAuthorizedUserList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizedUserList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultAuthorizedUserList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizedUserList = make_shared<vector<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultAuthorizedUserList>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultPagination>(model1);
      }
    }
    if (m.find("QRCodeType") != m.end() && !m["QRCodeType"].empty()) {
      QRCodeType = make_shared<string>(boost::any_cast<string>(m["QRCodeType"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResult() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResult> result{};

  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody> body{};

  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponse() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponse() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> QRCodeType{};

  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewRequest() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (QRCodeType) {
      res["QRCodeType"] = boost::any(*QRCodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QRCodeType") != m.end() && !m["QRCodeType"].empty()) {
      QRCodeType = make_shared<string>(boost::any_cast<string>(m["QRCodeType"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewRequest() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResultAuthorizedUserList : public Darabonba::Model {
public:
  shared_ptr<string> gmtAuthorized{};
  shared_ptr<string> phone{};
  shared_ptr<long> userId{};

  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResultAuthorizedUserList() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResultAuthorizedUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtAuthorized) {
      res["GmtAuthorized"] = boost::any(*gmtAuthorized);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtAuthorized") != m.end() && !m["GmtAuthorized"].empty()) {
      gmtAuthorized = make_shared<string>(boost::any_cast<string>(m["GmtAuthorized"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResultAuthorizedUserList() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResultPagination() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResultPagination() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> authorizationType{};
  shared_ptr<vector<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResultAuthorizedUserList>> authorizedUserList{};
  shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResultPagination> pagination{};
  shared_ptr<string> QRCodeType{};

  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResult() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (authorizationType) {
      res["AuthorizationType"] = boost::any(*authorizationType);
    }
    if (authorizedUserList) {
      vector<boost::any> temp1;
      for(auto item1:*authorizedUserList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizedUserList"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (QRCodeType) {
      res["QRCodeType"] = boost::any(*QRCodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("AuthorizationType") != m.end() && !m["AuthorizationType"].empty()) {
      authorizationType = make_shared<string>(boost::any_cast<string>(m["AuthorizationType"]));
    }
    if (m.find("AuthorizedUserList") != m.end() && !m["AuthorizedUserList"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizedUserList"].type()) {
        vector<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResultAuthorizedUserList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizedUserList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResultAuthorizedUserList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizedUserList = make_shared<vector<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResultAuthorizedUserList>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResultPagination>(model1);
      }
    }
    if (m.find("QRCodeType") != m.end() && !m["QRCodeType"].empty()) {
      QRCodeType = make_shared<string>(boost::any_cast<string>(m["QRCodeType"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResult() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBody() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBody() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBody> body{};

  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponse() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponse() = default;
};
class DescribeAntChainMiniAppBrowserTransactionQRCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> transactionHash{};

  DescribeAntChainMiniAppBrowserTransactionQRCodeRequest() {}

  explicit DescribeAntChainMiniAppBrowserTransactionQRCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (transactionHash) {
      res["TransactionHash"] = boost::any(*transactionHash);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("TransactionHash") != m.end() && !m["TransactionHash"].empty()) {
      transactionHash = make_shared<string>(boost::any_cast<string>(m["TransactionHash"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserTransactionQRCodeRequest() = default;
};
class DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> base64QRCodePNG{};
  shared_ptr<string> QRCodeContent{};
  shared_ptr<string> transactionHash{};

  DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBodyResult() {}

  explicit DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (base64QRCodePNG) {
      res["Base64QRCodePNG"] = boost::any(*base64QRCodePNG);
    }
    if (QRCodeContent) {
      res["QRCodeContent"] = boost::any(*QRCodeContent);
    }
    if (transactionHash) {
      res["TransactionHash"] = boost::any(*transactionHash);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("Base64QRCodePNG") != m.end() && !m["Base64QRCodePNG"].empty()) {
      base64QRCodePNG = make_shared<string>(boost::any_cast<string>(m["Base64QRCodePNG"]));
    }
    if (m.find("QRCodeContent") != m.end() && !m["QRCodeContent"].empty()) {
      QRCodeContent = make_shared<string>(boost::any_cast<string>(m["QRCodeContent"]));
    }
    if (m.find("TransactionHash") != m.end() && !m["TransactionHash"].empty()) {
      transactionHash = make_shared<string>(boost::any_cast<string>(m["TransactionHash"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBodyResult() = default;
};
class DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBodyResult> result{};

  DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBody() {}

  explicit DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBody() = default;
};
class DescribeAntChainMiniAppBrowserTransactionQRCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBody> body{};

  DescribeAntChainMiniAppBrowserTransactionQRCodeResponse() {}

  explicit DescribeAntChainMiniAppBrowserTransactionQRCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserTransactionQRCodeResponse() = default;
};
class DescribeAntChainMiniAppBrowserTransactionQRCodeNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> contractId{};
  shared_ptr<string> transactionHash{};

  DescribeAntChainMiniAppBrowserTransactionQRCodeNewRequest() {}

  explicit DescribeAntChainMiniAppBrowserTransactionQRCodeNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (contractId) {
      res["ContractId"] = boost::any(*contractId);
    }
    if (transactionHash) {
      res["TransactionHash"] = boost::any(*transactionHash);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ContractId") != m.end() && !m["ContractId"].empty()) {
      contractId = make_shared<string>(boost::any_cast<string>(m["ContractId"]));
    }
    if (m.find("TransactionHash") != m.end() && !m["TransactionHash"].empty()) {
      transactionHash = make_shared<string>(boost::any_cast<string>(m["TransactionHash"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserTransactionQRCodeNewRequest() = default;
};
class DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> base64QRCodePNG{};
  shared_ptr<string> QRCodeContent{};
  shared_ptr<string> transactionHash{};

  DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBodyResult() {}

  explicit DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (base64QRCodePNG) {
      res["Base64QRCodePNG"] = boost::any(*base64QRCodePNG);
    }
    if (QRCodeContent) {
      res["QRCodeContent"] = boost::any(*QRCodeContent);
    }
    if (transactionHash) {
      res["TransactionHash"] = boost::any(*transactionHash);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("Base64QRCodePNG") != m.end() && !m["Base64QRCodePNG"].empty()) {
      base64QRCodePNG = make_shared<string>(boost::any_cast<string>(m["Base64QRCodePNG"]));
    }
    if (m.find("QRCodeContent") != m.end() && !m["QRCodeContent"].empty()) {
      QRCodeContent = make_shared<string>(boost::any_cast<string>(m["QRCodeContent"]));
    }
    if (m.find("TransactionHash") != m.end() && !m["TransactionHash"].empty()) {
      transactionHash = make_shared<string>(boost::any_cast<string>(m["TransactionHash"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBodyResult() = default;
};
class DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBody() {}

  explicit DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBody() = default;
};
class DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBody> body{};

  DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponse() {}

  explicit DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponse() = default;
};
class DescribeAntChainNodesNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> consortiumId{};

  DescribeAntChainNodesNewRequest() {}

  explicit DescribeAntChainNodesNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
  }


  virtual ~DescribeAntChainNodesNewRequest() = default;
};
class DescribeAntChainNodesNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainNodesNewResponseBody() {}

  explicit DescribeAntChainNodesNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Result"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      result = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainNodesNewResponseBody() = default;
};
class DescribeAntChainNodesNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainNodesNewResponseBody> body{};

  DescribeAntChainNodesNewResponse() {}

  explicit DescribeAntChainNodesNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainNodesNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainNodesNewResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainNodesNewResponse() = default;
};
class DescribeAntChainQRCodeAuthorizationRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> QRCodeType{};

  DescribeAntChainQRCodeAuthorizationRequest() {}

  explicit DescribeAntChainQRCodeAuthorizationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (QRCodeType) {
      res["QRCodeType"] = boost::any(*QRCodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("QRCodeType") != m.end() && !m["QRCodeType"].empty()) {
      QRCodeType = make_shared<string>(boost::any_cast<string>(m["QRCodeType"]));
    }
  }


  virtual ~DescribeAntChainQRCodeAuthorizationRequest() = default;
};
class DescribeAntChainQRCodeAuthorizationResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> authorizationType{};
  shared_ptr<string> QRCodeType{};

  DescribeAntChainQRCodeAuthorizationResponseBodyResult() {}

  explicit DescribeAntChainQRCodeAuthorizationResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (authorizationType) {
      res["AuthorizationType"] = boost::any(*authorizationType);
    }
    if (QRCodeType) {
      res["QRCodeType"] = boost::any(*QRCodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("AuthorizationType") != m.end() && !m["AuthorizationType"].empty()) {
      authorizationType = make_shared<string>(boost::any_cast<string>(m["AuthorizationType"]));
    }
    if (m.find("QRCodeType") != m.end() && !m["QRCodeType"].empty()) {
      QRCodeType = make_shared<string>(boost::any_cast<string>(m["QRCodeType"]));
    }
  }


  virtual ~DescribeAntChainQRCodeAuthorizationResponseBodyResult() = default;
};
class DescribeAntChainQRCodeAuthorizationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainQRCodeAuthorizationResponseBodyResult> result{};

  DescribeAntChainQRCodeAuthorizationResponseBody() {}

  explicit DescribeAntChainQRCodeAuthorizationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainQRCodeAuthorizationResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainQRCodeAuthorizationResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainQRCodeAuthorizationResponseBody() = default;
};
class DescribeAntChainQRCodeAuthorizationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainQRCodeAuthorizationResponseBody> body{};

  DescribeAntChainQRCodeAuthorizationResponse() {}

  explicit DescribeAntChainQRCodeAuthorizationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainQRCodeAuthorizationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainQRCodeAuthorizationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainQRCodeAuthorizationResponse() = default;
};
class DescribeAntChainQRCodeAuthorizationNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> QRCodeType{};

  DescribeAntChainQRCodeAuthorizationNewRequest() {}

  explicit DescribeAntChainQRCodeAuthorizationNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (QRCodeType) {
      res["QRCodeType"] = boost::any(*QRCodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("QRCodeType") != m.end() && !m["QRCodeType"].empty()) {
      QRCodeType = make_shared<string>(boost::any_cast<string>(m["QRCodeType"]));
    }
  }


  virtual ~DescribeAntChainQRCodeAuthorizationNewRequest() = default;
};
class DescribeAntChainQRCodeAuthorizationNewResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> authorizationType{};
  shared_ptr<string> QRCodeType{};

  DescribeAntChainQRCodeAuthorizationNewResponseBodyResult() {}

  explicit DescribeAntChainQRCodeAuthorizationNewResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (authorizationType) {
      res["AuthorizationType"] = boost::any(*authorizationType);
    }
    if (QRCodeType) {
      res["QRCodeType"] = boost::any(*QRCodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("AuthorizationType") != m.end() && !m["AuthorizationType"].empty()) {
      authorizationType = make_shared<string>(boost::any_cast<string>(m["AuthorizationType"]));
    }
    if (m.find("QRCodeType") != m.end() && !m["QRCodeType"].empty()) {
      QRCodeType = make_shared<string>(boost::any_cast<string>(m["QRCodeType"]));
    }
  }


  virtual ~DescribeAntChainQRCodeAuthorizationNewResponseBodyResult() = default;
};
class DescribeAntChainQRCodeAuthorizationNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainQRCodeAuthorizationNewResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainQRCodeAuthorizationNewResponseBody() {}

  explicit DescribeAntChainQRCodeAuthorizationNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainQRCodeAuthorizationNewResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainQRCodeAuthorizationNewResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainQRCodeAuthorizationNewResponseBody() = default;
};
class DescribeAntChainQRCodeAuthorizationNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainQRCodeAuthorizationNewResponseBody> body{};

  DescribeAntChainQRCodeAuthorizationNewResponse() {}

  explicit DescribeAntChainQRCodeAuthorizationNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainQRCodeAuthorizationNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainQRCodeAuthorizationNewResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainQRCodeAuthorizationNewResponse() = default;
};
class DescribeAntChainRegionNamesRequest : public Darabonba::Model {
public:
  shared_ptr<string> locale{};

  DescribeAntChainRegionNamesRequest() {}

  explicit DescribeAntChainRegionNamesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (locale) {
      res["Locale"] = boost::any(*locale);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Locale") != m.end() && !m["Locale"].empty()) {
      locale = make_shared<string>(boost::any_cast<string>(m["Locale"]));
    }
  }


  virtual ~DescribeAntChainRegionNamesRequest() = default;
};
class DescribeAntChainRegionNamesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> regionName{};

  DescribeAntChainRegionNamesResponseBodyResult() {}

  explicit DescribeAntChainRegionNamesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (regionName) {
      res["RegionName"] = boost::any(*regionName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RegionName") != m.end() && !m["RegionName"].empty()) {
      regionName = make_shared<string>(boost::any_cast<string>(m["RegionName"]));
    }
  }


  virtual ~DescribeAntChainRegionNamesResponseBodyResult() = default;
};
class DescribeAntChainRegionNamesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeAntChainRegionNamesResponseBodyResult>> result{};

  DescribeAntChainRegionNamesResponseBody() {}

  explicit DescribeAntChainRegionNamesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeAntChainRegionNamesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainRegionNamesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeAntChainRegionNamesResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~DescribeAntChainRegionNamesResponseBody() = default;
};
class DescribeAntChainRegionNamesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainRegionNamesResponseBody> body{};

  DescribeAntChainRegionNamesResponse() {}

  explicit DescribeAntChainRegionNamesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainRegionNamesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainRegionNamesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainRegionNamesResponse() = default;
};
class DescribeAntChainRegionsForSaleResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> typeList{};

  DescribeAntChainRegionsForSaleResponseBodyResult() {}

  explicit DescribeAntChainRegionsForSaleResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (typeList) {
      res["TypeList"] = boost::any(*typeList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("TypeList") != m.end() && !m["TypeList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TypeList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TypeList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      typeList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeAntChainRegionsForSaleResponseBodyResult() = default;
};
class DescribeAntChainRegionsForSaleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeAntChainRegionsForSaleResponseBodyResult>> result{};

  DescribeAntChainRegionsForSaleResponseBody() {}

  explicit DescribeAntChainRegionsForSaleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeAntChainRegionsForSaleResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainRegionsForSaleResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeAntChainRegionsForSaleResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~DescribeAntChainRegionsForSaleResponseBody() = default;
};
class DescribeAntChainRegionsForSaleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainRegionsForSaleResponseBody> body{};

  DescribeAntChainRegionsForSaleResponse() {}

  explicit DescribeAntChainRegionsForSaleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainRegionsForSaleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainRegionsForSaleResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainRegionsForSaleResponse() = default;
};
class DescribeAntChainResourceTypesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> cpu{};
  shared_ptr<long> disk{};
  shared_ptr<long> memory{};
  shared_ptr<long> typeId_{};

  DescribeAntChainResourceTypesResponseBodyResult() {}

  explicit DescribeAntChainResourceTypesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (disk) {
      res["Disk"] = boost::any(*disk);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (typeId_) {
      res["TypeId"] = boost::any(*typeId_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("Disk") != m.end() && !m["Disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["Disk"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("TypeId") != m.end() && !m["TypeId"].empty()) {
      typeId_ = make_shared<long>(boost::any_cast<long>(m["TypeId"]));
    }
  }


  virtual ~DescribeAntChainResourceTypesResponseBodyResult() = default;
};
class DescribeAntChainResourceTypesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeAntChainResourceTypesResponseBodyResult>> result{};

  DescribeAntChainResourceTypesResponseBody() {}

  explicit DescribeAntChainResourceTypesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeAntChainResourceTypesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainResourceTypesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeAntChainResourceTypesResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~DescribeAntChainResourceTypesResponseBody() = default;
};
class DescribeAntChainResourceTypesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainResourceTypesResponseBody> body{};

  DescribeAntChainResourceTypesResponse() {}

  explicit DescribeAntChainResourceTypesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainResourceTypesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainResourceTypesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainResourceTypesResponse() = default;
};
class DescribeAntChainRestRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> consortiumId{};

  DescribeAntChainRestRequest() {}

  explicit DescribeAntChainRestRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
  }


  virtual ~DescribeAntChainRestRequest() = default;
};
class DescribeAntChainRestResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> accessId{};
  shared_ptr<long> createTime{};
  shared_ptr<long> updateTime{};

  DescribeAntChainRestResponseBodyResult() {}

  explicit DescribeAntChainRestResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessId) {
      res["AccessId"] = boost::any(*accessId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessId") != m.end() && !m["AccessId"].empty()) {
      accessId = make_shared<string>(boost::any_cast<string>(m["AccessId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeAntChainRestResponseBodyResult() = default;
};
class DescribeAntChainRestResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeAntChainRestResponseBodyResult>> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainRestResponseBody() {}

  explicit DescribeAntChainRestResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeAntChainRestResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainRestResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeAntChainRestResponseBodyResult>>(expect1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainRestResponseBody() = default;
};
class DescribeAntChainRestResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainRestResponseBody> body{};

  DescribeAntChainRestResponse() {}

  explicit DescribeAntChainRestResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainRestResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainRestResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainRestResponse() = default;
};
class DescribeAntChainSubnetListRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> consortiumId{};

  DescribeAntChainSubnetListRequest() {}

  explicit DescribeAntChainSubnetListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
  }


  virtual ~DescribeAntChainSubnetListRequest() = default;
};
class DescribeAntChainSubnetListResponseBodyResultBlockchainSubnetList : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<long> blockHeight{};
  shared_ptr<bool> consortiumMember{};
  shared_ptr<long> createTime{};
  shared_ptr<string> groupId{};
  shared_ptr<bool> monitor{};
  shared_ptr<string> name{};
  shared_ptr<long> nodeSum{};
  shared_ptr<string> rest{};
  shared_ptr<string> status{};
  shared_ptr<long> transactionSum{};

  DescribeAntChainSubnetListResponseBodyResultBlockchainSubnetList() {}

  explicit DescribeAntChainSubnetListResponseBodyResultBlockchainSubnetList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (blockHeight) {
      res["BlockHeight"] = boost::any(*blockHeight);
    }
    if (consortiumMember) {
      res["ConsortiumMember"] = boost::any(*consortiumMember);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (groupId) {
      res["GroupId"] = boost::any(*groupId);
    }
    if (monitor) {
      res["Monitor"] = boost::any(*monitor);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nodeSum) {
      res["NodeSum"] = boost::any(*nodeSum);
    }
    if (rest) {
      res["Rest"] = boost::any(*rest);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (transactionSum) {
      res["TransactionSum"] = boost::any(*transactionSum);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("BlockHeight") != m.end() && !m["BlockHeight"].empty()) {
      blockHeight = make_shared<long>(boost::any_cast<long>(m["BlockHeight"]));
    }
    if (m.find("ConsortiumMember") != m.end() && !m["ConsortiumMember"].empty()) {
      consortiumMember = make_shared<bool>(boost::any_cast<bool>(m["ConsortiumMember"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("GroupId") != m.end() && !m["GroupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["GroupId"]));
    }
    if (m.find("Monitor") != m.end() && !m["Monitor"].empty()) {
      monitor = make_shared<bool>(boost::any_cast<bool>(m["Monitor"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NodeSum") != m.end() && !m["NodeSum"].empty()) {
      nodeSum = make_shared<long>(boost::any_cast<long>(m["NodeSum"]));
    }
    if (m.find("Rest") != m.end() && !m["Rest"].empty()) {
      rest = make_shared<string>(boost::any_cast<string>(m["Rest"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TransactionSum") != m.end() && !m["TransactionSum"].empty()) {
      transactionSum = make_shared<long>(boost::any_cast<long>(m["TransactionSum"]));
    }
  }


  virtual ~DescribeAntChainSubnetListResponseBodyResultBlockchainSubnetList() = default;
};
class DescribeAntChainSubnetListResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> blockchainName{};
  shared_ptr<vector<DescribeAntChainSubnetListResponseBodyResultBlockchainSubnetList>> blockchainSubnetList{};
  shared_ptr<bool> consortiumAdmin{};

  DescribeAntChainSubnetListResponseBodyResult() {}

  explicit DescribeAntChainSubnetListResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (blockchainName) {
      res["BlockchainName"] = boost::any(*blockchainName);
    }
    if (blockchainSubnetList) {
      vector<boost::any> temp1;
      for(auto item1:*blockchainSubnetList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BlockchainSubnetList"] = boost::any(temp1);
    }
    if (consortiumAdmin) {
      res["ConsortiumAdmin"] = boost::any(*consortiumAdmin);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("BlockchainName") != m.end() && !m["BlockchainName"].empty()) {
      blockchainName = make_shared<string>(boost::any_cast<string>(m["BlockchainName"]));
    }
    if (m.find("BlockchainSubnetList") != m.end() && !m["BlockchainSubnetList"].empty()) {
      if (typeid(vector<boost::any>) == m["BlockchainSubnetList"].type()) {
        vector<DescribeAntChainSubnetListResponseBodyResultBlockchainSubnetList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BlockchainSubnetList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainSubnetListResponseBodyResultBlockchainSubnetList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        blockchainSubnetList = make_shared<vector<DescribeAntChainSubnetListResponseBodyResultBlockchainSubnetList>>(expect1);
      }
    }
    if (m.find("ConsortiumAdmin") != m.end() && !m["ConsortiumAdmin"].empty()) {
      consortiumAdmin = make_shared<bool>(boost::any_cast<bool>(m["ConsortiumAdmin"]));
    }
  }


  virtual ~DescribeAntChainSubnetListResponseBodyResult() = default;
};
class DescribeAntChainSubnetListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainSubnetListResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainSubnetListResponseBody() {}

  explicit DescribeAntChainSubnetListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainSubnetListResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainSubnetListResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainSubnetListResponseBody() = default;
};
class DescribeAntChainSubnetListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainSubnetListResponseBody> body{};

  DescribeAntChainSubnetListResponse() {}

  explicit DescribeAntChainSubnetListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainSubnetListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainSubnetListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainSubnetListResponse() = default;
};
class DescribeAntChainSubnetMemberListRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> pageNumber{};
  shared_ptr<string> pageSize{};

  DescribeAntChainSubnetMemberListRequest() {}

  explicit DescribeAntChainSubnetMemberListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<string>(boost::any_cast<string>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<string>(boost::any_cast<string>(m["PageSize"]));
    }
  }


  virtual ~DescribeAntChainSubnetMemberListRequest() = default;
};
class DescribeAntChainSubnetMemberListResponseBodyResultConsortiumMemberInfoList : public Darabonba::Model {
public:
  shared_ptr<long> joinTime{};
  shared_ptr<string> memberId{};
  shared_ptr<string> memberName{};
  shared_ptr<string> role{};
  shared_ptr<string> status{};

  DescribeAntChainSubnetMemberListResponseBodyResultConsortiumMemberInfoList() {}

  explicit DescribeAntChainSubnetMemberListResponseBodyResultConsortiumMemberInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (joinTime) {
      res["JoinTime"] = boost::any(*joinTime);
    }
    if (memberId) {
      res["MemberId"] = boost::any(*memberId);
    }
    if (memberName) {
      res["MemberName"] = boost::any(*memberName);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JoinTime") != m.end() && !m["JoinTime"].empty()) {
      joinTime = make_shared<long>(boost::any_cast<long>(m["JoinTime"]));
    }
    if (m.find("MemberId") != m.end() && !m["MemberId"].empty()) {
      memberId = make_shared<string>(boost::any_cast<string>(m["MemberId"]));
    }
    if (m.find("MemberName") != m.end() && !m["MemberName"].empty()) {
      memberName = make_shared<string>(boost::any_cast<string>(m["MemberName"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeAntChainSubnetMemberListResponseBodyResultConsortiumMemberInfoList() = default;
};
class DescribeAntChainSubnetMemberListResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainSubnetMemberListResponseBodyResultPagination() {}

  explicit DescribeAntChainSubnetMemberListResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainSubnetMemberListResponseBodyResultPagination() = default;
};
class DescribeAntChainSubnetMemberListResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> consortiumAdmin{};
  shared_ptr<vector<DescribeAntChainSubnetMemberListResponseBodyResultConsortiumMemberInfoList>> consortiumMemberInfoList{};
  shared_ptr<DescribeAntChainSubnetMemberListResponseBodyResultPagination> pagination{};

  DescribeAntChainSubnetMemberListResponseBodyResult() {}

  explicit DescribeAntChainSubnetMemberListResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumAdmin) {
      res["ConsortiumAdmin"] = boost::any(*consortiumAdmin);
    }
    if (consortiumMemberInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*consortiumMemberInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ConsortiumMemberInfoList"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumAdmin") != m.end() && !m["ConsortiumAdmin"].empty()) {
      consortiumAdmin = make_shared<bool>(boost::any_cast<bool>(m["ConsortiumAdmin"]));
    }
    if (m.find("ConsortiumMemberInfoList") != m.end() && !m["ConsortiumMemberInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["ConsortiumMemberInfoList"].type()) {
        vector<DescribeAntChainSubnetMemberListResponseBodyResultConsortiumMemberInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ConsortiumMemberInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainSubnetMemberListResponseBodyResultConsortiumMemberInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        consortiumMemberInfoList = make_shared<vector<DescribeAntChainSubnetMemberListResponseBodyResultConsortiumMemberInfoList>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainSubnetMemberListResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainSubnetMemberListResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeAntChainSubnetMemberListResponseBodyResult() = default;
};
class DescribeAntChainSubnetMemberListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainSubnetMemberListResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainSubnetMemberListResponseBody() {}

  explicit DescribeAntChainSubnetMemberListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainSubnetMemberListResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainSubnetMemberListResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainSubnetMemberListResponseBody() = default;
};
class DescribeAntChainSubnetMemberListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainSubnetMemberListResponseBody> body{};

  DescribeAntChainSubnetMemberListResponse() {}

  explicit DescribeAntChainSubnetMemberListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainSubnetMemberListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainSubnetMemberListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainSubnetMemberListResponse() = default;
};
class DescribeAntChainSubnetNodeListRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> consortiumId{};

  DescribeAntChainSubnetNodeListRequest() {}

  explicit DescribeAntChainSubnetNodeListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
  }


  virtual ~DescribeAntChainSubnetNodeListRequest() = default;
};
class DescribeAntChainSubnetNodeListResponseBodyResultChainNodeInfoList : public Darabonba::Model {
public:
  shared_ptr<string> diskTotal{};
  shared_ptr<string> diskUse{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeIp{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> nodePort{};
  shared_ptr<string> nodeSource{};
  shared_ptr<string> nodeState{};
  shared_ptr<string> nodeType{};
  shared_ptr<string> publicKey{};

  DescribeAntChainSubnetNodeListResponseBodyResultChainNodeInfoList() {}

  explicit DescribeAntChainSubnetNodeListResponseBodyResultChainNodeInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskTotal) {
      res["DiskTotal"] = boost::any(*diskTotal);
    }
    if (diskUse) {
      res["DiskUse"] = boost::any(*diskUse);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeIp) {
      res["NodeIp"] = boost::any(*nodeIp);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (nodePort) {
      res["NodePort"] = boost::any(*nodePort);
    }
    if (nodeSource) {
      res["NodeSource"] = boost::any(*nodeSource);
    }
    if (nodeState) {
      res["NodeState"] = boost::any(*nodeState);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    if (publicKey) {
      res["PublicKey"] = boost::any(*publicKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DiskTotal") != m.end() && !m["DiskTotal"].empty()) {
      diskTotal = make_shared<string>(boost::any_cast<string>(m["DiskTotal"]));
    }
    if (m.find("DiskUse") != m.end() && !m["DiskUse"].empty()) {
      diskUse = make_shared<string>(boost::any_cast<string>(m["DiskUse"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeIp") != m.end() && !m["NodeIp"].empty()) {
      nodeIp = make_shared<string>(boost::any_cast<string>(m["NodeIp"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("NodePort") != m.end() && !m["NodePort"].empty()) {
      nodePort = make_shared<string>(boost::any_cast<string>(m["NodePort"]));
    }
    if (m.find("NodeSource") != m.end() && !m["NodeSource"].empty()) {
      nodeSource = make_shared<string>(boost::any_cast<string>(m["NodeSource"]));
    }
    if (m.find("NodeState") != m.end() && !m["NodeState"].empty()) {
      nodeState = make_shared<string>(boost::any_cast<string>(m["NodeState"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
    if (m.find("PublicKey") != m.end() && !m["PublicKey"].empty()) {
      publicKey = make_shared<string>(boost::any_cast<string>(m["PublicKey"]));
    }
  }


  virtual ~DescribeAntChainSubnetNodeListResponseBodyResultChainNodeInfoList() = default;
};
class DescribeAntChainSubnetNodeListResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAntChainSubnetNodeListResponseBodyResultChainNodeInfoList>> chainNodeInfoList{};
  shared_ptr<bool> consortiumAdmin{};

  DescribeAntChainSubnetNodeListResponseBodyResult() {}

  explicit DescribeAntChainSubnetNodeListResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chainNodeInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*chainNodeInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ChainNodeInfoList"] = boost::any(temp1);
    }
    if (consortiumAdmin) {
      res["ConsortiumAdmin"] = boost::any(*consortiumAdmin);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChainNodeInfoList") != m.end() && !m["ChainNodeInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["ChainNodeInfoList"].type()) {
        vector<DescribeAntChainSubnetNodeListResponseBodyResultChainNodeInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ChainNodeInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainSubnetNodeListResponseBodyResultChainNodeInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        chainNodeInfoList = make_shared<vector<DescribeAntChainSubnetNodeListResponseBodyResultChainNodeInfoList>>(expect1);
      }
    }
    if (m.find("ConsortiumAdmin") != m.end() && !m["ConsortiumAdmin"].empty()) {
      consortiumAdmin = make_shared<bool>(boost::any_cast<bool>(m["ConsortiumAdmin"]));
    }
  }


  virtual ~DescribeAntChainSubnetNodeListResponseBodyResult() = default;
};
class DescribeAntChainSubnetNodeListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeAntChainSubnetNodeListResponseBodyResult>> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainSubnetNodeListResponseBody() {}

  explicit DescribeAntChainSubnetNodeListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeAntChainSubnetNodeListResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainSubnetNodeListResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeAntChainSubnetNodeListResponseBodyResult>>(expect1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainSubnetNodeListResponseBody() = default;
};
class DescribeAntChainSubnetNodeListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainSubnetNodeListResponseBody> body{};

  DescribeAntChainSubnetNodeListResponse() {}

  explicit DescribeAntChainSubnetNodeListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainSubnetNodeListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainSubnetNodeListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainSubnetNodeListResponse() = default;
};
class DescribeAntChainTransactionRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> hash{};

  DescribeAntChainTransactionRequest() {}

  explicit DescribeAntChainTransactionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (hash) {
      res["Hash"] = boost::any(*hash);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("Hash") != m.end() && !m["Hash"].empty()) {
      hash = make_shared<string>(boost::any_cast<string>(m["Hash"]));
    }
  }


  virtual ~DescribeAntChainTransactionRequest() = default;
};
class DescribeAntChainTransactionResponseBodyResultTransaction : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<vector<string>> extentions{};
  shared_ptr<string> from{};
  shared_ptr<string> gas{};
  shared_ptr<string> hash{};
  shared_ptr<string> nonce{};
  shared_ptr<long> period{};
  shared_ptr<vector<string>> signatures{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> to{};
  shared_ptr<string> txType{};
  shared_ptr<string> value{};

  DescribeAntChainTransactionResponseBodyResultTransaction() {}

  explicit DescribeAntChainTransactionResponseBodyResultTransaction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (extentions) {
      res["Extentions"] = boost::any(*extentions);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (gas) {
      res["Gas"] = boost::any(*gas);
    }
    if (hash) {
      res["Hash"] = boost::any(*hash);
    }
    if (nonce) {
      res["Nonce"] = boost::any(*nonce);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (signatures) {
      res["Signatures"] = boost::any(*signatures);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    if (txType) {
      res["TxType"] = boost::any(*txType);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Extentions") != m.end() && !m["Extentions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Extentions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Extentions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      extentions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("Gas") != m.end() && !m["Gas"].empty()) {
      gas = make_shared<string>(boost::any_cast<string>(m["Gas"]));
    }
    if (m.find("Hash") != m.end() && !m["Hash"].empty()) {
      hash = make_shared<string>(boost::any_cast<string>(m["Hash"]));
    }
    if (m.find("Nonce") != m.end() && !m["Nonce"].empty()) {
      nonce = make_shared<string>(boost::any_cast<string>(m["Nonce"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("Signatures") != m.end() && !m["Signatures"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Signatures"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Signatures"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signatures = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<string>(boost::any_cast<string>(m["To"]));
    }
    if (m.find("TxType") != m.end() && !m["TxType"].empty()) {
      txType = make_shared<string>(boost::any_cast<string>(m["TxType"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeAntChainTransactionResponseBodyResultTransaction() = default;
};
class DescribeAntChainTransactionResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> blockHash{};
  shared_ptr<long> blockHeight{};
  shared_ptr<string> blockVersion{};
  shared_ptr<long> createTime{};
  shared_ptr<string> hash{};
  shared_ptr<DescribeAntChainTransactionResponseBodyResultTransaction> transaction{};

  DescribeAntChainTransactionResponseBodyResult() {}

  explicit DescribeAntChainTransactionResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockHash) {
      res["BlockHash"] = boost::any(*blockHash);
    }
    if (blockHeight) {
      res["BlockHeight"] = boost::any(*blockHeight);
    }
    if (blockVersion) {
      res["BlockVersion"] = boost::any(*blockVersion);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (hash) {
      res["Hash"] = boost::any(*hash);
    }
    if (transaction) {
      res["Transaction"] = transaction ? boost::any(transaction->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockHash") != m.end() && !m["BlockHash"].empty()) {
      blockHash = make_shared<string>(boost::any_cast<string>(m["BlockHash"]));
    }
    if (m.find("BlockHeight") != m.end() && !m["BlockHeight"].empty()) {
      blockHeight = make_shared<long>(boost::any_cast<long>(m["BlockHeight"]));
    }
    if (m.find("BlockVersion") != m.end() && !m["BlockVersion"].empty()) {
      blockVersion = make_shared<string>(boost::any_cast<string>(m["BlockVersion"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Hash") != m.end() && !m["Hash"].empty()) {
      hash = make_shared<string>(boost::any_cast<string>(m["Hash"]));
    }
    if (m.find("Transaction") != m.end() && !m["Transaction"].empty()) {
      if (typeid(map<string, boost::any>) == m["Transaction"].type()) {
        DescribeAntChainTransactionResponseBodyResultTransaction model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Transaction"]));
        transaction = make_shared<DescribeAntChainTransactionResponseBodyResultTransaction>(model1);
      }
    }
  }


  virtual ~DescribeAntChainTransactionResponseBodyResult() = default;
};
class DescribeAntChainTransactionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainTransactionResponseBodyResult> result{};

  DescribeAntChainTransactionResponseBody() {}

  explicit DescribeAntChainTransactionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainTransactionResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainTransactionResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainTransactionResponseBody() = default;
};
class DescribeAntChainTransactionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainTransactionResponseBody> body{};

  DescribeAntChainTransactionResponse() {}

  explicit DescribeAntChainTransactionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainTransactionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainTransactionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainTransactionResponse() = default;
};
class DescribeAntChainTransactionNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> hash{};

  DescribeAntChainTransactionNewRequest() {}

  explicit DescribeAntChainTransactionNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (hash) {
      res["Hash"] = boost::any(*hash);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Hash") != m.end() && !m["Hash"].empty()) {
      hash = make_shared<string>(boost::any_cast<string>(m["Hash"]));
    }
  }


  virtual ~DescribeAntChainTransactionNewRequest() = default;
};
class DescribeAntChainTransactionNewResponseBodyResultTransaction : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<vector<string>> extentions{};
  shared_ptr<string> from{};
  shared_ptr<string> gas{};
  shared_ptr<string> hash{};
  shared_ptr<string> nonce{};
  shared_ptr<long> period{};
  shared_ptr<vector<string>> signatures{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> to{};
  shared_ptr<string> txType{};
  shared_ptr<string> value{};

  DescribeAntChainTransactionNewResponseBodyResultTransaction() {}

  explicit DescribeAntChainTransactionNewResponseBodyResultTransaction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (extentions) {
      res["Extentions"] = boost::any(*extentions);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (gas) {
      res["Gas"] = boost::any(*gas);
    }
    if (hash) {
      res["Hash"] = boost::any(*hash);
    }
    if (nonce) {
      res["Nonce"] = boost::any(*nonce);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (signatures) {
      res["Signatures"] = boost::any(*signatures);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    if (txType) {
      res["TxType"] = boost::any(*txType);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Extentions") != m.end() && !m["Extentions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Extentions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Extentions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      extentions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("Gas") != m.end() && !m["Gas"].empty()) {
      gas = make_shared<string>(boost::any_cast<string>(m["Gas"]));
    }
    if (m.find("Hash") != m.end() && !m["Hash"].empty()) {
      hash = make_shared<string>(boost::any_cast<string>(m["Hash"]));
    }
    if (m.find("Nonce") != m.end() && !m["Nonce"].empty()) {
      nonce = make_shared<string>(boost::any_cast<string>(m["Nonce"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("Signatures") != m.end() && !m["Signatures"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Signatures"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Signatures"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signatures = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<string>(boost::any_cast<string>(m["To"]));
    }
    if (m.find("TxType") != m.end() && !m["TxType"].empty()) {
      txType = make_shared<string>(boost::any_cast<string>(m["TxType"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeAntChainTransactionNewResponseBodyResultTransaction() = default;
};
class DescribeAntChainTransactionNewResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> blockHash{};
  shared_ptr<long> blockHeight{};
  shared_ptr<string> blockVersion{};
  shared_ptr<long> createTime{};
  shared_ptr<string> hash{};
  shared_ptr<DescribeAntChainTransactionNewResponseBodyResultTransaction> transaction{};

  DescribeAntChainTransactionNewResponseBodyResult() {}

  explicit DescribeAntChainTransactionNewResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockHash) {
      res["BlockHash"] = boost::any(*blockHash);
    }
    if (blockHeight) {
      res["BlockHeight"] = boost::any(*blockHeight);
    }
    if (blockVersion) {
      res["BlockVersion"] = boost::any(*blockVersion);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (hash) {
      res["Hash"] = boost::any(*hash);
    }
    if (transaction) {
      res["Transaction"] = transaction ? boost::any(transaction->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockHash") != m.end() && !m["BlockHash"].empty()) {
      blockHash = make_shared<string>(boost::any_cast<string>(m["BlockHash"]));
    }
    if (m.find("BlockHeight") != m.end() && !m["BlockHeight"].empty()) {
      blockHeight = make_shared<long>(boost::any_cast<long>(m["BlockHeight"]));
    }
    if (m.find("BlockVersion") != m.end() && !m["BlockVersion"].empty()) {
      blockVersion = make_shared<string>(boost::any_cast<string>(m["BlockVersion"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Hash") != m.end() && !m["Hash"].empty()) {
      hash = make_shared<string>(boost::any_cast<string>(m["Hash"]));
    }
    if (m.find("Transaction") != m.end() && !m["Transaction"].empty()) {
      if (typeid(map<string, boost::any>) == m["Transaction"].type()) {
        DescribeAntChainTransactionNewResponseBodyResultTransaction model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Transaction"]));
        transaction = make_shared<DescribeAntChainTransactionNewResponseBodyResultTransaction>(model1);
      }
    }
  }


  virtual ~DescribeAntChainTransactionNewResponseBodyResult() = default;
};
class DescribeAntChainTransactionNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainTransactionNewResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainTransactionNewResponseBody() {}

  explicit DescribeAntChainTransactionNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainTransactionNewResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainTransactionNewResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainTransactionNewResponseBody() = default;
};
class DescribeAntChainTransactionNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainTransactionNewResponseBody> body{};

  DescribeAntChainTransactionNewResponse() {}

  explicit DescribeAntChainTransactionNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainTransactionNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainTransactionNewResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainTransactionNewResponse() = default;
};
class DescribeAntChainTransactionReceiptNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> hash{};

  DescribeAntChainTransactionReceiptNewRequest() {}

  explicit DescribeAntChainTransactionReceiptNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (hash) {
      res["Hash"] = boost::any(*hash);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Hash") != m.end() && !m["Hash"].empty()) {
      hash = make_shared<string>(boost::any_cast<string>(m["Hash"]));
    }
  }


  virtual ~DescribeAntChainTransactionReceiptNewRequest() = default;
};
class DescribeAntChainTransactionReceiptNewResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> gasUsed{};
  shared_ptr<vector<string>> logs{};
  shared_ptr<long> result{};

  DescribeAntChainTransactionReceiptNewResponseBodyResult() {}

  explicit DescribeAntChainTransactionReceiptNewResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (gasUsed) {
      res["GasUsed"] = boost::any(*gasUsed);
    }
    if (logs) {
      res["Logs"] = boost::any(*logs);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("GasUsed") != m.end() && !m["GasUsed"].empty()) {
      gasUsed = make_shared<string>(boost::any_cast<string>(m["GasUsed"]));
    }
    if (m.find("Logs") != m.end() && !m["Logs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Logs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Logs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      logs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<long>(boost::any_cast<long>(m["Result"]));
    }
  }


  virtual ~DescribeAntChainTransactionReceiptNewResponseBodyResult() = default;
};
class DescribeAntChainTransactionReceiptNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainTransactionReceiptNewResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainTransactionReceiptNewResponseBody() {}

  explicit DescribeAntChainTransactionReceiptNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainTransactionReceiptNewResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainTransactionReceiptNewResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainTransactionReceiptNewResponseBody() = default;
};
class DescribeAntChainTransactionReceiptNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainTransactionReceiptNewResponseBody> body{};

  DescribeAntChainTransactionReceiptNewResponse() {}

  explicit DescribeAntChainTransactionReceiptNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainTransactionReceiptNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainTransactionReceiptNewResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainTransactionReceiptNewResponse() = default;
};
class DescribeAntChainTransactionStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<long> end{};
  shared_ptr<long> start{};

  DescribeAntChainTransactionStatisticsRequest() {}

  explicit DescribeAntChainTransactionStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
  }


  virtual ~DescribeAntChainTransactionStatisticsRequest() = default;
};
class DescribeAntChainTransactionStatisticsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<long> creatTime{};
  shared_ptr<long> dt{};
  shared_ptr<long> lastSumBlockHeight{};
  shared_ptr<long> transCount{};

  DescribeAntChainTransactionStatisticsResponseBodyResult() {}

  explicit DescribeAntChainTransactionStatisticsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (creatTime) {
      res["CreatTime"] = boost::any(*creatTime);
    }
    if (dt) {
      res["Dt"] = boost::any(*dt);
    }
    if (lastSumBlockHeight) {
      res["LastSumBlockHeight"] = boost::any(*lastSumBlockHeight);
    }
    if (transCount) {
      res["TransCount"] = boost::any(*transCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("CreatTime") != m.end() && !m["CreatTime"].empty()) {
      creatTime = make_shared<long>(boost::any_cast<long>(m["CreatTime"]));
    }
    if (m.find("Dt") != m.end() && !m["Dt"].empty()) {
      dt = make_shared<long>(boost::any_cast<long>(m["Dt"]));
    }
    if (m.find("LastSumBlockHeight") != m.end() && !m["LastSumBlockHeight"].empty()) {
      lastSumBlockHeight = make_shared<long>(boost::any_cast<long>(m["LastSumBlockHeight"]));
    }
    if (m.find("TransCount") != m.end() && !m["TransCount"].empty()) {
      transCount = make_shared<long>(boost::any_cast<long>(m["TransCount"]));
    }
  }


  virtual ~DescribeAntChainTransactionStatisticsResponseBodyResult() = default;
};
class DescribeAntChainTransactionStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeAntChainTransactionStatisticsResponseBodyResult>> result{};

  DescribeAntChainTransactionStatisticsResponseBody() {}

  explicit DescribeAntChainTransactionStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeAntChainTransactionStatisticsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainTransactionStatisticsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeAntChainTransactionStatisticsResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~DescribeAntChainTransactionStatisticsResponseBody() = default;
};
class DescribeAntChainTransactionStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainTransactionStatisticsResponseBody> body{};

  DescribeAntChainTransactionStatisticsResponse() {}

  explicit DescribeAntChainTransactionStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainTransactionStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainTransactionStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainTransactionStatisticsResponse() = default;
};
class DescribeAntChainTransactionStatisticsNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> consortiumId{};
  shared_ptr<long> end{};
  shared_ptr<long> start{};

  DescribeAntChainTransactionStatisticsNewRequest() {}

  explicit DescribeAntChainTransactionStatisticsNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
  }


  virtual ~DescribeAntChainTransactionStatisticsNewRequest() = default;
};
class DescribeAntChainTransactionStatisticsNewResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<long> creatTime{};
  shared_ptr<long> dt{};
  shared_ptr<long> lastSumBlockHeight{};
  shared_ptr<long> transCount{};

  DescribeAntChainTransactionStatisticsNewResponseBodyResult() {}

  explicit DescribeAntChainTransactionStatisticsNewResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (creatTime) {
      res["CreatTime"] = boost::any(*creatTime);
    }
    if (dt) {
      res["Dt"] = boost::any(*dt);
    }
    if (lastSumBlockHeight) {
      res["LastSumBlockHeight"] = boost::any(*lastSumBlockHeight);
    }
    if (transCount) {
      res["TransCount"] = boost::any(*transCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("CreatTime") != m.end() && !m["CreatTime"].empty()) {
      creatTime = make_shared<long>(boost::any_cast<long>(m["CreatTime"]));
    }
    if (m.find("Dt") != m.end() && !m["Dt"].empty()) {
      dt = make_shared<long>(boost::any_cast<long>(m["Dt"]));
    }
    if (m.find("LastSumBlockHeight") != m.end() && !m["LastSumBlockHeight"].empty()) {
      lastSumBlockHeight = make_shared<long>(boost::any_cast<long>(m["LastSumBlockHeight"]));
    }
    if (m.find("TransCount") != m.end() && !m["TransCount"].empty()) {
      transCount = make_shared<long>(boost::any_cast<long>(m["TransCount"]));
    }
  }


  virtual ~DescribeAntChainTransactionStatisticsNewResponseBodyResult() = default;
};
class DescribeAntChainTransactionStatisticsNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeAntChainTransactionStatisticsNewResponseBodyResult>> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainTransactionStatisticsNewResponseBody() {}

  explicit DescribeAntChainTransactionStatisticsNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeAntChainTransactionStatisticsNewResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainTransactionStatisticsNewResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeAntChainTransactionStatisticsNewResponseBodyResult>>(expect1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainTransactionStatisticsNewResponseBody() = default;
};
class DescribeAntChainTransactionStatisticsNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainTransactionStatisticsNewResponseBody> body{};

  DescribeAntChainTransactionStatisticsNewResponse() {}

  explicit DescribeAntChainTransactionStatisticsNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainTransactionStatisticsNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainTransactionStatisticsNewResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainTransactionStatisticsNewResponse() = default;
};
class DescribeAntChainsRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeAntChainsRequest() {}

  explicit DescribeAntChainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeAntChainsRequest() = default;
};
class DescribeAntChainsResponseBodyResultAntChains : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> antChainName{};
  shared_ptr<string> chainType{};
  shared_ptr<string> cipherSuit{};
  shared_ptr<long> createTime{};
  shared_ptr<long> expireTime{};
  shared_ptr<bool> isAdmin{};
  shared_ptr<string> memberStatus{};
  shared_ptr<string> merkleTreeSuit{};
  shared_ptr<string> network{};
  shared_ptr<long> nodeNum{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceSize{};
  shared_ptr<string> tlsAlgo{};
  shared_ptr<string> version{};

  DescribeAntChainsResponseBodyResultAntChains() {}

  explicit DescribeAntChainsResponseBodyResultAntChains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (antChainName) {
      res["AntChainName"] = boost::any(*antChainName);
    }
    if (chainType) {
      res["ChainType"] = boost::any(*chainType);
    }
    if (cipherSuit) {
      res["CipherSuit"] = boost::any(*cipherSuit);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (isAdmin) {
      res["IsAdmin"] = boost::any(*isAdmin);
    }
    if (memberStatus) {
      res["MemberStatus"] = boost::any(*memberStatus);
    }
    if (merkleTreeSuit) {
      res["MerkleTreeSuit"] = boost::any(*merkleTreeSuit);
    }
    if (network) {
      res["Network"] = boost::any(*network);
    }
    if (nodeNum) {
      res["NodeNum"] = boost::any(*nodeNum);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceSize) {
      res["ResourceSize"] = boost::any(*resourceSize);
    }
    if (tlsAlgo) {
      res["TlsAlgo"] = boost::any(*tlsAlgo);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("AntChainName") != m.end() && !m["AntChainName"].empty()) {
      antChainName = make_shared<string>(boost::any_cast<string>(m["AntChainName"]));
    }
    if (m.find("ChainType") != m.end() && !m["ChainType"].empty()) {
      chainType = make_shared<string>(boost::any_cast<string>(m["ChainType"]));
    }
    if (m.find("CipherSuit") != m.end() && !m["CipherSuit"].empty()) {
      cipherSuit = make_shared<string>(boost::any_cast<string>(m["CipherSuit"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("IsAdmin") != m.end() && !m["IsAdmin"].empty()) {
      isAdmin = make_shared<bool>(boost::any_cast<bool>(m["IsAdmin"]));
    }
    if (m.find("MemberStatus") != m.end() && !m["MemberStatus"].empty()) {
      memberStatus = make_shared<string>(boost::any_cast<string>(m["MemberStatus"]));
    }
    if (m.find("MerkleTreeSuit") != m.end() && !m["MerkleTreeSuit"].empty()) {
      merkleTreeSuit = make_shared<string>(boost::any_cast<string>(m["MerkleTreeSuit"]));
    }
    if (m.find("Network") != m.end() && !m["Network"].empty()) {
      network = make_shared<string>(boost::any_cast<string>(m["Network"]));
    }
    if (m.find("NodeNum") != m.end() && !m["NodeNum"].empty()) {
      nodeNum = make_shared<long>(boost::any_cast<long>(m["NodeNum"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceSize") != m.end() && !m["ResourceSize"].empty()) {
      resourceSize = make_shared<string>(boost::any_cast<string>(m["ResourceSize"]));
    }
    if (m.find("TlsAlgo") != m.end() && !m["TlsAlgo"].empty()) {
      tlsAlgo = make_shared<string>(boost::any_cast<string>(m["TlsAlgo"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeAntChainsResponseBodyResultAntChains() = default;
};
class DescribeAntChainsResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainsResponseBodyResultPagination() {}

  explicit DescribeAntChainsResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainsResponseBodyResultPagination() = default;
};
class DescribeAntChainsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAntChainsResponseBodyResultAntChains>> antChains{};
  shared_ptr<bool> isExist{};
  shared_ptr<DescribeAntChainsResponseBodyResultPagination> pagination{};

  DescribeAntChainsResponseBodyResult() {}

  explicit DescribeAntChainsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChains) {
      vector<boost::any> temp1;
      for(auto item1:*antChains){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AntChains"] = boost::any(temp1);
    }
    if (isExist) {
      res["IsExist"] = boost::any(*isExist);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChains") != m.end() && !m["AntChains"].empty()) {
      if (typeid(vector<boost::any>) == m["AntChains"].type()) {
        vector<DescribeAntChainsResponseBodyResultAntChains> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AntChains"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainsResponseBodyResultAntChains model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        antChains = make_shared<vector<DescribeAntChainsResponseBodyResultAntChains>>(expect1);
      }
    }
    if (m.find("IsExist") != m.end() && !m["IsExist"].empty()) {
      isExist = make_shared<bool>(boost::any_cast<bool>(m["IsExist"]));
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainsResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainsResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeAntChainsResponseBodyResult() = default;
};
class DescribeAntChainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainsResponseBodyResult> result{};

  DescribeAntChainsResponseBody() {}

  explicit DescribeAntChainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainsResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainsResponseBody() = default;
};
class DescribeAntChainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainsResponseBody> body{};

  DescribeAntChainsResponse() {}

  explicit DescribeAntChainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainsResponse() = default;
};
class DescribeAntChainsNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeAntChainsNewRequest() {}

  explicit DescribeAntChainsNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeAntChainsNewRequest() = default;
};
class DescribeAntChainsNewResponseBodyResultAntChains : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> antChainName{};
  shared_ptr<string> chainType{};
  shared_ptr<string> cipherSuit{};
  shared_ptr<long> createTime{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> isAdmin{};
  shared_ptr<string> memberStatus{};
  shared_ptr<string> merkleTreeSuit{};
  shared_ptr<bool> monitorStatus{};
  shared_ptr<string> network{};
  shared_ptr<long> nodeNum{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceSize{};
  shared_ptr<string> restStatus{};
  shared_ptr<string> tlsAlgo{};
  shared_ptr<string> version{};

  DescribeAntChainsNewResponseBodyResultAntChains() {}

  explicit DescribeAntChainsNewResponseBodyResultAntChains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (antChainName) {
      res["AntChainName"] = boost::any(*antChainName);
    }
    if (chainType) {
      res["ChainType"] = boost::any(*chainType);
    }
    if (cipherSuit) {
      res["CipherSuit"] = boost::any(*cipherSuit);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isAdmin) {
      res["IsAdmin"] = boost::any(*isAdmin);
    }
    if (memberStatus) {
      res["MemberStatus"] = boost::any(*memberStatus);
    }
    if (merkleTreeSuit) {
      res["MerkleTreeSuit"] = boost::any(*merkleTreeSuit);
    }
    if (monitorStatus) {
      res["MonitorStatus"] = boost::any(*monitorStatus);
    }
    if (network) {
      res["Network"] = boost::any(*network);
    }
    if (nodeNum) {
      res["NodeNum"] = boost::any(*nodeNum);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceSize) {
      res["ResourceSize"] = boost::any(*resourceSize);
    }
    if (restStatus) {
      res["RestStatus"] = boost::any(*restStatus);
    }
    if (tlsAlgo) {
      res["TlsAlgo"] = boost::any(*tlsAlgo);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("AntChainName") != m.end() && !m["AntChainName"].empty()) {
      antChainName = make_shared<string>(boost::any_cast<string>(m["AntChainName"]));
    }
    if (m.find("ChainType") != m.end() && !m["ChainType"].empty()) {
      chainType = make_shared<string>(boost::any_cast<string>(m["ChainType"]));
    }
    if (m.find("CipherSuit") != m.end() && !m["CipherSuit"].empty()) {
      cipherSuit = make_shared<string>(boost::any_cast<string>(m["CipherSuit"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IsAdmin") != m.end() && !m["IsAdmin"].empty()) {
      isAdmin = make_shared<bool>(boost::any_cast<bool>(m["IsAdmin"]));
    }
    if (m.find("MemberStatus") != m.end() && !m["MemberStatus"].empty()) {
      memberStatus = make_shared<string>(boost::any_cast<string>(m["MemberStatus"]));
    }
    if (m.find("MerkleTreeSuit") != m.end() && !m["MerkleTreeSuit"].empty()) {
      merkleTreeSuit = make_shared<string>(boost::any_cast<string>(m["MerkleTreeSuit"]));
    }
    if (m.find("MonitorStatus") != m.end() && !m["MonitorStatus"].empty()) {
      monitorStatus = make_shared<bool>(boost::any_cast<bool>(m["MonitorStatus"]));
    }
    if (m.find("Network") != m.end() && !m["Network"].empty()) {
      network = make_shared<string>(boost::any_cast<string>(m["Network"]));
    }
    if (m.find("NodeNum") != m.end() && !m["NodeNum"].empty()) {
      nodeNum = make_shared<long>(boost::any_cast<long>(m["NodeNum"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceSize") != m.end() && !m["ResourceSize"].empty()) {
      resourceSize = make_shared<string>(boost::any_cast<string>(m["ResourceSize"]));
    }
    if (m.find("RestStatus") != m.end() && !m["RestStatus"].empty()) {
      restStatus = make_shared<string>(boost::any_cast<string>(m["RestStatus"]));
    }
    if (m.find("TlsAlgo") != m.end() && !m["TlsAlgo"].empty()) {
      tlsAlgo = make_shared<string>(boost::any_cast<string>(m["TlsAlgo"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeAntChainsNewResponseBodyResultAntChains() = default;
};
class DescribeAntChainsNewResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainsNewResponseBodyResultPagination() {}

  explicit DescribeAntChainsNewResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainsNewResponseBodyResultPagination() = default;
};
class DescribeAntChainsNewResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAntChainsNewResponseBodyResultAntChains>> antChains{};
  shared_ptr<bool> isExist{};
  shared_ptr<DescribeAntChainsNewResponseBodyResultPagination> pagination{};

  DescribeAntChainsNewResponseBodyResult() {}

  explicit DescribeAntChainsNewResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChains) {
      vector<boost::any> temp1;
      for(auto item1:*antChains){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AntChains"] = boost::any(temp1);
    }
    if (isExist) {
      res["IsExist"] = boost::any(*isExist);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChains") != m.end() && !m["AntChains"].empty()) {
      if (typeid(vector<boost::any>) == m["AntChains"].type()) {
        vector<DescribeAntChainsNewResponseBodyResultAntChains> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AntChains"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainsNewResponseBodyResultAntChains model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        antChains = make_shared<vector<DescribeAntChainsNewResponseBodyResultAntChains>>(expect1);
      }
    }
    if (m.find("IsExist") != m.end() && !m["IsExist"].empty()) {
      isExist = make_shared<bool>(boost::any_cast<bool>(m["IsExist"]));
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainsNewResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainsNewResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeAntChainsNewResponseBodyResult() = default;
};
class DescribeAntChainsNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainsNewResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainsNewResponseBody() {}

  explicit DescribeAntChainsNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainsNewResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainsNewResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainsNewResponseBody() = default;
};
class DescribeAntChainsNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainsNewResponseBody> body{};

  DescribeAntChainsNewResponse() {}

  explicit DescribeAntChainsNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainsNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainsNewResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainsNewResponse() = default;
};
class DescribeAntRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> locale{};

  DescribeAntRegionsRequest() {}

  explicit DescribeAntRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (locale) {
      res["Locale"] = boost::any(*locale);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Locale") != m.end() && !m["Locale"].empty()) {
      locale = make_shared<string>(boost::any_cast<string>(m["Locale"]));
    }
  }


  virtual ~DescribeAntRegionsRequest() = default;
};
class DescribeAntRegionsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> localName{};
  shared_ptr<string> regionId{};

  DescribeAntRegionsResponseBodyResult() {}

  explicit DescribeAntRegionsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeAntRegionsResponseBodyResult() = default;
};
class DescribeAntRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeAntRegionsResponseBodyResult>> result{};

  DescribeAntRegionsResponseBody() {}

  explicit DescribeAntRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeAntRegionsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntRegionsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeAntRegionsResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~DescribeAntRegionsResponseBody() = default;
};
class DescribeAntRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntRegionsResponseBody> body{};

  DescribeAntRegionsResponse() {}

  explicit DescribeAntRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntRegionsResponse() = default;
};
class DescribeAppliesRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<long> current{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> status{};

  DescribeAppliesRequest() {}

  explicit DescribeAppliesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeAppliesRequest() = default;
};
class DescribeAppliesResponseBodyResultApplyHistoryList : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<long> createtime{};
  shared_ptr<long> id{};
  shared_ptr<string> rejectReason{};
  shared_ptr<string> reqAddr{};
  shared_ptr<string> signedAddr{};
  shared_ptr<long> status{};
  shared_ptr<long> updatetime{};
  shared_ptr<string> username{};

  DescribeAppliesResponseBodyResultApplyHistoryList() {}

  explicit DescribeAppliesResponseBodyResultApplyHistoryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (createtime) {
      res["Createtime"] = boost::any(*createtime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (rejectReason) {
      res["RejectReason"] = boost::any(*rejectReason);
    }
    if (reqAddr) {
      res["ReqAddr"] = boost::any(*reqAddr);
    }
    if (signedAddr) {
      res["SignedAddr"] = boost::any(*signedAddr);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updatetime) {
      res["Updatetime"] = boost::any(*updatetime);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Createtime") != m.end() && !m["Createtime"].empty()) {
      createtime = make_shared<long>(boost::any_cast<long>(m["Createtime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RejectReason") != m.end() && !m["RejectReason"].empty()) {
      rejectReason = make_shared<string>(boost::any_cast<string>(m["RejectReason"]));
    }
    if (m.find("ReqAddr") != m.end() && !m["ReqAddr"].empty()) {
      reqAddr = make_shared<string>(boost::any_cast<string>(m["ReqAddr"]));
    }
    if (m.find("SignedAddr") != m.end() && !m["SignedAddr"].empty()) {
      signedAddr = make_shared<string>(boost::any_cast<string>(m["SignedAddr"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Updatetime") != m.end() && !m["Updatetime"].empty()) {
      updatetime = make_shared<long>(boost::any_cast<long>(m["Updatetime"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~DescribeAppliesResponseBodyResultApplyHistoryList() = default;
};
class DescribeAppliesResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> current{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  DescribeAppliesResponseBodyResultPagination() {}

  explicit DescribeAppliesResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeAppliesResponseBodyResultPagination() = default;
};
class DescribeAppliesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAppliesResponseBodyResultApplyHistoryList>> applyHistoryList{};
  shared_ptr<DescribeAppliesResponseBodyResultPagination> pagination{};

  DescribeAppliesResponseBodyResult() {}

  explicit DescribeAppliesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyHistoryList) {
      vector<boost::any> temp1;
      for(auto item1:*applyHistoryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApplyHistoryList"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyHistoryList") != m.end() && !m["ApplyHistoryList"].empty()) {
      if (typeid(vector<boost::any>) == m["ApplyHistoryList"].type()) {
        vector<DescribeAppliesResponseBodyResultApplyHistoryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApplyHistoryList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAppliesResponseBodyResultApplyHistoryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applyHistoryList = make_shared<vector<DescribeAppliesResponseBodyResultApplyHistoryList>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAppliesResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAppliesResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeAppliesResponseBodyResult() = default;
};
class DescribeAppliesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAppliesResponseBodyResult> result{};

  DescribeAppliesResponseBody() {}

  explicit DescribeAppliesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAppliesResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAppliesResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAppliesResponseBody() = default;
};
class DescribeAppliesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAppliesResponseBody> body{};

  DescribeAppliesResponse() {}

  explicit DescribeAppliesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAppliesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAppliesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAppliesResponse() = default;
};
class DescribeBcSchemaRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};

  DescribeBcSchemaRequest() {}

  explicit DescribeBcSchemaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~DescribeBcSchemaRequest() = default;
};
class DescribeBcSchemaResponseBodyResultResponsesPropertiesDataSource : public Darabonba::Model {
public:
  shared_ptr<long> allowNull{};
  shared_ptr<string> annotation{};
  shared_ptr<string> field{};
  shared_ptr<long> indexes{};
  shared_ptr<long> key{};
  shared_ptr<long> length{};
  shared_ptr<string> reg{};
  shared_ptr<string> type{};

  DescribeBcSchemaResponseBodyResultResponsesPropertiesDataSource() {}

  explicit DescribeBcSchemaResponseBodyResultResponsesPropertiesDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowNull) {
      res["AllowNull"] = boost::any(*allowNull);
    }
    if (annotation) {
      res["Annotation"] = boost::any(*annotation);
    }
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (indexes) {
      res["Indexes"] = boost::any(*indexes);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (reg) {
      res["Reg"] = boost::any(*reg);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowNull") != m.end() && !m["AllowNull"].empty()) {
      allowNull = make_shared<long>(boost::any_cast<long>(m["AllowNull"]));
    }
    if (m.find("Annotation") != m.end() && !m["Annotation"].empty()) {
      annotation = make_shared<string>(boost::any_cast<string>(m["Annotation"]));
    }
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("Indexes") != m.end() && !m["Indexes"].empty()) {
      indexes = make_shared<long>(boost::any_cast<long>(m["Indexes"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<long>(boost::any_cast<long>(m["Key"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("Reg") != m.end() && !m["Reg"].empty()) {
      reg = make_shared<string>(boost::any_cast<string>(m["Reg"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeBcSchemaResponseBodyResultResponsesPropertiesDataSource() = default;
};
class DescribeBcSchemaResponseBodyResultResponsesProperties : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<DescribeBcSchemaResponseBodyResultResponsesPropertiesDataSource>> dataSource{};

  DescribeBcSchemaResponseBodyResultResponsesProperties() {}

  explicit DescribeBcSchemaResponseBodyResultResponsesProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (dataSource) {
      vector<boost::any> temp1;
      for(auto item1:*dataSource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataSource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(vector<boost::any>) == m["DataSource"].type()) {
        vector<DescribeBcSchemaResponseBodyResultResponsesPropertiesDataSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataSource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBcSchemaResponseBodyResultResponsesPropertiesDataSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataSource = make_shared<vector<DescribeBcSchemaResponseBodyResultResponsesPropertiesDataSource>>(expect1);
      }
    }
  }


  virtual ~DescribeBcSchemaResponseBodyResultResponsesProperties() = default;
};
class DescribeBcSchemaResponseBodyResultResponses : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> categoryName{};
  shared_ptr<string> description{};
  shared_ptr<DescribeBcSchemaResponseBodyResultResponsesProperties> properties{};

  DescribeBcSchemaResponseBodyResultResponses() {}

  explicit DescribeBcSchemaResponseBodyResultResponses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (categoryName) {
      res["CategoryName"] = boost::any(*categoryName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CategoryName") != m.end() && !m["CategoryName"].empty()) {
      categoryName = make_shared<string>(boost::any_cast<string>(m["CategoryName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        DescribeBcSchemaResponseBodyResultResponsesProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<DescribeBcSchemaResponseBodyResultResponsesProperties>(model1);
      }
    }
  }


  virtual ~DescribeBcSchemaResponseBodyResultResponses() = default;
};
class DescribeBcSchemaResponseBodyResultSchema : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<bool> isTemplate{};
  shared_ptr<string> name{};
  shared_ptr<long> updateTime{};
  shared_ptr<long> version{};

  DescribeBcSchemaResponseBodyResultSchema() {}

  explicit DescribeBcSchemaResponseBodyResultSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsTemplate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~DescribeBcSchemaResponseBodyResultSchema() = default;
};
class DescribeBcSchemaResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBcSchemaResponseBodyResultResponses>> responses{};
  shared_ptr<DescribeBcSchemaResponseBodyResultSchema> schema{};

  DescribeBcSchemaResponseBodyResult() {}

  explicit DescribeBcSchemaResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (responses) {
      vector<boost::any> temp1;
      for(auto item1:*responses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Responses"] = boost::any(temp1);
    }
    if (schema) {
      res["Schema"] = schema ? boost::any(schema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Responses") != m.end() && !m["Responses"].empty()) {
      if (typeid(vector<boost::any>) == m["Responses"].type()) {
        vector<DescribeBcSchemaResponseBodyResultResponses> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Responses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBcSchemaResponseBodyResultResponses model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        responses = make_shared<vector<DescribeBcSchemaResponseBodyResultResponses>>(expect1);
      }
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      if (typeid(map<string, boost::any>) == m["Schema"].type()) {
        DescribeBcSchemaResponseBodyResultSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Schema"]));
        schema = make_shared<DescribeBcSchemaResponseBodyResultSchema>(model1);
      }
    }
  }


  virtual ~DescribeBcSchemaResponseBodyResult() = default;
};
class DescribeBcSchemaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeBcSchemaResponseBodyResult> result{};

  DescribeBcSchemaResponseBody() {}

  explicit DescribeBcSchemaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeBcSchemaResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeBcSchemaResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeBcSchemaResponseBody() = default;
};
class DescribeBcSchemaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBcSchemaResponseBody> body{};

  DescribeBcSchemaResponse() {}

  explicit DescribeBcSchemaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBcSchemaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBcSchemaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBcSchemaResponse() = default;
};
class DescribeBlockRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<long> height{};

  DescribeBlockRequest() {}

  explicit DescribeBlockRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
  }


  virtual ~DescribeBlockRequest() = default;
};
class DescribeBlockResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> blockHash{};
  shared_ptr<long> createTime{};
  shared_ptr<long> height{};
  shared_ptr<string> previousHash{};
  shared_ptr<string> rootTxHash{};
  shared_ptr<string> transSummaryList{};
  shared_ptr<long> transactionSize{};
  shared_ptr<long> version{};

  DescribeBlockResponseBodyResult() {}

  explicit DescribeBlockResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (blockHash) {
      res["BlockHash"] = boost::any(*blockHash);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (previousHash) {
      res["PreviousHash"] = boost::any(*previousHash);
    }
    if (rootTxHash) {
      res["RootTxHash"] = boost::any(*rootTxHash);
    }
    if (transSummaryList) {
      res["TransSummaryList"] = boost::any(*transSummaryList);
    }
    if (transactionSize) {
      res["TransactionSize"] = boost::any(*transactionSize);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("BlockHash") != m.end() && !m["BlockHash"].empty()) {
      blockHash = make_shared<string>(boost::any_cast<string>(m["BlockHash"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("PreviousHash") != m.end() && !m["PreviousHash"].empty()) {
      previousHash = make_shared<string>(boost::any_cast<string>(m["PreviousHash"]));
    }
    if (m.find("RootTxHash") != m.end() && !m["RootTxHash"].empty()) {
      rootTxHash = make_shared<string>(boost::any_cast<string>(m["RootTxHash"]));
    }
    if (m.find("TransSummaryList") != m.end() && !m["TransSummaryList"].empty()) {
      transSummaryList = make_shared<string>(boost::any_cast<string>(m["TransSummaryList"]));
    }
    if (m.find("TransactionSize") != m.end() && !m["TransactionSize"].empty()) {
      transactionSize = make_shared<long>(boost::any_cast<long>(m["TransactionSize"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~DescribeBlockResponseBodyResult() = default;
};
class DescribeBlockResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeBlockResponseBodyResult> result{};

  DescribeBlockResponseBody() {}

  explicit DescribeBlockResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeBlockResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeBlockResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeBlockResponseBody() = default;
};
class DescribeBlockResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBlockResponseBody> body{};

  DescribeBlockResponse() {}

  explicit DescribeBlockResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBlockResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBlockResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBlockResponse() = default;
};
class DescribeBlockchainApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<long> current{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> status{};

  DescribeBlockchainApplicationRequest() {}

  explicit DescribeBlockchainApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeBlockchainApplicationRequest() = default;
};
class DescribeBlockchainApplicationResponseBodyResultApplyHistoryList : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<long> createtime{};
  shared_ptr<long> id{};
  shared_ptr<string> rejectReason{};
  shared_ptr<string> reqAddr{};
  shared_ptr<string> signedAddr{};
  shared_ptr<long> status{};
  shared_ptr<long> updatetime{};
  shared_ptr<string> username{};

  DescribeBlockchainApplicationResponseBodyResultApplyHistoryList() {}

  explicit DescribeBlockchainApplicationResponseBodyResultApplyHistoryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (createtime) {
      res["Createtime"] = boost::any(*createtime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (rejectReason) {
      res["RejectReason"] = boost::any(*rejectReason);
    }
    if (reqAddr) {
      res["ReqAddr"] = boost::any(*reqAddr);
    }
    if (signedAddr) {
      res["SignedAddr"] = boost::any(*signedAddr);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updatetime) {
      res["Updatetime"] = boost::any(*updatetime);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Createtime") != m.end() && !m["Createtime"].empty()) {
      createtime = make_shared<long>(boost::any_cast<long>(m["Createtime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RejectReason") != m.end() && !m["RejectReason"].empty()) {
      rejectReason = make_shared<string>(boost::any_cast<string>(m["RejectReason"]));
    }
    if (m.find("ReqAddr") != m.end() && !m["ReqAddr"].empty()) {
      reqAddr = make_shared<string>(boost::any_cast<string>(m["ReqAddr"]));
    }
    if (m.find("SignedAddr") != m.end() && !m["SignedAddr"].empty()) {
      signedAddr = make_shared<string>(boost::any_cast<string>(m["SignedAddr"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Updatetime") != m.end() && !m["Updatetime"].empty()) {
      updatetime = make_shared<long>(boost::any_cast<long>(m["Updatetime"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~DescribeBlockchainApplicationResponseBodyResultApplyHistoryList() = default;
};
class DescribeBlockchainApplicationResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> current{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  DescribeBlockchainApplicationResponseBodyResultPagination() {}

  explicit DescribeBlockchainApplicationResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeBlockchainApplicationResponseBodyResultPagination() = default;
};
class DescribeBlockchainApplicationResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBlockchainApplicationResponseBodyResultApplyHistoryList>> applyHistoryList{};
  shared_ptr<DescribeBlockchainApplicationResponseBodyResultPagination> pagination{};

  DescribeBlockchainApplicationResponseBodyResult() {}

  explicit DescribeBlockchainApplicationResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyHistoryList) {
      vector<boost::any> temp1;
      for(auto item1:*applyHistoryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApplyHistoryList"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyHistoryList") != m.end() && !m["ApplyHistoryList"].empty()) {
      if (typeid(vector<boost::any>) == m["ApplyHistoryList"].type()) {
        vector<DescribeBlockchainApplicationResponseBodyResultApplyHistoryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApplyHistoryList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBlockchainApplicationResponseBodyResultApplyHistoryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applyHistoryList = make_shared<vector<DescribeBlockchainApplicationResponseBodyResultApplyHistoryList>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeBlockchainApplicationResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeBlockchainApplicationResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeBlockchainApplicationResponseBodyResult() = default;
};
class DescribeBlockchainApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeBlockchainApplicationResponseBodyResult> result{};

  DescribeBlockchainApplicationResponseBody() {}

  explicit DescribeBlockchainApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeBlockchainApplicationResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeBlockchainApplicationResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeBlockchainApplicationResponseBody() = default;
};
class DescribeBlockchainApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBlockchainApplicationResponseBody> body{};

  DescribeBlockchainApplicationResponse() {}

  explicit DescribeBlockchainApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBlockchainApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBlockchainApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBlockchainApplicationResponse() = default;
};
class DescribeBlockchainConfigOptionRequest : public Darabonba::Model {
public:
  shared_ptr<string> purpose{};

  DescribeBlockchainConfigOptionRequest() {}

  explicit DescribeBlockchainConfigOptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (purpose) {
      res["Purpose"] = boost::any(*purpose);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Purpose") != m.end() && !m["Purpose"].empty()) {
      purpose = make_shared<string>(boost::any_cast<string>(m["Purpose"]));
    }
  }


  virtual ~DescribeBlockchainConfigOptionRequest() = default;
};
class DescribeBlockchainConfigOptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<map<string, boost::any>> result{};

  DescribeBlockchainConfigOptionResponseBody() {}

  explicit DescribeBlockchainConfigOptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Result"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      result = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~DescribeBlockchainConfigOptionResponseBody() = default;
};
class DescribeBlockchainConfigOptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBlockchainConfigOptionResponseBody> body{};

  DescribeBlockchainConfigOptionResponse() {}

  explicit DescribeBlockchainConfigOptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBlockchainConfigOptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBlockchainConfigOptionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBlockchainConfigOptionResponse() = default;
};
class DescribeBlockchainCreateTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> current{};
  shared_ptr<long> pageSize{};

  DescribeBlockchainCreateTaskRequest() {}

  explicit DescribeBlockchainCreateTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeBlockchainCreateTaskRequest() = default;
};
class DescribeBlockchainCreateTaskResponseBodyResultBlockchainCreateTasks : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<long> createTime{};
  shared_ptr<string> memo{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};

  DescribeBlockchainCreateTaskResponseBodyResultBlockchainCreateTasks() {}

  explicit DescribeBlockchainCreateTaskResponseBodyResultBlockchainCreateTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (memo) {
      res["Memo"] = boost::any(*memo);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Memo") != m.end() && !m["Memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["Memo"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeBlockchainCreateTaskResponseBodyResultBlockchainCreateTasks() = default;
};
class DescribeBlockchainCreateTaskResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> current{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  DescribeBlockchainCreateTaskResponseBodyResultPagination() {}

  explicit DescribeBlockchainCreateTaskResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeBlockchainCreateTaskResponseBodyResultPagination() = default;
};
class DescribeBlockchainCreateTaskResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBlockchainCreateTaskResponseBodyResultBlockchainCreateTasks>> blockchainCreateTasks{};
  shared_ptr<DescribeBlockchainCreateTaskResponseBodyResultPagination> pagination{};

  DescribeBlockchainCreateTaskResponseBodyResult() {}

  explicit DescribeBlockchainCreateTaskResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockchainCreateTasks) {
      vector<boost::any> temp1;
      for(auto item1:*blockchainCreateTasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BlockchainCreateTasks"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockchainCreateTasks") != m.end() && !m["BlockchainCreateTasks"].empty()) {
      if (typeid(vector<boost::any>) == m["BlockchainCreateTasks"].type()) {
        vector<DescribeBlockchainCreateTaskResponseBodyResultBlockchainCreateTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BlockchainCreateTasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBlockchainCreateTaskResponseBodyResultBlockchainCreateTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        blockchainCreateTasks = make_shared<vector<DescribeBlockchainCreateTaskResponseBodyResultBlockchainCreateTasks>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeBlockchainCreateTaskResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeBlockchainCreateTaskResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeBlockchainCreateTaskResponseBodyResult() = default;
};
class DescribeBlockchainCreateTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeBlockchainCreateTaskResponseBodyResult> result{};

  DescribeBlockchainCreateTaskResponseBody() {}

  explicit DescribeBlockchainCreateTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeBlockchainCreateTaskResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeBlockchainCreateTaskResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeBlockchainCreateTaskResponseBody() = default;
};
class DescribeBlockchainCreateTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBlockchainCreateTaskResponseBody> body{};

  DescribeBlockchainCreateTaskResponse() {}

  explicit DescribeBlockchainCreateTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBlockchainCreateTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBlockchainCreateTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBlockchainCreateTaskResponse() = default;
};
class DescribeBlockchainCreationConfigOptionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> purpose{};

  DescribeBlockchainCreationConfigOptionsRequest() {}

  explicit DescribeBlockchainCreationConfigOptionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (purpose) {
      res["Purpose"] = boost::any(*purpose);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Purpose") != m.end() && !m["Purpose"].empty()) {
      purpose = make_shared<string>(boost::any_cast<string>(m["Purpose"]));
    }
  }


  virtual ~DescribeBlockchainCreationConfigOptionsRequest() = default;
};
class DescribeBlockchainCreationConfigOptionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<map<string, boost::any>> result{};

  DescribeBlockchainCreationConfigOptionsResponseBody() {}

  explicit DescribeBlockchainCreationConfigOptionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Result"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      result = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~DescribeBlockchainCreationConfigOptionsResponseBody() = default;
};
class DescribeBlockchainCreationConfigOptionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBlockchainCreationConfigOptionsResponseBody> body{};

  DescribeBlockchainCreationConfigOptionsResponse() {}

  explicit DescribeBlockchainCreationConfigOptionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBlockchainCreationConfigOptionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBlockchainCreationConfigOptionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBlockchainCreationConfigOptionsResponse() = default;
};
class DescribeBlockchainInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};

  DescribeBlockchainInfoRequest() {}

  explicit DescribeBlockchainInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~DescribeBlockchainInfoRequest() = default;
};
class DescribeBlockchainInfoResponseBodyResultNodeInfoList : public Darabonba::Model {
public:
  shared_ptr<long> blockHeight{};
  shared_ptr<string> nodeName{};
  shared_ptr<bool> status{};
  shared_ptr<string> version{};

  DescribeBlockchainInfoResponseBodyResultNodeInfoList() {}

  explicit DescribeBlockchainInfoResponseBodyResultNodeInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockHeight) {
      res["BlockHeight"] = boost::any(*blockHeight);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockHeight") != m.end() && !m["BlockHeight"].empty()) {
      blockHeight = make_shared<long>(boost::any_cast<long>(m["BlockHeight"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeBlockchainInfoResponseBodyResultNodeInfoList() = default;
};
class DescribeBlockchainInfoResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> abnormalNodes{};
  shared_ptr<string> bizid{};
  shared_ptr<long> blockHeight{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> isRole{};
  shared_ptr<vector<DescribeBlockchainInfoResponseBodyResultNodeInfoList>> nodeInfoList{};
  shared_ptr<long> nodeNumber{};
  shared_ptr<bool> normal{};
  shared_ptr<long> transactionSum{};
  shared_ptr<string> version{};

  DescribeBlockchainInfoResponseBodyResult() {}

  explicit DescribeBlockchainInfoResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnormalNodes) {
      res["AbnormalNodes"] = boost::any(*abnormalNodes);
    }
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (blockHeight) {
      res["BlockHeight"] = boost::any(*blockHeight);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (isRole) {
      res["IsRole"] = boost::any(*isRole);
    }
    if (nodeInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*nodeInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeInfoList"] = boost::any(temp1);
    }
    if (nodeNumber) {
      res["NodeNumber"] = boost::any(*nodeNumber);
    }
    if (normal) {
      res["Normal"] = boost::any(*normal);
    }
    if (transactionSum) {
      res["TransactionSum"] = boost::any(*transactionSum);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbnormalNodes") != m.end() && !m["AbnormalNodes"].empty()) {
      abnormalNodes = make_shared<long>(boost::any_cast<long>(m["AbnormalNodes"]));
    }
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("BlockHeight") != m.end() && !m["BlockHeight"].empty()) {
      blockHeight = make_shared<long>(boost::any_cast<long>(m["BlockHeight"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("IsRole") != m.end() && !m["IsRole"].empty()) {
      isRole = make_shared<bool>(boost::any_cast<bool>(m["IsRole"]));
    }
    if (m.find("NodeInfoList") != m.end() && !m["NodeInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeInfoList"].type()) {
        vector<DescribeBlockchainInfoResponseBodyResultNodeInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBlockchainInfoResponseBodyResultNodeInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeInfoList = make_shared<vector<DescribeBlockchainInfoResponseBodyResultNodeInfoList>>(expect1);
      }
    }
    if (m.find("NodeNumber") != m.end() && !m["NodeNumber"].empty()) {
      nodeNumber = make_shared<long>(boost::any_cast<long>(m["NodeNumber"]));
    }
    if (m.find("Normal") != m.end() && !m["Normal"].empty()) {
      normal = make_shared<bool>(boost::any_cast<bool>(m["Normal"]));
    }
    if (m.find("TransactionSum") != m.end() && !m["TransactionSum"].empty()) {
      transactionSum = make_shared<long>(boost::any_cast<long>(m["TransactionSum"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeBlockchainInfoResponseBodyResult() = default;
};
class DescribeBlockchainInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeBlockchainInfoResponseBodyResult> result{};

  DescribeBlockchainInfoResponseBody() {}

  explicit DescribeBlockchainInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeBlockchainInfoResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeBlockchainInfoResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeBlockchainInfoResponseBody() = default;
};
class DescribeBlockchainInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBlockchainInfoResponseBody> body{};

  DescribeBlockchainInfoResponse() {}

  explicit DescribeBlockchainInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBlockchainInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBlockchainInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBlockchainInfoResponse() = default;
};
class DescribeBlockchainSchemaRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};

  DescribeBlockchainSchemaRequest() {}

  explicit DescribeBlockchainSchemaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~DescribeBlockchainSchemaRequest() = default;
};
class DescribeBlockchainSchemaResponseBodyResultResponsesPropertiesDataSource : public Darabonba::Model {
public:
  shared_ptr<long> allowNull{};
  shared_ptr<string> annotation{};
  shared_ptr<string> field{};
  shared_ptr<long> indexes{};
  shared_ptr<long> key{};
  shared_ptr<long> length{};
  shared_ptr<string> reg{};
  shared_ptr<string> type{};

  DescribeBlockchainSchemaResponseBodyResultResponsesPropertiesDataSource() {}

  explicit DescribeBlockchainSchemaResponseBodyResultResponsesPropertiesDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowNull) {
      res["AllowNull"] = boost::any(*allowNull);
    }
    if (annotation) {
      res["Annotation"] = boost::any(*annotation);
    }
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (indexes) {
      res["Indexes"] = boost::any(*indexes);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (reg) {
      res["Reg"] = boost::any(*reg);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowNull") != m.end() && !m["AllowNull"].empty()) {
      allowNull = make_shared<long>(boost::any_cast<long>(m["AllowNull"]));
    }
    if (m.find("Annotation") != m.end() && !m["Annotation"].empty()) {
      annotation = make_shared<string>(boost::any_cast<string>(m["Annotation"]));
    }
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("Indexes") != m.end() && !m["Indexes"].empty()) {
      indexes = make_shared<long>(boost::any_cast<long>(m["Indexes"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<long>(boost::any_cast<long>(m["Key"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("Reg") != m.end() && !m["Reg"].empty()) {
      reg = make_shared<string>(boost::any_cast<string>(m["Reg"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeBlockchainSchemaResponseBodyResultResponsesPropertiesDataSource() = default;
};
class DescribeBlockchainSchemaResponseBodyResultResponsesProperties : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<DescribeBlockchainSchemaResponseBodyResultResponsesPropertiesDataSource>> dataSource{};

  DescribeBlockchainSchemaResponseBodyResultResponsesProperties() {}

  explicit DescribeBlockchainSchemaResponseBodyResultResponsesProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (dataSource) {
      vector<boost::any> temp1;
      for(auto item1:*dataSource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataSource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(vector<boost::any>) == m["DataSource"].type()) {
        vector<DescribeBlockchainSchemaResponseBodyResultResponsesPropertiesDataSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataSource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBlockchainSchemaResponseBodyResultResponsesPropertiesDataSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataSource = make_shared<vector<DescribeBlockchainSchemaResponseBodyResultResponsesPropertiesDataSource>>(expect1);
      }
    }
  }


  virtual ~DescribeBlockchainSchemaResponseBodyResultResponsesProperties() = default;
};
class DescribeBlockchainSchemaResponseBodyResultResponses : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> categoryName{};
  shared_ptr<string> description{};
  shared_ptr<DescribeBlockchainSchemaResponseBodyResultResponsesProperties> properties{};

  DescribeBlockchainSchemaResponseBodyResultResponses() {}

  explicit DescribeBlockchainSchemaResponseBodyResultResponses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (categoryName) {
      res["CategoryName"] = boost::any(*categoryName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CategoryName") != m.end() && !m["CategoryName"].empty()) {
      categoryName = make_shared<string>(boost::any_cast<string>(m["CategoryName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        DescribeBlockchainSchemaResponseBodyResultResponsesProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<DescribeBlockchainSchemaResponseBodyResultResponsesProperties>(model1);
      }
    }
  }


  virtual ~DescribeBlockchainSchemaResponseBodyResultResponses() = default;
};
class DescribeBlockchainSchemaResponseBodyResultSchema : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<bool> isTemplate{};
  shared_ptr<string> name{};
  shared_ptr<long> updateTime{};
  shared_ptr<long> version{};

  DescribeBlockchainSchemaResponseBodyResultSchema() {}

  explicit DescribeBlockchainSchemaResponseBodyResultSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsTemplate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~DescribeBlockchainSchemaResponseBodyResultSchema() = default;
};
class DescribeBlockchainSchemaResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBlockchainSchemaResponseBodyResultResponses>> responses{};
  shared_ptr<DescribeBlockchainSchemaResponseBodyResultSchema> schema{};

  DescribeBlockchainSchemaResponseBodyResult() {}

  explicit DescribeBlockchainSchemaResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (responses) {
      vector<boost::any> temp1;
      for(auto item1:*responses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Responses"] = boost::any(temp1);
    }
    if (schema) {
      res["Schema"] = schema ? boost::any(schema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Responses") != m.end() && !m["Responses"].empty()) {
      if (typeid(vector<boost::any>) == m["Responses"].type()) {
        vector<DescribeBlockchainSchemaResponseBodyResultResponses> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Responses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBlockchainSchemaResponseBodyResultResponses model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        responses = make_shared<vector<DescribeBlockchainSchemaResponseBodyResultResponses>>(expect1);
      }
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      if (typeid(map<string, boost::any>) == m["Schema"].type()) {
        DescribeBlockchainSchemaResponseBodyResultSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Schema"]));
        schema = make_shared<DescribeBlockchainSchemaResponseBodyResultSchema>(model1);
      }
    }
  }


  virtual ~DescribeBlockchainSchemaResponseBodyResult() = default;
};
class DescribeBlockchainSchemaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeBlockchainSchemaResponseBodyResult> result{};

  DescribeBlockchainSchemaResponseBody() {}

  explicit DescribeBlockchainSchemaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeBlockchainSchemaResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeBlockchainSchemaResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeBlockchainSchemaResponseBody() = default;
};
class DescribeBlockchainSchemaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBlockchainSchemaResponseBody> body{};

  DescribeBlockchainSchemaResponse() {}

  explicit DescribeBlockchainSchemaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBlockchainSchemaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBlockchainSchemaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBlockchainSchemaResponse() = default;
};
class DescribeBlockchainSchemaDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<long> schemaId{};

  DescribeBlockchainSchemaDetailRequest() {}

  explicit DescribeBlockchainSchemaDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (schemaId) {
      res["SchemaId"] = boost::any(*schemaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("SchemaId") != m.end() && !m["SchemaId"].empty()) {
      schemaId = make_shared<long>(boost::any_cast<long>(m["SchemaId"]));
    }
  }


  virtual ~DescribeBlockchainSchemaDetailRequest() = default;
};
class DescribeBlockchainSchemaDetailResponseBodyResultResponsesPropertiesDataSource : public Darabonba::Model {
public:
  shared_ptr<long> allowNull{};
  shared_ptr<string> annotation{};
  shared_ptr<string> field{};
  shared_ptr<long> indexes{};
  shared_ptr<long> key{};
  shared_ptr<long> length{};
  shared_ptr<string> reg{};
  shared_ptr<string> type{};

  DescribeBlockchainSchemaDetailResponseBodyResultResponsesPropertiesDataSource() {}

  explicit DescribeBlockchainSchemaDetailResponseBodyResultResponsesPropertiesDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowNull) {
      res["AllowNull"] = boost::any(*allowNull);
    }
    if (annotation) {
      res["Annotation"] = boost::any(*annotation);
    }
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (indexes) {
      res["Indexes"] = boost::any(*indexes);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (reg) {
      res["Reg"] = boost::any(*reg);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowNull") != m.end() && !m["AllowNull"].empty()) {
      allowNull = make_shared<long>(boost::any_cast<long>(m["AllowNull"]));
    }
    if (m.find("Annotation") != m.end() && !m["Annotation"].empty()) {
      annotation = make_shared<string>(boost::any_cast<string>(m["Annotation"]));
    }
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("Indexes") != m.end() && !m["Indexes"].empty()) {
      indexes = make_shared<long>(boost::any_cast<long>(m["Indexes"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<long>(boost::any_cast<long>(m["Key"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("Reg") != m.end() && !m["Reg"].empty()) {
      reg = make_shared<string>(boost::any_cast<string>(m["Reg"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeBlockchainSchemaDetailResponseBodyResultResponsesPropertiesDataSource() = default;
};
class DescribeBlockchainSchemaDetailResponseBodyResultResponsesProperties : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<DescribeBlockchainSchemaDetailResponseBodyResultResponsesPropertiesDataSource>> dataSource{};

  DescribeBlockchainSchemaDetailResponseBodyResultResponsesProperties() {}

  explicit DescribeBlockchainSchemaDetailResponseBodyResultResponsesProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (dataSource) {
      vector<boost::any> temp1;
      for(auto item1:*dataSource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataSource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(vector<boost::any>) == m["DataSource"].type()) {
        vector<DescribeBlockchainSchemaDetailResponseBodyResultResponsesPropertiesDataSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataSource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBlockchainSchemaDetailResponseBodyResultResponsesPropertiesDataSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataSource = make_shared<vector<DescribeBlockchainSchemaDetailResponseBodyResultResponsesPropertiesDataSource>>(expect1);
      }
    }
  }


  virtual ~DescribeBlockchainSchemaDetailResponseBodyResultResponsesProperties() = default;
};
class DescribeBlockchainSchemaDetailResponseBodyResultResponses : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> categoryName{};
  shared_ptr<string> description{};
  shared_ptr<DescribeBlockchainSchemaDetailResponseBodyResultResponsesProperties> properties{};

  DescribeBlockchainSchemaDetailResponseBodyResultResponses() {}

  explicit DescribeBlockchainSchemaDetailResponseBodyResultResponses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (categoryName) {
      res["CategoryName"] = boost::any(*categoryName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CategoryName") != m.end() && !m["CategoryName"].empty()) {
      categoryName = make_shared<string>(boost::any_cast<string>(m["CategoryName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        DescribeBlockchainSchemaDetailResponseBodyResultResponsesProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<DescribeBlockchainSchemaDetailResponseBodyResultResponsesProperties>(model1);
      }
    }
  }


  virtual ~DescribeBlockchainSchemaDetailResponseBodyResultResponses() = default;
};
class DescribeBlockchainSchemaDetailResponseBodyResultSchema : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<bool> isTemplate{};
  shared_ptr<string> name{};
  shared_ptr<long> updateTime{};
  shared_ptr<long> version{};

  DescribeBlockchainSchemaDetailResponseBodyResultSchema() {}

  explicit DescribeBlockchainSchemaDetailResponseBodyResultSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsTemplate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~DescribeBlockchainSchemaDetailResponseBodyResultSchema() = default;
};
class DescribeBlockchainSchemaDetailResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBlockchainSchemaDetailResponseBodyResultResponses>> responses{};
  shared_ptr<DescribeBlockchainSchemaDetailResponseBodyResultSchema> schema{};

  DescribeBlockchainSchemaDetailResponseBodyResult() {}

  explicit DescribeBlockchainSchemaDetailResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (responses) {
      vector<boost::any> temp1;
      for(auto item1:*responses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Responses"] = boost::any(temp1);
    }
    if (schema) {
      res["Schema"] = schema ? boost::any(schema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Responses") != m.end() && !m["Responses"].empty()) {
      if (typeid(vector<boost::any>) == m["Responses"].type()) {
        vector<DescribeBlockchainSchemaDetailResponseBodyResultResponses> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Responses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBlockchainSchemaDetailResponseBodyResultResponses model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        responses = make_shared<vector<DescribeBlockchainSchemaDetailResponseBodyResultResponses>>(expect1);
      }
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      if (typeid(map<string, boost::any>) == m["Schema"].type()) {
        DescribeBlockchainSchemaDetailResponseBodyResultSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Schema"]));
        schema = make_shared<DescribeBlockchainSchemaDetailResponseBodyResultSchema>(model1);
      }
    }
  }


  virtual ~DescribeBlockchainSchemaDetailResponseBodyResult() = default;
};
class DescribeBlockchainSchemaDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeBlockchainSchemaDetailResponseBodyResult> result{};

  DescribeBlockchainSchemaDetailResponseBody() {}

  explicit DescribeBlockchainSchemaDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeBlockchainSchemaDetailResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeBlockchainSchemaDetailResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeBlockchainSchemaDetailResponseBody() = default;
};
class DescribeBlockchainSchemaDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBlockchainSchemaDetailResponseBody> body{};

  DescribeBlockchainSchemaDetailResponse() {}

  explicit DescribeBlockchainSchemaDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBlockchainSchemaDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBlockchainSchemaDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBlockchainSchemaDetailResponse() = default;
};
class DescribeBlockchainSchemaFileOSSPropertiesRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};

  DescribeBlockchainSchemaFileOSSPropertiesRequest() {}

  explicit DescribeBlockchainSchemaFileOSSPropertiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~DescribeBlockchainSchemaFileOSSPropertiesRequest() = default;
};
class DescribeBlockchainSchemaFileOSSPropertiesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> accessKeyId{};
  shared_ptr<string> accessKeySecret{};
  shared_ptr<string> bucketName{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> folderName{};

  DescribeBlockchainSchemaFileOSSPropertiesResponseBodyResult() {}

  explicit DescribeBlockchainSchemaFileOSSPropertiesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKeyId) {
      res["AccessKeyId"] = boost::any(*accessKeyId);
    }
    if (accessKeySecret) {
      res["AccessKeySecret"] = boost::any(*accessKeySecret);
    }
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (folderName) {
      res["FolderName"] = boost::any(*folderName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKeyId") != m.end() && !m["AccessKeyId"].empty()) {
      accessKeyId = make_shared<string>(boost::any_cast<string>(m["AccessKeyId"]));
    }
    if (m.find("AccessKeySecret") != m.end() && !m["AccessKeySecret"].empty()) {
      accessKeySecret = make_shared<string>(boost::any_cast<string>(m["AccessKeySecret"]));
    }
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("FolderName") != m.end() && !m["FolderName"].empty()) {
      folderName = make_shared<string>(boost::any_cast<string>(m["FolderName"]));
    }
  }


  virtual ~DescribeBlockchainSchemaFileOSSPropertiesResponseBodyResult() = default;
};
class DescribeBlockchainSchemaFileOSSPropertiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeBlockchainSchemaFileOSSPropertiesResponseBodyResult> result{};

  DescribeBlockchainSchemaFileOSSPropertiesResponseBody() {}

  explicit DescribeBlockchainSchemaFileOSSPropertiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeBlockchainSchemaFileOSSPropertiesResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeBlockchainSchemaFileOSSPropertiesResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeBlockchainSchemaFileOSSPropertiesResponseBody() = default;
};
class DescribeBlockchainSchemaFileOSSPropertiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBlockchainSchemaFileOSSPropertiesResponseBody> body{};

  DescribeBlockchainSchemaFileOSSPropertiesResponse() {}

  explicit DescribeBlockchainSchemaFileOSSPropertiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBlockchainSchemaFileOSSPropertiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBlockchainSchemaFileOSSPropertiesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBlockchainSchemaFileOSSPropertiesResponse() = default;
};
class DescribeBlockchainSchemaTemplatesResponseBodyResultSchemaList : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<long> isTemplate{};
  shared_ptr<string> name{};
  shared_ptr<long> updateTime{};
  shared_ptr<long> version{};

  DescribeBlockchainSchemaTemplatesResponseBodyResultSchemaList() {}

  explicit DescribeBlockchainSchemaTemplatesResponseBodyResultSchemaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<long>(boost::any_cast<long>(m["IsTemplate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~DescribeBlockchainSchemaTemplatesResponseBodyResultSchemaList() = default;
};
class DescribeBlockchainSchemaTemplatesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBlockchainSchemaTemplatesResponseBodyResultSchemaList>> schemaList{};

  DescribeBlockchainSchemaTemplatesResponseBodyResult() {}

  explicit DescribeBlockchainSchemaTemplatesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (schemaList) {
      vector<boost::any> temp1;
      for(auto item1:*schemaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SchemaList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SchemaList") != m.end() && !m["SchemaList"].empty()) {
      if (typeid(vector<boost::any>) == m["SchemaList"].type()) {
        vector<DescribeBlockchainSchemaTemplatesResponseBodyResultSchemaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SchemaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBlockchainSchemaTemplatesResponseBodyResultSchemaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        schemaList = make_shared<vector<DescribeBlockchainSchemaTemplatesResponseBodyResultSchemaList>>(expect1);
      }
    }
  }


  virtual ~DescribeBlockchainSchemaTemplatesResponseBodyResult() = default;
};
class DescribeBlockchainSchemaTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeBlockchainSchemaTemplatesResponseBodyResult> result{};

  DescribeBlockchainSchemaTemplatesResponseBody() {}

  explicit DescribeBlockchainSchemaTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeBlockchainSchemaTemplatesResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeBlockchainSchemaTemplatesResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeBlockchainSchemaTemplatesResponseBody() = default;
};
class DescribeBlockchainSchemaTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeBlockchainSchemaTemplatesResponseBody> body{};

  DescribeBlockchainSchemaTemplatesResponse() {}

  explicit DescribeBlockchainSchemaTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBlockchainSchemaTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBlockchainSchemaTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBlockchainSchemaTemplatesResponse() = default;
};
class DescribeCSIGatewayEndpointRequest : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};

  DescribeCSIGatewayEndpointRequest() {}

  explicit DescribeCSIGatewayEndpointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeCSIGatewayEndpointRequest() = default;
};
class DescribeCSIGatewayEndpointResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  DescribeCSIGatewayEndpointResponseBody() {}

  explicit DescribeCSIGatewayEndpointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeCSIGatewayEndpointResponseBody() = default;
};
class DescribeCSIGatewayEndpointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCSIGatewayEndpointResponseBody> body{};

  DescribeCSIGatewayEndpointResponse() {}

  explicit DescribeCSIGatewayEndpointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCSIGatewayEndpointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCSIGatewayEndpointResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCSIGatewayEndpointResponse() = default;
};
class DescribeCandidateOrganizationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> location{};

  DescribeCandidateOrganizationsRequest() {}

  explicit DescribeCandidateOrganizationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
  }


  virtual ~DescribeCandidateOrganizationsRequest() = default;
};
class DescribeCandidateOrganizationsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> clusterState{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> organizationName{};
  shared_ptr<string> serviceState{};

  DescribeCandidateOrganizationsResponseBodyResult() {}

  explicit DescribeCandidateOrganizationsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterState) {
      res["ClusterState"] = boost::any(*clusterState);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (organizationName) {
      res["OrganizationName"] = boost::any(*organizationName);
    }
    if (serviceState) {
      res["ServiceState"] = boost::any(*serviceState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterState") != m.end() && !m["ClusterState"].empty()) {
      clusterState = make_shared<string>(boost::any_cast<string>(m["ClusterState"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("OrganizationName") != m.end() && !m["OrganizationName"].empty()) {
      organizationName = make_shared<string>(boost::any_cast<string>(m["OrganizationName"]));
    }
    if (m.find("ServiceState") != m.end() && !m["ServiceState"].empty()) {
      serviceState = make_shared<string>(boost::any_cast<string>(m["ServiceState"]));
    }
  }


  virtual ~DescribeCandidateOrganizationsResponseBodyResult() = default;
};
class DescribeCandidateOrganizationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeCandidateOrganizationsResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeCandidateOrganizationsResponseBody() {}

  explicit DescribeCandidateOrganizationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeCandidateOrganizationsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCandidateOrganizationsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeCandidateOrganizationsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeCandidateOrganizationsResponseBody() = default;
};
class DescribeCandidateOrganizationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCandidateOrganizationsResponseBody> body{};

  DescribeCandidateOrganizationsResponse() {}

  explicit DescribeCandidateOrganizationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCandidateOrganizationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCandidateOrganizationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCandidateOrganizationsResponse() = default;
};
class DescribeChaincodeCollectionConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> location{};

  DescribeChaincodeCollectionConfigRequest() {}

  explicit DescribeChaincodeCollectionConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
  }


  virtual ~DescribeChaincodeCollectionConfigRequest() = default;
};
class DescribeChaincodeCollectionConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  DescribeChaincodeCollectionConfigResponseBody() {}

  explicit DescribeChaincodeCollectionConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeChaincodeCollectionConfigResponseBody() = default;
};
class DescribeChaincodeCollectionConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeChaincodeCollectionConfigResponseBody> body{};

  DescribeChaincodeCollectionConfigResponse() {}

  explicit DescribeChaincodeCollectionConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeChaincodeCollectionConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeChaincodeCollectionConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeChaincodeCollectionConfigResponse() = default;
};
class DescribeChaincodeDefinitionTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> organizationId{};

  DescribeChaincodeDefinitionTaskRequest() {}

  explicit DescribeChaincodeDefinitionTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeChaincodeDefinitionTaskRequest() = default;
};
class DescribeChaincodeDefinitionTaskResponseBodyResultContentChaincodeDefinition : public Darabonba::Model {
public:
  shared_ptr<string> chaincodePackageId{};
  shared_ptr<string> collectionConfig{};
  shared_ptr<string> endorsementPolicy{};
  shared_ptr<bool> initRequired{};
  shared_ptr<string> name{};
  shared_ptr<long> sequence{};
  shared_ptr<string> version{};

  DescribeChaincodeDefinitionTaskResponseBodyResultContentChaincodeDefinition() {}

  explicit DescribeChaincodeDefinitionTaskResponseBodyResultContentChaincodeDefinition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodePackageId) {
      res["ChaincodePackageId"] = boost::any(*chaincodePackageId);
    }
    if (collectionConfig) {
      res["CollectionConfig"] = boost::any(*collectionConfig);
    }
    if (endorsementPolicy) {
      res["EndorsementPolicy"] = boost::any(*endorsementPolicy);
    }
    if (initRequired) {
      res["InitRequired"] = boost::any(*initRequired);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodePackageId") != m.end() && !m["ChaincodePackageId"].empty()) {
      chaincodePackageId = make_shared<string>(boost::any_cast<string>(m["ChaincodePackageId"]));
    }
    if (m.find("CollectionConfig") != m.end() && !m["CollectionConfig"].empty()) {
      collectionConfig = make_shared<string>(boost::any_cast<string>(m["CollectionConfig"]));
    }
    if (m.find("EndorsementPolicy") != m.end() && !m["EndorsementPolicy"].empty()) {
      endorsementPolicy = make_shared<string>(boost::any_cast<string>(m["EndorsementPolicy"]));
    }
    if (m.find("InitRequired") != m.end() && !m["InitRequired"].empty()) {
      initRequired = make_shared<bool>(boost::any_cast<bool>(m["InitRequired"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<long>(boost::any_cast<long>(m["Sequence"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeChaincodeDefinitionTaskResponseBodyResultContentChaincodeDefinition() = default;
};
class DescribeChaincodeDefinitionTaskResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<DescribeChaincodeDefinitionTaskResponseBodyResultContentChaincodeDefinition> chaincodeDefinition{};

  DescribeChaincodeDefinitionTaskResponseBodyResultContent() {}

  explicit DescribeChaincodeDefinitionTaskResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeDefinition) {
      res["ChaincodeDefinition"] = chaincodeDefinition ? boost::any(chaincodeDefinition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeDefinition") != m.end() && !m["ChaincodeDefinition"].empty()) {
      if (typeid(map<string, boost::any>) == m["ChaincodeDefinition"].type()) {
        DescribeChaincodeDefinitionTaskResponseBodyResultContentChaincodeDefinition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ChaincodeDefinition"]));
        chaincodeDefinition = make_shared<DescribeChaincodeDefinitionTaskResponseBodyResultContentChaincodeDefinition>(model1);
      }
    }
  }


  virtual ~DescribeChaincodeDefinitionTaskResponseBodyResultContent() = default;
};
class DescribeChaincodeDefinitionTaskResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<string>> approvers{};
  shared_ptr<string> channelName{};
  shared_ptr<DescribeChaincodeDefinitionTaskResponseBodyResultContent> content{};
  shared_ptr<long> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> type{};

  DescribeChaincodeDefinitionTaskResponseBodyResult() {}

  explicit DescribeChaincodeDefinitionTaskResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (approvers) {
      res["Approvers"] = boost::any(*approvers);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Approvers") != m.end() && !m["Approvers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Approvers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Approvers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      approvers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        DescribeChaincodeDefinitionTaskResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<DescribeChaincodeDefinitionTaskResponseBodyResultContent>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeChaincodeDefinitionTaskResponseBodyResult() = default;
};
class DescribeChaincodeDefinitionTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeChaincodeDefinitionTaskResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeChaincodeDefinitionTaskResponseBody() {}

  explicit DescribeChaincodeDefinitionTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeChaincodeDefinitionTaskResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeChaincodeDefinitionTaskResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeChaincodeDefinitionTaskResponseBody() = default;
};
class DescribeChaincodeDefinitionTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeChaincodeDefinitionTaskResponseBody> body{};

  DescribeChaincodeDefinitionTaskResponse() {}

  explicit DescribeChaincodeDefinitionTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeChaincodeDefinitionTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeChaincodeDefinitionTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeChaincodeDefinitionTaskResponse() = default;
};
class DescribeChaincodeUploadPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};

  DescribeChaincodeUploadPolicyRequest() {}

  explicit DescribeChaincodeUploadPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeChaincodeUploadPolicyRequest() = default;
};
class DescribeChaincodeUploadPolicyResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> accessId{};
  shared_ptr<string> dir{};
  shared_ptr<long> expire{};
  shared_ptr<string> host{};
  shared_ptr<string> policy{};
  shared_ptr<string> signature{};

  DescribeChaincodeUploadPolicyResponseBodyResult() {}

  explicit DescribeChaincodeUploadPolicyResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessId) {
      res["AccessId"] = boost::any(*accessId);
    }
    if (dir) {
      res["Dir"] = boost::any(*dir);
    }
    if (expire) {
      res["Expire"] = boost::any(*expire);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessId") != m.end() && !m["AccessId"].empty()) {
      accessId = make_shared<string>(boost::any_cast<string>(m["AccessId"]));
    }
    if (m.find("Dir") != m.end() && !m["Dir"].empty()) {
      dir = make_shared<string>(boost::any_cast<string>(m["Dir"]));
    }
    if (m.find("Expire") != m.end() && !m["Expire"].empty()) {
      expire = make_shared<long>(boost::any_cast<long>(m["Expire"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
  }


  virtual ~DescribeChaincodeUploadPolicyResponseBodyResult() = default;
};
class DescribeChaincodeUploadPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeChaincodeUploadPolicyResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeChaincodeUploadPolicyResponseBody() {}

  explicit DescribeChaincodeUploadPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeChaincodeUploadPolicyResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeChaincodeUploadPolicyResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeChaincodeUploadPolicyResponseBody() = default;
};
class DescribeChaincodeUploadPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeChaincodeUploadPolicyResponseBody> body{};

  DescribeChaincodeUploadPolicyResponse() {}

  explicit DescribeChaincodeUploadPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeChaincodeUploadPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeChaincodeUploadPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeChaincodeUploadPolicyResponse() = default;
};
class DescribeChannelChaincodesRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> organizationId{};

  DescribeChannelChaincodesRequest() {}

  explicit DescribeChannelChaincodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeChannelChaincodesRequest() = default;
};
class DescribeChannelChaincodesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> binding{};
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> deployTime{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<string> installed{};
  shared_ptr<bool> management{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> version{};

  DescribeChannelChaincodesResponseBodyResult() {}

  explicit DescribeChannelChaincodesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (binding) {
      res["Binding"] = boost::any(*binding);
    }
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (deployTime) {
      res["DeployTime"] = boost::any(*deployTime);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (installed) {
      res["Installed"] = boost::any(*installed);
    }
    if (management) {
      res["Management"] = boost::any(*management);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Binding") != m.end() && !m["Binding"].empty()) {
      binding = make_shared<bool>(boost::any_cast<bool>(m["Binding"]));
    }
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("DeployTime") != m.end() && !m["DeployTime"].empty()) {
      deployTime = make_shared<string>(boost::any_cast<string>(m["DeployTime"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("Installed") != m.end() && !m["Installed"].empty()) {
      installed = make_shared<string>(boost::any_cast<string>(m["Installed"]));
    }
    if (m.find("Management") != m.end() && !m["Management"].empty()) {
      management = make_shared<bool>(boost::any_cast<bool>(m["Management"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeChannelChaincodesResponseBodyResult() = default;
};
class DescribeChannelChaincodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeChannelChaincodesResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeChannelChaincodesResponseBody() {}

  explicit DescribeChannelChaincodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeChannelChaincodesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeChannelChaincodesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeChannelChaincodesResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeChannelChaincodesResponseBody() = default;
};
class DescribeChannelChaincodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeChannelChaincodesResponseBody> body{};

  DescribeChannelChaincodesResponse() {}

  explicit DescribeChannelChaincodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeChannelChaincodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeChannelChaincodesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeChannelChaincodesResponse() = default;
};
class DescribeChannelMembersRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> organizationId{};

  DescribeChannelMembersRequest() {}

  explicit DescribeChannelMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeChannelMembersRequest() = default;
};
class DescribeChannelMembersResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> acceptTime{};
  shared_ptr<string> channelId{};
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<string> inviteTime{};
  shared_ptr<string> name{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> state{};
  shared_ptr<bool> withPeer{};

  DescribeChannelMembersResponseBodyResult() {}

  explicit DescribeChannelMembersResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptTime) {
      res["AcceptTime"] = boost::any(*acceptTime);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (inviteTime) {
      res["InviteTime"] = boost::any(*inviteTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (withPeer) {
      res["WithPeer"] = boost::any(*withPeer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptTime") != m.end() && !m["AcceptTime"].empty()) {
      acceptTime = make_shared<string>(boost::any_cast<string>(m["AcceptTime"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("InviteTime") != m.end() && !m["InviteTime"].empty()) {
      inviteTime = make_shared<string>(boost::any_cast<string>(m["InviteTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("WithPeer") != m.end() && !m["WithPeer"].empty()) {
      withPeer = make_shared<bool>(boost::any_cast<bool>(m["WithPeer"]));
    }
  }


  virtual ~DescribeChannelMembersResponseBodyResult() = default;
};
class DescribeChannelMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeChannelMembersResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeChannelMembersResponseBody() {}

  explicit DescribeChannelMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeChannelMembersResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeChannelMembersResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeChannelMembersResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeChannelMembersResponseBody() = default;
};
class DescribeChannelMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeChannelMembersResponseBody> body{};

  DescribeChannelMembersResponse() {}

  explicit DescribeChannelMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeChannelMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeChannelMembersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeChannelMembersResponse() = default;
};
class DescribeChannelTriggersRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> organizationId{};

  DescribeChannelTriggersRequest() {}

  explicit DescribeChannelTriggersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeChannelTriggersRequest() = default;
};
class DescribeChannelTriggersResponseBodyResultCheckpoint : public Darabonba::Model {
public:
  shared_ptr<long> errorCount{};
  shared_ptr<long> height{};
  shared_ptr<long> index{};
  shared_ptr<string> type{};

  DescribeChannelTriggersResponseBodyResultCheckpoint() {}

  explicit DescribeChannelTriggersResponseBodyResultCheckpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCount) {
      res["ErrorCount"] = boost::any(*errorCount);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCount") != m.end() && !m["ErrorCount"].empty()) {
      errorCount = make_shared<long>(boost::any_cast<long>(m["ErrorCount"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeChannelTriggersResponseBodyResultCheckpoint() = default;
};
class DescribeChannelTriggersResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> channelName{};
  shared_ptr<DescribeChannelTriggersResponseBodyResultCheckpoint> checkpoint{};
  shared_ptr<long> createTime{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> name{};
  shared_ptr<string> options{};
  shared_ptr<string> source{};
  shared_ptr<long> status{};
  shared_ptr<string> type{};

  DescribeChannelTriggersResponseBodyResult() {}

  explicit DescribeChannelTriggersResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (checkpoint) {
      res["Checkpoint"] = checkpoint ? boost::any(checkpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (options) {
      res["Options"] = boost::any(*options);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("Checkpoint") != m.end() && !m["Checkpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["Checkpoint"].type()) {
        DescribeChannelTriggersResponseBodyResultCheckpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Checkpoint"]));
        checkpoint = make_shared<DescribeChannelTriggersResponseBodyResultCheckpoint>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Options") != m.end() && !m["Options"].empty()) {
      options = make_shared<string>(boost::any_cast<string>(m["Options"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeChannelTriggersResponseBodyResult() = default;
};
class DescribeChannelTriggersResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeChannelTriggersResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeChannelTriggersResponseBody() {}

  explicit DescribeChannelTriggersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeChannelTriggersResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeChannelTriggersResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeChannelTriggersResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeChannelTriggersResponseBody() = default;
};
class DescribeChannelTriggersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeChannelTriggersResponseBody> body{};

  DescribeChannelTriggersResponse() {}

  explicit DescribeChannelTriggersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeChannelTriggersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeChannelTriggersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeChannelTriggersResponse() = default;
};
class DescribeCloudIntegrationServiceTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};
  shared_ptr<string> service{};

  DescribeCloudIntegrationServiceTokenRequest() {}

  explicit DescribeCloudIntegrationServiceTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (service) {
      res["Service"] = boost::any(*service);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("Service") != m.end() && !m["Service"].empty()) {
      service = make_shared<string>(boost::any_cast<string>(m["Service"]));
    }
  }


  virtual ~DescribeCloudIntegrationServiceTokenRequest() = default;
};
class DescribeCloudIntegrationServiceTokenResponseBodyResultHistory : public Darabonba::Model {
public:
  shared_ptr<string> service{};
  shared_ptr<string> token{};
  shared_ptr<string> type{};

  DescribeCloudIntegrationServiceTokenResponseBodyResultHistory() {}

  explicit DescribeCloudIntegrationServiceTokenResponseBodyResultHistory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (service) {
      res["Service"] = boost::any(*service);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Service") != m.end() && !m["Service"].empty()) {
      service = make_shared<string>(boost::any_cast<string>(m["Service"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeCloudIntegrationServiceTokenResponseBodyResultHistory() = default;
};
class DescribeCloudIntegrationServiceTokenResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCloudIntegrationServiceTokenResponseBodyResultHistory>> history{};
  shared_ptr<string> service{};
  shared_ptr<string> token{};
  shared_ptr<string> type{};

  DescribeCloudIntegrationServiceTokenResponseBodyResult() {}

  explicit DescribeCloudIntegrationServiceTokenResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (history) {
      vector<boost::any> temp1;
      for(auto item1:*history){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["History"] = boost::any(temp1);
    }
    if (service) {
      res["Service"] = boost::any(*service);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("History") != m.end() && !m["History"].empty()) {
      if (typeid(vector<boost::any>) == m["History"].type()) {
        vector<DescribeCloudIntegrationServiceTokenResponseBodyResultHistory> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["History"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudIntegrationServiceTokenResponseBodyResultHistory model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        history = make_shared<vector<DescribeCloudIntegrationServiceTokenResponseBodyResultHistory>>(expect1);
      }
    }
    if (m.find("Service") != m.end() && !m["Service"].empty()) {
      service = make_shared<string>(boost::any_cast<string>(m["Service"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeCloudIntegrationServiceTokenResponseBodyResult() = default;
};
class DescribeCloudIntegrationServiceTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeCloudIntegrationServiceTokenResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeCloudIntegrationServiceTokenResponseBody() {}

  explicit DescribeCloudIntegrationServiceTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeCloudIntegrationServiceTokenResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeCloudIntegrationServiceTokenResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeCloudIntegrationServiceTokenResponseBody() = default;
};
class DescribeCloudIntegrationServiceTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCloudIntegrationServiceTokenResponseBody> body{};

  DescribeCloudIntegrationServiceTokenResponse() {}

  explicit DescribeCloudIntegrationServiceTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudIntegrationServiceTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudIntegrationServiceTokenResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudIntegrationServiceTokenResponse() = default;
};
class DescribeCloudServiceOrganizationStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};

  DescribeCloudServiceOrganizationStatusRequest() {}

  explicit DescribeCloudServiceOrganizationStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeCloudServiceOrganizationStatusRequest() = default;
};
class DescribeCloudServiceOrganizationStatusResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> grantPrivilegeUrl{};
  shared_ptr<string> organizationId{};
  shared_ptr<bool> serviceOpenStatus{};
  shared_ptr<string> serviceOpenUrl{};
  shared_ptr<bool> servicePrivilegeStatus{};
  shared_ptr<string> serviceType{};

  DescribeCloudServiceOrganizationStatusResponseBodyResult() {}

  explicit DescribeCloudServiceOrganizationStatusResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (grantPrivilegeUrl) {
      res["GrantPrivilegeUrl"] = boost::any(*grantPrivilegeUrl);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (serviceOpenStatus) {
      res["ServiceOpenStatus"] = boost::any(*serviceOpenStatus);
    }
    if (serviceOpenUrl) {
      res["ServiceOpenUrl"] = boost::any(*serviceOpenUrl);
    }
    if (servicePrivilegeStatus) {
      res["ServicePrivilegeStatus"] = boost::any(*servicePrivilegeStatus);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GrantPrivilegeUrl") != m.end() && !m["GrantPrivilegeUrl"].empty()) {
      grantPrivilegeUrl = make_shared<string>(boost::any_cast<string>(m["GrantPrivilegeUrl"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("ServiceOpenStatus") != m.end() && !m["ServiceOpenStatus"].empty()) {
      serviceOpenStatus = make_shared<bool>(boost::any_cast<bool>(m["ServiceOpenStatus"]));
    }
    if (m.find("ServiceOpenUrl") != m.end() && !m["ServiceOpenUrl"].empty()) {
      serviceOpenUrl = make_shared<string>(boost::any_cast<string>(m["ServiceOpenUrl"]));
    }
    if (m.find("ServicePrivilegeStatus") != m.end() && !m["ServicePrivilegeStatus"].empty()) {
      servicePrivilegeStatus = make_shared<bool>(boost::any_cast<bool>(m["ServicePrivilegeStatus"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
  }


  virtual ~DescribeCloudServiceOrganizationStatusResponseBodyResult() = default;
};
class DescribeCloudServiceOrganizationStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeCloudServiceOrganizationStatusResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeCloudServiceOrganizationStatusResponseBody() {}

  explicit DescribeCloudServiceOrganizationStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeCloudServiceOrganizationStatusResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudServiceOrganizationStatusResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeCloudServiceOrganizationStatusResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeCloudServiceOrganizationStatusResponseBody() = default;
};
class DescribeCloudServiceOrganizationStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCloudServiceOrganizationStatusResponseBody> body{};

  DescribeCloudServiceOrganizationStatusResponse() {}

  explicit DescribeCloudServiceOrganizationStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudServiceOrganizationStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudServiceOrganizationStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudServiceOrganizationStatusResponse() = default;
};
class DescribeCloudServiceTypeStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};
  shared_ptr<string> serviceType{};

  DescribeCloudServiceTypeStatusRequest() {}

  explicit DescribeCloudServiceTypeStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
  }


  virtual ~DescribeCloudServiceTypeStatusRequest() = default;
};
class DescribeCloudServiceTypeStatusResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> grantPrivilegeUrl{};
  shared_ptr<string> organizationId{};
  shared_ptr<bool> serviceOpenStatus{};
  shared_ptr<string> serviceOpenUrl{};
  shared_ptr<bool> servicePrivilegeStatus{};
  shared_ptr<string> serviceType{};

  DescribeCloudServiceTypeStatusResponseBodyResult() {}

  explicit DescribeCloudServiceTypeStatusResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (grantPrivilegeUrl) {
      res["GrantPrivilegeUrl"] = boost::any(*grantPrivilegeUrl);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (serviceOpenStatus) {
      res["ServiceOpenStatus"] = boost::any(*serviceOpenStatus);
    }
    if (serviceOpenUrl) {
      res["ServiceOpenUrl"] = boost::any(*serviceOpenUrl);
    }
    if (servicePrivilegeStatus) {
      res["ServicePrivilegeStatus"] = boost::any(*servicePrivilegeStatus);
    }
    if (serviceType) {
      res["ServiceType"] = boost::any(*serviceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GrantPrivilegeUrl") != m.end() && !m["GrantPrivilegeUrl"].empty()) {
      grantPrivilegeUrl = make_shared<string>(boost::any_cast<string>(m["GrantPrivilegeUrl"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("ServiceOpenStatus") != m.end() && !m["ServiceOpenStatus"].empty()) {
      serviceOpenStatus = make_shared<bool>(boost::any_cast<bool>(m["ServiceOpenStatus"]));
    }
    if (m.find("ServiceOpenUrl") != m.end() && !m["ServiceOpenUrl"].empty()) {
      serviceOpenUrl = make_shared<string>(boost::any_cast<string>(m["ServiceOpenUrl"]));
    }
    if (m.find("ServicePrivilegeStatus") != m.end() && !m["ServicePrivilegeStatus"].empty()) {
      servicePrivilegeStatus = make_shared<bool>(boost::any_cast<bool>(m["ServicePrivilegeStatus"]));
    }
    if (m.find("ServiceType") != m.end() && !m["ServiceType"].empty()) {
      serviceType = make_shared<string>(boost::any_cast<string>(m["ServiceType"]));
    }
  }


  virtual ~DescribeCloudServiceTypeStatusResponseBodyResult() = default;
};
class DescribeCloudServiceTypeStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeCloudServiceTypeStatusResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeCloudServiceTypeStatusResponseBody() {}

  explicit DescribeCloudServiceTypeStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeCloudServiceTypeStatusResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeCloudServiceTypeStatusResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeCloudServiceTypeStatusResponseBody() = default;
};
class DescribeCloudServiceTypeStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCloudServiceTypeStatusResponseBody> body{};

  DescribeCloudServiceTypeStatusResponse() {}

  explicit DescribeCloudServiceTypeStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudServiceTypeStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudServiceTypeStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudServiceTypeStatusResponse() = default;
};
class DescribeConsortiumAdminStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> location{};

  DescribeConsortiumAdminStatusRequest() {}

  explicit DescribeConsortiumAdminStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
  }


  virtual ~DescribeConsortiumAdminStatusRequest() = default;
};
class DescribeConsortiumAdminStatusResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> consortiumAdministrator{};
  shared_ptr<string> consortiumId{};

  DescribeConsortiumAdminStatusResponseBodyResult() {}

  explicit DescribeConsortiumAdminStatusResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumAdministrator) {
      res["ConsortiumAdministrator"] = boost::any(*consortiumAdministrator);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumAdministrator") != m.end() && !m["ConsortiumAdministrator"].empty()) {
      consortiumAdministrator = make_shared<bool>(boost::any_cast<bool>(m["ConsortiumAdministrator"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
  }


  virtual ~DescribeConsortiumAdminStatusResponseBodyResult() = default;
};
class DescribeConsortiumAdminStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeConsortiumAdminStatusResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeConsortiumAdminStatusResponseBody() {}

  explicit DescribeConsortiumAdminStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeConsortiumAdminStatusResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeConsortiumAdminStatusResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeConsortiumAdminStatusResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeConsortiumAdminStatusResponseBody() = default;
};
class DescribeConsortiumAdminStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeConsortiumAdminStatusResponseBody> body{};

  DescribeConsortiumAdminStatusResponse() {}

  explicit DescribeConsortiumAdminStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeConsortiumAdminStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeConsortiumAdminStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeConsortiumAdminStatusResponse() = default;
};
class DescribeConsortiumChaincodesRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> location{};

  DescribeConsortiumChaincodesRequest() {}

  explicit DescribeConsortiumChaincodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
  }


  virtual ~DescribeConsortiumChaincodesRequest() = default;
};
class DescribeConsortiumChaincodesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deployTime{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<string> input{};
  shared_ptr<bool> install{};
  shared_ptr<bool> management{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<string> providerId{};
  shared_ptr<string> providerName{};
  shared_ptr<string> state{};
  shared_ptr<long> type{};
  shared_ptr<string> version{};

  DescribeConsortiumChaincodesResponseBodyResult() {}

  explicit DescribeConsortiumChaincodesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deployTime) {
      res["DeployTime"] = boost::any(*deployTime);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (install) {
      res["Install"] = boost::any(*install);
    }
    if (management) {
      res["Management"] = boost::any(*management);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (providerId) {
      res["ProviderId"] = boost::any(*providerId);
    }
    if (providerName) {
      res["ProviderName"] = boost::any(*providerName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeployTime") != m.end() && !m["DeployTime"].empty()) {
      deployTime = make_shared<string>(boost::any_cast<string>(m["DeployTime"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Install") != m.end() && !m["Install"].empty()) {
      install = make_shared<bool>(boost::any_cast<bool>(m["Install"]));
    }
    if (m.find("Management") != m.end() && !m["Management"].empty()) {
      management = make_shared<bool>(boost::any_cast<bool>(m["Management"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ProviderId") != m.end() && !m["ProviderId"].empty()) {
      providerId = make_shared<string>(boost::any_cast<string>(m["ProviderId"]));
    }
    if (m.find("ProviderName") != m.end() && !m["ProviderName"].empty()) {
      providerName = make_shared<string>(boost::any_cast<string>(m["ProviderName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeConsortiumChaincodesResponseBodyResult() = default;
};
class DescribeConsortiumChaincodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeConsortiumChaincodesResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeConsortiumChaincodesResponseBody() {}

  explicit DescribeConsortiumChaincodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeConsortiumChaincodesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeConsortiumChaincodesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeConsortiumChaincodesResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeConsortiumChaincodesResponseBody() = default;
};
class DescribeConsortiumChaincodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeConsortiumChaincodesResponseBody> body{};

  DescribeConsortiumChaincodesResponse() {}

  explicit DescribeConsortiumChaincodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeConsortiumChaincodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeConsortiumChaincodesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeConsortiumChaincodesResponse() = default;
};
class DescribeConsortiumChannelsRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> location{};

  DescribeConsortiumChannelsRequest() {}

  explicit DescribeConsortiumChannelsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
  }


  virtual ~DescribeConsortiumChannelsRequest() = default;
};
class DescribeConsortiumChannelsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> batchTimeout{};
  shared_ptr<long> blockCount{};
  shared_ptr<long> chaincodeCount{};
  shared_ptr<string> channelId{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> consortiumName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deleteTime{};
  shared_ptr<bool> deleted{};
  shared_ptr<bool> hybird{};
  shared_ptr<long> id{};
  shared_ptr<long> maxMessageCount{};
  shared_ptr<long> memberCount{};
  shared_ptr<string> memberJoinedCount{};
  shared_ptr<string> name{};
  shared_ptr<bool> needJoined{};
  shared_ptr<string> ownerBid{};
  shared_ptr<string> ownerName{};
  shared_ptr<long> ownerUid{};
  shared_ptr<long> preferredMaxBytes{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};
  shared_ptr<bool> supportChannelConfig{};
  shared_ptr<string> updateTime{};

  DescribeConsortiumChannelsResponseBodyResult() {}

  explicit DescribeConsortiumChannelsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchTimeout) {
      res["BatchTimeout"] = boost::any(*batchTimeout);
    }
    if (blockCount) {
      res["BlockCount"] = boost::any(*blockCount);
    }
    if (chaincodeCount) {
      res["ChaincodeCount"] = boost::any(*chaincodeCount);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (consortiumName) {
      res["ConsortiumName"] = boost::any(*consortiumName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deleteTime) {
      res["DeleteTime"] = boost::any(*deleteTime);
    }
    if (deleted) {
      res["Deleted"] = boost::any(*deleted);
    }
    if (hybird) {
      res["Hybird"] = boost::any(*hybird);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (maxMessageCount) {
      res["MaxMessageCount"] = boost::any(*maxMessageCount);
    }
    if (memberCount) {
      res["MemberCount"] = boost::any(*memberCount);
    }
    if (memberJoinedCount) {
      res["MemberJoinedCount"] = boost::any(*memberJoinedCount);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (needJoined) {
      res["NeedJoined"] = boost::any(*needJoined);
    }
    if (ownerBid) {
      res["OwnerBid"] = boost::any(*ownerBid);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUid) {
      res["OwnerUid"] = boost::any(*ownerUid);
    }
    if (preferredMaxBytes) {
      res["PreferredMaxBytes"] = boost::any(*preferredMaxBytes);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (supportChannelConfig) {
      res["SupportChannelConfig"] = boost::any(*supportChannelConfig);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchTimeout") != m.end() && !m["BatchTimeout"].empty()) {
      batchTimeout = make_shared<long>(boost::any_cast<long>(m["BatchTimeout"]));
    }
    if (m.find("BlockCount") != m.end() && !m["BlockCount"].empty()) {
      blockCount = make_shared<long>(boost::any_cast<long>(m["BlockCount"]));
    }
    if (m.find("ChaincodeCount") != m.end() && !m["ChaincodeCount"].empty()) {
      chaincodeCount = make_shared<long>(boost::any_cast<long>(m["ChaincodeCount"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("ConsortiumName") != m.end() && !m["ConsortiumName"].empty()) {
      consortiumName = make_shared<string>(boost::any_cast<string>(m["ConsortiumName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeleteTime") != m.end() && !m["DeleteTime"].empty()) {
      deleteTime = make_shared<string>(boost::any_cast<string>(m["DeleteTime"]));
    }
    if (m.find("Deleted") != m.end() && !m["Deleted"].empty()) {
      deleted = make_shared<bool>(boost::any_cast<bool>(m["Deleted"]));
    }
    if (m.find("Hybird") != m.end() && !m["Hybird"].empty()) {
      hybird = make_shared<bool>(boost::any_cast<bool>(m["Hybird"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("MaxMessageCount") != m.end() && !m["MaxMessageCount"].empty()) {
      maxMessageCount = make_shared<long>(boost::any_cast<long>(m["MaxMessageCount"]));
    }
    if (m.find("MemberCount") != m.end() && !m["MemberCount"].empty()) {
      memberCount = make_shared<long>(boost::any_cast<long>(m["MemberCount"]));
    }
    if (m.find("MemberJoinedCount") != m.end() && !m["MemberJoinedCount"].empty()) {
      memberJoinedCount = make_shared<string>(boost::any_cast<string>(m["MemberJoinedCount"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NeedJoined") != m.end() && !m["NeedJoined"].empty()) {
      needJoined = make_shared<bool>(boost::any_cast<bool>(m["NeedJoined"]));
    }
    if (m.find("OwnerBid") != m.end() && !m["OwnerBid"].empty()) {
      ownerBid = make_shared<string>(boost::any_cast<string>(m["OwnerBid"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUid") != m.end() && !m["OwnerUid"].empty()) {
      ownerUid = make_shared<long>(boost::any_cast<long>(m["OwnerUid"]));
    }
    if (m.find("PreferredMaxBytes") != m.end() && !m["PreferredMaxBytes"].empty()) {
      preferredMaxBytes = make_shared<long>(boost::any_cast<long>(m["PreferredMaxBytes"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("SupportChannelConfig") != m.end() && !m["SupportChannelConfig"].empty()) {
      supportChannelConfig = make_shared<bool>(boost::any_cast<bool>(m["SupportChannelConfig"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeConsortiumChannelsResponseBodyResult() = default;
};
class DescribeConsortiumChannelsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeConsortiumChannelsResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeConsortiumChannelsResponseBody() {}

  explicit DescribeConsortiumChannelsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeConsortiumChannelsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeConsortiumChannelsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeConsortiumChannelsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeConsortiumChannelsResponseBody() = default;
};
class DescribeConsortiumChannelsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeConsortiumChannelsResponseBody> body{};

  DescribeConsortiumChannelsResponse() {}

  explicit DescribeConsortiumChannelsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeConsortiumChannelsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeConsortiumChannelsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeConsortiumChannelsResponse() = default;
};
class DescribeConsortiumConfigResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channelPolicy{};
  shared_ptr<vector<string>> ordererType{};

  DescribeConsortiumConfigResponseBodyResult() {}

  explicit DescribeConsortiumConfigResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelPolicy) {
      res["ChannelPolicy"] = boost::any(*channelPolicy);
    }
    if (ordererType) {
      res["OrdererType"] = boost::any(*ordererType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelPolicy") != m.end() && !m["ChannelPolicy"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ChannelPolicy"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ChannelPolicy"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channelPolicy = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OrdererType") != m.end() && !m["OrdererType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrdererType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrdererType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ordererType = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeConsortiumConfigResponseBodyResult() = default;
};
class DescribeConsortiumConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeConsortiumConfigResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeConsortiumConfigResponseBody() {}

  explicit DescribeConsortiumConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeConsortiumConfigResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeConsortiumConfigResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeConsortiumConfigResponseBody() = default;
};
class DescribeConsortiumConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeConsortiumConfigResponseBody> body{};

  DescribeConsortiumConfigResponse() {}

  explicit DescribeConsortiumConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeConsortiumConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeConsortiumConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeConsortiumConfigResponse() = default;
};
class DescribeConsortiumDeletableRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> location{};

  DescribeConsortiumDeletableRequest() {}

  explicit DescribeConsortiumDeletableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
  }


  virtual ~DescribeConsortiumDeletableRequest() = default;
};
class DescribeConsortiumDeletableResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> codeName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<bool> deletable{};
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> state{};
  shared_ptr<string> zoneId{};

  DescribeConsortiumDeletableResponseBodyResult() {}

  explicit DescribeConsortiumDeletableResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codeName) {
      res["CodeName"] = boost::any(*codeName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (deletable) {
      res["Deletable"] = boost::any(*deletable);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodeName") != m.end() && !m["CodeName"].empty()) {
      codeName = make_shared<string>(boost::any_cast<string>(m["CodeName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Deletable") != m.end() && !m["Deletable"].empty()) {
      deletable = make_shared<bool>(boost::any_cast<bool>(m["Deletable"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeConsortiumDeletableResponseBodyResult() = default;
};
class DescribeConsortiumDeletableResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeConsortiumDeletableResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeConsortiumDeletableResponseBody() {}

  explicit DescribeConsortiumDeletableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeConsortiumDeletableResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeConsortiumDeletableResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeConsortiumDeletableResponseBody() = default;
};
class DescribeConsortiumDeletableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeConsortiumDeletableResponseBody> body{};

  DescribeConsortiumDeletableResponse() {}

  explicit DescribeConsortiumDeletableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeConsortiumDeletableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeConsortiumDeletableResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeConsortiumDeletableResponse() = default;
};
class DescribeConsortiumMemberApprovalRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> location{};

  DescribeConsortiumMemberApprovalRequest() {}

  explicit DescribeConsortiumMemberApprovalRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
  }


  virtual ~DescribeConsortiumMemberApprovalRequest() = default;
};
class DescribeConsortiumMemberApprovalResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> channelCreatePolicy{};
  shared_ptr<string> confirmTime{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> consortiumName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> organizationName{};
  shared_ptr<string> state{};

  DescribeConsortiumMemberApprovalResponseBodyResult() {}

  explicit DescribeConsortiumMemberApprovalResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelCreatePolicy) {
      res["ChannelCreatePolicy"] = boost::any(*channelCreatePolicy);
    }
    if (confirmTime) {
      res["ConfirmTime"] = boost::any(*confirmTime);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (consortiumName) {
      res["ConsortiumName"] = boost::any(*consortiumName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (organizationName) {
      res["OrganizationName"] = boost::any(*organizationName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelCreatePolicy") != m.end() && !m["ChannelCreatePolicy"].empty()) {
      channelCreatePolicy = make_shared<string>(boost::any_cast<string>(m["ChannelCreatePolicy"]));
    }
    if (m.find("ConfirmTime") != m.end() && !m["ConfirmTime"].empty()) {
      confirmTime = make_shared<string>(boost::any_cast<string>(m["ConfirmTime"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("ConsortiumName") != m.end() && !m["ConsortiumName"].empty()) {
      consortiumName = make_shared<string>(boost::any_cast<string>(m["ConsortiumName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("OrganizationName") != m.end() && !m["OrganizationName"].empty()) {
      organizationName = make_shared<string>(boost::any_cast<string>(m["OrganizationName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~DescribeConsortiumMemberApprovalResponseBodyResult() = default;
};
class DescribeConsortiumMemberApprovalResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeConsortiumMemberApprovalResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeConsortiumMemberApprovalResponseBody() {}

  explicit DescribeConsortiumMemberApprovalResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeConsortiumMemberApprovalResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeConsortiumMemberApprovalResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeConsortiumMemberApprovalResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeConsortiumMemberApprovalResponseBody() = default;
};
class DescribeConsortiumMemberApprovalResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeConsortiumMemberApprovalResponseBody> body{};

  DescribeConsortiumMemberApprovalResponse() {}

  explicit DescribeConsortiumMemberApprovalResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeConsortiumMemberApprovalResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeConsortiumMemberApprovalResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeConsortiumMemberApprovalResponse() = default;
};
class DescribeConsortiumMembersRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> location{};

  DescribeConsortiumMembersRequest() {}

  explicit DescribeConsortiumMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
  }


  virtual ~DescribeConsortiumMembersRequest() = default;
};
class DescribeConsortiumMembersResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<string> joinedTime{};
  shared_ptr<string> name{};
  shared_ptr<string> organizationId{};

  DescribeConsortiumMembersResponseBodyResult() {}

  explicit DescribeConsortiumMembersResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (joinedTime) {
      res["JoinedTime"] = boost::any(*joinedTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("JoinedTime") != m.end() && !m["JoinedTime"].empty()) {
      joinedTime = make_shared<string>(boost::any_cast<string>(m["JoinedTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeConsortiumMembersResponseBodyResult() = default;
};
class DescribeConsortiumMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeConsortiumMembersResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeConsortiumMembersResponseBody() {}

  explicit DescribeConsortiumMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeConsortiumMembersResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeConsortiumMembersResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeConsortiumMembersResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeConsortiumMembersResponseBody() = default;
};
class DescribeConsortiumMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeConsortiumMembersResponseBody> body{};

  DescribeConsortiumMembersResponse() {}

  explicit DescribeConsortiumMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeConsortiumMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeConsortiumMembersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeConsortiumMembersResponse() = default;
};
class DescribeConsortiumOrderersRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> location{};

  DescribeConsortiumOrderersRequest() {}

  explicit DescribeConsortiumOrderersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
  }


  virtual ~DescribeConsortiumOrderersRequest() = default;
};
class DescribeConsortiumOrderersResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> domain{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> name{};
  shared_ptr<long> port{};
  shared_ptr<string> updateTime{};

  DescribeConsortiumOrderersResponseBodyResult() {}

  explicit DescribeConsortiumOrderersResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeConsortiumOrderersResponseBodyResult() = default;
};
class DescribeConsortiumOrderersResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeConsortiumOrderersResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeConsortiumOrderersResponseBody() {}

  explicit DescribeConsortiumOrderersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeConsortiumOrderersResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeConsortiumOrderersResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeConsortiumOrderersResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeConsortiumOrderersResponseBody() = default;
};
class DescribeConsortiumOrderersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeConsortiumOrderersResponseBody> body{};

  DescribeConsortiumOrderersResponse() {}

  explicit DescribeConsortiumOrderersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeConsortiumOrderersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeConsortiumOrderersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeConsortiumOrderersResponse() = default;
};
class DescribeConsortiumSpecsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};
  shared_ptr<string> name{};
  shared_ptr<string> title{};

  DescribeConsortiumSpecsResponseBodyResult() {}

  explicit DescribeConsortiumSpecsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~DescribeConsortiumSpecsResponseBodyResult() = default;
};
class DescribeConsortiumSpecsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeConsortiumSpecsResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeConsortiumSpecsResponseBody() {}

  explicit DescribeConsortiumSpecsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeConsortiumSpecsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeConsortiumSpecsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeConsortiumSpecsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeConsortiumSpecsResponseBody() = default;
};
class DescribeConsortiumSpecsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeConsortiumSpecsResponseBody> body{};

  DescribeConsortiumSpecsResponse() {}

  explicit DescribeConsortiumSpecsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeConsortiumSpecsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeConsortiumSpecsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeConsortiumSpecsResponse() = default;
};
class DescribeConsortiumsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeConsortiumsRequestTag() {}

  explicit DescribeConsortiumsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeConsortiumsRequestTag() = default;
};
class DescribeConsortiumsRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> location{};
  shared_ptr<vector<DescribeConsortiumsRequestTag>> tag{};

  DescribeConsortiumsRequest() {}

  explicit DescribeConsortiumsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeConsortiumsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeConsortiumsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeConsortiumsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeConsortiumsRequest() = default;
};
class DescribeConsortiumsResponseBodyResultTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeConsortiumsResponseBodyResultTags() {}

  explicit DescribeConsortiumsResponseBodyResultTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeConsortiumsResponseBodyResultTags() = default;
};
class DescribeConsortiumsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> CAName{};
  shared_ptr<string> CAUrl{};
  shared_ptr<long> channelCount{};
  shared_ptr<string> channelPolicy{};
  shared_ptr<string> codeName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> domain{};
  shared_ptr<string> expireState{};
  shared_ptr<string> expiredTime{};
  shared_ptr<bool> hybrid{};
  shared_ptr<string> MSP{};
  shared_ptr<string> majorVersion{};
  shared_ptr<string> name{};
  shared_ptr<long> ordererCount{};
  shared_ptr<long> organizationCount{};
  shared_ptr<string> ownerBid{};
  shared_ptr<string> ownerName{};
  shared_ptr<long> ownerUid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> specName{};
  shared_ptr<string> state{};
  shared_ptr<bool> supportChannelConfig{};
  shared_ptr<vector<DescribeConsortiumsResponseBodyResultTags>> tags{};

  DescribeConsortiumsResponseBodyResult() {}

  explicit DescribeConsortiumsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (CAName) {
      res["CAName"] = boost::any(*CAName);
    }
    if (CAUrl) {
      res["CAUrl"] = boost::any(*CAUrl);
    }
    if (channelCount) {
      res["ChannelCount"] = boost::any(*channelCount);
    }
    if (channelPolicy) {
      res["ChannelPolicy"] = boost::any(*channelPolicy);
    }
    if (codeName) {
      res["CodeName"] = boost::any(*codeName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (expireState) {
      res["ExpireState"] = boost::any(*expireState);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (hybrid) {
      res["Hybrid"] = boost::any(*hybrid);
    }
    if (MSP) {
      res["MSP"] = boost::any(*MSP);
    }
    if (majorVersion) {
      res["MajorVersion"] = boost::any(*majorVersion);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ordererCount) {
      res["OrdererCount"] = boost::any(*ordererCount);
    }
    if (organizationCount) {
      res["OrganizationCount"] = boost::any(*organizationCount);
    }
    if (ownerBid) {
      res["OwnerBid"] = boost::any(*ownerBid);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUid) {
      res["OwnerUid"] = boost::any(*ownerUid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (specName) {
      res["SpecName"] = boost::any(*specName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (supportChannelConfig) {
      res["SupportChannelConfig"] = boost::any(*supportChannelConfig);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CAName") != m.end() && !m["CAName"].empty()) {
      CAName = make_shared<string>(boost::any_cast<string>(m["CAName"]));
    }
    if (m.find("CAUrl") != m.end() && !m["CAUrl"].empty()) {
      CAUrl = make_shared<string>(boost::any_cast<string>(m["CAUrl"]));
    }
    if (m.find("ChannelCount") != m.end() && !m["ChannelCount"].empty()) {
      channelCount = make_shared<long>(boost::any_cast<long>(m["ChannelCount"]));
    }
    if (m.find("ChannelPolicy") != m.end() && !m["ChannelPolicy"].empty()) {
      channelPolicy = make_shared<string>(boost::any_cast<string>(m["ChannelPolicy"]));
    }
    if (m.find("CodeName") != m.end() && !m["CodeName"].empty()) {
      codeName = make_shared<string>(boost::any_cast<string>(m["CodeName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ExpireState") != m.end() && !m["ExpireState"].empty()) {
      expireState = make_shared<string>(boost::any_cast<string>(m["ExpireState"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("Hybrid") != m.end() && !m["Hybrid"].empty()) {
      hybrid = make_shared<bool>(boost::any_cast<bool>(m["Hybrid"]));
    }
    if (m.find("MSP") != m.end() && !m["MSP"].empty()) {
      MSP = make_shared<string>(boost::any_cast<string>(m["MSP"]));
    }
    if (m.find("MajorVersion") != m.end() && !m["MajorVersion"].empty()) {
      majorVersion = make_shared<string>(boost::any_cast<string>(m["MajorVersion"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrdererCount") != m.end() && !m["OrdererCount"].empty()) {
      ordererCount = make_shared<long>(boost::any_cast<long>(m["OrdererCount"]));
    }
    if (m.find("OrganizationCount") != m.end() && !m["OrganizationCount"].empty()) {
      organizationCount = make_shared<long>(boost::any_cast<long>(m["OrganizationCount"]));
    }
    if (m.find("OwnerBid") != m.end() && !m["OwnerBid"].empty()) {
      ownerBid = make_shared<string>(boost::any_cast<string>(m["OwnerBid"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUid") != m.end() && !m["OwnerUid"].empty()) {
      ownerUid = make_shared<long>(boost::any_cast<long>(m["OwnerUid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SpecName") != m.end() && !m["SpecName"].empty()) {
      specName = make_shared<string>(boost::any_cast<string>(m["SpecName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("SupportChannelConfig") != m.end() && !m["SupportChannelConfig"].empty()) {
      supportChannelConfig = make_shared<bool>(boost::any_cast<bool>(m["SupportChannelConfig"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeConsortiumsResponseBodyResultTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeConsortiumsResponseBodyResultTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeConsortiumsResponseBodyResultTags>>(expect1);
      }
    }
  }


  virtual ~DescribeConsortiumsResponseBodyResult() = default;
};
class DescribeConsortiumsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeConsortiumsResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeConsortiumsResponseBody() {}

  explicit DescribeConsortiumsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeConsortiumsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeConsortiumsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeConsortiumsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeConsortiumsResponseBody() = default;
};
class DescribeConsortiumsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeConsortiumsResponseBody> body{};

  DescribeConsortiumsResponse() {}

  explicit DescribeConsortiumsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeConsortiumsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeConsortiumsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeConsortiumsResponse() = default;
};
class DescribeDownloadPathsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};

  DescribeDownloadPathsRequest() {}

  explicit DescribeDownloadPathsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~DescribeDownloadPathsRequest() = default;
};
class DescribeDownloadPathsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> bizviewUrl{};
  shared_ptr<string> certUrl{};
  shared_ptr<string> sdkUrl{};

  DescribeDownloadPathsResponseBodyResult() {}

  explicit DescribeDownloadPathsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizviewUrl) {
      res["BizviewUrl"] = boost::any(*bizviewUrl);
    }
    if (certUrl) {
      res["CertUrl"] = boost::any(*certUrl);
    }
    if (sdkUrl) {
      res["SdkUrl"] = boost::any(*sdkUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizviewUrl") != m.end() && !m["BizviewUrl"].empty()) {
      bizviewUrl = make_shared<string>(boost::any_cast<string>(m["BizviewUrl"]));
    }
    if (m.find("CertUrl") != m.end() && !m["CertUrl"].empty()) {
      certUrl = make_shared<string>(boost::any_cast<string>(m["CertUrl"]));
    }
    if (m.find("SdkUrl") != m.end() && !m["SdkUrl"].empty()) {
      sdkUrl = make_shared<string>(boost::any_cast<string>(m["SdkUrl"]));
    }
  }


  virtual ~DescribeDownloadPathsResponseBodyResult() = default;
};
class DescribeDownloadPathsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDownloadPathsResponseBodyResult> result{};

  DescribeDownloadPathsResponseBody() {}

  explicit DescribeDownloadPathsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeDownloadPathsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeDownloadPathsResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeDownloadPathsResponseBody() = default;
};
class DescribeDownloadPathsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDownloadPathsResponseBody> body{};

  DescribeDownloadPathsResponse() {}

  explicit DescribeDownloadPathsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDownloadPathsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDownloadPathsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDownloadPathsResponse() = default;
};
class DescribeDownloadPathsOfContractChainRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};

  DescribeDownloadPathsOfContractChainRequest() {}

  explicit DescribeDownloadPathsOfContractChainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~DescribeDownloadPathsOfContractChainRequest() = default;
};
class DescribeDownloadPathsOfContractChainResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> caUrl{};
  shared_ptr<string> certUrl{};
  shared_ptr<string> trustCaUrl{};

  DescribeDownloadPathsOfContractChainResponseBodyResult() {}

  explicit DescribeDownloadPathsOfContractChainResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caUrl) {
      res["CaUrl"] = boost::any(*caUrl);
    }
    if (certUrl) {
      res["CertUrl"] = boost::any(*certUrl);
    }
    if (trustCaUrl) {
      res["TrustCaUrl"] = boost::any(*trustCaUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaUrl") != m.end() && !m["CaUrl"].empty()) {
      caUrl = make_shared<string>(boost::any_cast<string>(m["CaUrl"]));
    }
    if (m.find("CertUrl") != m.end() && !m["CertUrl"].empty()) {
      certUrl = make_shared<string>(boost::any_cast<string>(m["CertUrl"]));
    }
    if (m.find("TrustCaUrl") != m.end() && !m["TrustCaUrl"].empty()) {
      trustCaUrl = make_shared<string>(boost::any_cast<string>(m["TrustCaUrl"]));
    }
  }


  virtual ~DescribeDownloadPathsOfContractChainResponseBodyResult() = default;
};
class DescribeDownloadPathsOfContractChainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDownloadPathsOfContractChainResponseBodyResult> result{};

  DescribeDownloadPathsOfContractChainResponseBody() {}

  explicit DescribeDownloadPathsOfContractChainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeDownloadPathsOfContractChainResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeDownloadPathsOfContractChainResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeDownloadPathsOfContractChainResponseBody() = default;
};
class DescribeDownloadPathsOfContractChainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDownloadPathsOfContractChainResponseBody> body{};

  DescribeDownloadPathsOfContractChainResponse() {}

  explicit DescribeDownloadPathsOfContractChainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDownloadPathsOfContractChainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDownloadPathsOfContractChainResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDownloadPathsOfContractChainResponse() = default;
};
class DescribeDownloadPathsOfNotaryChainRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};

  DescribeDownloadPathsOfNotaryChainRequest() {}

  explicit DescribeDownloadPathsOfNotaryChainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~DescribeDownloadPathsOfNotaryChainRequest() = default;
};
class DescribeDownloadPathsOfNotaryChainResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> bizviewUrl{};
  shared_ptr<string> certUrl{};
  shared_ptr<string> sdkUrl{};

  DescribeDownloadPathsOfNotaryChainResponseBodyResult() {}

  explicit DescribeDownloadPathsOfNotaryChainResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizviewUrl) {
      res["BizviewUrl"] = boost::any(*bizviewUrl);
    }
    if (certUrl) {
      res["CertUrl"] = boost::any(*certUrl);
    }
    if (sdkUrl) {
      res["SdkUrl"] = boost::any(*sdkUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizviewUrl") != m.end() && !m["BizviewUrl"].empty()) {
      bizviewUrl = make_shared<string>(boost::any_cast<string>(m["BizviewUrl"]));
    }
    if (m.find("CertUrl") != m.end() && !m["CertUrl"].empty()) {
      certUrl = make_shared<string>(boost::any_cast<string>(m["CertUrl"]));
    }
    if (m.find("SdkUrl") != m.end() && !m["SdkUrl"].empty()) {
      sdkUrl = make_shared<string>(boost::any_cast<string>(m["SdkUrl"]));
    }
  }


  virtual ~DescribeDownloadPathsOfNotaryChainResponseBodyResult() = default;
};
class DescribeDownloadPathsOfNotaryChainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDownloadPathsOfNotaryChainResponseBodyResult> result{};

  DescribeDownloadPathsOfNotaryChainResponseBody() {}

  explicit DescribeDownloadPathsOfNotaryChainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeDownloadPathsOfNotaryChainResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeDownloadPathsOfNotaryChainResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeDownloadPathsOfNotaryChainResponseBody() = default;
};
class DescribeDownloadPathsOfNotaryChainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDownloadPathsOfNotaryChainResponseBody> body{};

  DescribeDownloadPathsOfNotaryChainResponse() {}

  explicit DescribeDownloadPathsOfNotaryChainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDownloadPathsOfNotaryChainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDownloadPathsOfNotaryChainResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDownloadPathsOfNotaryChainResponse() = default;
};
class DescribeEcosphereSpecsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};
  shared_ptr<string> name{};
  shared_ptr<string> title{};

  DescribeEcosphereSpecsResponseBodyResult() {}

  explicit DescribeEcosphereSpecsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~DescribeEcosphereSpecsResponseBodyResult() = default;
};
class DescribeEcosphereSpecsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeEcosphereSpecsResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeEcosphereSpecsResponseBody() {}

  explicit DescribeEcosphereSpecsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeEcosphereSpecsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEcosphereSpecsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeEcosphereSpecsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeEcosphereSpecsResponseBody() = default;
};
class DescribeEcosphereSpecsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEcosphereSpecsResponseBody> body{};

  DescribeEcosphereSpecsResponse() {}

  explicit DescribeEcosphereSpecsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEcosphereSpecsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEcosphereSpecsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEcosphereSpecsResponse() = default;
};
class DescribeEthereumRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  DescribeEthereumRequest() {}

  explicit DescribeEthereumRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DescribeEthereumRequest() = default;
};
class DescribeEthereumResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> consensus{};
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> networkId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> state{};

  DescribeEthereumResponseBodyResult() {}

  explicit DescribeEthereumResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consensus) {
      res["Consensus"] = boost::any(*consensus);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Consensus") != m.end() && !m["Consensus"].empty()) {
      consensus = make_shared<string>(boost::any_cast<string>(m["Consensus"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~DescribeEthereumResponseBodyResult() = default;
};
class DescribeEthereumResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeEthereumResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeEthereumResponseBody() {}

  explicit DescribeEthereumResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeEthereumResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeEthereumResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeEthereumResponseBody() = default;
};
class DescribeEthereumResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEthereumResponseBody> body{};

  DescribeEthereumResponse() {}

  explicit DescribeEthereumResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEthereumResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEthereumResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEthereumResponse() = default;
};
class DescribeEthereumClientUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> nodeId{};

  DescribeEthereumClientUsersRequest() {}

  explicit DescribeEthereumClientUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
  }


  virtual ~DescribeEthereumClientUsersRequest() = default;
};
class DescribeEthereumClientUsersResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> username{};

  DescribeEthereumClientUsersResponseBodyResult() {}

  explicit DescribeEthereumClientUsersResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~DescribeEthereumClientUsersResponseBodyResult() = default;
};
class DescribeEthereumClientUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeEthereumClientUsersResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeEthereumClientUsersResponseBody() {}

  explicit DescribeEthereumClientUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeEthereumClientUsersResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEthereumClientUsersResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeEthereumClientUsersResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeEthereumClientUsersResponseBody() = default;
};
class DescribeEthereumClientUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEthereumClientUsersResponseBody> body{};

  DescribeEthereumClientUsersResponse() {}

  explicit DescribeEthereumClientUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEthereumClientUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEthereumClientUsersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEthereumClientUsersResponse() = default;
};
class DescribeEthereumDeletableRequest : public Darabonba::Model {
public:
  shared_ptr<string> ethereumId{};

  DescribeEthereumDeletableRequest() {}

  explicit DescribeEthereumDeletableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ethereumId) {
      res["EthereumId"] = boost::any(*ethereumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EthereumId") != m.end() && !m["EthereumId"].empty()) {
      ethereumId = make_shared<string>(boost::any_cast<string>(m["EthereumId"]));
    }
  }


  virtual ~DescribeEthereumDeletableRequest() = default;
};
class DescribeEthereumDeletableResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> deletable{};
  shared_ptr<string> ethereumId{};

  DescribeEthereumDeletableResponseBodyResult() {}

  explicit DescribeEthereumDeletableResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deletable) {
      res["Deletable"] = boost::any(*deletable);
    }
    if (ethereumId) {
      res["EthereumId"] = boost::any(*ethereumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Deletable") != m.end() && !m["Deletable"].empty()) {
      deletable = make_shared<bool>(boost::any_cast<bool>(m["Deletable"]));
    }
    if (m.find("EthereumId") != m.end() && !m["EthereumId"].empty()) {
      ethereumId = make_shared<string>(boost::any_cast<string>(m["EthereumId"]));
    }
  }


  virtual ~DescribeEthereumDeletableResponseBodyResult() = default;
};
class DescribeEthereumDeletableResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeEthereumDeletableResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeEthereumDeletableResponseBody() {}

  explicit DescribeEthereumDeletableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeEthereumDeletableResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeEthereumDeletableResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeEthereumDeletableResponseBody() = default;
};
class DescribeEthereumDeletableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEthereumDeletableResponseBody> body{};

  DescribeEthereumDeletableResponse() {}

  explicit DescribeEthereumDeletableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEthereumDeletableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEthereumDeletableResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEthereumDeletableResponse() = default;
};
class DescribeEthereumInvitaionRequest : public Darabonba::Model {
public:
  shared_ptr<string> token{};

  DescribeEthereumInvitaionRequest() {}

  explicit DescribeEthereumInvitaionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (token) {
      res["Token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
  }


  virtual ~DescribeEthereumInvitaionRequest() = default;
};
class DescribeEthereumInvitaionResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> consensus{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> networkId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> state{};

  DescribeEthereumInvitaionResponseBodyResult() {}

  explicit DescribeEthereumInvitaionResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consensus) {
      res["Consensus"] = boost::any(*consensus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Consensus") != m.end() && !m["Consensus"].empty()) {
      consensus = make_shared<string>(boost::any_cast<string>(m["Consensus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~DescribeEthereumInvitaionResponseBodyResult() = default;
};
class DescribeEthereumInvitaionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeEthereumInvitaionResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeEthereumInvitaionResponseBody() {}

  explicit DescribeEthereumInvitaionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeEthereumInvitaionResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeEthereumInvitaionResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeEthereumInvitaionResponseBody() = default;
};
class DescribeEthereumInvitaionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEthereumInvitaionResponseBody> body{};

  DescribeEthereumInvitaionResponse() {}

  explicit DescribeEthereumInvitaionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEthereumInvitaionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEthereumInvitaionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEthereumInvitaionResponse() = default;
};
class DescribeEthereumInviteeRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  DescribeEthereumInviteeRequest() {}

  explicit DescribeEthereumInviteeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DescribeEthereumInviteeRequest() = default;
};
class DescribeEthereumInviteeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<string> ethereumId{};
  shared_ptr<string> ethereumName{};
  shared_ptr<string> id{};
  shared_ptr<long> networkId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> publicIp{};
  shared_ptr<string> regionId{};
  shared_ptr<string> rpcPort{};
  shared_ptr<string> state{};
  shared_ptr<string> wsPort{};

  DescribeEthereumInviteeResponseBodyResult() {}

  explicit DescribeEthereumInviteeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ethereumId) {
      res["EthereumId"] = boost::any(*ethereumId);
    }
    if (ethereumName) {
      res["EthereumName"] = boost::any(*ethereumName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (publicIp) {
      res["PublicIp"] = boost::any(*publicIp);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (rpcPort) {
      res["RpcPort"] = boost::any(*rpcPort);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (wsPort) {
      res["WsPort"] = boost::any(*wsPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EthereumId") != m.end() && !m["EthereumId"].empty()) {
      ethereumId = make_shared<string>(boost::any_cast<string>(m["EthereumId"]));
    }
    if (m.find("EthereumName") != m.end() && !m["EthereumName"].empty()) {
      ethereumName = make_shared<string>(boost::any_cast<string>(m["EthereumName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<long>(boost::any_cast<long>(m["NetworkId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("PublicIp") != m.end() && !m["PublicIp"].empty()) {
      publicIp = make_shared<string>(boost::any_cast<string>(m["PublicIp"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RpcPort") != m.end() && !m["RpcPort"].empty()) {
      rpcPort = make_shared<string>(boost::any_cast<string>(m["RpcPort"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("WsPort") != m.end() && !m["WsPort"].empty()) {
      wsPort = make_shared<string>(boost::any_cast<string>(m["WsPort"]));
    }
  }


  virtual ~DescribeEthereumInviteeResponseBodyResult() = default;
};
class DescribeEthereumInviteeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeEthereumInviteeResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeEthereumInviteeResponseBody() {}

  explicit DescribeEthereumInviteeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeEthereumInviteeResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEthereumInviteeResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeEthereumInviteeResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeEthereumInviteeResponseBody() = default;
};
class DescribeEthereumInviteeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEthereumInviteeResponseBody> body{};

  DescribeEthereumInviteeResponse() {}

  explicit DescribeEthereumInviteeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEthereumInviteeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEthereumInviteeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEthereumInviteeResponse() = default;
};
class DescribeEthereumNodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  DescribeEthereumNodeRequest() {}

  explicit DescribeEthereumNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DescribeEthereumNodeRequest() = default;
};
class DescribeEthereumNodeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<string> ethereumId{};
  shared_ptr<string> ethereumName{};
  shared_ptr<string> id{};
  shared_ptr<string> networkId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> publicIp{};
  shared_ptr<string> regionId{};
  shared_ptr<long> rpcPort{};
  shared_ptr<string> state{};
  shared_ptr<long> wsPort{};

  DescribeEthereumNodeResponseBodyResult() {}

  explicit DescribeEthereumNodeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ethereumId) {
      res["EthereumId"] = boost::any(*ethereumId);
    }
    if (ethereumName) {
      res["EthereumName"] = boost::any(*ethereumName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (publicIp) {
      res["PublicIp"] = boost::any(*publicIp);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (rpcPort) {
      res["RpcPort"] = boost::any(*rpcPort);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (wsPort) {
      res["WsPort"] = boost::any(*wsPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EthereumId") != m.end() && !m["EthereumId"].empty()) {
      ethereumId = make_shared<string>(boost::any_cast<string>(m["EthereumId"]));
    }
    if (m.find("EthereumName") != m.end() && !m["EthereumName"].empty()) {
      ethereumName = make_shared<string>(boost::any_cast<string>(m["EthereumName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("PublicIp") != m.end() && !m["PublicIp"].empty()) {
      publicIp = make_shared<string>(boost::any_cast<string>(m["PublicIp"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RpcPort") != m.end() && !m["RpcPort"].empty()) {
      rpcPort = make_shared<long>(boost::any_cast<long>(m["RpcPort"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("WsPort") != m.end() && !m["WsPort"].empty()) {
      wsPort = make_shared<long>(boost::any_cast<long>(m["WsPort"]));
    }
  }


  virtual ~DescribeEthereumNodeResponseBodyResult() = default;
};
class DescribeEthereumNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeEthereumNodeResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeEthereumNodeResponseBody() {}

  explicit DescribeEthereumNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeEthereumNodeResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeEthereumNodeResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeEthereumNodeResponseBody() = default;
};
class DescribeEthereumNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEthereumNodeResponseBody> body{};

  DescribeEthereumNodeResponse() {}

  explicit DescribeEthereumNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEthereumNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEthereumNodeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEthereumNodeResponse() = default;
};
class DescribeEthereumNodeConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> nodeId{};

  DescribeEthereumNodeConfigurationRequest() {}

  explicit DescribeEthereumNodeConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
  }


  virtual ~DescribeEthereumNodeConfigurationRequest() = default;
};
class DescribeEthereumNodeConfigurationResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> genesisJson{};
  shared_ptr<string> IP{};
  shared_ptr<string> nodePub{};
  shared_ptr<long> p2pPort{};
  shared_ptr<string> permissionedNodesJson{};
  shared_ptr<long> raftPort{};
  shared_ptr<long> rpcPort{};
  shared_ptr<string> staticNodesJson{};
  shared_ptr<string> TMJson{};
  shared_ptr<long> TMPort{};
  shared_ptr<string> TMPub{};
  shared_ptr<long> WSPort{};

  DescribeEthereumNodeConfigurationResponseBodyResult() {}

  explicit DescribeEthereumNodeConfigurationResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (genesisJson) {
      res["GenesisJson"] = boost::any(*genesisJson);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (nodePub) {
      res["NodePub"] = boost::any(*nodePub);
    }
    if (p2pPort) {
      res["P2pPort"] = boost::any(*p2pPort);
    }
    if (permissionedNodesJson) {
      res["PermissionedNodesJson"] = boost::any(*permissionedNodesJson);
    }
    if (raftPort) {
      res["RaftPort"] = boost::any(*raftPort);
    }
    if (rpcPort) {
      res["RpcPort"] = boost::any(*rpcPort);
    }
    if (staticNodesJson) {
      res["StaticNodesJson"] = boost::any(*staticNodesJson);
    }
    if (TMJson) {
      res["TMJson"] = boost::any(*TMJson);
    }
    if (TMPort) {
      res["TMPort"] = boost::any(*TMPort);
    }
    if (TMPub) {
      res["TMPub"] = boost::any(*TMPub);
    }
    if (WSPort) {
      res["WSPort"] = boost::any(*WSPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GenesisJson") != m.end() && !m["GenesisJson"].empty()) {
      genesisJson = make_shared<string>(boost::any_cast<string>(m["GenesisJson"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("NodePub") != m.end() && !m["NodePub"].empty()) {
      nodePub = make_shared<string>(boost::any_cast<string>(m["NodePub"]));
    }
    if (m.find("P2pPort") != m.end() && !m["P2pPort"].empty()) {
      p2pPort = make_shared<long>(boost::any_cast<long>(m["P2pPort"]));
    }
    if (m.find("PermissionedNodesJson") != m.end() && !m["PermissionedNodesJson"].empty()) {
      permissionedNodesJson = make_shared<string>(boost::any_cast<string>(m["PermissionedNodesJson"]));
    }
    if (m.find("RaftPort") != m.end() && !m["RaftPort"].empty()) {
      raftPort = make_shared<long>(boost::any_cast<long>(m["RaftPort"]));
    }
    if (m.find("RpcPort") != m.end() && !m["RpcPort"].empty()) {
      rpcPort = make_shared<long>(boost::any_cast<long>(m["RpcPort"]));
    }
    if (m.find("StaticNodesJson") != m.end() && !m["StaticNodesJson"].empty()) {
      staticNodesJson = make_shared<string>(boost::any_cast<string>(m["StaticNodesJson"]));
    }
    if (m.find("TMJson") != m.end() && !m["TMJson"].empty()) {
      TMJson = make_shared<string>(boost::any_cast<string>(m["TMJson"]));
    }
    if (m.find("TMPort") != m.end() && !m["TMPort"].empty()) {
      TMPort = make_shared<long>(boost::any_cast<long>(m["TMPort"]));
    }
    if (m.find("TMPub") != m.end() && !m["TMPub"].empty()) {
      TMPub = make_shared<string>(boost::any_cast<string>(m["TMPub"]));
    }
    if (m.find("WSPort") != m.end() && !m["WSPort"].empty()) {
      WSPort = make_shared<long>(boost::any_cast<long>(m["WSPort"]));
    }
  }


  virtual ~DescribeEthereumNodeConfigurationResponseBodyResult() = default;
};
class DescribeEthereumNodeConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeEthereumNodeConfigurationResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeEthereumNodeConfigurationResponseBody() {}

  explicit DescribeEthereumNodeConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeEthereumNodeConfigurationResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEthereumNodeConfigurationResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeEthereumNodeConfigurationResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeEthereumNodeConfigurationResponseBody() = default;
};
class DescribeEthereumNodeConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEthereumNodeConfigurationResponseBody> body{};

  DescribeEthereumNodeConfigurationResponse() {}

  explicit DescribeEthereumNodeConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEthereumNodeConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEthereumNodeConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEthereumNodeConfigurationResponse() = default;
};
class DescribeEthereumNodeInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> nodeId{};

  DescribeEthereumNodeInfoRequest() {}

  explicit DescribeEthereumNodeInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
  }


  virtual ~DescribeEthereumNodeInfoRequest() = default;
};
class DescribeEthereumNodeInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  DescribeEthereumNodeInfoResponseBody() {}

  explicit DescribeEthereumNodeInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeEthereumNodeInfoResponseBody() = default;
};
class DescribeEthereumNodeInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEthereumNodeInfoResponseBody> body{};

  DescribeEthereumNodeInfoResponse() {}

  explicit DescribeEthereumNodeInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEthereumNodeInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEthereumNodeInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEthereumNodeInfoResponse() = default;
};
class DescribeEthereumNodeLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> lines{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> target{};

  DescribeEthereumNodeLogsRequest() {}

  explicit DescribeEthereumNodeLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lines) {
      res["Lines"] = boost::any(*lines);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lines") != m.end() && !m["Lines"].empty()) {
      lines = make_shared<string>(boost::any_cast<string>(m["Lines"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
  }


  virtual ~DescribeEthereumNodeLogsRequest() = default;
};
class DescribeEthereumNodeLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  DescribeEthereumNodeLogsResponseBody() {}

  explicit DescribeEthereumNodeLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeEthereumNodeLogsResponseBody() = default;
};
class DescribeEthereumNodeLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEthereumNodeLogsResponseBody> body{};

  DescribeEthereumNodeLogsResponse() {}

  explicit DescribeEthereumNodeLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEthereumNodeLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEthereumNodeLogsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEthereumNodeLogsResponse() = default;
};
class DescribeEthereumNodesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> consensus{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<string> ethereumId{};
  shared_ptr<string> ethereumName{};
  shared_ptr<bool> external{};
  shared_ptr<string> id{};
  shared_ptr<long> networkId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> publicIp{};
  shared_ptr<string> regionId{};
  shared_ptr<string> rpcPort{};
  shared_ptr<string> state{};
  shared_ptr<bool> validator{};
  shared_ptr<string> wsPort{};

  DescribeEthereumNodesResponseBodyResult() {}

  explicit DescribeEthereumNodesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consensus) {
      res["Consensus"] = boost::any(*consensus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ethereumId) {
      res["EthereumId"] = boost::any(*ethereumId);
    }
    if (ethereumName) {
      res["EthereumName"] = boost::any(*ethereumName);
    }
    if (external) {
      res["External"] = boost::any(*external);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (publicIp) {
      res["PublicIp"] = boost::any(*publicIp);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (rpcPort) {
      res["RpcPort"] = boost::any(*rpcPort);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (validator) {
      res["Validator"] = boost::any(*validator);
    }
    if (wsPort) {
      res["WsPort"] = boost::any(*wsPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Consensus") != m.end() && !m["Consensus"].empty()) {
      consensus = make_shared<string>(boost::any_cast<string>(m["Consensus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EthereumId") != m.end() && !m["EthereumId"].empty()) {
      ethereumId = make_shared<string>(boost::any_cast<string>(m["EthereumId"]));
    }
    if (m.find("EthereumName") != m.end() && !m["EthereumName"].empty()) {
      ethereumName = make_shared<string>(boost::any_cast<string>(m["EthereumName"]));
    }
    if (m.find("External") != m.end() && !m["External"].empty()) {
      external = make_shared<bool>(boost::any_cast<bool>(m["External"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<long>(boost::any_cast<long>(m["NetworkId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("PublicIp") != m.end() && !m["PublicIp"].empty()) {
      publicIp = make_shared<string>(boost::any_cast<string>(m["PublicIp"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RpcPort") != m.end() && !m["RpcPort"].empty()) {
      rpcPort = make_shared<string>(boost::any_cast<string>(m["RpcPort"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Validator") != m.end() && !m["Validator"].empty()) {
      validator = make_shared<bool>(boost::any_cast<bool>(m["Validator"]));
    }
    if (m.find("WsPort") != m.end() && !m["WsPort"].empty()) {
      wsPort = make_shared<string>(boost::any_cast<string>(m["WsPort"]));
    }
  }


  virtual ~DescribeEthereumNodesResponseBodyResult() = default;
};
class DescribeEthereumNodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeEthereumNodesResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeEthereumNodesResponseBody() {}

  explicit DescribeEthereumNodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeEthereumNodesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEthereumNodesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeEthereumNodesResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeEthereumNodesResponseBody() = default;
};
class DescribeEthereumNodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEthereumNodesResponseBody> body{};

  DescribeEthereumNodesResponse() {}

  explicit DescribeEthereumNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEthereumNodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEthereumNodesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEthereumNodesResponse() = default;
};
class DescribeEthereumsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> consensus{};
  shared_ptr<long> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<bool> deletable{};
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> networkId{};
  shared_ptr<long> nodeNumber{};
  shared_ptr<string> regionId{};
  shared_ptr<string> state{};

  DescribeEthereumsResponseBodyResult() {}

  explicit DescribeEthereumsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consensus) {
      res["Consensus"] = boost::any(*consensus);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (deletable) {
      res["Deletable"] = boost::any(*deletable);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (nodeNumber) {
      res["NodeNumber"] = boost::any(*nodeNumber);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Consensus") != m.end() && !m["Consensus"].empty()) {
      consensus = make_shared<string>(boost::any_cast<string>(m["Consensus"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Deletable") != m.end() && !m["Deletable"].empty()) {
      deletable = make_shared<bool>(boost::any_cast<bool>(m["Deletable"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("NodeNumber") != m.end() && !m["NodeNumber"].empty()) {
      nodeNumber = make_shared<long>(boost::any_cast<long>(m["NodeNumber"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~DescribeEthereumsResponseBodyResult() = default;
};
class DescribeEthereumsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeEthereumsResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeEthereumsResponseBody() {}

  explicit DescribeEthereumsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeEthereumsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeEthereumsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeEthereumsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeEthereumsResponseBody() = default;
};
class DescribeEthereumsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEthereumsResponseBody> body{};

  DescribeEthereumsResponse() {}

  explicit DescribeEthereumsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEthereumsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEthereumsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEthereumsResponse() = default;
};
class DescribeExplorerRequest : public Darabonba::Model {
public:
  shared_ptr<string> exBody{};
  shared_ptr<string> exMethod{};
  shared_ptr<string> exUrl{};
  shared_ptr<string> organizationId{};

  DescribeExplorerRequest() {}

  explicit DescribeExplorerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exBody) {
      res["ExBody"] = boost::any(*exBody);
    }
    if (exMethod) {
      res["ExMethod"] = boost::any(*exMethod);
    }
    if (exUrl) {
      res["ExUrl"] = boost::any(*exUrl);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExBody") != m.end() && !m["ExBody"].empty()) {
      exBody = make_shared<string>(boost::any_cast<string>(m["ExBody"]));
    }
    if (m.find("ExMethod") != m.end() && !m["ExMethod"].empty()) {
      exMethod = make_shared<string>(boost::any_cast<string>(m["ExMethod"]));
    }
    if (m.find("ExUrl") != m.end() && !m["ExUrl"].empty()) {
      exUrl = make_shared<string>(boost::any_cast<string>(m["ExUrl"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeExplorerRequest() = default;
};
class DescribeExplorerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  DescribeExplorerResponseBody() {}

  explicit DescribeExplorerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeExplorerResponseBody() = default;
};
class DescribeExplorerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeExplorerResponseBody> body{};

  DescribeExplorerResponse() {}

  explicit DescribeExplorerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExplorerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExplorerResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExplorerResponse() = default;
};
class DescribeExplorerURLRequest : public Darabonba::Model {
public:
  shared_ptr<string> nodeId{};

  DescribeExplorerURLRequest() {}

  explicit DescribeExplorerURLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
  }


  virtual ~DescribeExplorerURLRequest() = default;
};
class DescribeExplorerURLResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  DescribeExplorerURLResponseBody() {}

  explicit DescribeExplorerURLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeExplorerURLResponseBody() = default;
};
class DescribeExplorerURLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeExplorerURLResponseBody> body{};

  DescribeExplorerURLResponse() {}

  explicit DescribeExplorerURLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeExplorerURLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeExplorerURLResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeExplorerURLResponse() = default;
};
class DescribeFabricChaincodeEndorsePolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeName{};
  shared_ptr<string> channelId{};
  shared_ptr<string> organizationId{};

  DescribeFabricChaincodeEndorsePolicyRequest() {}

  explicit DescribeFabricChaincodeEndorsePolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeName) {
      res["ChaincodeName"] = boost::any(*chaincodeName);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeName") != m.end() && !m["ChaincodeName"].empty()) {
      chaincodeName = make_shared<string>(boost::any_cast<string>(m["ChaincodeName"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeFabricChaincodeEndorsePolicyRequest() = default;
};
class DescribeFabricChaincodeEndorsePolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  DescribeFabricChaincodeEndorsePolicyResponseBody() {}

  explicit DescribeFabricChaincodeEndorsePolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricChaincodeEndorsePolicyResponseBody() = default;
};
class DescribeFabricChaincodeEndorsePolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricChaincodeEndorsePolicyResponseBody> body{};

  DescribeFabricChaincodeEndorsePolicyResponse() {}

  explicit DescribeFabricChaincodeEndorsePolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricChaincodeEndorsePolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricChaincodeEndorsePolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricChaincodeEndorsePolicyResponse() = default;
};
class DescribeFabricChaincodeLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> lines{};
  shared_ptr<long> offset{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> peerName{};

  DescribeFabricChaincodeLogsRequest() {}

  explicit DescribeFabricChaincodeLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (lines) {
      res["Lines"] = boost::any(*lines);
    }
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (peerName) {
      res["PeerName"] = boost::any(*peerName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("Lines") != m.end() && !m["Lines"].empty()) {
      lines = make_shared<string>(boost::any_cast<string>(m["Lines"]));
    }
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("PeerName") != m.end() && !m["PeerName"].empty()) {
      peerName = make_shared<string>(boost::any_cast<string>(m["PeerName"]));
    }
  }


  virtual ~DescribeFabricChaincodeLogsRequest() = default;
};
class DescribeFabricChaincodeLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  DescribeFabricChaincodeLogsResponseBody() {}

  explicit DescribeFabricChaincodeLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricChaincodeLogsResponseBody() = default;
};
class DescribeFabricChaincodeLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricChaincodeLogsResponseBody> body{};

  DescribeFabricChaincodeLogsResponse() {}

  explicit DescribeFabricChaincodeLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricChaincodeLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricChaincodeLogsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricChaincodeLogsResponse() = default;
};
class DescribeFabricChannelConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> organizationId{};

  DescribeFabricChannelConfigRequest() {}

  explicit DescribeFabricChannelConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeFabricChannelConfigRequest() = default;
};
class DescribeFabricChannelConfigResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> absoluteMaxBytes{};
  shared_ptr<string> batchTimeout{};
  shared_ptr<long> maxMessageCount{};
  shared_ptr<long> preferredMaxBytes{};

  DescribeFabricChannelConfigResponseBodyResult() {}

  explicit DescribeFabricChannelConfigResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (absoluteMaxBytes) {
      res["AbsoluteMaxBytes"] = boost::any(*absoluteMaxBytes);
    }
    if (batchTimeout) {
      res["BatchTimeout"] = boost::any(*batchTimeout);
    }
    if (maxMessageCount) {
      res["MaxMessageCount"] = boost::any(*maxMessageCount);
    }
    if (preferredMaxBytes) {
      res["PreferredMaxBytes"] = boost::any(*preferredMaxBytes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbsoluteMaxBytes") != m.end() && !m["AbsoluteMaxBytes"].empty()) {
      absoluteMaxBytes = make_shared<long>(boost::any_cast<long>(m["AbsoluteMaxBytes"]));
    }
    if (m.find("BatchTimeout") != m.end() && !m["BatchTimeout"].empty()) {
      batchTimeout = make_shared<string>(boost::any_cast<string>(m["BatchTimeout"]));
    }
    if (m.find("MaxMessageCount") != m.end() && !m["MaxMessageCount"].empty()) {
      maxMessageCount = make_shared<long>(boost::any_cast<long>(m["MaxMessageCount"]));
    }
    if (m.find("PreferredMaxBytes") != m.end() && !m["PreferredMaxBytes"].empty()) {
      preferredMaxBytes = make_shared<long>(boost::any_cast<long>(m["PreferredMaxBytes"]));
    }
  }


  virtual ~DescribeFabricChannelConfigResponseBodyResult() = default;
};
class DescribeFabricChannelConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeFabricChannelConfigResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeFabricChannelConfigResponseBody() {}

  explicit DescribeFabricChannelConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeFabricChannelConfigResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeFabricChannelConfigResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricChannelConfigResponseBody() = default;
};
class DescribeFabricChannelConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricChannelConfigResponseBody> body{};

  DescribeFabricChannelConfigResponse() {}

  explicit DescribeFabricChannelConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricChannelConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricChannelConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricChannelConfigResponse() = default;
};
class DescribeFabricChannelOrdererRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> organizationId{};

  DescribeFabricChannelOrdererRequest() {}

  explicit DescribeFabricChannelOrdererRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeFabricChannelOrdererRequest() = default;
};
class DescribeFabricChannelOrdererResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> certificate{};
  shared_ptr<string> key{};
  shared_ptr<string> tlsroot{};

  DescribeFabricChannelOrdererResponseBodyResult() {}

  explicit DescribeFabricChannelOrdererResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (tlsroot) {
      res["Tlsroot"] = boost::any(*tlsroot);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Tlsroot") != m.end() && !m["Tlsroot"].empty()) {
      tlsroot = make_shared<string>(boost::any_cast<string>(m["Tlsroot"]));
    }
  }


  virtual ~DescribeFabricChannelOrdererResponseBodyResult() = default;
};
class DescribeFabricChannelOrdererResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeFabricChannelOrdererResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeFabricChannelOrdererResponseBody() {}

  explicit DescribeFabricChannelOrdererResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeFabricChannelOrdererResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFabricChannelOrdererResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeFabricChannelOrdererResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricChannelOrdererResponseBody() = default;
};
class DescribeFabricChannelOrdererResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricChannelOrdererResponseBody> body{};

  DescribeFabricChannelOrdererResponse() {}

  explicit DescribeFabricChannelOrdererResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricChannelOrdererResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricChannelOrdererResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricChannelOrdererResponse() = default;
};
class DescribeFabricChannelOrganizationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> organizationId{};

  DescribeFabricChannelOrganizationsRequest() {}

  explicit DescribeFabricChannelOrganizationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeFabricChannelOrganizationsRequest() = default;
};
class DescribeFabricChannelOrganizationsResponseBodyResultAnchorPeers : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<long> port{};

  DescribeFabricChannelOrganizationsResponseBodyResultAnchorPeers() {}

  explicit DescribeFabricChannelOrganizationsResponseBodyResultAnchorPeers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
  }


  virtual ~DescribeFabricChannelOrganizationsResponseBodyResultAnchorPeers() = default;
};
class DescribeFabricChannelOrganizationsResponseBodyResultOrdererNodes : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> certificate{};
  shared_ptr<string> key{};
  shared_ptr<string> tlsroot{};

  DescribeFabricChannelOrganizationsResponseBodyResultOrdererNodes() {}

  explicit DescribeFabricChannelOrganizationsResponseBodyResultOrdererNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (tlsroot) {
      res["Tlsroot"] = boost::any(*tlsroot);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Tlsroot") != m.end() && !m["Tlsroot"].empty()) {
      tlsroot = make_shared<string>(boost::any_cast<string>(m["Tlsroot"]));
    }
  }


  virtual ~DescribeFabricChannelOrganizationsResponseBodyResultOrdererNodes() = default;
};
class DescribeFabricChannelOrganizationsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeFabricChannelOrganizationsResponseBodyResultAnchorPeers>> anchorPeers{};
  shared_ptr<string> crls{};
  shared_ptr<string> mspId{};
  shared_ptr<string> mspType{};
  shared_ptr<bool> orderer{};
  shared_ptr<vector<DescribeFabricChannelOrganizationsResponseBodyResultOrdererNodes>> ordererNodes{};
  shared_ptr<string> rootCertificates{};
  shared_ptr<string> tlsRootCertificates{};

  DescribeFabricChannelOrganizationsResponseBodyResult() {}

  explicit DescribeFabricChannelOrganizationsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (anchorPeers) {
      vector<boost::any> temp1;
      for(auto item1:*anchorPeers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnchorPeers"] = boost::any(temp1);
    }
    if (crls) {
      res["Crls"] = boost::any(*crls);
    }
    if (mspId) {
      res["MspId"] = boost::any(*mspId);
    }
    if (mspType) {
      res["MspType"] = boost::any(*mspType);
    }
    if (orderer) {
      res["Orderer"] = boost::any(*orderer);
    }
    if (ordererNodes) {
      vector<boost::any> temp1;
      for(auto item1:*ordererNodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OrdererNodes"] = boost::any(temp1);
    }
    if (rootCertificates) {
      res["RootCertificates"] = boost::any(*rootCertificates);
    }
    if (tlsRootCertificates) {
      res["TlsRootCertificates"] = boost::any(*tlsRootCertificates);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnchorPeers") != m.end() && !m["AnchorPeers"].empty()) {
      if (typeid(vector<boost::any>) == m["AnchorPeers"].type()) {
        vector<DescribeFabricChannelOrganizationsResponseBodyResultAnchorPeers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnchorPeers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFabricChannelOrganizationsResponseBodyResultAnchorPeers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        anchorPeers = make_shared<vector<DescribeFabricChannelOrganizationsResponseBodyResultAnchorPeers>>(expect1);
      }
    }
    if (m.find("Crls") != m.end() && !m["Crls"].empty()) {
      crls = make_shared<string>(boost::any_cast<string>(m["Crls"]));
    }
    if (m.find("MspId") != m.end() && !m["MspId"].empty()) {
      mspId = make_shared<string>(boost::any_cast<string>(m["MspId"]));
    }
    if (m.find("MspType") != m.end() && !m["MspType"].empty()) {
      mspType = make_shared<string>(boost::any_cast<string>(m["MspType"]));
    }
    if (m.find("Orderer") != m.end() && !m["Orderer"].empty()) {
      orderer = make_shared<bool>(boost::any_cast<bool>(m["Orderer"]));
    }
    if (m.find("OrdererNodes") != m.end() && !m["OrdererNodes"].empty()) {
      if (typeid(vector<boost::any>) == m["OrdererNodes"].type()) {
        vector<DescribeFabricChannelOrganizationsResponseBodyResultOrdererNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OrdererNodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFabricChannelOrganizationsResponseBodyResultOrdererNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ordererNodes = make_shared<vector<DescribeFabricChannelOrganizationsResponseBodyResultOrdererNodes>>(expect1);
      }
    }
    if (m.find("RootCertificates") != m.end() && !m["RootCertificates"].empty()) {
      rootCertificates = make_shared<string>(boost::any_cast<string>(m["RootCertificates"]));
    }
    if (m.find("TlsRootCertificates") != m.end() && !m["TlsRootCertificates"].empty()) {
      tlsRootCertificates = make_shared<string>(boost::any_cast<string>(m["TlsRootCertificates"]));
    }
  }


  virtual ~DescribeFabricChannelOrganizationsResponseBodyResult() = default;
};
class DescribeFabricChannelOrganizationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeFabricChannelOrganizationsResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeFabricChannelOrganizationsResponseBody() {}

  explicit DescribeFabricChannelOrganizationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeFabricChannelOrganizationsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeFabricChannelOrganizationsResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricChannelOrganizationsResponseBody() = default;
};
class DescribeFabricChannelOrganizationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricChannelOrganizationsResponseBody> body{};

  DescribeFabricChannelOrganizationsResponse() {}

  explicit DescribeFabricChannelOrganizationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricChannelOrganizationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricChannelOrganizationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricChannelOrganizationsResponse() = default;
};
class DescribeFabricJoinRequestRequest : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};

  DescribeFabricJoinRequestRequest() {}

  explicit DescribeFabricJoinRequestRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeFabricJoinRequestRequest() = default;
};
class DescribeFabricJoinRequestResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  DescribeFabricJoinRequestResponseBody() {}

  explicit DescribeFabricJoinRequestResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricJoinRequestResponseBody() = default;
};
class DescribeFabricJoinRequestResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricJoinRequestResponseBody> body{};

  DescribeFabricJoinRequestResponse() {}

  explicit DescribeFabricJoinRequestResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricJoinRequestResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricJoinRequestResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricJoinRequestResponse() = default;
};
class DescribeFabricJoinResponseRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> organizationId{};

  DescribeFabricJoinResponseRequest() {}

  explicit DescribeFabricJoinResponseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeFabricJoinResponseRequest() = default;
};
class DescribeFabricJoinResponseResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  DescribeFabricJoinResponseResponseBody() {}

  explicit DescribeFabricJoinResponseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricJoinResponseResponseBody() = default;
};
class DescribeFabricJoinResponseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricJoinResponseResponseBody> body{};

  DescribeFabricJoinResponseResponse() {}

  explicit DescribeFabricJoinResponseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricJoinResponseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricJoinResponseResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricJoinResponseResponse() = default;
};
class DescribeFabricManagementChaincodesRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> organizationId{};

  DescribeFabricManagementChaincodesRequest() {}

  explicit DescribeFabricManagementChaincodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeFabricManagementChaincodesRequest() = default;
};
class DescribeFabricManagementChaincodesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> input{};
  shared_ptr<string> name{};
  shared_ptr<long> path{};
  shared_ptr<long> type{};
  shared_ptr<string> version{};

  DescribeFabricManagementChaincodesResponseBodyResult() {}

  explicit DescribeFabricManagementChaincodesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<long>(boost::any_cast<long>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeFabricManagementChaincodesResponseBodyResult() = default;
};
class DescribeFabricManagementChaincodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeFabricManagementChaincodesResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeFabricManagementChaincodesResponseBody() {}

  explicit DescribeFabricManagementChaincodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeFabricManagementChaincodesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFabricManagementChaincodesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeFabricManagementChaincodesResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricManagementChaincodesResponseBody() = default;
};
class DescribeFabricManagementChaincodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricManagementChaincodesResponseBody> body{};

  DescribeFabricManagementChaincodesResponse() {}

  explicit DescribeFabricManagementChaincodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricManagementChaincodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricManagementChaincodesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricManagementChaincodesResponse() = default;
};
class DescribeFabricOrganizationChaincodePackageRequest : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};

  DescribeFabricOrganizationChaincodePackageRequest() {}

  explicit DescribeFabricOrganizationChaincodePackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeFabricOrganizationChaincodePackageRequest() = default;
};
class DescribeFabricOrganizationChaincodePackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> result{};
  shared_ptr<bool> success{};

  DescribeFabricOrganizationChaincodePackageResponseBody() {}

  explicit DescribeFabricOrganizationChaincodePackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Result"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      result = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricOrganizationChaincodePackageResponseBody() = default;
};
class DescribeFabricOrganizationChaincodePackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricOrganizationChaincodePackageResponseBody> body{};

  DescribeFabricOrganizationChaincodePackageResponse() {}

  explicit DescribeFabricOrganizationChaincodePackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricOrganizationChaincodePackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricOrganizationChaincodePackageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricOrganizationChaincodePackageResponse() = default;
};
class DescribeFabricOrganizationEgressRequest : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};

  DescribeFabricOrganizationEgressRequest() {}

  explicit DescribeFabricOrganizationEgressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeFabricOrganizationEgressRequest() = default;
};
class DescribeFabricOrganizationEgressResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> result{};
  shared_ptr<bool> success{};

  DescribeFabricOrganizationEgressResponseBody() {}

  explicit DescribeFabricOrganizationEgressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Result"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      result = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricOrganizationEgressResponseBody() = default;
};
class DescribeFabricOrganizationEgressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricOrganizationEgressResponseBody> body{};

  DescribeFabricOrganizationEgressResponse() {}

  explicit DescribeFabricOrganizationEgressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricOrganizationEgressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricOrganizationEgressResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricOrganizationEgressResponse() = default;
};
class DescribeFabricPeerChannelsRequest : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};

  DescribeFabricPeerChannelsRequest() {}

  explicit DescribeFabricPeerChannelsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeFabricPeerChannelsRequest() = default;
};
class DescribeFabricPeerChannelsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> result{};
  shared_ptr<bool> success{};

  DescribeFabricPeerChannelsResponseBody() {}

  explicit DescribeFabricPeerChannelsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Result"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      result = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricPeerChannelsResponseBody() = default;
};
class DescribeFabricPeerChannelsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricPeerChannelsResponseBody> body{};

  DescribeFabricPeerChannelsResponse() {}

  explicit DescribeFabricPeerChannelsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricPeerChannelsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricPeerChannelsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricPeerChannelsResponse() = default;
};
class DescribeGovernanceTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> taskId{};

  DescribeGovernanceTaskRequest() {}

  explicit DescribeGovernanceTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~DescribeGovernanceTaskRequest() = default;
};
class DescribeGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<long> port{};

  DescribeGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers() {}

  explicit DescribeGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
  }


  virtual ~DescribeGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers() = default;
};
class DescribeGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> certificate{};
  shared_ptr<string> key{};
  shared_ptr<string> tlsroot{};

  DescribeGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes() {}

  explicit DescribeGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (tlsroot) {
      res["Tlsroot"] = boost::any(*tlsroot);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Tlsroot") != m.end() && !m["Tlsroot"].empty()) {
      tlsroot = make_shared<string>(boost::any_cast<string>(m["Tlsroot"]));
    }
  }


  virtual ~DescribeGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes() = default;
};
class DescribeGovernanceTaskResponseBodyResultContentAddedOrganizations : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers>> anchorPeers{};
  shared_ptr<string> crls{};
  shared_ptr<string> mspId{};
  shared_ptr<string> mspType{};
  shared_ptr<bool> orderer{};
  shared_ptr<vector<DescribeGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes>> ordererNodes{};
  shared_ptr<string> rootCertificates{};
  shared_ptr<string> tlsRootCertificates{};

  DescribeGovernanceTaskResponseBodyResultContentAddedOrganizations() {}

  explicit DescribeGovernanceTaskResponseBodyResultContentAddedOrganizations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (anchorPeers) {
      vector<boost::any> temp1;
      for(auto item1:*anchorPeers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnchorPeers"] = boost::any(temp1);
    }
    if (crls) {
      res["Crls"] = boost::any(*crls);
    }
    if (mspId) {
      res["MspId"] = boost::any(*mspId);
    }
    if (mspType) {
      res["MspType"] = boost::any(*mspType);
    }
    if (orderer) {
      res["Orderer"] = boost::any(*orderer);
    }
    if (ordererNodes) {
      vector<boost::any> temp1;
      for(auto item1:*ordererNodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OrdererNodes"] = boost::any(temp1);
    }
    if (rootCertificates) {
      res["RootCertificates"] = boost::any(*rootCertificates);
    }
    if (tlsRootCertificates) {
      res["TlsRootCertificates"] = boost::any(*tlsRootCertificates);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnchorPeers") != m.end() && !m["AnchorPeers"].empty()) {
      if (typeid(vector<boost::any>) == m["AnchorPeers"].type()) {
        vector<DescribeGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnchorPeers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        anchorPeers = make_shared<vector<DescribeGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers>>(expect1);
      }
    }
    if (m.find("Crls") != m.end() && !m["Crls"].empty()) {
      crls = make_shared<string>(boost::any_cast<string>(m["Crls"]));
    }
    if (m.find("MspId") != m.end() && !m["MspId"].empty()) {
      mspId = make_shared<string>(boost::any_cast<string>(m["MspId"]));
    }
    if (m.find("MspType") != m.end() && !m["MspType"].empty()) {
      mspType = make_shared<string>(boost::any_cast<string>(m["MspType"]));
    }
    if (m.find("Orderer") != m.end() && !m["Orderer"].empty()) {
      orderer = make_shared<bool>(boost::any_cast<bool>(m["Orderer"]));
    }
    if (m.find("OrdererNodes") != m.end() && !m["OrdererNodes"].empty()) {
      if (typeid(vector<boost::any>) == m["OrdererNodes"].type()) {
        vector<DescribeGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OrdererNodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ordererNodes = make_shared<vector<DescribeGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes>>(expect1);
      }
    }
    if (m.find("RootCertificates") != m.end() && !m["RootCertificates"].empty()) {
      rootCertificates = make_shared<string>(boost::any_cast<string>(m["RootCertificates"]));
    }
    if (m.find("TlsRootCertificates") != m.end() && !m["TlsRootCertificates"].empty()) {
      tlsRootCertificates = make_shared<string>(boost::any_cast<string>(m["TlsRootCertificates"]));
    }
  }


  virtual ~DescribeGovernanceTaskResponseBodyResultContentAddedOrganizations() = default;
};
class DescribeGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs : public Darabonba::Model {
public:
  shared_ptr<string> input{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<long> type{};
  shared_ptr<string> version{};

  DescribeGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs() {}

  explicit DescribeGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs() = default;
};
class DescribeGovernanceTaskResponseBodyResultContentChaincodeSpecPkg : public Darabonba::Model {
public:
  shared_ptr<DescribeGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs> cs{};
  shared_ptr<string> policy{};
  shared_ptr<string> sha256{};

  DescribeGovernanceTaskResponseBodyResultContentChaincodeSpecPkg() {}

  explicit DescribeGovernanceTaskResponseBodyResultContentChaincodeSpecPkg(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cs) {
      res["Cs"] = cs ? boost::any(cs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (sha256) {
      res["Sha256"] = boost::any(*sha256);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cs") != m.end() && !m["Cs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cs"].type()) {
        DescribeGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cs"]));
        cs = make_shared<DescribeGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs>(model1);
      }
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Sha256") != m.end() && !m["Sha256"].empty()) {
      sha256 = make_shared<string>(boost::any_cast<string>(m["Sha256"]));
    }
  }


  virtual ~DescribeGovernanceTaskResponseBodyResultContentChaincodeSpecPkg() = default;
};
class DescribeGovernanceTaskResponseBodyResultContentOrdererConfig : public Darabonba::Model {
public:
  shared_ptr<string> batchTimeout{};
  shared_ptr<long> maxMessageCount{};
  shared_ptr<long> preferredMaxBytes{};

  DescribeGovernanceTaskResponseBodyResultContentOrdererConfig() {}

  explicit DescribeGovernanceTaskResponseBodyResultContentOrdererConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchTimeout) {
      res["BatchTimeout"] = boost::any(*batchTimeout);
    }
    if (maxMessageCount) {
      res["MaxMessageCount"] = boost::any(*maxMessageCount);
    }
    if (preferredMaxBytes) {
      res["PreferredMaxBytes"] = boost::any(*preferredMaxBytes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchTimeout") != m.end() && !m["BatchTimeout"].empty()) {
      batchTimeout = make_shared<string>(boost::any_cast<string>(m["BatchTimeout"]));
    }
    if (m.find("MaxMessageCount") != m.end() && !m["MaxMessageCount"].empty()) {
      maxMessageCount = make_shared<long>(boost::any_cast<long>(m["MaxMessageCount"]));
    }
    if (m.find("PreferredMaxBytes") != m.end() && !m["PreferredMaxBytes"].empty()) {
      preferredMaxBytes = make_shared<long>(boost::any_cast<long>(m["PreferredMaxBytes"]));
    }
  }


  virtual ~DescribeGovernanceTaskResponseBodyResultContentOrdererConfig() = default;
};
class DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<long> port{};

  DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers() {}

  explicit DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
  }


  virtual ~DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers() = default;
};
class DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> certificate{};
  shared_ptr<string> key{};
  shared_ptr<string> tlsroot{};

  DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes() {}

  explicit DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (tlsroot) {
      res["Tlsroot"] = boost::any(*tlsroot);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Tlsroot") != m.end() && !m["Tlsroot"].empty()) {
      tlsroot = make_shared<string>(boost::any_cast<string>(m["Tlsroot"]));
    }
  }


  virtual ~DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes() = default;
};
class DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizations : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers>> anchorPeers{};
  shared_ptr<string> crls{};
  shared_ptr<string> mspId{};
  shared_ptr<string> mspType{};
  shared_ptr<bool> orderer{};
  shared_ptr<vector<DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes>> ordererNodes{};
  shared_ptr<string> rootCertificates{};
  shared_ptr<string> tlsRootCertificates{};

  DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizations() {}

  explicit DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (anchorPeers) {
      vector<boost::any> temp1;
      for(auto item1:*anchorPeers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnchorPeers"] = boost::any(temp1);
    }
    if (crls) {
      res["Crls"] = boost::any(*crls);
    }
    if (mspId) {
      res["MspId"] = boost::any(*mspId);
    }
    if (mspType) {
      res["MspType"] = boost::any(*mspType);
    }
    if (orderer) {
      res["Orderer"] = boost::any(*orderer);
    }
    if (ordererNodes) {
      vector<boost::any> temp1;
      for(auto item1:*ordererNodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OrdererNodes"] = boost::any(temp1);
    }
    if (rootCertificates) {
      res["RootCertificates"] = boost::any(*rootCertificates);
    }
    if (tlsRootCertificates) {
      res["TlsRootCertificates"] = boost::any(*tlsRootCertificates);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnchorPeers") != m.end() && !m["AnchorPeers"].empty()) {
      if (typeid(vector<boost::any>) == m["AnchorPeers"].type()) {
        vector<DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnchorPeers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        anchorPeers = make_shared<vector<DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers>>(expect1);
      }
    }
    if (m.find("Crls") != m.end() && !m["Crls"].empty()) {
      crls = make_shared<string>(boost::any_cast<string>(m["Crls"]));
    }
    if (m.find("MspId") != m.end() && !m["MspId"].empty()) {
      mspId = make_shared<string>(boost::any_cast<string>(m["MspId"]));
    }
    if (m.find("MspType") != m.end() && !m["MspType"].empty()) {
      mspType = make_shared<string>(boost::any_cast<string>(m["MspType"]));
    }
    if (m.find("Orderer") != m.end() && !m["Orderer"].empty()) {
      orderer = make_shared<bool>(boost::any_cast<bool>(m["Orderer"]));
    }
    if (m.find("OrdererNodes") != m.end() && !m["OrdererNodes"].empty()) {
      if (typeid(vector<boost::any>) == m["OrdererNodes"].type()) {
        vector<DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OrdererNodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ordererNodes = make_shared<vector<DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes>>(expect1);
      }
    }
    if (m.find("RootCertificates") != m.end() && !m["RootCertificates"].empty()) {
      rootCertificates = make_shared<string>(boost::any_cast<string>(m["RootCertificates"]));
    }
    if (m.find("TlsRootCertificates") != m.end() && !m["TlsRootCertificates"].empty()) {
      tlsRootCertificates = make_shared<string>(boost::any_cast<string>(m["TlsRootCertificates"]));
    }
  }


  virtual ~DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizations() = default;
};
class DescribeGovernanceTaskResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGovernanceTaskResponseBodyResultContentAddedOrganizations>> addedOrganizations{};
  shared_ptr<DescribeGovernanceTaskResponseBodyResultContentChaincodeSpecPkg> chaincodeSpecPkg{};
  shared_ptr<DescribeGovernanceTaskResponseBodyResultContentOrdererConfig> ordererConfig{};
  shared_ptr<string> raw{};
  shared_ptr<vector<DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizations>> removedOrganizations{};
  shared_ptr<string> rwSets{};

  DescribeGovernanceTaskResponseBodyResultContent() {}

  explicit DescribeGovernanceTaskResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addedOrganizations) {
      vector<boost::any> temp1;
      for(auto item1:*addedOrganizations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AddedOrganizations"] = boost::any(temp1);
    }
    if (chaincodeSpecPkg) {
      res["ChaincodeSpecPkg"] = chaincodeSpecPkg ? boost::any(chaincodeSpecPkg->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ordererConfig) {
      res["OrdererConfig"] = ordererConfig ? boost::any(ordererConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (raw) {
      res["Raw"] = boost::any(*raw);
    }
    if (removedOrganizations) {
      vector<boost::any> temp1;
      for(auto item1:*removedOrganizations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RemovedOrganizations"] = boost::any(temp1);
    }
    if (rwSets) {
      res["RwSets"] = boost::any(*rwSets);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddedOrganizations") != m.end() && !m["AddedOrganizations"].empty()) {
      if (typeid(vector<boost::any>) == m["AddedOrganizations"].type()) {
        vector<DescribeGovernanceTaskResponseBodyResultContentAddedOrganizations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AddedOrganizations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGovernanceTaskResponseBodyResultContentAddedOrganizations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addedOrganizations = make_shared<vector<DescribeGovernanceTaskResponseBodyResultContentAddedOrganizations>>(expect1);
      }
    }
    if (m.find("ChaincodeSpecPkg") != m.end() && !m["ChaincodeSpecPkg"].empty()) {
      if (typeid(map<string, boost::any>) == m["ChaincodeSpecPkg"].type()) {
        DescribeGovernanceTaskResponseBodyResultContentChaincodeSpecPkg model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ChaincodeSpecPkg"]));
        chaincodeSpecPkg = make_shared<DescribeGovernanceTaskResponseBodyResultContentChaincodeSpecPkg>(model1);
      }
    }
    if (m.find("OrdererConfig") != m.end() && !m["OrdererConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OrdererConfig"].type()) {
        DescribeGovernanceTaskResponseBodyResultContentOrdererConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OrdererConfig"]));
        ordererConfig = make_shared<DescribeGovernanceTaskResponseBodyResultContentOrdererConfig>(model1);
      }
    }
    if (m.find("Raw") != m.end() && !m["Raw"].empty()) {
      raw = make_shared<string>(boost::any_cast<string>(m["Raw"]));
    }
    if (m.find("RemovedOrganizations") != m.end() && !m["RemovedOrganizations"].empty()) {
      if (typeid(vector<boost::any>) == m["RemovedOrganizations"].type()) {
        vector<DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RemovedOrganizations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        removedOrganizations = make_shared<vector<DescribeGovernanceTaskResponseBodyResultContentRemovedOrganizations>>(expect1);
      }
    }
    if (m.find("RwSets") != m.end() && !m["RwSets"].empty()) {
      rwSets = make_shared<string>(boost::any_cast<string>(m["RwSets"]));
    }
  }


  virtual ~DescribeGovernanceTaskResponseBodyResultContent() = default;
};
class DescribeGovernanceTaskResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<DescribeGovernanceTaskResponseBodyResultContent> content{};
  shared_ptr<long> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> type{};

  DescribeGovernanceTaskResponseBodyResult() {}

  explicit DescribeGovernanceTaskResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        DescribeGovernanceTaskResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<DescribeGovernanceTaskResponseBodyResultContent>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeGovernanceTaskResponseBodyResult() = default;
};
class DescribeGovernanceTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeGovernanceTaskResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeGovernanceTaskResponseBody() {}

  explicit DescribeGovernanceTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeGovernanceTaskResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeGovernanceTaskResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeGovernanceTaskResponseBody() = default;
};
class DescribeGovernanceTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGovernanceTaskResponseBody> body{};

  DescribeGovernanceTaskResponse() {}

  explicit DescribeGovernanceTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGovernanceTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGovernanceTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGovernanceTaskResponse() = default;
};
class DescribeGovernanceTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> organizationId{};

  DescribeGovernanceTasksRequest() {}

  explicit DescribeGovernanceTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeGovernanceTasksRequest() = default;
};
class DescribeGovernanceTasksResponseBodyResultContentAddedOrganizationsAnchorPeers : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<long> port{};

  DescribeGovernanceTasksResponseBodyResultContentAddedOrganizationsAnchorPeers() {}

  explicit DescribeGovernanceTasksResponseBodyResultContentAddedOrganizationsAnchorPeers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
  }


  virtual ~DescribeGovernanceTasksResponseBodyResultContentAddedOrganizationsAnchorPeers() = default;
};
class DescribeGovernanceTasksResponseBodyResultContentAddedOrganizationsOrdererNodes : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> certificate{};
  shared_ptr<string> key{};
  shared_ptr<string> tlsroot{};

  DescribeGovernanceTasksResponseBodyResultContentAddedOrganizationsOrdererNodes() {}

  explicit DescribeGovernanceTasksResponseBodyResultContentAddedOrganizationsOrdererNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (tlsroot) {
      res["Tlsroot"] = boost::any(*tlsroot);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Tlsroot") != m.end() && !m["Tlsroot"].empty()) {
      tlsroot = make_shared<string>(boost::any_cast<string>(m["Tlsroot"]));
    }
  }


  virtual ~DescribeGovernanceTasksResponseBodyResultContentAddedOrganizationsOrdererNodes() = default;
};
class DescribeGovernanceTasksResponseBodyResultContentAddedOrganizations : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGovernanceTasksResponseBodyResultContentAddedOrganizationsAnchorPeers>> anchorPeers{};
  shared_ptr<string> crls{};
  shared_ptr<string> mspId{};
  shared_ptr<string> mspType{};
  shared_ptr<bool> orderer{};
  shared_ptr<vector<DescribeGovernanceTasksResponseBodyResultContentAddedOrganizationsOrdererNodes>> ordererNodes{};
  shared_ptr<string> rootCertificates{};
  shared_ptr<string> tlsRootCertificates{};

  DescribeGovernanceTasksResponseBodyResultContentAddedOrganizations() {}

  explicit DescribeGovernanceTasksResponseBodyResultContentAddedOrganizations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (anchorPeers) {
      vector<boost::any> temp1;
      for(auto item1:*anchorPeers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnchorPeers"] = boost::any(temp1);
    }
    if (crls) {
      res["Crls"] = boost::any(*crls);
    }
    if (mspId) {
      res["MspId"] = boost::any(*mspId);
    }
    if (mspType) {
      res["MspType"] = boost::any(*mspType);
    }
    if (orderer) {
      res["Orderer"] = boost::any(*orderer);
    }
    if (ordererNodes) {
      vector<boost::any> temp1;
      for(auto item1:*ordererNodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OrdererNodes"] = boost::any(temp1);
    }
    if (rootCertificates) {
      res["RootCertificates"] = boost::any(*rootCertificates);
    }
    if (tlsRootCertificates) {
      res["TlsRootCertificates"] = boost::any(*tlsRootCertificates);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnchorPeers") != m.end() && !m["AnchorPeers"].empty()) {
      if (typeid(vector<boost::any>) == m["AnchorPeers"].type()) {
        vector<DescribeGovernanceTasksResponseBodyResultContentAddedOrganizationsAnchorPeers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnchorPeers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGovernanceTasksResponseBodyResultContentAddedOrganizationsAnchorPeers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        anchorPeers = make_shared<vector<DescribeGovernanceTasksResponseBodyResultContentAddedOrganizationsAnchorPeers>>(expect1);
      }
    }
    if (m.find("Crls") != m.end() && !m["Crls"].empty()) {
      crls = make_shared<string>(boost::any_cast<string>(m["Crls"]));
    }
    if (m.find("MspId") != m.end() && !m["MspId"].empty()) {
      mspId = make_shared<string>(boost::any_cast<string>(m["MspId"]));
    }
    if (m.find("MspType") != m.end() && !m["MspType"].empty()) {
      mspType = make_shared<string>(boost::any_cast<string>(m["MspType"]));
    }
    if (m.find("Orderer") != m.end() && !m["Orderer"].empty()) {
      orderer = make_shared<bool>(boost::any_cast<bool>(m["Orderer"]));
    }
    if (m.find("OrdererNodes") != m.end() && !m["OrdererNodes"].empty()) {
      if (typeid(vector<boost::any>) == m["OrdererNodes"].type()) {
        vector<DescribeGovernanceTasksResponseBodyResultContentAddedOrganizationsOrdererNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OrdererNodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGovernanceTasksResponseBodyResultContentAddedOrganizationsOrdererNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ordererNodes = make_shared<vector<DescribeGovernanceTasksResponseBodyResultContentAddedOrganizationsOrdererNodes>>(expect1);
      }
    }
    if (m.find("RootCertificates") != m.end() && !m["RootCertificates"].empty()) {
      rootCertificates = make_shared<string>(boost::any_cast<string>(m["RootCertificates"]));
    }
    if (m.find("TlsRootCertificates") != m.end() && !m["TlsRootCertificates"].empty()) {
      tlsRootCertificates = make_shared<string>(boost::any_cast<string>(m["TlsRootCertificates"]));
    }
  }


  virtual ~DescribeGovernanceTasksResponseBodyResultContentAddedOrganizations() = default;
};
class DescribeGovernanceTasksResponseBodyResultContentChaincodeSpecPkgCs : public Darabonba::Model {
public:
  shared_ptr<string> input{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<long> type{};
  shared_ptr<string> version{};

  DescribeGovernanceTasksResponseBodyResultContentChaincodeSpecPkgCs() {}

  explicit DescribeGovernanceTasksResponseBodyResultContentChaincodeSpecPkgCs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeGovernanceTasksResponseBodyResultContentChaincodeSpecPkgCs() = default;
};
class DescribeGovernanceTasksResponseBodyResultContentChaincodeSpecPkg : public Darabonba::Model {
public:
  shared_ptr<DescribeGovernanceTasksResponseBodyResultContentChaincodeSpecPkgCs> cs{};
  shared_ptr<string> policy{};
  shared_ptr<string> sha256{};

  DescribeGovernanceTasksResponseBodyResultContentChaincodeSpecPkg() {}

  explicit DescribeGovernanceTasksResponseBodyResultContentChaincodeSpecPkg(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cs) {
      res["Cs"] = cs ? boost::any(cs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (sha256) {
      res["Sha256"] = boost::any(*sha256);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cs") != m.end() && !m["Cs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cs"].type()) {
        DescribeGovernanceTasksResponseBodyResultContentChaincodeSpecPkgCs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cs"]));
        cs = make_shared<DescribeGovernanceTasksResponseBodyResultContentChaincodeSpecPkgCs>(model1);
      }
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Sha256") != m.end() && !m["Sha256"].empty()) {
      sha256 = make_shared<string>(boost::any_cast<string>(m["Sha256"]));
    }
  }


  virtual ~DescribeGovernanceTasksResponseBodyResultContentChaincodeSpecPkg() = default;
};
class DescribeGovernanceTasksResponseBodyResultContentOrdererConfig : public Darabonba::Model {
public:
  shared_ptr<string> batchTimeout{};
  shared_ptr<long> maxMessageCount{};
  shared_ptr<long> preferredMaxBytes{};

  DescribeGovernanceTasksResponseBodyResultContentOrdererConfig() {}

  explicit DescribeGovernanceTasksResponseBodyResultContentOrdererConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchTimeout) {
      res["BatchTimeout"] = boost::any(*batchTimeout);
    }
    if (maxMessageCount) {
      res["MaxMessageCount"] = boost::any(*maxMessageCount);
    }
    if (preferredMaxBytes) {
      res["PreferredMaxBytes"] = boost::any(*preferredMaxBytes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchTimeout") != m.end() && !m["BatchTimeout"].empty()) {
      batchTimeout = make_shared<string>(boost::any_cast<string>(m["BatchTimeout"]));
    }
    if (m.find("MaxMessageCount") != m.end() && !m["MaxMessageCount"].empty()) {
      maxMessageCount = make_shared<long>(boost::any_cast<long>(m["MaxMessageCount"]));
    }
    if (m.find("PreferredMaxBytes") != m.end() && !m["PreferredMaxBytes"].empty()) {
      preferredMaxBytes = make_shared<long>(boost::any_cast<long>(m["PreferredMaxBytes"]));
    }
  }


  virtual ~DescribeGovernanceTasksResponseBodyResultContentOrdererConfig() = default;
};
class DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizationsAnchorPeers : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<long> port{};

  DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizationsAnchorPeers() {}

  explicit DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizationsAnchorPeers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
  }


  virtual ~DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizationsAnchorPeers() = default;
};
class DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizationsOrdererNodes : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> certificate{};
  shared_ptr<string> key{};
  shared_ptr<string> tlsroot{};

  DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizationsOrdererNodes() {}

  explicit DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizationsOrdererNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (tlsroot) {
      res["Tlsroot"] = boost::any(*tlsroot);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Tlsroot") != m.end() && !m["Tlsroot"].empty()) {
      tlsroot = make_shared<string>(boost::any_cast<string>(m["Tlsroot"]));
    }
  }


  virtual ~DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizationsOrdererNodes() = default;
};
class DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizations : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizationsAnchorPeers>> anchorPeers{};
  shared_ptr<string> crls{};
  shared_ptr<string> mspId{};
  shared_ptr<string> mspType{};
  shared_ptr<bool> orderer{};
  shared_ptr<vector<DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizationsOrdererNodes>> ordererNodes{};
  shared_ptr<string> rootCertificates{};
  shared_ptr<string> tlsRootCertificates{};

  DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizations() {}

  explicit DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (anchorPeers) {
      vector<boost::any> temp1;
      for(auto item1:*anchorPeers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnchorPeers"] = boost::any(temp1);
    }
    if (crls) {
      res["Crls"] = boost::any(*crls);
    }
    if (mspId) {
      res["MspId"] = boost::any(*mspId);
    }
    if (mspType) {
      res["MspType"] = boost::any(*mspType);
    }
    if (orderer) {
      res["Orderer"] = boost::any(*orderer);
    }
    if (ordererNodes) {
      vector<boost::any> temp1;
      for(auto item1:*ordererNodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OrdererNodes"] = boost::any(temp1);
    }
    if (rootCertificates) {
      res["RootCertificates"] = boost::any(*rootCertificates);
    }
    if (tlsRootCertificates) {
      res["TlsRootCertificates"] = boost::any(*tlsRootCertificates);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnchorPeers") != m.end() && !m["AnchorPeers"].empty()) {
      if (typeid(vector<boost::any>) == m["AnchorPeers"].type()) {
        vector<DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizationsAnchorPeers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnchorPeers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizationsAnchorPeers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        anchorPeers = make_shared<vector<DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizationsAnchorPeers>>(expect1);
      }
    }
    if (m.find("Crls") != m.end() && !m["Crls"].empty()) {
      crls = make_shared<string>(boost::any_cast<string>(m["Crls"]));
    }
    if (m.find("MspId") != m.end() && !m["MspId"].empty()) {
      mspId = make_shared<string>(boost::any_cast<string>(m["MspId"]));
    }
    if (m.find("MspType") != m.end() && !m["MspType"].empty()) {
      mspType = make_shared<string>(boost::any_cast<string>(m["MspType"]));
    }
    if (m.find("Orderer") != m.end() && !m["Orderer"].empty()) {
      orderer = make_shared<bool>(boost::any_cast<bool>(m["Orderer"]));
    }
    if (m.find("OrdererNodes") != m.end() && !m["OrdererNodes"].empty()) {
      if (typeid(vector<boost::any>) == m["OrdererNodes"].type()) {
        vector<DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizationsOrdererNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OrdererNodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizationsOrdererNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ordererNodes = make_shared<vector<DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizationsOrdererNodes>>(expect1);
      }
    }
    if (m.find("RootCertificates") != m.end() && !m["RootCertificates"].empty()) {
      rootCertificates = make_shared<string>(boost::any_cast<string>(m["RootCertificates"]));
    }
    if (m.find("TlsRootCertificates") != m.end() && !m["TlsRootCertificates"].empty()) {
      tlsRootCertificates = make_shared<string>(boost::any_cast<string>(m["TlsRootCertificates"]));
    }
  }


  virtual ~DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizations() = default;
};
class DescribeGovernanceTasksResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGovernanceTasksResponseBodyResultContentAddedOrganizations>> addedOrganizations{};
  shared_ptr<DescribeGovernanceTasksResponseBodyResultContentChaincodeSpecPkg> chaincodeSpecPkg{};
  shared_ptr<DescribeGovernanceTasksResponseBodyResultContentOrdererConfig> ordererConfig{};
  shared_ptr<string> raw{};
  shared_ptr<vector<DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizations>> removedOrganizations{};
  shared_ptr<string> rwSets{};

  DescribeGovernanceTasksResponseBodyResultContent() {}

  explicit DescribeGovernanceTasksResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addedOrganizations) {
      vector<boost::any> temp1;
      for(auto item1:*addedOrganizations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AddedOrganizations"] = boost::any(temp1);
    }
    if (chaincodeSpecPkg) {
      res["ChaincodeSpecPkg"] = chaincodeSpecPkg ? boost::any(chaincodeSpecPkg->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ordererConfig) {
      res["OrdererConfig"] = ordererConfig ? boost::any(ordererConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (raw) {
      res["Raw"] = boost::any(*raw);
    }
    if (removedOrganizations) {
      vector<boost::any> temp1;
      for(auto item1:*removedOrganizations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RemovedOrganizations"] = boost::any(temp1);
    }
    if (rwSets) {
      res["RwSets"] = boost::any(*rwSets);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddedOrganizations") != m.end() && !m["AddedOrganizations"].empty()) {
      if (typeid(vector<boost::any>) == m["AddedOrganizations"].type()) {
        vector<DescribeGovernanceTasksResponseBodyResultContentAddedOrganizations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AddedOrganizations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGovernanceTasksResponseBodyResultContentAddedOrganizations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addedOrganizations = make_shared<vector<DescribeGovernanceTasksResponseBodyResultContentAddedOrganizations>>(expect1);
      }
    }
    if (m.find("ChaincodeSpecPkg") != m.end() && !m["ChaincodeSpecPkg"].empty()) {
      if (typeid(map<string, boost::any>) == m["ChaincodeSpecPkg"].type()) {
        DescribeGovernanceTasksResponseBodyResultContentChaincodeSpecPkg model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ChaincodeSpecPkg"]));
        chaincodeSpecPkg = make_shared<DescribeGovernanceTasksResponseBodyResultContentChaincodeSpecPkg>(model1);
      }
    }
    if (m.find("OrdererConfig") != m.end() && !m["OrdererConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OrdererConfig"].type()) {
        DescribeGovernanceTasksResponseBodyResultContentOrdererConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OrdererConfig"]));
        ordererConfig = make_shared<DescribeGovernanceTasksResponseBodyResultContentOrdererConfig>(model1);
      }
    }
    if (m.find("Raw") != m.end() && !m["Raw"].empty()) {
      raw = make_shared<string>(boost::any_cast<string>(m["Raw"]));
    }
    if (m.find("RemovedOrganizations") != m.end() && !m["RemovedOrganizations"].empty()) {
      if (typeid(vector<boost::any>) == m["RemovedOrganizations"].type()) {
        vector<DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RemovedOrganizations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        removedOrganizations = make_shared<vector<DescribeGovernanceTasksResponseBodyResultContentRemovedOrganizations>>(expect1);
      }
    }
    if (m.find("RwSets") != m.end() && !m["RwSets"].empty()) {
      rwSets = make_shared<string>(boost::any_cast<string>(m["RwSets"]));
    }
  }


  virtual ~DescribeGovernanceTasksResponseBodyResultContent() = default;
};
class DescribeGovernanceTasksResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<DescribeGovernanceTasksResponseBodyResultContent> content{};
  shared_ptr<long> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> type{};

  DescribeGovernanceTasksResponseBodyResult() {}

  explicit DescribeGovernanceTasksResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        DescribeGovernanceTasksResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<DescribeGovernanceTasksResponseBodyResultContent>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeGovernanceTasksResponseBodyResult() = default;
};
class DescribeGovernanceTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeGovernanceTasksResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeGovernanceTasksResponseBody() {}

  explicit DescribeGovernanceTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeGovernanceTasksResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGovernanceTasksResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeGovernanceTasksResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeGovernanceTasksResponseBody() = default;
};
class DescribeGovernanceTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeGovernanceTasksResponseBody> body{};

  DescribeGovernanceTasksResponse() {}

  explicit DescribeGovernanceTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGovernanceTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGovernanceTasksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGovernanceTasksResponse() = default;
};
class DescribeInvitationCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};

  DescribeInvitationCodeRequest() {}

  explicit DescribeInvitationCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
  }


  virtual ~DescribeInvitationCodeRequest() = default;
};
class DescribeInvitationCodeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> accepted{};
  shared_ptr<string> code{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> email{};
  shared_ptr<string> expireTime{};
  shared_ptr<long> id{};
  shared_ptr<string> sendTime{};
  shared_ptr<string> senderBid{};
  shared_ptr<long> senderId{};
  shared_ptr<string> senderName{};
  shared_ptr<string> url{};

  DescribeInvitationCodeResponseBodyResult() {}

  explicit DescribeInvitationCodeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accepted) {
      res["Accepted"] = boost::any(*accepted);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (sendTime) {
      res["SendTime"] = boost::any(*sendTime);
    }
    if (senderBid) {
      res["SenderBid"] = boost::any(*senderBid);
    }
    if (senderId) {
      res["SenderId"] = boost::any(*senderId);
    }
    if (senderName) {
      res["SenderName"] = boost::any(*senderName);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Accepted") != m.end() && !m["Accepted"].empty()) {
      accepted = make_shared<bool>(boost::any_cast<bool>(m["Accepted"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("SendTime") != m.end() && !m["SendTime"].empty()) {
      sendTime = make_shared<string>(boost::any_cast<string>(m["SendTime"]));
    }
    if (m.find("SenderBid") != m.end() && !m["SenderBid"].empty()) {
      senderBid = make_shared<string>(boost::any_cast<string>(m["SenderBid"]));
    }
    if (m.find("SenderId") != m.end() && !m["SenderId"].empty()) {
      senderId = make_shared<long>(boost::any_cast<long>(m["SenderId"]));
    }
    if (m.find("SenderName") != m.end() && !m["SenderName"].empty()) {
      senderName = make_shared<string>(boost::any_cast<string>(m["SenderName"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~DescribeInvitationCodeResponseBodyResult() = default;
};
class DescribeInvitationCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeInvitationCodeResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeInvitationCodeResponseBody() {}

  explicit DescribeInvitationCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeInvitationCodeResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeInvitationCodeResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeInvitationCodeResponseBody() = default;
};
class DescribeInvitationCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInvitationCodeResponseBody> body{};

  DescribeInvitationCodeResponse() {}

  explicit DescribeInvitationCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInvitationCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInvitationCodeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInvitationCodeResponse() = default;
};
class DescribeInvitationListRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};

  DescribeInvitationListRequest() {}

  explicit DescribeInvitationListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
  }


  virtual ~DescribeInvitationListRequest() = default;
};
class DescribeInvitationListResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> email{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> sendTime{};

  DescribeInvitationListResponseBodyResult() {}

  explicit DescribeInvitationListResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (sendTime) {
      res["SendTime"] = boost::any(*sendTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("SendTime") != m.end() && !m["SendTime"].empty()) {
      sendTime = make_shared<string>(boost::any_cast<string>(m["SendTime"]));
    }
  }


  virtual ~DescribeInvitationListResponseBodyResult() = default;
};
class DescribeInvitationListResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeInvitationListResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeInvitationListResponseBody() {}

  explicit DescribeInvitationListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeInvitationListResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInvitationListResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeInvitationListResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeInvitationListResponseBody() = default;
};
class DescribeInvitationListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInvitationListResponseBody> body{};

  DescribeInvitationListResponse() {}

  explicit DescribeInvitationListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInvitationListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInvitationListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInvitationListResponse() = default;
};
class DescribeInviterRequest : public Darabonba::Model {
public:
  shared_ptr<string> code{};

  DescribeInviterRequest() {}

  explicit DescribeInviterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~DescribeInviterRequest() = default;
};
class DescribeInviterResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> consortiumName{};
  shared_ptr<string> expireTime{};
  shared_ptr<long> inviterId{};
  shared_ptr<string> inviterName{};

  DescribeInviterResponseBodyResult() {}

  explicit DescribeInviterResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (consortiumName) {
      res["ConsortiumName"] = boost::any(*consortiumName);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (inviterId) {
      res["InviterId"] = boost::any(*inviterId);
    }
    if (inviterName) {
      res["InviterName"] = boost::any(*inviterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("ConsortiumName") != m.end() && !m["ConsortiumName"].empty()) {
      consortiumName = make_shared<string>(boost::any_cast<string>(m["ConsortiumName"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("InviterId") != m.end() && !m["InviterId"].empty()) {
      inviterId = make_shared<long>(boost::any_cast<long>(m["InviterId"]));
    }
    if (m.find("InviterName") != m.end() && !m["InviterName"].empty()) {
      inviterName = make_shared<string>(boost::any_cast<string>(m["InviterName"]));
    }
  }


  virtual ~DescribeInviterResponseBodyResult() = default;
};
class DescribeInviterResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeInviterResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeInviterResponseBody() {}

  explicit DescribeInviterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeInviterResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeInviterResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeInviterResponseBody() = default;
};
class DescribeInviterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInviterResponseBody> body{};

  DescribeInviterResponse() {}

  explicit DescribeInviterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInviterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInviterResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInviterResponse() = default;
};
class DescribeLatest15BlocksRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};

  DescribeLatest15BlocksRequest() {}

  explicit DescribeLatest15BlocksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~DescribeLatest15BlocksRequest() = default;
};
class DescribeLatest15BlocksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<map<string, boost::any>>> result{};

  DescribeLatest15BlocksResponseBody() {}

  explicit DescribeLatest15BlocksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Result"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      result = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
  }


  virtual ~DescribeLatest15BlocksResponseBody() = default;
};
class DescribeLatest15BlocksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLatest15BlocksResponseBody> body{};

  DescribeLatest15BlocksResponse() {}

  explicit DescribeLatest15BlocksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLatest15BlocksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLatest15BlocksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLatest15BlocksResponse() = default;
};
class DescribeLatest15TransDigestsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};

  DescribeLatest15TransDigestsRequest() {}

  explicit DescribeLatest15TransDigestsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~DescribeLatest15TransDigestsRequest() = default;
};
class DescribeLatest15TransDigestsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<map<string, boost::any>>> result{};

  DescribeLatest15TransDigestsResponseBody() {}

  explicit DescribeLatest15TransDigestsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Result"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      result = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
  }


  virtual ~DescribeLatest15TransDigestsResponseBody() = default;
};
class DescribeLatest15TransDigestsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLatest15TransDigestsResponseBody> body{};

  DescribeLatest15TransDigestsResponse() {}

  explicit DescribeLatest15TransDigestsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLatest15TransDigestsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLatest15TransDigestsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLatest15TransDigestsResponse() = default;
};
class DescribeLatestBlocksRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};

  DescribeLatestBlocksRequest() {}

  explicit DescribeLatestBlocksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~DescribeLatestBlocksRequest() = default;
};
class DescribeLatestBlocksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<map<string, boost::any>>> result{};

  DescribeLatestBlocksResponseBody() {}

  explicit DescribeLatestBlocksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Result"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      result = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
  }


  virtual ~DescribeLatestBlocksResponseBody() = default;
};
class DescribeLatestBlocksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLatestBlocksResponseBody> body{};

  DescribeLatestBlocksResponse() {}

  explicit DescribeLatestBlocksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLatestBlocksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLatestBlocksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLatestBlocksResponse() = default;
};
class DescribeLatestTransactionDigestsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};

  DescribeLatestTransactionDigestsRequest() {}

  explicit DescribeLatestTransactionDigestsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~DescribeLatestTransactionDigestsRequest() = default;
};
class DescribeLatestTransactionDigestsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<map<string, boost::any>>> result{};

  DescribeLatestTransactionDigestsResponseBody() {}

  explicit DescribeLatestTransactionDigestsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Result"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      result = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
  }


  virtual ~DescribeLatestTransactionDigestsResponseBody() = default;
};
class DescribeLatestTransactionDigestsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLatestTransactionDigestsResponseBody> body{};

  DescribeLatestTransactionDigestsResponse() {}

  explicit DescribeLatestTransactionDigestsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLatestTransactionDigestsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLatestTransactionDigestsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLatestTransactionDigestsResponse() = default;
};
class DescribeMemberRoleRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};

  DescribeMemberRoleRequest() {}

  explicit DescribeMemberRoleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~DescribeMemberRoleRequest() = default;
};
class DescribeMemberRoleResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> role{};

  DescribeMemberRoleResponseBodyResult() {}

  explicit DescribeMemberRoleResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (role) {
      res["Role"] = boost::any(*role);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<long>(boost::any_cast<long>(m["Role"]));
    }
  }


  virtual ~DescribeMemberRoleResponseBodyResult() = default;
};
class DescribeMemberRoleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeMemberRoleResponseBodyResult> result{};

  DescribeMemberRoleResponseBody() {}

  explicit DescribeMemberRoleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeMemberRoleResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeMemberRoleResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeMemberRoleResponseBody() = default;
};
class DescribeMemberRoleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMemberRoleResponseBody> body{};

  DescribeMemberRoleResponse() {}

  explicit DescribeMemberRoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMemberRoleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMemberRoleResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMemberRoleResponse() = default;
};
class DescribeMembersRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<long> current{};
  shared_ptr<long> pageSize{};

  DescribeMembersRequest() {}

  explicit DescribeMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeMembersRequest() = default;
};
class DescribeMembersResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> current{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  DescribeMembersResponseBodyResultPagination() {}

  explicit DescribeMembersResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~DescribeMembersResponseBodyResultPagination() = default;
};
class DescribeMembersResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<string>> memberList{};
  shared_ptr<DescribeMembersResponseBodyResultPagination> pagination{};

  DescribeMembersResponseBodyResult() {}

  explicit DescribeMembersResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memberList) {
      res["MemberList"] = boost::any(*memberList);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MemberList") != m.end() && !m["MemberList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MemberList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MemberList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      memberList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeMembersResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeMembersResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeMembersResponseBodyResult() = default;
};
class DescribeMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeMembersResponseBodyResult> result{};

  DescribeMembersResponseBody() {}

  explicit DescribeMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeMembersResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeMembersResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeMembersResponseBody() = default;
};
class DescribeMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMembersResponseBody> body{};

  DescribeMembersResponse() {}

  explicit DescribeMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMembersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMembersResponse() = default;
};
class DescribeMetricRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<string> innerIp{};
  shared_ptr<string> metric{};
  shared_ptr<string> period{};
  shared_ptr<string> port{};
  shared_ptr<string> timeArea{};

  DescribeMetricRequest() {}

  explicit DescribeMetricRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (innerIp) {
      res["InnerIp"] = boost::any(*innerIp);
    }
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (timeArea) {
      res["TimeArea"] = boost::any(*timeArea);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("InnerIp") != m.end() && !m["InnerIp"].empty()) {
      innerIp = make_shared<string>(boost::any_cast<string>(m["InnerIp"]));
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("TimeArea") != m.end() && !m["TimeArea"].empty()) {
      timeArea = make_shared<string>(boost::any_cast<string>(m["TimeArea"]));
    }
  }


  virtual ~DescribeMetricRequest() = default;
};
class DescribeMetricResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  DescribeMetricResponseBody() {}

  explicit DescribeMetricResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~DescribeMetricResponseBody() = default;
};
class DescribeMetricResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMetricResponseBody> body{};

  DescribeMetricResponse() {}

  explicit DescribeMetricResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMetricResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMetricResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMetricResponse() = default;
};
class DescribeMyBlockchainsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<long> createtime{};
  shared_ptr<long> id{};
  shared_ptr<string> rejectReason{};
  shared_ptr<string> reqAddr{};
  shared_ptr<string> signedAddr{};
  shared_ptr<long> status{};
  shared_ptr<long> updatetime{};
  shared_ptr<string> username{};

  DescribeMyBlockchainsResponseBodyResult() {}

  explicit DescribeMyBlockchainsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (createtime) {
      res["Createtime"] = boost::any(*createtime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (rejectReason) {
      res["RejectReason"] = boost::any(*rejectReason);
    }
    if (reqAddr) {
      res["ReqAddr"] = boost::any(*reqAddr);
    }
    if (signedAddr) {
      res["SignedAddr"] = boost::any(*signedAddr);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updatetime) {
      res["Updatetime"] = boost::any(*updatetime);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Createtime") != m.end() && !m["Createtime"].empty()) {
      createtime = make_shared<long>(boost::any_cast<long>(m["Createtime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RejectReason") != m.end() && !m["RejectReason"].empty()) {
      rejectReason = make_shared<string>(boost::any_cast<string>(m["RejectReason"]));
    }
    if (m.find("ReqAddr") != m.end() && !m["ReqAddr"].empty()) {
      reqAddr = make_shared<string>(boost::any_cast<string>(m["ReqAddr"]));
    }
    if (m.find("SignedAddr") != m.end() && !m["SignedAddr"].empty()) {
      signedAddr = make_shared<string>(boost::any_cast<string>(m["SignedAddr"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Updatetime") != m.end() && !m["Updatetime"].empty()) {
      updatetime = make_shared<long>(boost::any_cast<long>(m["Updatetime"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~DescribeMyBlockchainsResponseBodyResult() = default;
};
class DescribeMyBlockchainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeMyBlockchainsResponseBodyResult>> result{};

  DescribeMyBlockchainsResponseBody() {}

  explicit DescribeMyBlockchainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeMyBlockchainsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMyBlockchainsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeMyBlockchainsResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~DescribeMyBlockchainsResponseBody() = default;
};
class DescribeMyBlockchainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMyBlockchainsResponseBody> body{};

  DescribeMyBlockchainsResponse() {}

  explicit DescribeMyBlockchainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMyBlockchainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMyBlockchainsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMyBlockchainsResponse() = default;
};
class DescribeMyBlockchanInfosResponseBodyResultNodeInfoList : public Darabonba::Model {
public:
  shared_ptr<long> blockHeight{};
  shared_ptr<string> nodeName{};
  shared_ptr<bool> status{};
  shared_ptr<string> version{};

  DescribeMyBlockchanInfosResponseBodyResultNodeInfoList() {}

  explicit DescribeMyBlockchanInfosResponseBodyResultNodeInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockHeight) {
      res["BlockHeight"] = boost::any(*blockHeight);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockHeight") != m.end() && !m["BlockHeight"].empty()) {
      blockHeight = make_shared<long>(boost::any_cast<long>(m["BlockHeight"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeMyBlockchanInfosResponseBodyResultNodeInfoList() = default;
};
class DescribeMyBlockchanInfosResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> abnormalNodes{};
  shared_ptr<string> bizid{};
  shared_ptr<long> blockHeight{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> isRole{};
  shared_ptr<string> name{};
  shared_ptr<vector<DescribeMyBlockchanInfosResponseBodyResultNodeInfoList>> nodeInfoList{};
  shared_ptr<long> nodeNumber{};
  shared_ptr<bool> normal{};
  shared_ptr<long> transactionSum{};
  shared_ptr<string> version{};

  DescribeMyBlockchanInfosResponseBodyResult() {}

  explicit DescribeMyBlockchanInfosResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnormalNodes) {
      res["AbnormalNodes"] = boost::any(*abnormalNodes);
    }
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (blockHeight) {
      res["BlockHeight"] = boost::any(*blockHeight);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (isRole) {
      res["IsRole"] = boost::any(*isRole);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nodeInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*nodeInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeInfoList"] = boost::any(temp1);
    }
    if (nodeNumber) {
      res["NodeNumber"] = boost::any(*nodeNumber);
    }
    if (normal) {
      res["Normal"] = boost::any(*normal);
    }
    if (transactionSum) {
      res["TransactionSum"] = boost::any(*transactionSum);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbnormalNodes") != m.end() && !m["AbnormalNodes"].empty()) {
      abnormalNodes = make_shared<long>(boost::any_cast<long>(m["AbnormalNodes"]));
    }
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("BlockHeight") != m.end() && !m["BlockHeight"].empty()) {
      blockHeight = make_shared<long>(boost::any_cast<long>(m["BlockHeight"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("IsRole") != m.end() && !m["IsRole"].empty()) {
      isRole = make_shared<bool>(boost::any_cast<bool>(m["IsRole"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NodeInfoList") != m.end() && !m["NodeInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeInfoList"].type()) {
        vector<DescribeMyBlockchanInfosResponseBodyResultNodeInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMyBlockchanInfosResponseBodyResultNodeInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeInfoList = make_shared<vector<DescribeMyBlockchanInfosResponseBodyResultNodeInfoList>>(expect1);
      }
    }
    if (m.find("NodeNumber") != m.end() && !m["NodeNumber"].empty()) {
      nodeNumber = make_shared<long>(boost::any_cast<long>(m["NodeNumber"]));
    }
    if (m.find("Normal") != m.end() && !m["Normal"].empty()) {
      normal = make_shared<bool>(boost::any_cast<bool>(m["Normal"]));
    }
    if (m.find("TransactionSum") != m.end() && !m["TransactionSum"].empty()) {
      transactionSum = make_shared<long>(boost::any_cast<long>(m["TransactionSum"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeMyBlockchanInfosResponseBodyResult() = default;
};
class DescribeMyBlockchanInfosResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeMyBlockchanInfosResponseBodyResult>> result{};

  DescribeMyBlockchanInfosResponseBody() {}

  explicit DescribeMyBlockchanInfosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeMyBlockchanInfosResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMyBlockchanInfosResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeMyBlockchanInfosResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~DescribeMyBlockchanInfosResponseBody() = default;
};
class DescribeMyBlockchanInfosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMyBlockchanInfosResponseBody> body{};

  DescribeMyBlockchanInfosResponse() {}

  explicit DescribeMyBlockchanInfosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMyBlockchanInfosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMyBlockchanInfosResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMyBlockchanInfosResponse() = default;
};
class DescribeMySuccessAppliesResponseBodyResultNodeInfoList : public Darabonba::Model {
public:
  shared_ptr<long> blockHeight{};
  shared_ptr<string> nodeName{};
  shared_ptr<bool> status{};
  shared_ptr<string> version{};

  DescribeMySuccessAppliesResponseBodyResultNodeInfoList() {}

  explicit DescribeMySuccessAppliesResponseBodyResultNodeInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockHeight) {
      res["BlockHeight"] = boost::any(*blockHeight);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockHeight") != m.end() && !m["BlockHeight"].empty()) {
      blockHeight = make_shared<long>(boost::any_cast<long>(m["BlockHeight"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeMySuccessAppliesResponseBodyResultNodeInfoList() = default;
};
class DescribeMySuccessAppliesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> abnormalNodes{};
  shared_ptr<string> bizid{};
  shared_ptr<long> blockHeight{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> isRole{};
  shared_ptr<string> name{};
  shared_ptr<vector<DescribeMySuccessAppliesResponseBodyResultNodeInfoList>> nodeInfoList{};
  shared_ptr<long> nodeNumber{};
  shared_ptr<bool> normal{};
  shared_ptr<long> transactionSum{};
  shared_ptr<string> version{};

  DescribeMySuccessAppliesResponseBodyResult() {}

  explicit DescribeMySuccessAppliesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnormalNodes) {
      res["AbnormalNodes"] = boost::any(*abnormalNodes);
    }
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (blockHeight) {
      res["BlockHeight"] = boost::any(*blockHeight);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (isRole) {
      res["IsRole"] = boost::any(*isRole);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nodeInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*nodeInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeInfoList"] = boost::any(temp1);
    }
    if (nodeNumber) {
      res["NodeNumber"] = boost::any(*nodeNumber);
    }
    if (normal) {
      res["Normal"] = boost::any(*normal);
    }
    if (transactionSum) {
      res["TransactionSum"] = boost::any(*transactionSum);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbnormalNodes") != m.end() && !m["AbnormalNodes"].empty()) {
      abnormalNodes = make_shared<long>(boost::any_cast<long>(m["AbnormalNodes"]));
    }
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("BlockHeight") != m.end() && !m["BlockHeight"].empty()) {
      blockHeight = make_shared<long>(boost::any_cast<long>(m["BlockHeight"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("IsRole") != m.end() && !m["IsRole"].empty()) {
      isRole = make_shared<bool>(boost::any_cast<bool>(m["IsRole"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NodeInfoList") != m.end() && !m["NodeInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeInfoList"].type()) {
        vector<DescribeMySuccessAppliesResponseBodyResultNodeInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMySuccessAppliesResponseBodyResultNodeInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeInfoList = make_shared<vector<DescribeMySuccessAppliesResponseBodyResultNodeInfoList>>(expect1);
      }
    }
    if (m.find("NodeNumber") != m.end() && !m["NodeNumber"].empty()) {
      nodeNumber = make_shared<long>(boost::any_cast<long>(m["NodeNumber"]));
    }
    if (m.find("Normal") != m.end() && !m["Normal"].empty()) {
      normal = make_shared<bool>(boost::any_cast<bool>(m["Normal"]));
    }
    if (m.find("TransactionSum") != m.end() && !m["TransactionSum"].empty()) {
      transactionSum = make_shared<long>(boost::any_cast<long>(m["TransactionSum"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeMySuccessAppliesResponseBodyResult() = default;
};
class DescribeMySuccessAppliesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeMySuccessAppliesResponseBodyResult>> result{};

  DescribeMySuccessAppliesResponseBody() {}

  explicit DescribeMySuccessAppliesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeMySuccessAppliesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMySuccessAppliesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeMySuccessAppliesResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~DescribeMySuccessAppliesResponseBody() = default;
};
class DescribeMySuccessAppliesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMySuccessAppliesResponseBody> body{};

  DescribeMySuccessAppliesResponse() {}

  explicit DescribeMySuccessAppliesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMySuccessAppliesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMySuccessAppliesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMySuccessAppliesResponse() = default;
};
class DescribeMySuccessfulApplicationResponseBodyResultNodeInfoList : public Darabonba::Model {
public:
  shared_ptr<long> blockHeight{};
  shared_ptr<string> nodeName{};
  shared_ptr<bool> status{};
  shared_ptr<string> version{};

  DescribeMySuccessfulApplicationResponseBodyResultNodeInfoList() {}

  explicit DescribeMySuccessfulApplicationResponseBodyResultNodeInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockHeight) {
      res["BlockHeight"] = boost::any(*blockHeight);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockHeight") != m.end() && !m["BlockHeight"].empty()) {
      blockHeight = make_shared<long>(boost::any_cast<long>(m["BlockHeight"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeMySuccessfulApplicationResponseBodyResultNodeInfoList() = default;
};
class DescribeMySuccessfulApplicationResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> abnormalNodes{};
  shared_ptr<string> bizid{};
  shared_ptr<long> blockHeight{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> isRole{};
  shared_ptr<string> name{};
  shared_ptr<vector<DescribeMySuccessfulApplicationResponseBodyResultNodeInfoList>> nodeInfoList{};
  shared_ptr<long> nodeNumber{};
  shared_ptr<bool> normal{};
  shared_ptr<long> transactionSum{};
  shared_ptr<string> version{};

  DescribeMySuccessfulApplicationResponseBodyResult() {}

  explicit DescribeMySuccessfulApplicationResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnormalNodes) {
      res["AbnormalNodes"] = boost::any(*abnormalNodes);
    }
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (blockHeight) {
      res["BlockHeight"] = boost::any(*blockHeight);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (isRole) {
      res["IsRole"] = boost::any(*isRole);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nodeInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*nodeInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeInfoList"] = boost::any(temp1);
    }
    if (nodeNumber) {
      res["NodeNumber"] = boost::any(*nodeNumber);
    }
    if (normal) {
      res["Normal"] = boost::any(*normal);
    }
    if (transactionSum) {
      res["TransactionSum"] = boost::any(*transactionSum);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbnormalNodes") != m.end() && !m["AbnormalNodes"].empty()) {
      abnormalNodes = make_shared<long>(boost::any_cast<long>(m["AbnormalNodes"]));
    }
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("BlockHeight") != m.end() && !m["BlockHeight"].empty()) {
      blockHeight = make_shared<long>(boost::any_cast<long>(m["BlockHeight"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("IsRole") != m.end() && !m["IsRole"].empty()) {
      isRole = make_shared<bool>(boost::any_cast<bool>(m["IsRole"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NodeInfoList") != m.end() && !m["NodeInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeInfoList"].type()) {
        vector<DescribeMySuccessfulApplicationResponseBodyResultNodeInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMySuccessfulApplicationResponseBodyResultNodeInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeInfoList = make_shared<vector<DescribeMySuccessfulApplicationResponseBodyResultNodeInfoList>>(expect1);
      }
    }
    if (m.find("NodeNumber") != m.end() && !m["NodeNumber"].empty()) {
      nodeNumber = make_shared<long>(boost::any_cast<long>(m["NodeNumber"]));
    }
    if (m.find("Normal") != m.end() && !m["Normal"].empty()) {
      normal = make_shared<bool>(boost::any_cast<bool>(m["Normal"]));
    }
    if (m.find("TransactionSum") != m.end() && !m["TransactionSum"].empty()) {
      transactionSum = make_shared<long>(boost::any_cast<long>(m["TransactionSum"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeMySuccessfulApplicationResponseBodyResult() = default;
};
class DescribeMySuccessfulApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeMySuccessfulApplicationResponseBodyResult>> result{};

  DescribeMySuccessfulApplicationResponseBody() {}

  explicit DescribeMySuccessfulApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeMySuccessfulApplicationResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeMySuccessfulApplicationResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeMySuccessfulApplicationResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~DescribeMySuccessfulApplicationResponseBody() = default;
};
class DescribeMySuccessfulApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeMySuccessfulApplicationResponseBody> body{};

  DescribeMySuccessfulApplicationResponse() {}

  explicit DescribeMySuccessfulApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeMySuccessfulApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeMySuccessfulApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeMySuccessfulApplicationResponse() = default;
};
class DescribeNetstatURLRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  DescribeNetstatURLRequest() {}

  explicit DescribeNetstatURLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~DescribeNetstatURLRequest() = default;
};
class DescribeNetstatURLResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  DescribeNetstatURLResponseBody() {}

  explicit DescribeNetstatURLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeNetstatURLResponseBody() = default;
};
class DescribeNetstatURLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeNetstatURLResponseBody> body{};

  DescribeNetstatURLResponse() {}

  explicit DescribeNetstatURLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeNetstatURLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeNetstatURLResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeNetstatURLResponse() = default;
};
class DescribeOrdererLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> lines{};
  shared_ptr<string> ordererName{};

  DescribeOrdererLogsRequest() {}

  explicit DescribeOrdererLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (lines) {
      res["Lines"] = boost::any(*lines);
    }
    if (ordererName) {
      res["OrdererName"] = boost::any(*ordererName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Lines") != m.end() && !m["Lines"].empty()) {
      lines = make_shared<string>(boost::any_cast<string>(m["Lines"]));
    }
    if (m.find("OrdererName") != m.end() && !m["OrdererName"].empty()) {
      ordererName = make_shared<string>(boost::any_cast<string>(m["OrdererName"]));
    }
  }


  virtual ~DescribeOrdererLogsRequest() = default;
};
class DescribeOrdererLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  DescribeOrdererLogsResponseBody() {}

  explicit DescribeOrdererLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeOrdererLogsResponseBody() = default;
};
class DescribeOrdererLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOrdererLogsResponseBody> body{};

  DescribeOrdererLogsResponse() {}

  explicit DescribeOrdererLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOrdererLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOrdererLogsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOrdererLogsResponse() = default;
};
class DescribeOrganizationRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeOrganizationRequestTag() {}

  explicit DescribeOrganizationRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeOrganizationRequestTag() = default;
};
class DescribeOrganizationRequest : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};
  shared_ptr<vector<DescribeOrganizationRequestTag>> tag{};

  DescribeOrganizationRequest() {}

  explicit DescribeOrganizationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeOrganizationRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOrganizationRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeOrganizationRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeOrganizationRequest() = default;
};
class DescribeOrganizationResponseBodyResultTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeOrganizationResponseBodyResultTags() {}

  explicit DescribeOrganizationResponseBodyResultTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeOrganizationResponseBodyResultTags() = default;
};
class DescribeOrganizationResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> CAName{};
  shared_ptr<string> CAUrl{};
  shared_ptr<string> codeName{};
  shared_ptr<long> consortiumCount{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> MSP{};
  shared_ptr<string> name{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> ownerBid{};
  shared_ptr<string> ownerName{};
  shared_ptr<long> ownerUid{};
  shared_ptr<long> peerCount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> specName{};
  shared_ptr<string> state{};
  shared_ptr<vector<DescribeOrganizationResponseBodyResultTags>> tags{};
  shared_ptr<long> userCount{};
  shared_ptr<string> zoneId{};

  DescribeOrganizationResponseBodyResult() {}

  explicit DescribeOrganizationResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (CAName) {
      res["CAName"] = boost::any(*CAName);
    }
    if (CAUrl) {
      res["CAUrl"] = boost::any(*CAUrl);
    }
    if (codeName) {
      res["CodeName"] = boost::any(*codeName);
    }
    if (consortiumCount) {
      res["ConsortiumCount"] = boost::any(*consortiumCount);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (MSP) {
      res["MSP"] = boost::any(*MSP);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (ownerBid) {
      res["OwnerBid"] = boost::any(*ownerBid);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUid) {
      res["OwnerUid"] = boost::any(*ownerUid);
    }
    if (peerCount) {
      res["PeerCount"] = boost::any(*peerCount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (specName) {
      res["SpecName"] = boost::any(*specName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (userCount) {
      res["UserCount"] = boost::any(*userCount);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CAName") != m.end() && !m["CAName"].empty()) {
      CAName = make_shared<string>(boost::any_cast<string>(m["CAName"]));
    }
    if (m.find("CAUrl") != m.end() && !m["CAUrl"].empty()) {
      CAUrl = make_shared<string>(boost::any_cast<string>(m["CAUrl"]));
    }
    if (m.find("CodeName") != m.end() && !m["CodeName"].empty()) {
      codeName = make_shared<string>(boost::any_cast<string>(m["CodeName"]));
    }
    if (m.find("ConsortiumCount") != m.end() && !m["ConsortiumCount"].empty()) {
      consortiumCount = make_shared<long>(boost::any_cast<long>(m["ConsortiumCount"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("MSP") != m.end() && !m["MSP"].empty()) {
      MSP = make_shared<string>(boost::any_cast<string>(m["MSP"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("OwnerBid") != m.end() && !m["OwnerBid"].empty()) {
      ownerBid = make_shared<string>(boost::any_cast<string>(m["OwnerBid"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUid") != m.end() && !m["OwnerUid"].empty()) {
      ownerUid = make_shared<long>(boost::any_cast<long>(m["OwnerUid"]));
    }
    if (m.find("PeerCount") != m.end() && !m["PeerCount"].empty()) {
      peerCount = make_shared<long>(boost::any_cast<long>(m["PeerCount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SpecName") != m.end() && !m["SpecName"].empty()) {
      specName = make_shared<string>(boost::any_cast<string>(m["SpecName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeOrganizationResponseBodyResultTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOrganizationResponseBodyResultTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeOrganizationResponseBodyResultTags>>(expect1);
      }
    }
    if (m.find("UserCount") != m.end() && !m["UserCount"].empty()) {
      userCount = make_shared<long>(boost::any_cast<long>(m["UserCount"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeOrganizationResponseBodyResult() = default;
};
class DescribeOrganizationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeOrganizationResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeOrganizationResponseBody() {}

  explicit DescribeOrganizationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeOrganizationResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeOrganizationResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeOrganizationResponseBody() = default;
};
class DescribeOrganizationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOrganizationResponseBody> body{};

  DescribeOrganizationResponse() {}

  explicit DescribeOrganizationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOrganizationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOrganizationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOrganizationResponse() = default;
};
class DescribeOrganizationChaincodesRequest : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};

  DescribeOrganizationChaincodesRequest() {}

  explicit DescribeOrganizationChaincodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeOrganizationChaincodesRequest() = default;
};
class DescribeOrganizationChaincodesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> binding{};
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> chaincodePackageId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> deployTime{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<string> installed{};
  shared_ptr<bool> management{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> version{};

  DescribeOrganizationChaincodesResponseBodyResult() {}

  explicit DescribeOrganizationChaincodesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (binding) {
      res["Binding"] = boost::any(*binding);
    }
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (chaincodePackageId) {
      res["ChaincodePackageId"] = boost::any(*chaincodePackageId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (deployTime) {
      res["DeployTime"] = boost::any(*deployTime);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (installed) {
      res["Installed"] = boost::any(*installed);
    }
    if (management) {
      res["Management"] = boost::any(*management);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Binding") != m.end() && !m["Binding"].empty()) {
      binding = make_shared<bool>(boost::any_cast<bool>(m["Binding"]));
    }
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("ChaincodePackageId") != m.end() && !m["ChaincodePackageId"].empty()) {
      chaincodePackageId = make_shared<string>(boost::any_cast<string>(m["ChaincodePackageId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("DeployTime") != m.end() && !m["DeployTime"].empty()) {
      deployTime = make_shared<string>(boost::any_cast<string>(m["DeployTime"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("Installed") != m.end() && !m["Installed"].empty()) {
      installed = make_shared<string>(boost::any_cast<string>(m["Installed"]));
    }
    if (m.find("Management") != m.end() && !m["Management"].empty()) {
      management = make_shared<bool>(boost::any_cast<bool>(m["Management"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeOrganizationChaincodesResponseBodyResult() = default;
};
class DescribeOrganizationChaincodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeOrganizationChaincodesResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeOrganizationChaincodesResponseBody() {}

  explicit DescribeOrganizationChaincodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeOrganizationChaincodesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOrganizationChaincodesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeOrganizationChaincodesResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeOrganizationChaincodesResponseBody() = default;
};
class DescribeOrganizationChaincodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOrganizationChaincodesResponseBody> body{};

  DescribeOrganizationChaincodesResponse() {}

  explicit DescribeOrganizationChaincodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOrganizationChaincodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOrganizationChaincodesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOrganizationChaincodesResponse() = default;
};
class DescribeOrganizationChannelsRequest : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};

  DescribeOrganizationChannelsRequest() {}

  explicit DescribeOrganizationChannelsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeOrganizationChannelsRequest() = default;
};
class DescribeOrganizationChannelsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> batchTimeout{};
  shared_ptr<long> blockCount{};
  shared_ptr<long> chaincodeCount{};
  shared_ptr<string> channelId{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> consortiumName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deleteTime{};
  shared_ptr<bool> deleted{};
  shared_ptr<bool> hybird{};
  shared_ptr<long> maxMessageCount{};
  shared_ptr<long> memberCount{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerBid{};
  shared_ptr<string> ownerName{};
  shared_ptr<long> ownerUid{};
  shared_ptr<long> preferredMaxBytes{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};
  shared_ptr<bool> supportChannelConfig{};
  shared_ptr<string> updateTime{};

  DescribeOrganizationChannelsResponseBodyResult() {}

  explicit DescribeOrganizationChannelsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchTimeout) {
      res["BatchTimeout"] = boost::any(*batchTimeout);
    }
    if (blockCount) {
      res["BlockCount"] = boost::any(*blockCount);
    }
    if (chaincodeCount) {
      res["ChaincodeCount"] = boost::any(*chaincodeCount);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (consortiumName) {
      res["ConsortiumName"] = boost::any(*consortiumName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deleteTime) {
      res["DeleteTime"] = boost::any(*deleteTime);
    }
    if (deleted) {
      res["Deleted"] = boost::any(*deleted);
    }
    if (hybird) {
      res["Hybird"] = boost::any(*hybird);
    }
    if (maxMessageCount) {
      res["MaxMessageCount"] = boost::any(*maxMessageCount);
    }
    if (memberCount) {
      res["MemberCount"] = boost::any(*memberCount);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerBid) {
      res["OwnerBid"] = boost::any(*ownerBid);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUid) {
      res["OwnerUid"] = boost::any(*ownerUid);
    }
    if (preferredMaxBytes) {
      res["PreferredMaxBytes"] = boost::any(*preferredMaxBytes);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (supportChannelConfig) {
      res["SupportChannelConfig"] = boost::any(*supportChannelConfig);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchTimeout") != m.end() && !m["BatchTimeout"].empty()) {
      batchTimeout = make_shared<long>(boost::any_cast<long>(m["BatchTimeout"]));
    }
    if (m.find("BlockCount") != m.end() && !m["BlockCount"].empty()) {
      blockCount = make_shared<long>(boost::any_cast<long>(m["BlockCount"]));
    }
    if (m.find("ChaincodeCount") != m.end() && !m["ChaincodeCount"].empty()) {
      chaincodeCount = make_shared<long>(boost::any_cast<long>(m["ChaincodeCount"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("ConsortiumName") != m.end() && !m["ConsortiumName"].empty()) {
      consortiumName = make_shared<string>(boost::any_cast<string>(m["ConsortiumName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeleteTime") != m.end() && !m["DeleteTime"].empty()) {
      deleteTime = make_shared<string>(boost::any_cast<string>(m["DeleteTime"]));
    }
    if (m.find("Deleted") != m.end() && !m["Deleted"].empty()) {
      deleted = make_shared<bool>(boost::any_cast<bool>(m["Deleted"]));
    }
    if (m.find("Hybird") != m.end() && !m["Hybird"].empty()) {
      hybird = make_shared<bool>(boost::any_cast<bool>(m["Hybird"]));
    }
    if (m.find("MaxMessageCount") != m.end() && !m["MaxMessageCount"].empty()) {
      maxMessageCount = make_shared<long>(boost::any_cast<long>(m["MaxMessageCount"]));
    }
    if (m.find("MemberCount") != m.end() && !m["MemberCount"].empty()) {
      memberCount = make_shared<long>(boost::any_cast<long>(m["MemberCount"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerBid") != m.end() && !m["OwnerBid"].empty()) {
      ownerBid = make_shared<string>(boost::any_cast<string>(m["OwnerBid"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUid") != m.end() && !m["OwnerUid"].empty()) {
      ownerUid = make_shared<long>(boost::any_cast<long>(m["OwnerUid"]));
    }
    if (m.find("PreferredMaxBytes") != m.end() && !m["PreferredMaxBytes"].empty()) {
      preferredMaxBytes = make_shared<long>(boost::any_cast<long>(m["PreferredMaxBytes"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("SupportChannelConfig") != m.end() && !m["SupportChannelConfig"].empty()) {
      supportChannelConfig = make_shared<bool>(boost::any_cast<bool>(m["SupportChannelConfig"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeOrganizationChannelsResponseBodyResult() = default;
};
class DescribeOrganizationChannelsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeOrganizationChannelsResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeOrganizationChannelsResponseBody() {}

  explicit DescribeOrganizationChannelsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeOrganizationChannelsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOrganizationChannelsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeOrganizationChannelsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeOrganizationChannelsResponseBody() = default;
};
class DescribeOrganizationChannelsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOrganizationChannelsResponseBody> body{};

  DescribeOrganizationChannelsResponse() {}

  explicit DescribeOrganizationChannelsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOrganizationChannelsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOrganizationChannelsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOrganizationChannelsResponse() = default;
};
class DescribeOrganizationDeletableRequest : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};

  DescribeOrganizationDeletableRequest() {}

  explicit DescribeOrganizationDeletableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeOrganizationDeletableRequest() = default;
};
class DescribeOrganizationDeletableResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> codeName{};
  shared_ptr<bool> deletable{};
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<string> name{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> state{};
  shared_ptr<string> zoneId{};

  DescribeOrganizationDeletableResponseBodyResult() {}

  explicit DescribeOrganizationDeletableResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codeName) {
      res["CodeName"] = boost::any(*codeName);
    }
    if (deletable) {
      res["Deletable"] = boost::any(*deletable);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodeName") != m.end() && !m["CodeName"].empty()) {
      codeName = make_shared<string>(boost::any_cast<string>(m["CodeName"]));
    }
    if (m.find("Deletable") != m.end() && !m["Deletable"].empty()) {
      deletable = make_shared<bool>(boost::any_cast<bool>(m["Deletable"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeOrganizationDeletableResponseBodyResult() = default;
};
class DescribeOrganizationDeletableResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeOrganizationDeletableResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeOrganizationDeletableResponseBody() {}

  explicit DescribeOrganizationDeletableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeOrganizationDeletableResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeOrganizationDeletableResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeOrganizationDeletableResponseBody() = default;
};
class DescribeOrganizationDeletableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOrganizationDeletableResponseBody> body{};

  DescribeOrganizationDeletableResponse() {}

  explicit DescribeOrganizationDeletableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOrganizationDeletableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOrganizationDeletableResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOrganizationDeletableResponse() = default;
};
class DescribeOrganizationMembersRequest : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};

  DescribeOrganizationMembersRequest() {}

  explicit DescribeOrganizationMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeOrganizationMembersRequest() = default;
};
class DescribeOrganizationMembersResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> consortiumName{};
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<string> id{};
  shared_ptr<string> joinedTime{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};

  DescribeOrganizationMembersResponseBodyResult() {}

  explicit DescribeOrganizationMembersResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (consortiumName) {
      res["ConsortiumName"] = boost::any(*consortiumName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (joinedTime) {
      res["JoinedTime"] = boost::any(*joinedTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("ConsortiumName") != m.end() && !m["ConsortiumName"].empty()) {
      consortiumName = make_shared<string>(boost::any_cast<string>(m["ConsortiumName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("JoinedTime") != m.end() && !m["JoinedTime"].empty()) {
      joinedTime = make_shared<string>(boost::any_cast<string>(m["JoinedTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~DescribeOrganizationMembersResponseBodyResult() = default;
};
class DescribeOrganizationMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeOrganizationMembersResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeOrganizationMembersResponseBody() {}

  explicit DescribeOrganizationMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeOrganizationMembersResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOrganizationMembersResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeOrganizationMembersResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeOrganizationMembersResponseBody() = default;
};
class DescribeOrganizationMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOrganizationMembersResponseBody> body{};

  DescribeOrganizationMembersResponse() {}

  explicit DescribeOrganizationMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOrganizationMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOrganizationMembersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOrganizationMembersResponse() = default;
};
class DescribeOrganizationPeersRequest : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};

  DescribeOrganizationPeersRequest() {}

  explicit DescribeOrganizationPeersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeOrganizationPeersRequest() = default;
};
class DescribeOrganizationPeersResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> domain{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<bool> isAnchor{};
  shared_ptr<string> name{};
  shared_ptr<long> port{};
  shared_ptr<string> updateTime{};

  DescribeOrganizationPeersResponseBodyResult() {}

  explicit DescribeOrganizationPeersResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (isAnchor) {
      res["IsAnchor"] = boost::any(*isAnchor);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("IsAnchor") != m.end() && !m["IsAnchor"].empty()) {
      isAnchor = make_shared<bool>(boost::any_cast<bool>(m["IsAnchor"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeOrganizationPeersResponseBodyResult() = default;
};
class DescribeOrganizationPeersResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeOrganizationPeersResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeOrganizationPeersResponseBody() {}

  explicit DescribeOrganizationPeersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeOrganizationPeersResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOrganizationPeersResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeOrganizationPeersResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeOrganizationPeersResponseBody() = default;
};
class DescribeOrganizationPeersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOrganizationPeersResponseBody> body{};

  DescribeOrganizationPeersResponse() {}

  explicit DescribeOrganizationPeersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOrganizationPeersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOrganizationPeersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOrganizationPeersResponse() = default;
};
class DescribeOrganizationSpecsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};
  shared_ptr<string> name{};
  shared_ptr<string> title{};

  DescribeOrganizationSpecsResponseBodyResult() {}

  explicit DescribeOrganizationSpecsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~DescribeOrganizationSpecsResponseBodyResult() = default;
};
class DescribeOrganizationSpecsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeOrganizationSpecsResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeOrganizationSpecsResponseBody() {}

  explicit DescribeOrganizationSpecsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeOrganizationSpecsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOrganizationSpecsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeOrganizationSpecsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeOrganizationSpecsResponseBody() = default;
};
class DescribeOrganizationSpecsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOrganizationSpecsResponseBody> body{};

  DescribeOrganizationSpecsResponse() {}

  explicit DescribeOrganizationSpecsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOrganizationSpecsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOrganizationSpecsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOrganizationSpecsResponse() = default;
};
class DescribeOrganizationTriggersRequest : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};

  DescribeOrganizationTriggersRequest() {}

  explicit DescribeOrganizationTriggersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeOrganizationTriggersRequest() = default;
};
class DescribeOrganizationTriggersResponseBodyResultCheckpoint : public Darabonba::Model {
public:
  shared_ptr<long> errorCount{};
  shared_ptr<long> height{};
  shared_ptr<long> index{};
  shared_ptr<string> type{};

  DescribeOrganizationTriggersResponseBodyResultCheckpoint() {}

  explicit DescribeOrganizationTriggersResponseBodyResultCheckpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCount) {
      res["ErrorCount"] = boost::any(*errorCount);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCount") != m.end() && !m["ErrorCount"].empty()) {
      errorCount = make_shared<long>(boost::any_cast<long>(m["ErrorCount"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeOrganizationTriggersResponseBodyResultCheckpoint() = default;
};
class DescribeOrganizationTriggersResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> channelName{};
  shared_ptr<DescribeOrganizationTriggersResponseBodyResultCheckpoint> checkpoint{};
  shared_ptr<long> createTime{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> name{};
  shared_ptr<string> options{};
  shared_ptr<string> source{};
  shared_ptr<long> status{};
  shared_ptr<string> type{};

  DescribeOrganizationTriggersResponseBodyResult() {}

  explicit DescribeOrganizationTriggersResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (checkpoint) {
      res["Checkpoint"] = checkpoint ? boost::any(checkpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (options) {
      res["Options"] = boost::any(*options);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("Checkpoint") != m.end() && !m["Checkpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["Checkpoint"].type()) {
        DescribeOrganizationTriggersResponseBodyResultCheckpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Checkpoint"]));
        checkpoint = make_shared<DescribeOrganizationTriggersResponseBodyResultCheckpoint>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Options") != m.end() && !m["Options"].empty()) {
      options = make_shared<string>(boost::any_cast<string>(m["Options"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeOrganizationTriggersResponseBodyResult() = default;
};
class DescribeOrganizationTriggersResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeOrganizationTriggersResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeOrganizationTriggersResponseBody() {}

  explicit DescribeOrganizationTriggersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeOrganizationTriggersResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOrganizationTriggersResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeOrganizationTriggersResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeOrganizationTriggersResponseBody() = default;
};
class DescribeOrganizationTriggersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOrganizationTriggersResponseBody> body{};

  DescribeOrganizationTriggersResponse() {}

  explicit DescribeOrganizationTriggersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOrganizationTriggersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOrganizationTriggersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOrganizationTriggersResponse() = default;
};
class DescribeOrganizationUserCertsRequest : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};
  shared_ptr<string> username{};

  DescribeOrganizationUserCertsRequest() {}

  explicit DescribeOrganizationUserCertsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~DescribeOrganizationUserCertsRequest() = default;
};
class DescribeOrganizationUserCertsResponseBodyResultCertificates : public Darabonba::Model {
public:
  shared_ptr<string> certData{};
  shared_ptr<string> issuer{};
  shared_ptr<string> name{};
  shared_ptr<string> scope{};
  shared_ptr<string> subject{};
  shared_ptr<string> validFrom{};
  shared_ptr<string> validTo{};

  DescribeOrganizationUserCertsResponseBodyResultCertificates() {}

  explicit DescribeOrganizationUserCertsResponseBodyResultCertificates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certData) {
      res["CertData"] = boost::any(*certData);
    }
    if (issuer) {
      res["Issuer"] = boost::any(*issuer);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (scope) {
      res["Scope"] = boost::any(*scope);
    }
    if (subject) {
      res["Subject"] = boost::any(*subject);
    }
    if (validFrom) {
      res["ValidFrom"] = boost::any(*validFrom);
    }
    if (validTo) {
      res["ValidTo"] = boost::any(*validTo);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertData") != m.end() && !m["CertData"].empty()) {
      certData = make_shared<string>(boost::any_cast<string>(m["CertData"]));
    }
    if (m.find("Issuer") != m.end() && !m["Issuer"].empty()) {
      issuer = make_shared<string>(boost::any_cast<string>(m["Issuer"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Scope") != m.end() && !m["Scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["Scope"]));
    }
    if (m.find("Subject") != m.end() && !m["Subject"].empty()) {
      subject = make_shared<string>(boost::any_cast<string>(m["Subject"]));
    }
    if (m.find("ValidFrom") != m.end() && !m["ValidFrom"].empty()) {
      validFrom = make_shared<string>(boost::any_cast<string>(m["ValidFrom"]));
    }
    if (m.find("ValidTo") != m.end() && !m["ValidTo"].empty()) {
      validTo = make_shared<string>(boost::any_cast<string>(m["ValidTo"]));
    }
  }


  virtual ~DescribeOrganizationUserCertsResponseBodyResultCertificates() = default;
};
class DescribeOrganizationUserCertsResponseBodyResultKeyPair : public Darabonba::Model {
public:
  shared_ptr<string> privateKey{};
  shared_ptr<string> publicKey{};

  DescribeOrganizationUserCertsResponseBodyResultKeyPair() {}

  explicit DescribeOrganizationUserCertsResponseBodyResultKeyPair(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateKey) {
      res["PrivateKey"] = boost::any(*privateKey);
    }
    if (publicKey) {
      res["PublicKey"] = boost::any(*publicKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PrivateKey") != m.end() && !m["PrivateKey"].empty()) {
      privateKey = make_shared<string>(boost::any_cast<string>(m["PrivateKey"]));
    }
    if (m.find("PublicKey") != m.end() && !m["PublicKey"].empty()) {
      publicKey = make_shared<string>(boost::any_cast<string>(m["PublicKey"]));
    }
  }


  virtual ~DescribeOrganizationUserCertsResponseBodyResultKeyPair() = default;
};
class DescribeOrganizationUserCertsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeOrganizationUserCertsResponseBodyResultCertificates>> certificates{};
  shared_ptr<DescribeOrganizationUserCertsResponseBodyResultKeyPair> keyPair{};

  DescribeOrganizationUserCertsResponseBodyResult() {}

  explicit DescribeOrganizationUserCertsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificates) {
      vector<boost::any> temp1;
      for(auto item1:*certificates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Certificates"] = boost::any(temp1);
    }
    if (keyPair) {
      res["KeyPair"] = keyPair ? boost::any(keyPair->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Certificates") != m.end() && !m["Certificates"].empty()) {
      if (typeid(vector<boost::any>) == m["Certificates"].type()) {
        vector<DescribeOrganizationUserCertsResponseBodyResultCertificates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Certificates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOrganizationUserCertsResponseBodyResultCertificates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certificates = make_shared<vector<DescribeOrganizationUserCertsResponseBodyResultCertificates>>(expect1);
      }
    }
    if (m.find("KeyPair") != m.end() && !m["KeyPair"].empty()) {
      if (typeid(map<string, boost::any>) == m["KeyPair"].type()) {
        DescribeOrganizationUserCertsResponseBodyResultKeyPair model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["KeyPair"]));
        keyPair = make_shared<DescribeOrganizationUserCertsResponseBodyResultKeyPair>(model1);
      }
    }
  }


  virtual ~DescribeOrganizationUserCertsResponseBodyResult() = default;
};
class DescribeOrganizationUserCertsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeOrganizationUserCertsResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeOrganizationUserCertsResponseBody() {}

  explicit DescribeOrganizationUserCertsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeOrganizationUserCertsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeOrganizationUserCertsResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeOrganizationUserCertsResponseBody() = default;
};
class DescribeOrganizationUserCertsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOrganizationUserCertsResponseBody> body{};

  DescribeOrganizationUserCertsResponse() {}

  explicit DescribeOrganizationUserCertsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOrganizationUserCertsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOrganizationUserCertsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOrganizationUserCertsResponse() = default;
};
class DescribeOrganizationUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};

  DescribeOrganizationUsersRequest() {}

  explicit DescribeOrganizationUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeOrganizationUsersRequest() = default;
};
class DescribeOrganizationUsersResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> attrs{};
  shared_ptr<string> callerBid{};
  shared_ptr<long> callerUid{};
  shared_ptr<string> createTime{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> fullName{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> username{};

  DescribeOrganizationUsersResponseBodyResult() {}

  explicit DescribeOrganizationUsersResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attrs) {
      res["Attrs"] = boost::any(*attrs);
    }
    if (callerBid) {
      res["CallerBid"] = boost::any(*callerBid);
    }
    if (callerUid) {
      res["CallerUid"] = boost::any(*callerUid);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (fullName) {
      res["FullName"] = boost::any(*fullName);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attrs") != m.end() && !m["Attrs"].empty()) {
      attrs = make_shared<string>(boost::any_cast<string>(m["Attrs"]));
    }
    if (m.find("CallerBid") != m.end() && !m["CallerBid"].empty()) {
      callerBid = make_shared<string>(boost::any_cast<string>(m["CallerBid"]));
    }
    if (m.find("CallerUid") != m.end() && !m["CallerUid"].empty()) {
      callerUid = make_shared<long>(boost::any_cast<long>(m["CallerUid"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("FullName") != m.end() && !m["FullName"].empty()) {
      fullName = make_shared<string>(boost::any_cast<string>(m["FullName"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~DescribeOrganizationUsersResponseBodyResult() = default;
};
class DescribeOrganizationUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeOrganizationUsersResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeOrganizationUsersResponseBody() {}

  explicit DescribeOrganizationUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeOrganizationUsersResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOrganizationUsersResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeOrganizationUsersResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeOrganizationUsersResponseBody() = default;
};
class DescribeOrganizationUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOrganizationUsersResponseBody> body{};

  DescribeOrganizationUsersResponse() {}

  explicit DescribeOrganizationUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOrganizationUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOrganizationUsersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOrganizationUsersResponse() = default;
};
class DescribeOrganizationsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeOrganizationsRequestTag() {}

  explicit DescribeOrganizationsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeOrganizationsRequestTag() = default;
};
class DescribeOrganizationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<vector<DescribeOrganizationsRequestTag>> tag{};

  DescribeOrganizationsRequest() {}

  explicit DescribeOrganizationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeOrganizationsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOrganizationsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeOrganizationsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeOrganizationsRequest() = default;
};
class DescribeOrganizationsResponseBodyResultTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeOrganizationsResponseBodyResultTags() {}

  explicit DescribeOrganizationsResponseBodyResultTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeOrganizationsResponseBodyResultTags() = default;
};
class DescribeOrganizationsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> codeName{};
  shared_ptr<long> consortiumCount{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<string> expireState{};
  shared_ptr<string> expiredTime{};
  shared_ptr<bool> hybrid{};
  shared_ptr<string> majorVersion{};
  shared_ptr<string> name{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> ownerBid{};
  shared_ptr<string> ownerName{};
  shared_ptr<long> ownerUid{};
  shared_ptr<long> peerCount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> specName{};
  shared_ptr<string> state{};
  shared_ptr<vector<DescribeOrganizationsResponseBodyResultTags>> tags{};
  shared_ptr<long> userCount{};
  shared_ptr<string> zoneId{};

  DescribeOrganizationsResponseBodyResult() {}

  explicit DescribeOrganizationsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codeName) {
      res["CodeName"] = boost::any(*codeName);
    }
    if (consortiumCount) {
      res["ConsortiumCount"] = boost::any(*consortiumCount);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (expireState) {
      res["ExpireState"] = boost::any(*expireState);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (hybrid) {
      res["Hybrid"] = boost::any(*hybrid);
    }
    if (majorVersion) {
      res["MajorVersion"] = boost::any(*majorVersion);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (ownerBid) {
      res["OwnerBid"] = boost::any(*ownerBid);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUid) {
      res["OwnerUid"] = boost::any(*ownerUid);
    }
    if (peerCount) {
      res["PeerCount"] = boost::any(*peerCount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (specName) {
      res["SpecName"] = boost::any(*specName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (userCount) {
      res["UserCount"] = boost::any(*userCount);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodeName") != m.end() && !m["CodeName"].empty()) {
      codeName = make_shared<string>(boost::any_cast<string>(m["CodeName"]));
    }
    if (m.find("ConsortiumCount") != m.end() && !m["ConsortiumCount"].empty()) {
      consortiumCount = make_shared<long>(boost::any_cast<long>(m["ConsortiumCount"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ExpireState") != m.end() && !m["ExpireState"].empty()) {
      expireState = make_shared<string>(boost::any_cast<string>(m["ExpireState"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("Hybrid") != m.end() && !m["Hybrid"].empty()) {
      hybrid = make_shared<bool>(boost::any_cast<bool>(m["Hybrid"]));
    }
    if (m.find("MajorVersion") != m.end() && !m["MajorVersion"].empty()) {
      majorVersion = make_shared<string>(boost::any_cast<string>(m["MajorVersion"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("OwnerBid") != m.end() && !m["OwnerBid"].empty()) {
      ownerBid = make_shared<string>(boost::any_cast<string>(m["OwnerBid"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUid") != m.end() && !m["OwnerUid"].empty()) {
      ownerUid = make_shared<long>(boost::any_cast<long>(m["OwnerUid"]));
    }
    if (m.find("PeerCount") != m.end() && !m["PeerCount"].empty()) {
      peerCount = make_shared<long>(boost::any_cast<long>(m["PeerCount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SpecName") != m.end() && !m["SpecName"].empty()) {
      specName = make_shared<string>(boost::any_cast<string>(m["SpecName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeOrganizationsResponseBodyResultTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOrganizationsResponseBodyResultTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeOrganizationsResponseBodyResultTags>>(expect1);
      }
    }
    if (m.find("UserCount") != m.end() && !m["UserCount"].empty()) {
      userCount = make_shared<long>(boost::any_cast<long>(m["UserCount"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeOrganizationsResponseBodyResult() = default;
};
class DescribeOrganizationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeOrganizationsResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeOrganizationsResponseBody() {}

  explicit DescribeOrganizationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeOrganizationsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOrganizationsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeOrganizationsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeOrganizationsResponseBody() = default;
};
class DescribeOrganizationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOrganizationsResponseBody> body{};

  DescribeOrganizationsResponse() {}

  explicit DescribeOrganizationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOrganizationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOrganizationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOrganizationsResponse() = default;
};
class DescribeOrgnaizationChaincodesRequest : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};

  DescribeOrgnaizationChaincodesRequest() {}

  explicit DescribeOrgnaizationChaincodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeOrgnaizationChaincodesRequest() = default;
};
class DescribeOrgnaizationChaincodesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> deployTime{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<string> installed{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<string> state{};
  shared_ptr<string> version{};

  DescribeOrgnaizationChaincodesResponseBodyResult() {}

  explicit DescribeOrgnaizationChaincodesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (deployTime) {
      res["DeployTime"] = boost::any(*deployTime);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (installed) {
      res["Installed"] = boost::any(*installed);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("DeployTime") != m.end() && !m["DeployTime"].empty()) {
      deployTime = make_shared<string>(boost::any_cast<string>(m["DeployTime"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("Installed") != m.end() && !m["Installed"].empty()) {
      installed = make_shared<string>(boost::any_cast<string>(m["Installed"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeOrgnaizationChaincodesResponseBodyResult() = default;
};
class DescribeOrgnaizationChaincodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeOrgnaizationChaincodesResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeOrgnaizationChaincodesResponseBody() {}

  explicit DescribeOrgnaizationChaincodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeOrgnaizationChaincodesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeOrgnaizationChaincodesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeOrgnaizationChaincodesResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeOrgnaizationChaincodesResponseBody() = default;
};
class DescribeOrgnaizationChaincodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOrgnaizationChaincodesResponseBody> body{};

  DescribeOrgnaizationChaincodesResponse() {}

  explicit DescribeOrgnaizationChaincodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOrgnaizationChaincodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOrgnaizationChaincodesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOrgnaizationChaincodesResponse() = default;
};
class DescribeOssPropertiesRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};

  DescribeOssPropertiesRequest() {}

  explicit DescribeOssPropertiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~DescribeOssPropertiesRequest() = default;
};
class DescribeOssPropertiesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> accessKeyId{};
  shared_ptr<string> accessKeySecret{};
  shared_ptr<string> bucketName{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> folderName{};

  DescribeOssPropertiesResponseBodyResult() {}

  explicit DescribeOssPropertiesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKeyId) {
      res["AccessKeyId"] = boost::any(*accessKeyId);
    }
    if (accessKeySecret) {
      res["AccessKeySecret"] = boost::any(*accessKeySecret);
    }
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (folderName) {
      res["FolderName"] = boost::any(*folderName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKeyId") != m.end() && !m["AccessKeyId"].empty()) {
      accessKeyId = make_shared<string>(boost::any_cast<string>(m["AccessKeyId"]));
    }
    if (m.find("AccessKeySecret") != m.end() && !m["AccessKeySecret"].empty()) {
      accessKeySecret = make_shared<string>(boost::any_cast<string>(m["AccessKeySecret"]));
    }
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("FolderName") != m.end() && !m["FolderName"].empty()) {
      folderName = make_shared<string>(boost::any_cast<string>(m["FolderName"]));
    }
  }


  virtual ~DescribeOssPropertiesResponseBodyResult() = default;
};
class DescribeOssPropertiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeOssPropertiesResponseBodyResult> result{};

  DescribeOssPropertiesResponseBody() {}

  explicit DescribeOssPropertiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeOssPropertiesResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeOssPropertiesResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeOssPropertiesResponseBody() = default;
};
class DescribeOssPropertiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeOssPropertiesResponseBody> body{};

  DescribeOssPropertiesResponse() {}

  explicit DescribeOssPropertiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeOssPropertiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeOssPropertiesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeOssPropertiesResponse() = default;
};
class DescribePeerLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> lines{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> peerName{};

  DescribePeerLogsRequest() {}

  explicit DescribePeerLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lines) {
      res["Lines"] = boost::any(*lines);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (peerName) {
      res["PeerName"] = boost::any(*peerName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lines") != m.end() && !m["Lines"].empty()) {
      lines = make_shared<string>(boost::any_cast<string>(m["Lines"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("PeerName") != m.end() && !m["PeerName"].empty()) {
      peerName = make_shared<string>(boost::any_cast<string>(m["PeerName"]));
    }
  }


  virtual ~DescribePeerLogsRequest() = default;
};
class DescribePeerLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  DescribePeerLogsResponseBody() {}

  explicit DescribePeerLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribePeerLogsResponseBody() = default;
};
class DescribePeerLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePeerLogsResponseBody> body{};

  DescribePeerLogsResponse() {}

  explicit DescribePeerLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePeerLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePeerLogsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePeerLogsResponse() = default;
};
class DescribePublicAntChainContractProjectContentTreeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<map<string, boost::any>>> children{};

  DescribePublicAntChainContractProjectContentTreeResponseBodyResult() {}

  explicit DescribePublicAntChainContractProjectContentTreeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (children) {
      res["Children"] = boost::any(*children);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Children") != m.end() && !m["Children"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Children"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Children"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      children = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
  }


  virtual ~DescribePublicAntChainContractProjectContentTreeResponseBodyResult() = default;
};
class DescribePublicAntChainContractProjectContentTreeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribePublicAntChainContractProjectContentTreeResponseBodyResult> result{};

  DescribePublicAntChainContractProjectContentTreeResponseBody() {}

  explicit DescribePublicAntChainContractProjectContentTreeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribePublicAntChainContractProjectContentTreeResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribePublicAntChainContractProjectContentTreeResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribePublicAntChainContractProjectContentTreeResponseBody() = default;
};
class DescribePublicAntChainContractProjectContentTreeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePublicAntChainContractProjectContentTreeResponseBody> body{};

  DescribePublicAntChainContractProjectContentTreeResponse() {}

  explicit DescribePublicAntChainContractProjectContentTreeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePublicAntChainContractProjectContentTreeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePublicAntChainContractProjectContentTreeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePublicAntChainContractProjectContentTreeResponse() = default;
};
class DescribePublicAntChainDownloadPathsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};

  DescribePublicAntChainDownloadPathsRequest() {}

  explicit DescribePublicAntChainDownloadPathsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~DescribePublicAntChainDownloadPathsRequest() = default;
};
class DescribePublicAntChainDownloadPathsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> caCrtUrl{};
  shared_ptr<string> clientCrtUrl{};
  shared_ptr<string> sdkUrl{};
  shared_ptr<string> trustCaUrl{};

  DescribePublicAntChainDownloadPathsResponseBodyResult() {}

  explicit DescribePublicAntChainDownloadPathsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caCrtUrl) {
      res["CaCrtUrl"] = boost::any(*caCrtUrl);
    }
    if (clientCrtUrl) {
      res["ClientCrtUrl"] = boost::any(*clientCrtUrl);
    }
    if (sdkUrl) {
      res["SdkUrl"] = boost::any(*sdkUrl);
    }
    if (trustCaUrl) {
      res["TrustCaUrl"] = boost::any(*trustCaUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaCrtUrl") != m.end() && !m["CaCrtUrl"].empty()) {
      caCrtUrl = make_shared<string>(boost::any_cast<string>(m["CaCrtUrl"]));
    }
    if (m.find("ClientCrtUrl") != m.end() && !m["ClientCrtUrl"].empty()) {
      clientCrtUrl = make_shared<string>(boost::any_cast<string>(m["ClientCrtUrl"]));
    }
    if (m.find("SdkUrl") != m.end() && !m["SdkUrl"].empty()) {
      sdkUrl = make_shared<string>(boost::any_cast<string>(m["SdkUrl"]));
    }
    if (m.find("TrustCaUrl") != m.end() && !m["TrustCaUrl"].empty()) {
      trustCaUrl = make_shared<string>(boost::any_cast<string>(m["TrustCaUrl"]));
    }
  }


  virtual ~DescribePublicAntChainDownloadPathsResponseBodyResult() = default;
};
class DescribePublicAntChainDownloadPathsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribePublicAntChainDownloadPathsResponseBodyResult> result{};

  DescribePublicAntChainDownloadPathsResponseBody() {}

  explicit DescribePublicAntChainDownloadPathsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribePublicAntChainDownloadPathsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribePublicAntChainDownloadPathsResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribePublicAntChainDownloadPathsResponseBody() = default;
};
class DescribePublicAntChainDownloadPathsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePublicAntChainDownloadPathsResponseBody> body{};

  DescribePublicAntChainDownloadPathsResponse() {}

  explicit DescribePublicAntChainDownloadPathsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePublicAntChainDownloadPathsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePublicAntChainDownloadPathsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePublicAntChainDownloadPathsResponse() = default;
};
class DescribePublicCloudIDEEnvConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};

  DescribePublicCloudIDEEnvConfigsRequest() {}

  explicit DescribePublicCloudIDEEnvConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~DescribePublicCloudIDEEnvConfigsRequest() = default;
};
class DescribePublicCloudIDEEnvConfigsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<string> name{};
  shared_ptr<string> trialAccount{};
  shared_ptr<string> trialAccountPrivateKey{};
  shared_ptr<string> version{};

  DescribePublicCloudIDEEnvConfigsResponseBodyResult() {}

  explicit DescribePublicCloudIDEEnvConfigsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (trialAccount) {
      res["TrialAccount"] = boost::any(*trialAccount);
    }
    if (trialAccountPrivateKey) {
      res["TrialAccountPrivateKey"] = boost::any(*trialAccountPrivateKey);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("TrialAccount") != m.end() && !m["TrialAccount"].empty()) {
      trialAccount = make_shared<string>(boost::any_cast<string>(m["TrialAccount"]));
    }
    if (m.find("TrialAccountPrivateKey") != m.end() && !m["TrialAccountPrivateKey"].empty()) {
      trialAccountPrivateKey = make_shared<string>(boost::any_cast<string>(m["TrialAccountPrivateKey"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribePublicCloudIDEEnvConfigsResponseBodyResult() = default;
};
class DescribePublicCloudIDEEnvConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribePublicCloudIDEEnvConfigsResponseBodyResult>> result{};

  DescribePublicCloudIDEEnvConfigsResponseBody() {}

  explicit DescribePublicCloudIDEEnvConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribePublicCloudIDEEnvConfigsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribePublicCloudIDEEnvConfigsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribePublicCloudIDEEnvConfigsResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~DescribePublicCloudIDEEnvConfigsResponseBody() = default;
};
class DescribePublicCloudIDEEnvConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePublicCloudIDEEnvConfigsResponseBody> body{};

  DescribePublicCloudIDEEnvConfigsResponse() {}

  explicit DescribePublicCloudIDEEnvConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePublicCloudIDEEnvConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePublicCloudIDEEnvConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePublicCloudIDEEnvConfigsResponse() = default;
};
class DescribeQRCodeAccessLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};

  DescribeQRCodeAccessLogRequest() {}

  explicit DescribeQRCodeAccessLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~DescribeQRCodeAccessLogRequest() = default;
};
class DescribeQRCodeAccessLogResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> accessAlipayAccountCount{};
  shared_ptr<long> accessCount{};

  DescribeQRCodeAccessLogResponseBodyResult() {}

  explicit DescribeQRCodeAccessLogResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessAlipayAccountCount) {
      res["AccessAlipayAccountCount"] = boost::any(*accessAlipayAccountCount);
    }
    if (accessCount) {
      res["AccessCount"] = boost::any(*accessCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessAlipayAccountCount") != m.end() && !m["AccessAlipayAccountCount"].empty()) {
      accessAlipayAccountCount = make_shared<long>(boost::any_cast<long>(m["AccessAlipayAccountCount"]));
    }
    if (m.find("AccessCount") != m.end() && !m["AccessCount"].empty()) {
      accessCount = make_shared<long>(boost::any_cast<long>(m["AccessCount"]));
    }
  }


  virtual ~DescribeQRCodeAccessLogResponseBodyResult() = default;
};
class DescribeQRCodeAccessLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeQRCodeAccessLogResponseBodyResult> result{};

  DescribeQRCodeAccessLogResponseBody() {}

  explicit DescribeQRCodeAccessLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeQRCodeAccessLogResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeQRCodeAccessLogResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeQRCodeAccessLogResponseBody() = default;
};
class DescribeQRCodeAccessLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeQRCodeAccessLogResponseBody> body{};

  DescribeQRCodeAccessLogResponse() {}

  explicit DescribeQRCodeAccessLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeQRCodeAccessLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeQRCodeAccessLogResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeQRCodeAccessLogResponse() = default;
};
class DescribeQRCodeAuthorityRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};

  DescribeQRCodeAuthorityRequest() {}

  explicit DescribeQRCodeAuthorityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~DescribeQRCodeAuthorityRequest() = default;
};
class DescribeQRCodeAuthorityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  DescribeQRCodeAuthorityResponseBody() {}

  explicit DescribeQRCodeAuthorityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~DescribeQRCodeAuthorityResponseBody() = default;
};
class DescribeQRCodeAuthorityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeQRCodeAuthorityResponseBody> body{};

  DescribeQRCodeAuthorityResponse() {}

  explicit DescribeQRCodeAuthorityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeQRCodeAuthorityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeQRCodeAuthorityResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeQRCodeAuthorityResponse() = default;
};
class DescribeRegionsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<bool> online{};
  shared_ptr<string> regionId{};
  shared_ptr<string> title{};

  DescribeRegionsResponseBodyResult() {}

  explicit DescribeRegionsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (online) {
      res["Online"] = boost::any(*online);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("Online") != m.end() && !m["Online"].empty()) {
      online = make_shared<bool>(boost::any_cast<bool>(m["Online"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~DescribeRegionsResponseBodyResult() = default;
};
class DescribeRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeRegionsResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeRegionsResponseBody() {}

  explicit DescribeRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeRegionsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRegionsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeRegionsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeRegionsResponseBody() = default;
};
class DescribeRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRegionsResponseBody> body{};

  DescribeRegionsResponse() {}

  explicit DescribeRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRegionsResponse() = default;
};
class DescribeResourceTypeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> cpu{};
  shared_ptr<long> disk{};
  shared_ptr<long> memory{};
  shared_ptr<long> typeId_{};
  shared_ptr<string> typeName_{};

  DescribeResourceTypeResponseBodyResult() {}

  explicit DescribeResourceTypeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (disk) {
      res["Disk"] = boost::any(*disk);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (typeId_) {
      res["TypeId"] = boost::any(*typeId_);
    }
    if (typeName_) {
      res["TypeName"] = boost::any(*typeName_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("Disk") != m.end() && !m["Disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["Disk"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("TypeId") != m.end() && !m["TypeId"].empty()) {
      typeId_ = make_shared<long>(boost::any_cast<long>(m["TypeId"]));
    }
    if (m.find("TypeName") != m.end() && !m["TypeName"].empty()) {
      typeName_ = make_shared<string>(boost::any_cast<string>(m["TypeName"]));
    }
  }


  virtual ~DescribeResourceTypeResponseBodyResult() = default;
};
class DescribeResourceTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeResourceTypeResponseBodyResult>> result{};

  DescribeResourceTypeResponseBody() {}

  explicit DescribeResourceTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeResourceTypeResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceTypeResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeResourceTypeResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~DescribeResourceTypeResponseBody() = default;
};
class DescribeResourceTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeResourceTypeResponseBody> body{};

  DescribeResourceTypeResponse() {}

  explicit DescribeResourceTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeResourceTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeResourceTypeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeResourceTypeResponse() = default;
};
class DescribeResourceTypesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> cpu{};
  shared_ptr<long> disk{};
  shared_ptr<long> memory{};
  shared_ptr<long> typeId_{};
  shared_ptr<string> typeName_{};

  DescribeResourceTypesResponseBodyResult() {}

  explicit DescribeResourceTypesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (disk) {
      res["Disk"] = boost::any(*disk);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (typeId_) {
      res["TypeId"] = boost::any(*typeId_);
    }
    if (typeName_) {
      res["TypeName"] = boost::any(*typeName_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("Disk") != m.end() && !m["Disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["Disk"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("TypeId") != m.end() && !m["TypeId"].empty()) {
      typeId_ = make_shared<long>(boost::any_cast<long>(m["TypeId"]));
    }
    if (m.find("TypeName") != m.end() && !m["TypeName"].empty()) {
      typeName_ = make_shared<string>(boost::any_cast<string>(m["TypeName"]));
    }
  }


  virtual ~DescribeResourceTypesResponseBodyResult() = default;
};
class DescribeResourceTypesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeResourceTypesResponseBodyResult>> result{};

  DescribeResourceTypesResponseBody() {}

  explicit DescribeResourceTypesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeResourceTypesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeResourceTypesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeResourceTypesResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~DescribeResourceTypesResponseBody() = default;
};
class DescribeResourceTypesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeResourceTypesResponseBody> body{};

  DescribeResourceTypesResponse() {}

  explicit DescribeResourceTypesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeResourceTypesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeResourceTypesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeResourceTypesResponse() = default;
};
class DescribeRootDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  DescribeRootDomainResponseBody() {}

  explicit DescribeRootDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeRootDomainResponseBody() = default;
};
class DescribeRootDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRootDomainResponseBody> body{};

  DescribeRootDomainResponse() {}

  explicit DescribeRootDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRootDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRootDomainResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRootDomainResponse() = default;
};
class DescribeSchemaDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<long> schemaId{};

  DescribeSchemaDetailRequest() {}

  explicit DescribeSchemaDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (schemaId) {
      res["SchemaId"] = boost::any(*schemaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("SchemaId") != m.end() && !m["SchemaId"].empty()) {
      schemaId = make_shared<long>(boost::any_cast<long>(m["SchemaId"]));
    }
  }


  virtual ~DescribeSchemaDetailRequest() = default;
};
class DescribeSchemaDetailResponseBodyResultResponsesPropertiesDataSource : public Darabonba::Model {
public:
  shared_ptr<long> allowNull{};
  shared_ptr<string> annotation{};
  shared_ptr<string> field{};
  shared_ptr<long> indexes{};
  shared_ptr<long> key{};
  shared_ptr<long> length{};
  shared_ptr<string> reg{};
  shared_ptr<string> type{};

  DescribeSchemaDetailResponseBodyResultResponsesPropertiesDataSource() {}

  explicit DescribeSchemaDetailResponseBodyResultResponsesPropertiesDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowNull) {
      res["AllowNull"] = boost::any(*allowNull);
    }
    if (annotation) {
      res["Annotation"] = boost::any(*annotation);
    }
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (indexes) {
      res["Indexes"] = boost::any(*indexes);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (reg) {
      res["Reg"] = boost::any(*reg);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowNull") != m.end() && !m["AllowNull"].empty()) {
      allowNull = make_shared<long>(boost::any_cast<long>(m["AllowNull"]));
    }
    if (m.find("Annotation") != m.end() && !m["Annotation"].empty()) {
      annotation = make_shared<string>(boost::any_cast<string>(m["Annotation"]));
    }
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("Indexes") != m.end() && !m["Indexes"].empty()) {
      indexes = make_shared<long>(boost::any_cast<long>(m["Indexes"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<long>(boost::any_cast<long>(m["Key"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("Reg") != m.end() && !m["Reg"].empty()) {
      reg = make_shared<string>(boost::any_cast<string>(m["Reg"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeSchemaDetailResponseBodyResultResponsesPropertiesDataSource() = default;
};
class DescribeSchemaDetailResponseBodyResultResponsesProperties : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<DescribeSchemaDetailResponseBodyResultResponsesPropertiesDataSource>> dataSource{};

  DescribeSchemaDetailResponseBodyResultResponsesProperties() {}

  explicit DescribeSchemaDetailResponseBodyResultResponsesProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (dataSource) {
      vector<boost::any> temp1;
      for(auto item1:*dataSource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataSource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(vector<boost::any>) == m["DataSource"].type()) {
        vector<DescribeSchemaDetailResponseBodyResultResponsesPropertiesDataSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataSource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSchemaDetailResponseBodyResultResponsesPropertiesDataSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataSource = make_shared<vector<DescribeSchemaDetailResponseBodyResultResponsesPropertiesDataSource>>(expect1);
      }
    }
  }


  virtual ~DescribeSchemaDetailResponseBodyResultResponsesProperties() = default;
};
class DescribeSchemaDetailResponseBodyResultResponses : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> categoryName{};
  shared_ptr<string> description{};
  shared_ptr<DescribeSchemaDetailResponseBodyResultResponsesProperties> properties{};

  DescribeSchemaDetailResponseBodyResultResponses() {}

  explicit DescribeSchemaDetailResponseBodyResultResponses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (categoryName) {
      res["CategoryName"] = boost::any(*categoryName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CategoryName") != m.end() && !m["CategoryName"].empty()) {
      categoryName = make_shared<string>(boost::any_cast<string>(m["CategoryName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        DescribeSchemaDetailResponseBodyResultResponsesProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<DescribeSchemaDetailResponseBodyResultResponsesProperties>(model1);
      }
    }
  }


  virtual ~DescribeSchemaDetailResponseBodyResultResponses() = default;
};
class DescribeSchemaDetailResponseBodyResultSchema : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<bool> isTemplate{};
  shared_ptr<string> name{};
  shared_ptr<long> updateTime{};
  shared_ptr<long> version{};

  DescribeSchemaDetailResponseBodyResultSchema() {}

  explicit DescribeSchemaDetailResponseBodyResultSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsTemplate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~DescribeSchemaDetailResponseBodyResultSchema() = default;
};
class DescribeSchemaDetailResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSchemaDetailResponseBodyResultResponses>> responses{};
  shared_ptr<DescribeSchemaDetailResponseBodyResultSchema> schema{};

  DescribeSchemaDetailResponseBodyResult() {}

  explicit DescribeSchemaDetailResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (responses) {
      vector<boost::any> temp1;
      for(auto item1:*responses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Responses"] = boost::any(temp1);
    }
    if (schema) {
      res["Schema"] = schema ? boost::any(schema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Responses") != m.end() && !m["Responses"].empty()) {
      if (typeid(vector<boost::any>) == m["Responses"].type()) {
        vector<DescribeSchemaDetailResponseBodyResultResponses> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Responses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSchemaDetailResponseBodyResultResponses model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        responses = make_shared<vector<DescribeSchemaDetailResponseBodyResultResponses>>(expect1);
      }
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      if (typeid(map<string, boost::any>) == m["Schema"].type()) {
        DescribeSchemaDetailResponseBodyResultSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Schema"]));
        schema = make_shared<DescribeSchemaDetailResponseBodyResultSchema>(model1);
      }
    }
  }


  virtual ~DescribeSchemaDetailResponseBodyResult() = default;
};
class DescribeSchemaDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSchemaDetailResponseBodyResult> result{};

  DescribeSchemaDetailResponseBody() {}

  explicit DescribeSchemaDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeSchemaDetailResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeSchemaDetailResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeSchemaDetailResponseBody() = default;
};
class DescribeSchemaDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSchemaDetailResponseBody> body{};

  DescribeSchemaDetailResponse() {}

  explicit DescribeSchemaDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSchemaDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSchemaDetailResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSchemaDetailResponse() = default;
};
class DescribeSmartContractJobStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  DescribeSmartContractJobStatusRequest() {}

  explicit DescribeSmartContractJobStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~DescribeSmartContractJobStatusRequest() = default;
};
class DescribeSmartContractJobStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  DescribeSmartContractJobStatusResponseBody() {}

  explicit DescribeSmartContractJobStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeSmartContractJobStatusResponseBody() = default;
};
class DescribeSmartContractJobStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSmartContractJobStatusResponseBody> body{};

  DescribeSmartContractJobStatusResponse() {}

  explicit DescribeSmartContractJobStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSmartContractJobStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSmartContractJobStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSmartContractJobStatusResponse() = default;
};
class DescribeSmartContractJobsRequest : public Darabonba::Model {
public:
  shared_ptr<long> size{};
  shared_ptr<long> start{};

  DescribeSmartContractJobsRequest() {}

  explicit DescribeSmartContractJobsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
  }


  virtual ~DescribeSmartContractJobsRequest() = default;
};
class DescribeSmartContractJobsResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> finishedTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> status{};
  shared_ptr<string> userBid{};
  shared_ptr<long> userId{};

  DescribeSmartContractJobsResponseBodyResultContent() {}

  explicit DescribeSmartContractJobsResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishedTime) {
      res["FinishedTime"] = boost::any(*finishedTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userBid) {
      res["UserBid"] = boost::any(*userBid);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("FinishedTime") != m.end() && !m["FinishedTime"].empty()) {
      finishedTime = make_shared<long>(boost::any_cast<long>(m["FinishedTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserBid") != m.end() && !m["UserBid"].empty()) {
      userBid = make_shared<string>(boost::any_cast<string>(m["UserBid"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
  }


  virtual ~DescribeSmartContractJobsResponseBodyResultContent() = default;
};
class DescribeSmartContractJobsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSmartContractJobsResponseBodyResultContent>> content{};
  shared_ptr<bool> first{};
  shared_ptr<bool> last{};
  shared_ptr<long> numberOfElements{};
  shared_ptr<long> size{};
  shared_ptr<long> totalElements{};
  shared_ptr<long> totalPages{};

  DescribeSmartContractJobsResponseBodyResult() {}

  explicit DescribeSmartContractJobsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      vector<boost::any> temp1;
      for(auto item1:*content){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Content"] = boost::any(temp1);
    }
    if (first) {
      res["First"] = boost::any(*first);
    }
    if (last) {
      res["Last"] = boost::any(*last);
    }
    if (numberOfElements) {
      res["NumberOfElements"] = boost::any(*numberOfElements);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (totalElements) {
      res["TotalElements"] = boost::any(*totalElements);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(vector<boost::any>) == m["Content"].type()) {
        vector<DescribeSmartContractJobsResponseBodyResultContent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Content"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSmartContractJobsResponseBodyResultContent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        content = make_shared<vector<DescribeSmartContractJobsResponseBodyResultContent>>(expect1);
      }
    }
    if (m.find("First") != m.end() && !m["First"].empty()) {
      first = make_shared<bool>(boost::any_cast<bool>(m["First"]));
    }
    if (m.find("Last") != m.end() && !m["Last"].empty()) {
      last = make_shared<bool>(boost::any_cast<bool>(m["Last"]));
    }
    if (m.find("NumberOfElements") != m.end() && !m["NumberOfElements"].empty()) {
      numberOfElements = make_shared<long>(boost::any_cast<long>(m["NumberOfElements"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TotalElements") != m.end() && !m["TotalElements"].empty()) {
      totalElements = make_shared<long>(boost::any_cast<long>(m["TotalElements"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~DescribeSmartContractJobsResponseBodyResult() = default;
};
class DescribeSmartContractJobsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSmartContractJobsResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeSmartContractJobsResponseBody() {}

  explicit DescribeSmartContractJobsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeSmartContractJobsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeSmartContractJobsResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeSmartContractJobsResponseBody() = default;
};
class DescribeSmartContractJobsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSmartContractJobsResponseBody> body{};

  DescribeSmartContractJobsResponse() {}

  explicit DescribeSmartContractJobsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSmartContractJobsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSmartContractJobsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSmartContractJobsResponse() = default;
};
class DescribeSmartContractJobsByNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> size{};
  shared_ptr<long> start{};

  DescribeSmartContractJobsByNameRequest() {}

  explicit DescribeSmartContractJobsByNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
  }


  virtual ~DescribeSmartContractJobsByNameRequest() = default;
};
class DescribeSmartContractJobsByNameResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<long> finishedTime{};
  shared_ptr<string> jobId{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> status{};
  shared_ptr<string> userBid{};
  shared_ptr<string> userId{};

  DescribeSmartContractJobsByNameResponseBodyResultContent() {}

  explicit DescribeSmartContractJobsByNameResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (finishedTime) {
      res["FinishedTime"] = boost::any(*finishedTime);
    }
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (userBid) {
      res["UserBid"] = boost::any(*userBid);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("FinishedTime") != m.end() && !m["FinishedTime"].empty()) {
      finishedTime = make_shared<long>(boost::any_cast<long>(m["FinishedTime"]));
    }
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UserBid") != m.end() && !m["UserBid"].empty()) {
      userBid = make_shared<string>(boost::any_cast<string>(m["UserBid"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
  }


  virtual ~DescribeSmartContractJobsByNameResponseBodyResultContent() = default;
};
class DescribeSmartContractJobsByNameResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSmartContractJobsByNameResponseBodyResultContent>> content{};
  shared_ptr<bool> first{};
  shared_ptr<bool> last{};
  shared_ptr<long> numberOfElements{};
  shared_ptr<long> size{};
  shared_ptr<long> totalElements{};
  shared_ptr<long> totalPages{};

  DescribeSmartContractJobsByNameResponseBodyResult() {}

  explicit DescribeSmartContractJobsByNameResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      vector<boost::any> temp1;
      for(auto item1:*content){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Content"] = boost::any(temp1);
    }
    if (first) {
      res["First"] = boost::any(*first);
    }
    if (last) {
      res["Last"] = boost::any(*last);
    }
    if (numberOfElements) {
      res["NumberOfElements"] = boost::any(*numberOfElements);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (totalElements) {
      res["TotalElements"] = boost::any(*totalElements);
    }
    if (totalPages) {
      res["TotalPages"] = boost::any(*totalPages);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(vector<boost::any>) == m["Content"].type()) {
        vector<DescribeSmartContractJobsByNameResponseBodyResultContent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Content"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSmartContractJobsByNameResponseBodyResultContent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        content = make_shared<vector<DescribeSmartContractJobsByNameResponseBodyResultContent>>(expect1);
      }
    }
    if (m.find("First") != m.end() && !m["First"].empty()) {
      first = make_shared<bool>(boost::any_cast<bool>(m["First"]));
    }
    if (m.find("Last") != m.end() && !m["Last"].empty()) {
      last = make_shared<bool>(boost::any_cast<bool>(m["Last"]));
    }
    if (m.find("NumberOfElements") != m.end() && !m["NumberOfElements"].empty()) {
      numberOfElements = make_shared<long>(boost::any_cast<long>(m["NumberOfElements"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TotalElements") != m.end() && !m["TotalElements"].empty()) {
      totalElements = make_shared<long>(boost::any_cast<long>(m["TotalElements"]));
    }
    if (m.find("TotalPages") != m.end() && !m["TotalPages"].empty()) {
      totalPages = make_shared<long>(boost::any_cast<long>(m["TotalPages"]));
    }
  }


  virtual ~DescribeSmartContractJobsByNameResponseBodyResult() = default;
};
class DescribeSmartContractJobsByNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSmartContractJobsByNameResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeSmartContractJobsByNameResponseBody() {}

  explicit DescribeSmartContractJobsByNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeSmartContractJobsByNameResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeSmartContractJobsByNameResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeSmartContractJobsByNameResponseBody() = default;
};
class DescribeSmartContractJobsByNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSmartContractJobsByNameResponseBody> body{};

  DescribeSmartContractJobsByNameResponse() {}

  explicit DescribeSmartContractJobsByNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSmartContractJobsByNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSmartContractJobsByNameResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSmartContractJobsByNameResponse() = default;
};
class DescribeSmartContractResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  DescribeSmartContractResultRequest() {}

  explicit DescribeSmartContractResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~DescribeSmartContractResultRequest() = default;
};
class DescribeSmartContractResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  DescribeSmartContractResultResponseBody() {}

  explicit DescribeSmartContractResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeSmartContractResultResponseBody() = default;
};
class DescribeSmartContractResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSmartContractResultResponseBody> body{};

  DescribeSmartContractResultResponse() {}

  explicit DescribeSmartContractResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSmartContractResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSmartContractResultResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSmartContractResultResponse() = default;
};
class DescribeSmartContractResultContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};

  DescribeSmartContractResultContentRequest() {}

  explicit DescribeSmartContractResultContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
  }


  virtual ~DescribeSmartContractResultContentRequest() = default;
};
class DescribeSmartContractResultContentResponseBodyResultDiagnosticsRange : public Darabonba::Model {
public:
  shared_ptr<long> character{};
  shared_ptr<long> line{};

  DescribeSmartContractResultContentResponseBodyResultDiagnosticsRange() {}

  explicit DescribeSmartContractResultContentResponseBodyResultDiagnosticsRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (character) {
      res["Character"] = boost::any(*character);
    }
    if (line) {
      res["Line"] = boost::any(*line);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Character") != m.end() && !m["Character"].empty()) {
      character = make_shared<long>(boost::any_cast<long>(m["Character"]));
    }
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      line = make_shared<long>(boost::any_cast<long>(m["Line"]));
    }
  }


  virtual ~DescribeSmartContractResultContentResponseBodyResultDiagnosticsRange() = default;
};
class DescribeSmartContractResultContentResponseBodyResultDiagnosticsTraceLocationRange : public Darabonba::Model {
public:
  shared_ptr<long> character{};
  shared_ptr<long> line{};

  DescribeSmartContractResultContentResponseBodyResultDiagnosticsTraceLocationRange() {}

  explicit DescribeSmartContractResultContentResponseBodyResultDiagnosticsTraceLocationRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (character) {
      res["Character"] = boost::any(*character);
    }
    if (line) {
      res["Line"] = boost::any(*line);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Character") != m.end() && !m["Character"].empty()) {
      character = make_shared<long>(boost::any_cast<long>(m["Character"]));
    }
    if (m.find("Line") != m.end() && !m["Line"].empty()) {
      line = make_shared<long>(boost::any_cast<long>(m["Line"]));
    }
  }


  virtual ~DescribeSmartContractResultContentResponseBodyResultDiagnosticsTraceLocationRange() = default;
};
class DescribeSmartContractResultContentResponseBodyResultDiagnosticsTraceLocation : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSmartContractResultContentResponseBodyResultDiagnosticsTraceLocationRange>> range{};
  shared_ptr<string> uri{};

  DescribeSmartContractResultContentResponseBodyResultDiagnosticsTraceLocation() {}

  explicit DescribeSmartContractResultContentResponseBodyResultDiagnosticsTraceLocation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (range) {
      vector<boost::any> temp1;
      for(auto item1:*range){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Range"] = boost::any(temp1);
    }
    if (uri) {
      res["Uri"] = boost::any(*uri);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Range") != m.end() && !m["Range"].empty()) {
      if (typeid(vector<boost::any>) == m["Range"].type()) {
        vector<DescribeSmartContractResultContentResponseBodyResultDiagnosticsTraceLocationRange> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Range"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSmartContractResultContentResponseBodyResultDiagnosticsTraceLocationRange model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        range = make_shared<vector<DescribeSmartContractResultContentResponseBodyResultDiagnosticsTraceLocationRange>>(expect1);
      }
    }
    if (m.find("Uri") != m.end() && !m["Uri"].empty()) {
      uri = make_shared<string>(boost::any_cast<string>(m["Uri"]));
    }
  }


  virtual ~DescribeSmartContractResultContentResponseBodyResultDiagnosticsTraceLocation() = default;
};
class DescribeSmartContractResultContentResponseBodyResultDiagnosticsTrace : public Darabonba::Model {
public:
  shared_ptr<DescribeSmartContractResultContentResponseBodyResultDiagnosticsTraceLocation> location{};
  shared_ptr<string> message{};

  DescribeSmartContractResultContentResponseBodyResultDiagnosticsTrace() {}

  explicit DescribeSmartContractResultContentResponseBodyResultDiagnosticsTrace(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = location ? boost::any(location->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      if (typeid(map<string, boost::any>) == m["Location"].type()) {
        DescribeSmartContractResultContentResponseBodyResultDiagnosticsTraceLocation model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Location"]));
        location = make_shared<DescribeSmartContractResultContentResponseBodyResultDiagnosticsTraceLocation>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
  }


  virtual ~DescribeSmartContractResultContentResponseBodyResultDiagnosticsTrace() = default;
};
class DescribeSmartContractResultContentResponseBodyResultDiagnostics : public Darabonba::Model {
public:
  shared_ptr<string> advice{};
  shared_ptr<string> code{};
  shared_ptr<string> detail{};
  shared_ptr<string> message{};
  shared_ptr<vector<DescribeSmartContractResultContentResponseBodyResultDiagnosticsRange>> range{};
  shared_ptr<long> severity{};
  shared_ptr<string> source{};
  shared_ptr<vector<DescribeSmartContractResultContentResponseBodyResultDiagnosticsTrace>> trace{};

  DescribeSmartContractResultContentResponseBodyResultDiagnostics() {}

  explicit DescribeSmartContractResultContentResponseBodyResultDiagnostics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (detail) {
      res["Detail"] = boost::any(*detail);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (range) {
      vector<boost::any> temp1;
      for(auto item1:*range){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Range"] = boost::any(temp1);
    }
    if (severity) {
      res["Severity"] = boost::any(*severity);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (trace) {
      vector<boost::any> temp1;
      for(auto item1:*trace){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Trace"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      advice = make_shared<string>(boost::any_cast<string>(m["Advice"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Detail") != m.end() && !m["Detail"].empty()) {
      detail = make_shared<string>(boost::any_cast<string>(m["Detail"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Range") != m.end() && !m["Range"].empty()) {
      if (typeid(vector<boost::any>) == m["Range"].type()) {
        vector<DescribeSmartContractResultContentResponseBodyResultDiagnosticsRange> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Range"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSmartContractResultContentResponseBodyResultDiagnosticsRange model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        range = make_shared<vector<DescribeSmartContractResultContentResponseBodyResultDiagnosticsRange>>(expect1);
      }
    }
    if (m.find("Severity") != m.end() && !m["Severity"].empty()) {
      severity = make_shared<long>(boost::any_cast<long>(m["Severity"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Trace") != m.end() && !m["Trace"].empty()) {
      if (typeid(vector<boost::any>) == m["Trace"].type()) {
        vector<DescribeSmartContractResultContentResponseBodyResultDiagnosticsTrace> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Trace"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSmartContractResultContentResponseBodyResultDiagnosticsTrace model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        trace = make_shared<vector<DescribeSmartContractResultContentResponseBodyResultDiagnosticsTrace>>(expect1);
      }
    }
  }


  virtual ~DescribeSmartContractResultContentResponseBodyResultDiagnostics() = default;
};
class DescribeSmartContractResultContentResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSmartContractResultContentResponseBodyResultDiagnostics>> diagnostics{};
  shared_ptr<string> uri{};

  DescribeSmartContractResultContentResponseBodyResult() {}

  explicit DescribeSmartContractResultContentResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diagnostics) {
      vector<boost::any> temp1;
      for(auto item1:*diagnostics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Diagnostics"] = boost::any(temp1);
    }
    if (uri) {
      res["Uri"] = boost::any(*uri);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Diagnostics") != m.end() && !m["Diagnostics"].empty()) {
      if (typeid(vector<boost::any>) == m["Diagnostics"].type()) {
        vector<DescribeSmartContractResultContentResponseBodyResultDiagnostics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Diagnostics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSmartContractResultContentResponseBodyResultDiagnostics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        diagnostics = make_shared<vector<DescribeSmartContractResultContentResponseBodyResultDiagnostics>>(expect1);
      }
    }
    if (m.find("Uri") != m.end() && !m["Uri"].empty()) {
      uri = make_shared<string>(boost::any_cast<string>(m["Uri"]));
    }
  }


  virtual ~DescribeSmartContractResultContentResponseBodyResult() = default;
};
class DescribeSmartContractResultContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSmartContractResultContentResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeSmartContractResultContentResponseBody() {}

  explicit DescribeSmartContractResultContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeSmartContractResultContentResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSmartContractResultContentResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeSmartContractResultContentResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeSmartContractResultContentResponseBody() = default;
};
class DescribeSmartContractResultContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSmartContractResultContentResponseBody> body{};

  DescribeSmartContractResultContentResponse() {}

  explicit DescribeSmartContractResultContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSmartContractResultContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSmartContractResultContentResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSmartContractResultContentResponse() = default;
};
class DescribeSubscribeCloudServiceIntegrationStateRequest : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};

  DescribeSubscribeCloudServiceIntegrationStateRequest() {}

  explicit DescribeSubscribeCloudServiceIntegrationStateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeSubscribeCloudServiceIntegrationStateRequest() = default;
};
class DescribeSubscribeCloudServiceIntegrationStateResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  DescribeSubscribeCloudServiceIntegrationStateResponseBody() {}

  explicit DescribeSubscribeCloudServiceIntegrationStateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeSubscribeCloudServiceIntegrationStateResponseBody() = default;
};
class DescribeSubscribeCloudServiceIntegrationStateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSubscribeCloudServiceIntegrationStateResponseBody> body{};

  DescribeSubscribeCloudServiceIntegrationStateResponse() {}

  explicit DescribeSubscribeCloudServiceIntegrationStateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSubscribeCloudServiceIntegrationStateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSubscribeCloudServiceIntegrationStateResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSubscribeCloudServiceIntegrationStateResponse() = default;
};
class DescribeTasksResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> assignee{};
  shared_ptr<bool> handled{};
  shared_ptr<string> operationType{};
  shared_ptr<long> requestTime{};
  shared_ptr<string> responseTime{};
  shared_ptr<string> result{};
  shared_ptr<string> sender{};
  shared_ptr<string> target{};
  shared_ptr<long> taskId{};
  shared_ptr<string> taskState{};

  DescribeTasksResponseBodyResult() {}

  explicit DescribeTasksResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (assignee) {
      res["Assignee"] = boost::any(*assignee);
    }
    if (handled) {
      res["Handled"] = boost::any(*handled);
    }
    if (operationType) {
      res["OperationType"] = boost::any(*operationType);
    }
    if (requestTime) {
      res["RequestTime"] = boost::any(*requestTime);
    }
    if (responseTime) {
      res["ResponseTime"] = boost::any(*responseTime);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (sender) {
      res["Sender"] = boost::any(*sender);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskState) {
      res["TaskState"] = boost::any(*taskState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Assignee") != m.end() && !m["Assignee"].empty()) {
      assignee = make_shared<string>(boost::any_cast<string>(m["Assignee"]));
    }
    if (m.find("Handled") != m.end() && !m["Handled"].empty()) {
      handled = make_shared<bool>(boost::any_cast<bool>(m["Handled"]));
    }
    if (m.find("OperationType") != m.end() && !m["OperationType"].empty()) {
      operationType = make_shared<string>(boost::any_cast<string>(m["OperationType"]));
    }
    if (m.find("RequestTime") != m.end() && !m["RequestTime"].empty()) {
      requestTime = make_shared<long>(boost::any_cast<long>(m["RequestTime"]));
    }
    if (m.find("ResponseTime") != m.end() && !m["ResponseTime"].empty()) {
      responseTime = make_shared<string>(boost::any_cast<string>(m["ResponseTime"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Sender") != m.end() && !m["Sender"].empty()) {
      sender = make_shared<string>(boost::any_cast<string>(m["Sender"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
    if (m.find("TaskState") != m.end() && !m["TaskState"].empty()) {
      taskState = make_shared<string>(boost::any_cast<string>(m["TaskState"]));
    }
  }


  virtual ~DescribeTasksResponseBodyResult() = default;
};
class DescribeTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeTasksResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeTasksResponseBody() {}

  explicit DescribeTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeTasksResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTasksResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeTasksResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeTasksResponseBody() = default;
};
class DescribeTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTasksResponseBody> body{};

  DescribeTasksResponse() {}

  explicit DescribeTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTasksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTasksResponse() = default;
};
class DescribeTemplatesResponseBodyResultSchemaList : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<long> isTemplate{};
  shared_ptr<string> name{};
  shared_ptr<long> updateTime{};
  shared_ptr<long> version{};

  DescribeTemplatesResponseBodyResultSchemaList() {}

  explicit DescribeTemplatesResponseBodyResultSchemaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<long>(boost::any_cast<long>(m["IsTemplate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~DescribeTemplatesResponseBodyResultSchemaList() = default;
};
class DescribeTemplatesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeTemplatesResponseBodyResultSchemaList>> schemaList{};

  DescribeTemplatesResponseBodyResult() {}

  explicit DescribeTemplatesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (schemaList) {
      vector<boost::any> temp1;
      for(auto item1:*schemaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SchemaList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SchemaList") != m.end() && !m["SchemaList"].empty()) {
      if (typeid(vector<boost::any>) == m["SchemaList"].type()) {
        vector<DescribeTemplatesResponseBodyResultSchemaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SchemaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTemplatesResponseBodyResultSchemaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        schemaList = make_shared<vector<DescribeTemplatesResponseBodyResultSchemaList>>(expect1);
      }
    }
  }


  virtual ~DescribeTemplatesResponseBodyResult() = default;
};
class DescribeTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeTemplatesResponseBodyResult> result{};

  DescribeTemplatesResponseBody() {}

  explicit DescribeTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeTemplatesResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeTemplatesResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeTemplatesResponseBody() = default;
};
class DescribeTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTemplatesResponseBody> body{};

  DescribeTemplatesResponse() {}

  explicit DescribeTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTemplatesResponse() = default;
};
class DescribeTransactionRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<string> hash{};

  DescribeTransactionRequest() {}

  explicit DescribeTransactionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (hash) {
      res["Hash"] = boost::any(*hash);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Hash") != m.end() && !m["Hash"].empty()) {
      hash = make_shared<string>(boost::any_cast<string>(m["Hash"]));
    }
  }


  virtual ~DescribeTransactionRequest() = default;
};
class DescribeTransactionResponseBodyResultTransactionV10 : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<vector<string>> extentions{};
  shared_ptr<string> from{};
  shared_ptr<string> gas{};
  shared_ptr<string> hash{};
  shared_ptr<string> nonce{};
  shared_ptr<long> period{};
  shared_ptr<vector<string>> signatureList{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> to{};
  shared_ptr<string> txType{};
  shared_ptr<string> value{};

  DescribeTransactionResponseBodyResultTransactionV10() {}

  explicit DescribeTransactionResponseBodyResultTransactionV10(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (extentions) {
      res["Extentions"] = boost::any(*extentions);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (gas) {
      res["Gas"] = boost::any(*gas);
    }
    if (hash) {
      res["Hash"] = boost::any(*hash);
    }
    if (nonce) {
      res["Nonce"] = boost::any(*nonce);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (signatureList) {
      res["SignatureList"] = boost::any(*signatureList);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    if (txType) {
      res["TxType"] = boost::any(*txType);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Extentions") != m.end() && !m["Extentions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Extentions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Extentions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      extentions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("Gas") != m.end() && !m["Gas"].empty()) {
      gas = make_shared<string>(boost::any_cast<string>(m["Gas"]));
    }
    if (m.find("Hash") != m.end() && !m["Hash"].empty()) {
      hash = make_shared<string>(boost::any_cast<string>(m["Hash"]));
    }
    if (m.find("Nonce") != m.end() && !m["Nonce"].empty()) {
      nonce = make_shared<string>(boost::any_cast<string>(m["Nonce"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("SignatureList") != m.end() && !m["SignatureList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignatureList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignatureList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signatureList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<string>(boost::any_cast<string>(m["To"]));
    }
    if (m.find("TxType") != m.end() && !m["TxType"].empty()) {
      txType = make_shared<string>(boost::any_cast<string>(m["TxType"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeTransactionResponseBodyResultTransactionV10() = default;
};
class DescribeTransactionResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> blockHash{};
  shared_ptr<long> blockHeight{};
  shared_ptr<long> blockVersion{};
  shared_ptr<long> category{};
  shared_ptr<string> content{};
  shared_ptr<string> contentHash{};
  shared_ptr<long> createTime{};
  shared_ptr<string> hash{};
  shared_ptr<string> keyName{};
  shared_ptr<string> keyWrap{};
  shared_ptr<string> nonce{};
  shared_ptr<long> referenceCount{};
  shared_ptr<vector<string>> referenceList{};
  shared_ptr<string> transTypeV6{};
  shared_ptr<DescribeTransactionResponseBodyResultTransactionV10> transactionV10{};

  DescribeTransactionResponseBodyResult() {}

  explicit DescribeTransactionResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockHash) {
      res["BlockHash"] = boost::any(*blockHash);
    }
    if (blockHeight) {
      res["BlockHeight"] = boost::any(*blockHeight);
    }
    if (blockVersion) {
      res["BlockVersion"] = boost::any(*blockVersion);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentHash) {
      res["ContentHash"] = boost::any(*contentHash);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (hash) {
      res["Hash"] = boost::any(*hash);
    }
    if (keyName) {
      res["KeyName"] = boost::any(*keyName);
    }
    if (keyWrap) {
      res["KeyWrap"] = boost::any(*keyWrap);
    }
    if (nonce) {
      res["Nonce"] = boost::any(*nonce);
    }
    if (referenceCount) {
      res["ReferenceCount"] = boost::any(*referenceCount);
    }
    if (referenceList) {
      res["ReferenceList"] = boost::any(*referenceList);
    }
    if (transTypeV6) {
      res["TransTypeV6"] = boost::any(*transTypeV6);
    }
    if (transactionV10) {
      res["TransactionV10"] = transactionV10 ? boost::any(transactionV10->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockHash") != m.end() && !m["BlockHash"].empty()) {
      blockHash = make_shared<string>(boost::any_cast<string>(m["BlockHash"]));
    }
    if (m.find("BlockHeight") != m.end() && !m["BlockHeight"].empty()) {
      blockHeight = make_shared<long>(boost::any_cast<long>(m["BlockHeight"]));
    }
    if (m.find("BlockVersion") != m.end() && !m["BlockVersion"].empty()) {
      blockVersion = make_shared<long>(boost::any_cast<long>(m["BlockVersion"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<long>(boost::any_cast<long>(m["Category"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentHash") != m.end() && !m["ContentHash"].empty()) {
      contentHash = make_shared<string>(boost::any_cast<string>(m["ContentHash"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Hash") != m.end() && !m["Hash"].empty()) {
      hash = make_shared<string>(boost::any_cast<string>(m["Hash"]));
    }
    if (m.find("KeyName") != m.end() && !m["KeyName"].empty()) {
      keyName = make_shared<string>(boost::any_cast<string>(m["KeyName"]));
    }
    if (m.find("KeyWrap") != m.end() && !m["KeyWrap"].empty()) {
      keyWrap = make_shared<string>(boost::any_cast<string>(m["KeyWrap"]));
    }
    if (m.find("Nonce") != m.end() && !m["Nonce"].empty()) {
      nonce = make_shared<string>(boost::any_cast<string>(m["Nonce"]));
    }
    if (m.find("ReferenceCount") != m.end() && !m["ReferenceCount"].empty()) {
      referenceCount = make_shared<long>(boost::any_cast<long>(m["ReferenceCount"]));
    }
    if (m.find("ReferenceList") != m.end() && !m["ReferenceList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReferenceList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReferenceList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      referenceList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TransTypeV6") != m.end() && !m["TransTypeV6"].empty()) {
      transTypeV6 = make_shared<string>(boost::any_cast<string>(m["TransTypeV6"]));
    }
    if (m.find("TransactionV10") != m.end() && !m["TransactionV10"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransactionV10"].type()) {
        DescribeTransactionResponseBodyResultTransactionV10 model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransactionV10"]));
        transactionV10 = make_shared<DescribeTransactionResponseBodyResultTransactionV10>(model1);
      }
    }
  }


  virtual ~DescribeTransactionResponseBodyResult() = default;
};
class DescribeTransactionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeTransactionResponseBodyResult> result{};

  DescribeTransactionResponseBody() {}

  explicit DescribeTransactionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeTransactionResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeTransactionResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeTransactionResponseBody() = default;
};
class DescribeTransactionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTransactionResponseBody> body{};

  DescribeTransactionResponse() {}

  explicit DescribeTransactionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTransactionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTransactionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTransactionResponse() = default;
};
class DescribeTransactionFor2CBrowserRequest : public Darabonba::Model {
public:
  shared_ptr<string> alipayAuthCode{};
  shared_ptr<string> bizid{};
  shared_ptr<string> hash{};

  DescribeTransactionFor2CBrowserRequest() {}

  explicit DescribeTransactionFor2CBrowserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alipayAuthCode) {
      res["AlipayAuthCode"] = boost::any(*alipayAuthCode);
    }
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (hash) {
      res["Hash"] = boost::any(*hash);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlipayAuthCode") != m.end() && !m["AlipayAuthCode"].empty()) {
      alipayAuthCode = make_shared<string>(boost::any_cast<string>(m["AlipayAuthCode"]));
    }
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Hash") != m.end() && !m["Hash"].empty()) {
      hash = make_shared<string>(boost::any_cast<string>(m["Hash"]));
    }
  }


  virtual ~DescribeTransactionFor2CBrowserRequest() = default;
};
class DescribeTransactionFor2CBrowserResponseBodyResultTransactionV10 : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<vector<string>> extentions{};
  shared_ptr<string> from{};
  shared_ptr<string> gas{};
  shared_ptr<string> hash{};
  shared_ptr<string> nonce{};
  shared_ptr<long> period{};
  shared_ptr<vector<string>> signatureList{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> to{};
  shared_ptr<string> txType{};
  shared_ptr<string> value{};

  DescribeTransactionFor2CBrowserResponseBodyResultTransactionV10() {}

  explicit DescribeTransactionFor2CBrowserResponseBodyResultTransactionV10(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (extentions) {
      res["Extentions"] = boost::any(*extentions);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (gas) {
      res["Gas"] = boost::any(*gas);
    }
    if (hash) {
      res["Hash"] = boost::any(*hash);
    }
    if (nonce) {
      res["Nonce"] = boost::any(*nonce);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (signatureList) {
      res["SignatureList"] = boost::any(*signatureList);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    if (txType) {
      res["TxType"] = boost::any(*txType);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Extentions") != m.end() && !m["Extentions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Extentions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Extentions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      extentions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("Gas") != m.end() && !m["Gas"].empty()) {
      gas = make_shared<string>(boost::any_cast<string>(m["Gas"]));
    }
    if (m.find("Hash") != m.end() && !m["Hash"].empty()) {
      hash = make_shared<string>(boost::any_cast<string>(m["Hash"]));
    }
    if (m.find("Nonce") != m.end() && !m["Nonce"].empty()) {
      nonce = make_shared<string>(boost::any_cast<string>(m["Nonce"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("SignatureList") != m.end() && !m["SignatureList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SignatureList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SignatureList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signatureList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<string>(boost::any_cast<string>(m["To"]));
    }
    if (m.find("TxType") != m.end() && !m["TxType"].empty()) {
      txType = make_shared<string>(boost::any_cast<string>(m["TxType"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeTransactionFor2CBrowserResponseBodyResultTransactionV10() = default;
};
class DescribeTransactionFor2CBrowserResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> blockHash{};
  shared_ptr<long> blockHeight{};
  shared_ptr<long> blockVersion{};
  shared_ptr<long> category{};
  shared_ptr<string> content{};
  shared_ptr<string> contentHash{};
  shared_ptr<long> createTime{};
  shared_ptr<string> hash{};
  shared_ptr<string> keyName{};
  shared_ptr<string> keyWrap{};
  shared_ptr<string> nonce{};
  shared_ptr<long> referenceCount{};
  shared_ptr<vector<string>> referenceList{};
  shared_ptr<string> transTypeV6{};
  shared_ptr<DescribeTransactionFor2CBrowserResponseBodyResultTransactionV10> transactionV10{};

  DescribeTransactionFor2CBrowserResponseBodyResult() {}

  explicit DescribeTransactionFor2CBrowserResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockHash) {
      res["BlockHash"] = boost::any(*blockHash);
    }
    if (blockHeight) {
      res["BlockHeight"] = boost::any(*blockHeight);
    }
    if (blockVersion) {
      res["BlockVersion"] = boost::any(*blockVersion);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentHash) {
      res["ContentHash"] = boost::any(*contentHash);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (hash) {
      res["Hash"] = boost::any(*hash);
    }
    if (keyName) {
      res["KeyName"] = boost::any(*keyName);
    }
    if (keyWrap) {
      res["KeyWrap"] = boost::any(*keyWrap);
    }
    if (nonce) {
      res["Nonce"] = boost::any(*nonce);
    }
    if (referenceCount) {
      res["ReferenceCount"] = boost::any(*referenceCount);
    }
    if (referenceList) {
      res["ReferenceList"] = boost::any(*referenceList);
    }
    if (transTypeV6) {
      res["TransTypeV6"] = boost::any(*transTypeV6);
    }
    if (transactionV10) {
      res["TransactionV10"] = transactionV10 ? boost::any(transactionV10->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockHash") != m.end() && !m["BlockHash"].empty()) {
      blockHash = make_shared<string>(boost::any_cast<string>(m["BlockHash"]));
    }
    if (m.find("BlockHeight") != m.end() && !m["BlockHeight"].empty()) {
      blockHeight = make_shared<long>(boost::any_cast<long>(m["BlockHeight"]));
    }
    if (m.find("BlockVersion") != m.end() && !m["BlockVersion"].empty()) {
      blockVersion = make_shared<long>(boost::any_cast<long>(m["BlockVersion"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<long>(boost::any_cast<long>(m["Category"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentHash") != m.end() && !m["ContentHash"].empty()) {
      contentHash = make_shared<string>(boost::any_cast<string>(m["ContentHash"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Hash") != m.end() && !m["Hash"].empty()) {
      hash = make_shared<string>(boost::any_cast<string>(m["Hash"]));
    }
    if (m.find("KeyName") != m.end() && !m["KeyName"].empty()) {
      keyName = make_shared<string>(boost::any_cast<string>(m["KeyName"]));
    }
    if (m.find("KeyWrap") != m.end() && !m["KeyWrap"].empty()) {
      keyWrap = make_shared<string>(boost::any_cast<string>(m["KeyWrap"]));
    }
    if (m.find("Nonce") != m.end() && !m["Nonce"].empty()) {
      nonce = make_shared<string>(boost::any_cast<string>(m["Nonce"]));
    }
    if (m.find("ReferenceCount") != m.end() && !m["ReferenceCount"].empty()) {
      referenceCount = make_shared<long>(boost::any_cast<long>(m["ReferenceCount"]));
    }
    if (m.find("ReferenceList") != m.end() && !m["ReferenceList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ReferenceList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ReferenceList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      referenceList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("TransTypeV6") != m.end() && !m["TransTypeV6"].empty()) {
      transTypeV6 = make_shared<string>(boost::any_cast<string>(m["TransTypeV6"]));
    }
    if (m.find("TransactionV10") != m.end() && !m["TransactionV10"].empty()) {
      if (typeid(map<string, boost::any>) == m["TransactionV10"].type()) {
        DescribeTransactionFor2CBrowserResponseBodyResultTransactionV10 model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TransactionV10"]));
        transactionV10 = make_shared<DescribeTransactionFor2CBrowserResponseBodyResultTransactionV10>(model1);
      }
    }
  }


  virtual ~DescribeTransactionFor2CBrowserResponseBodyResult() = default;
};
class DescribeTransactionFor2CBrowserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeTransactionFor2CBrowserResponseBodyResult> result{};

  DescribeTransactionFor2CBrowserResponseBody() {}

  explicit DescribeTransactionFor2CBrowserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeTransactionFor2CBrowserResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeTransactionFor2CBrowserResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeTransactionFor2CBrowserResponseBody() = default;
};
class DescribeTransactionFor2CBrowserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTransactionFor2CBrowserResponseBody> body{};

  DescribeTransactionFor2CBrowserResponse() {}

  explicit DescribeTransactionFor2CBrowserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTransactionFor2CBrowserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTransactionFor2CBrowserResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTransactionFor2CBrowserResponse() = default;
};
class DescribeTransactionQRCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<string> hash{};

  DescribeTransactionQRCodeRequest() {}

  explicit DescribeTransactionQRCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (hash) {
      res["Hash"] = boost::any(*hash);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Hash") != m.end() && !m["Hash"].empty()) {
      hash = make_shared<string>(boost::any_cast<string>(m["Hash"]));
    }
  }


  virtual ~DescribeTransactionQRCodeRequest() = default;
};
class DescribeTransactionQRCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  DescribeTransactionQRCodeResponseBody() {}

  explicit DescribeTransactionQRCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~DescribeTransactionQRCodeResponseBody() = default;
};
class DescribeTransactionQRCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTransactionQRCodeResponseBody> body{};

  DescribeTransactionQRCodeResponse() {}

  explicit DescribeTransactionQRCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTransactionQRCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTransactionQRCodeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTransactionQRCodeResponse() = default;
};
class DescribeTransactionReceiptFor2CBrowserRequest : public Darabonba::Model {
public:
  shared_ptr<string> alipayAuthCode{};
  shared_ptr<string> bizid{};
  shared_ptr<string> hash{};

  DescribeTransactionReceiptFor2CBrowserRequest() {}

  explicit DescribeTransactionReceiptFor2CBrowserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alipayAuthCode) {
      res["AlipayAuthCode"] = boost::any(*alipayAuthCode);
    }
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (hash) {
      res["Hash"] = boost::any(*hash);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlipayAuthCode") != m.end() && !m["AlipayAuthCode"].empty()) {
      alipayAuthCode = make_shared<string>(boost::any_cast<string>(m["AlipayAuthCode"]));
    }
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Hash") != m.end() && !m["Hash"].empty()) {
      hash = make_shared<string>(boost::any_cast<string>(m["Hash"]));
    }
  }


  virtual ~DescribeTransactionReceiptFor2CBrowserRequest() = default;
};
class DescribeTransactionReceiptFor2CBrowserResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> gasUsed{};
  shared_ptr<vector<string>> logs{};
  shared_ptr<long> result{};

  DescribeTransactionReceiptFor2CBrowserResponseBodyResult() {}

  explicit DescribeTransactionReceiptFor2CBrowserResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (gasUsed) {
      res["GasUsed"] = boost::any(*gasUsed);
    }
    if (logs) {
      res["Logs"] = boost::any(*logs);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("GasUsed") != m.end() && !m["GasUsed"].empty()) {
      gasUsed = make_shared<string>(boost::any_cast<string>(m["GasUsed"]));
    }
    if (m.find("Logs") != m.end() && !m["Logs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Logs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Logs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      logs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<long>(boost::any_cast<long>(m["Result"]));
    }
  }


  virtual ~DescribeTransactionReceiptFor2CBrowserResponseBodyResult() = default;
};
class DescribeTransactionReceiptFor2CBrowserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeTransactionReceiptFor2CBrowserResponseBodyResult> result{};

  DescribeTransactionReceiptFor2CBrowserResponseBody() {}

  explicit DescribeTransactionReceiptFor2CBrowserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeTransactionReceiptFor2CBrowserResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeTransactionReceiptFor2CBrowserResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeTransactionReceiptFor2CBrowserResponseBody() = default;
};
class DescribeTransactionReceiptFor2CBrowserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTransactionReceiptFor2CBrowserResponseBody> body{};

  DescribeTransactionReceiptFor2CBrowserResponse() {}

  explicit DescribeTransactionReceiptFor2CBrowserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTransactionReceiptFor2CBrowserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTransactionReceiptFor2CBrowserResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTransactionReceiptFor2CBrowserResponse() = default;
};
class DescribeTriggerRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> name{};
  shared_ptr<string> organizationId{};

  DescribeTriggerRequest() {}

  explicit DescribeTriggerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeTriggerRequest() = default;
};
class DescribeTriggerResponseBodyResultCheckpoint : public Darabonba::Model {
public:
  shared_ptr<long> errorCount{};
  shared_ptr<long> height{};
  shared_ptr<long> index{};
  shared_ptr<string> type{};

  DescribeTriggerResponseBodyResultCheckpoint() {}

  explicit DescribeTriggerResponseBodyResultCheckpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCount) {
      res["ErrorCount"] = boost::any(*errorCount);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCount") != m.end() && !m["ErrorCount"].empty()) {
      errorCount = make_shared<long>(boost::any_cast<long>(m["ErrorCount"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeTriggerResponseBodyResultCheckpoint() = default;
};
class DescribeTriggerResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> channelName{};
  shared_ptr<DescribeTriggerResponseBodyResultCheckpoint> checkpoint{};
  shared_ptr<long> createTime{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> name{};
  shared_ptr<string> options{};
  shared_ptr<string> source{};
  shared_ptr<long> status{};
  shared_ptr<string> type{};

  DescribeTriggerResponseBodyResult() {}

  explicit DescribeTriggerResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (checkpoint) {
      res["Checkpoint"] = checkpoint ? boost::any(checkpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (options) {
      res["Options"] = boost::any(*options);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("Checkpoint") != m.end() && !m["Checkpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["Checkpoint"].type()) {
        DescribeTriggerResponseBodyResultCheckpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Checkpoint"]));
        checkpoint = make_shared<DescribeTriggerResponseBodyResultCheckpoint>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Options") != m.end() && !m["Options"].empty()) {
      options = make_shared<string>(boost::any_cast<string>(m["Options"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeTriggerResponseBodyResult() = default;
};
class DescribeTriggerResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeTriggerResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeTriggerResponseBody() {}

  explicit DescribeTriggerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeTriggerResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeTriggerResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeTriggerResponseBody() = default;
};
class DescribeTriggerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTriggerResponseBody> body{};

  DescribeTriggerResponse() {}

  explicit DescribeTriggerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTriggerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTriggerResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTriggerResponse() = default;
};
class DestroyConsortiumRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};

  DestroyConsortiumRequest() {}

  explicit DestroyConsortiumRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
  }


  virtual ~DestroyConsortiumRequest() = default;
};
class DestroyConsortiumResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> name{};

  DestroyConsortiumResponseBodyResult() {}

  explicit DestroyConsortiumResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DestroyConsortiumResponseBodyResult() = default;
};
class DestroyConsortiumResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DestroyConsortiumResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DestroyConsortiumResponseBody() {}

  explicit DestroyConsortiumResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DestroyConsortiumResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DestroyConsortiumResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DestroyConsortiumResponseBody() = default;
};
class DestroyConsortiumResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DestroyConsortiumResponseBody> body{};

  DestroyConsortiumResponse() {}

  explicit DestroyConsortiumResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DestroyConsortiumResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DestroyConsortiumResponseBody>(model1);
      }
    }
  }


  virtual ~DestroyConsortiumResponse() = default;
};
class DestroyEthereumRequest : public Darabonba::Model {
public:
  shared_ptr<string> ethereumId{};

  DestroyEthereumRequest() {}

  explicit DestroyEthereumRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ethereumId) {
      res["EthereumId"] = boost::any(*ethereumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EthereumId") != m.end() && !m["EthereumId"].empty()) {
      ethereumId = make_shared<string>(boost::any_cast<string>(m["EthereumId"]));
    }
  }


  virtual ~DestroyEthereumRequest() = default;
};
class DestroyEthereumResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> consensus{};
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> networkId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> state{};

  DestroyEthereumResponseBodyResult() {}

  explicit DestroyEthereumResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consensus) {
      res["Consensus"] = boost::any(*consensus);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Consensus") != m.end() && !m["Consensus"].empty()) {
      consensus = make_shared<string>(boost::any_cast<string>(m["Consensus"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~DestroyEthereumResponseBodyResult() = default;
};
class DestroyEthereumResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DestroyEthereumResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DestroyEthereumResponseBody() {}

  explicit DestroyEthereumResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DestroyEthereumResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DestroyEthereumResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DestroyEthereumResponseBody() = default;
};
class DestroyEthereumResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DestroyEthereumResponseBody> body{};

  DestroyEthereumResponse() {}

  explicit DestroyEthereumResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DestroyEthereumResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DestroyEthereumResponseBody>(model1);
      }
    }
  }


  virtual ~DestroyEthereumResponse() = default;
};
class DestroyOrganizationRequest : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};

  DestroyOrganizationRequest() {}

  explicit DestroyOrganizationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DestroyOrganizationRequest() = default;
};
class DestroyOrganizationResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> organizationId{};

  DestroyOrganizationResponseBodyResult() {}

  explicit DestroyOrganizationResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DestroyOrganizationResponseBodyResult() = default;
};
class DestroyOrganizationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DestroyOrganizationResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DestroyOrganizationResponseBody() {}

  explicit DestroyOrganizationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DestroyOrganizationResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DestroyOrganizationResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DestroyOrganizationResponseBody() = default;
};
class DestroyOrganizationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DestroyOrganizationResponseBody> body{};

  DestroyOrganizationResponse() {}

  explicit DestroyOrganizationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DestroyOrganizationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DestroyOrganizationResponseBody>(model1);
      }
    }
  }


  virtual ~DestroyOrganizationResponse() = default;
};
class DownloadAllRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};

  DownloadAllRequest() {}

  explicit DownloadAllRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~DownloadAllRequest() = default;
};
class DownloadAllResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> bizviewUrl{};
  shared_ptr<string> certUrl{};
  shared_ptr<string> sdkUrl{};

  DownloadAllResponseBodyResult() {}

  explicit DownloadAllResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizviewUrl) {
      res["BizviewUrl"] = boost::any(*bizviewUrl);
    }
    if (certUrl) {
      res["CertUrl"] = boost::any(*certUrl);
    }
    if (sdkUrl) {
      res["SdkUrl"] = boost::any(*sdkUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BizviewUrl") != m.end() && !m["BizviewUrl"].empty()) {
      bizviewUrl = make_shared<string>(boost::any_cast<string>(m["BizviewUrl"]));
    }
    if (m.find("CertUrl") != m.end() && !m["CertUrl"].empty()) {
      certUrl = make_shared<string>(boost::any_cast<string>(m["CertUrl"]));
    }
    if (m.find("SdkUrl") != m.end() && !m["SdkUrl"].empty()) {
      sdkUrl = make_shared<string>(boost::any_cast<string>(m["SdkUrl"]));
    }
  }


  virtual ~DownloadAllResponseBodyResult() = default;
};
class DownloadAllResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DownloadAllResponseBodyResult> result{};

  DownloadAllResponseBody() {}

  explicit DownloadAllResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DownloadAllResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DownloadAllResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DownloadAllResponseBody() = default;
};
class DownloadAllResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DownloadAllResponseBody> body{};

  DownloadAllResponse() {}

  explicit DownloadAllResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DownloadAllResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DownloadAllResponseBody>(model1);
      }
    }
  }


  virtual ~DownloadAllResponse() = default;
};
class DownloadBizviewRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};

  DownloadBizviewRequest() {}

  explicit DownloadBizviewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~DownloadBizviewRequest() = default;
};
class DownloadBizviewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  DownloadBizviewResponseBody() {}

  explicit DownloadBizviewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~DownloadBizviewResponseBody() = default;
};
class DownloadBizviewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DownloadBizviewResponseBody> body{};

  DownloadBizviewResponse() {}

  explicit DownloadBizviewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DownloadBizviewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DownloadBizviewResponseBody>(model1);
      }
    }
  }


  virtual ~DownloadBizviewResponse() = default;
};
class DownloadFabricChannelSDKRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> username{};

  DownloadFabricChannelSDKRequest() {}

  explicit DownloadFabricChannelSDKRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~DownloadFabricChannelSDKRequest() = default;
};
class DownloadFabricChannelSDKResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> path{};

  DownloadFabricChannelSDKResponseBodyResult() {}

  explicit DownloadFabricChannelSDKResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~DownloadFabricChannelSDKResponseBodyResult() = default;
};
class DownloadFabricChannelSDKResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DownloadFabricChannelSDKResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DownloadFabricChannelSDKResponseBody() {}

  explicit DownloadFabricChannelSDKResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DownloadFabricChannelSDKResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DownloadFabricChannelSDKResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DownloadFabricChannelSDKResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DownloadFabricChannelSDKResponseBody() = default;
};
class DownloadFabricChannelSDKResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DownloadFabricChannelSDKResponseBody> body{};

  DownloadFabricChannelSDKResponse() {}

  explicit DownloadFabricChannelSDKResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DownloadFabricChannelSDKResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DownloadFabricChannelSDKResponseBody>(model1);
      }
    }
  }


  virtual ~DownloadFabricChannelSDKResponse() = default;
};
class DownloadOrganizationSDKRequest : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> username{};

  DownloadOrganizationSDKRequest() {}

  explicit DownloadOrganizationSDKRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~DownloadOrganizationSDKRequest() = default;
};
class DownloadOrganizationSDKResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> path{};

  DownloadOrganizationSDKResponseBodyResult() {}

  explicit DownloadOrganizationSDKResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~DownloadOrganizationSDKResponseBodyResult() = default;
};
class DownloadOrganizationSDKResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DownloadOrganizationSDKResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DownloadOrganizationSDKResponseBody() {}

  explicit DownloadOrganizationSDKResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DownloadOrganizationSDKResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DownloadOrganizationSDKResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DownloadOrganizationSDKResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DownloadOrganizationSDKResponseBody() = default;
};
class DownloadOrganizationSDKResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DownloadOrganizationSDKResponseBody> body{};

  DownloadOrganizationSDKResponse() {}

  explicit DownloadOrganizationSDKResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DownloadOrganizationSDKResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DownloadOrganizationSDKResponseBody>(model1);
      }
    }
  }


  virtual ~DownloadOrganizationSDKResponse() = default;
};
class DownloadSDK2Request : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};

  DownloadSDK2Request() {}

  explicit DownloadSDK2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~DownloadSDK2Request() = default;
};
class DownloadSDK2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  DownloadSDK2ResponseBody() {}

  explicit DownloadSDK2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~DownloadSDK2ResponseBody() = default;
};
class DownloadSDK2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DownloadSDK2ResponseBody> body{};

  DownloadSDK2Response() {}

  explicit DownloadSDK2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DownloadSDK2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DownloadSDK2ResponseBody>(model1);
      }
    }
  }


  virtual ~DownloadSDK2Response() = default;
};
class DownloadSdkRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};

  DownloadSdkRequest() {}

  explicit DownloadSdkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~DownloadSdkRequest() = default;
};
class DownloadSdkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  DownloadSdkResponseBody() {}

  explicit DownloadSdkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~DownloadSdkResponseBody() = default;
};
class DownloadSdkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DownloadSdkResponseBody> body{};

  DownloadSdkResponse() {}

  explicit DownloadSdkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DownloadSdkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DownloadSdkResponseBody>(model1);
      }
    }
  }


  virtual ~DownloadSdkResponse() = default;
};
class DownloadSignedDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<string> path{};

  DownloadSignedDataRequest() {}

  explicit DownloadSignedDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~DownloadSignedDataRequest() = default;
};
class DownloadSignedDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  DownloadSignedDataResponseBody() {}

  explicit DownloadSignedDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~DownloadSignedDataResponseBody() = default;
};
class DownloadSignedDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DownloadSignedDataResponseBody> body{};

  DownloadSignedDataResponse() {}

  explicit DownloadSignedDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DownloadSignedDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DownloadSignedDataResponseBody>(model1);
      }
    }
  }


  virtual ~DownloadSignedDataResponse() = default;
};
class DuplicateAntChainContractProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> projectId{};
  shared_ptr<string> projectVersion{};

  DuplicateAntChainContractProjectRequest() {}

  explicit DuplicateAntChainContractProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectVersion) {
      res["ProjectVersion"] = boost::any(*projectVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectVersion") != m.end() && !m["ProjectVersion"].empty()) {
      projectVersion = make_shared<string>(boost::any_cast<string>(m["ProjectVersion"]));
    }
  }


  virtual ~DuplicateAntChainContractProjectRequest() = default;
};
class DuplicateAntChainContractProjectResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<long> gmtModified{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> version{};

  DuplicateAntChainContractProjectResponseBodyResult() {}

  explicit DuplicateAntChainContractProjectResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DuplicateAntChainContractProjectResponseBodyResult() = default;
};
class DuplicateAntChainContractProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DuplicateAntChainContractProjectResponseBodyResult> result{};

  DuplicateAntChainContractProjectResponseBody() {}

  explicit DuplicateAntChainContractProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DuplicateAntChainContractProjectResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DuplicateAntChainContractProjectResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DuplicateAntChainContractProjectResponseBody() = default;
};
class DuplicateAntChainContractProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DuplicateAntChainContractProjectResponseBody> body{};

  DuplicateAntChainContractProjectResponse() {}

  explicit DuplicateAntChainContractProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DuplicateAntChainContractProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DuplicateAntChainContractProjectResponseBody>(model1);
      }
    }
  }


  virtual ~DuplicateAntChainContractProjectResponse() = default;
};
class FreezeAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> bizid{};

  FreezeAccountRequest() {}

  explicit FreezeAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~FreezeAccountRequest() = default;
};
class FreezeAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  FreezeAccountResponseBody() {}

  explicit FreezeAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~FreezeAccountResponseBody() = default;
};
class FreezeAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FreezeAccountResponseBody> body{};

  FreezeAccountResponse() {}

  explicit FreezeAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FreezeAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FreezeAccountResponseBody>(model1);
      }
    }
  }


  virtual ~FreezeAccountResponse() = default;
};
class FreezeAntChainAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> antChainId{};

  FreezeAntChainAccountRequest() {}

  explicit FreezeAntChainAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
  }


  virtual ~FreezeAntChainAccountRequest() = default;
};
class FreezeAntChainAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  FreezeAntChainAccountResponseBody() {}

  explicit FreezeAntChainAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~FreezeAntChainAccountResponseBody() = default;
};
class FreezeAntChainAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FreezeAntChainAccountResponseBody> body{};

  FreezeAntChainAccountResponse() {}

  explicit FreezeAntChainAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FreezeAntChainAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FreezeAntChainAccountResponseBody>(model1);
      }
    }
  }


  virtual ~FreezeAntChainAccountResponse() = default;
};
class GetAppliesRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<long> current{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> status{};

  GetAppliesRequest() {}

  explicit GetAppliesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetAppliesRequest() = default;
};
class GetAppliesResponseBodyResultApplyHistoryList : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<long> createtime{};
  shared_ptr<long> id{};
  shared_ptr<string> rejectReason{};
  shared_ptr<string> reqAddr{};
  shared_ptr<string> signedAddr{};
  shared_ptr<long> status{};
  shared_ptr<long> updatetime{};
  shared_ptr<string> username{};

  GetAppliesResponseBodyResultApplyHistoryList() {}

  explicit GetAppliesResponseBodyResultApplyHistoryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (createtime) {
      res["Createtime"] = boost::any(*createtime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (rejectReason) {
      res["RejectReason"] = boost::any(*rejectReason);
    }
    if (reqAddr) {
      res["ReqAddr"] = boost::any(*reqAddr);
    }
    if (signedAddr) {
      res["SignedAddr"] = boost::any(*signedAddr);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updatetime) {
      res["Updatetime"] = boost::any(*updatetime);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Createtime") != m.end() && !m["Createtime"].empty()) {
      createtime = make_shared<long>(boost::any_cast<long>(m["Createtime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RejectReason") != m.end() && !m["RejectReason"].empty()) {
      rejectReason = make_shared<string>(boost::any_cast<string>(m["RejectReason"]));
    }
    if (m.find("ReqAddr") != m.end() && !m["ReqAddr"].empty()) {
      reqAddr = make_shared<string>(boost::any_cast<string>(m["ReqAddr"]));
    }
    if (m.find("SignedAddr") != m.end() && !m["SignedAddr"].empty()) {
      signedAddr = make_shared<string>(boost::any_cast<string>(m["SignedAddr"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Updatetime") != m.end() && !m["Updatetime"].empty()) {
      updatetime = make_shared<long>(boost::any_cast<long>(m["Updatetime"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~GetAppliesResponseBodyResultApplyHistoryList() = default;
};
class GetAppliesResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> current{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  GetAppliesResponseBodyResultPagination() {}

  explicit GetAppliesResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetAppliesResponseBodyResultPagination() = default;
};
class GetAppliesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<GetAppliesResponseBodyResultApplyHistoryList>> applyHistoryList{};
  shared_ptr<GetAppliesResponseBodyResultPagination> pagination{};

  GetAppliesResponseBodyResult() {}

  explicit GetAppliesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (applyHistoryList) {
      vector<boost::any> temp1;
      for(auto item1:*applyHistoryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ApplyHistoryList"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ApplyHistoryList") != m.end() && !m["ApplyHistoryList"].empty()) {
      if (typeid(vector<boost::any>) == m["ApplyHistoryList"].type()) {
        vector<GetAppliesResponseBodyResultApplyHistoryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ApplyHistoryList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetAppliesResponseBodyResultApplyHistoryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        applyHistoryList = make_shared<vector<GetAppliesResponseBodyResultApplyHistoryList>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        GetAppliesResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<GetAppliesResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~GetAppliesResponseBodyResult() = default;
};
class GetAppliesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetAppliesResponseBodyResult> result{};

  GetAppliesResponseBody() {}

  explicit GetAppliesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        GetAppliesResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<GetAppliesResponseBodyResult>(model1);
      }
    }
  }


  virtual ~GetAppliesResponseBody() = default;
};
class GetAppliesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetAppliesResponseBody> body{};

  GetAppliesResponse() {}

  explicit GetAppliesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAppliesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAppliesResponseBody>(model1);
      }
    }
  }


  virtual ~GetAppliesResponse() = default;
};
class GetBcSchemaRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};

  GetBcSchemaRequest() {}

  explicit GetBcSchemaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~GetBcSchemaRequest() = default;
};
class GetBcSchemaResponseBodyResultResponsesPropertiesDataSource : public Darabonba::Model {
public:
  shared_ptr<long> allowNull{};
  shared_ptr<string> annotation{};
  shared_ptr<string> field{};
  shared_ptr<long> indexes{};
  shared_ptr<long> key{};
  shared_ptr<long> length{};
  shared_ptr<string> reg{};
  shared_ptr<string> type{};

  GetBcSchemaResponseBodyResultResponsesPropertiesDataSource() {}

  explicit GetBcSchemaResponseBodyResultResponsesPropertiesDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowNull) {
      res["AllowNull"] = boost::any(*allowNull);
    }
    if (annotation) {
      res["Annotation"] = boost::any(*annotation);
    }
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (indexes) {
      res["Indexes"] = boost::any(*indexes);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (reg) {
      res["Reg"] = boost::any(*reg);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowNull") != m.end() && !m["AllowNull"].empty()) {
      allowNull = make_shared<long>(boost::any_cast<long>(m["AllowNull"]));
    }
    if (m.find("Annotation") != m.end() && !m["Annotation"].empty()) {
      annotation = make_shared<string>(boost::any_cast<string>(m["Annotation"]));
    }
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("Indexes") != m.end() && !m["Indexes"].empty()) {
      indexes = make_shared<long>(boost::any_cast<long>(m["Indexes"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<long>(boost::any_cast<long>(m["Key"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("Reg") != m.end() && !m["Reg"].empty()) {
      reg = make_shared<string>(boost::any_cast<string>(m["Reg"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~GetBcSchemaResponseBodyResultResponsesPropertiesDataSource() = default;
};
class GetBcSchemaResponseBodyResultResponsesProperties : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<GetBcSchemaResponseBodyResultResponsesPropertiesDataSource>> dataSource{};

  GetBcSchemaResponseBodyResultResponsesProperties() {}

  explicit GetBcSchemaResponseBodyResultResponsesProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (dataSource) {
      vector<boost::any> temp1;
      for(auto item1:*dataSource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataSource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(vector<boost::any>) == m["DataSource"].type()) {
        vector<GetBcSchemaResponseBodyResultResponsesPropertiesDataSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataSource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBcSchemaResponseBodyResultResponsesPropertiesDataSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataSource = make_shared<vector<GetBcSchemaResponseBodyResultResponsesPropertiesDataSource>>(expect1);
      }
    }
  }


  virtual ~GetBcSchemaResponseBodyResultResponsesProperties() = default;
};
class GetBcSchemaResponseBodyResultResponses : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> categoryName{};
  shared_ptr<string> description{};
  shared_ptr<GetBcSchemaResponseBodyResultResponsesProperties> properties{};

  GetBcSchemaResponseBodyResultResponses() {}

  explicit GetBcSchemaResponseBodyResultResponses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (categoryName) {
      res["CategoryName"] = boost::any(*categoryName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CategoryName") != m.end() && !m["CategoryName"].empty()) {
      categoryName = make_shared<string>(boost::any_cast<string>(m["CategoryName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        GetBcSchemaResponseBodyResultResponsesProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<GetBcSchemaResponseBodyResultResponsesProperties>(model1);
      }
    }
  }


  virtual ~GetBcSchemaResponseBodyResultResponses() = default;
};
class GetBcSchemaResponseBodyResultSchema : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<bool> isTemplate{};
  shared_ptr<string> name{};
  shared_ptr<long> updateTime{};
  shared_ptr<long> version{};

  GetBcSchemaResponseBodyResultSchema() {}

  explicit GetBcSchemaResponseBodyResultSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsTemplate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~GetBcSchemaResponseBodyResultSchema() = default;
};
class GetBcSchemaResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<GetBcSchemaResponseBodyResultResponses>> responses{};
  shared_ptr<GetBcSchemaResponseBodyResultSchema> schema{};

  GetBcSchemaResponseBodyResult() {}

  explicit GetBcSchemaResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (responses) {
      vector<boost::any> temp1;
      for(auto item1:*responses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Responses"] = boost::any(temp1);
    }
    if (schema) {
      res["Schema"] = schema ? boost::any(schema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Responses") != m.end() && !m["Responses"].empty()) {
      if (typeid(vector<boost::any>) == m["Responses"].type()) {
        vector<GetBcSchemaResponseBodyResultResponses> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Responses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBcSchemaResponseBodyResultResponses model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        responses = make_shared<vector<GetBcSchemaResponseBodyResultResponses>>(expect1);
      }
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      if (typeid(map<string, boost::any>) == m["Schema"].type()) {
        GetBcSchemaResponseBodyResultSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Schema"]));
        schema = make_shared<GetBcSchemaResponseBodyResultSchema>(model1);
      }
    }
  }


  virtual ~GetBcSchemaResponseBodyResult() = default;
};
class GetBcSchemaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetBcSchemaResponseBodyResult> result{};

  GetBcSchemaResponseBody() {}

  explicit GetBcSchemaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        GetBcSchemaResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<GetBcSchemaResponseBodyResult>(model1);
      }
    }
  }


  virtual ~GetBcSchemaResponseBody() = default;
};
class GetBcSchemaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBcSchemaResponseBody> body{};

  GetBcSchemaResponse() {}

  explicit GetBcSchemaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBcSchemaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBcSchemaResponseBody>(model1);
      }
    }
  }


  virtual ~GetBcSchemaResponse() = default;
};
class GetBlockchainCreateTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> current{};
  shared_ptr<long> pageSize{};

  GetBlockchainCreateTaskRequest() {}

  explicit GetBlockchainCreateTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~GetBlockchainCreateTaskRequest() = default;
};
class GetBlockchainCreateTaskResponseBodyResultBlockchainCreateTasksBlockchainCreateTasks : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<long> createTime{};
  shared_ptr<string> memo{};
  shared_ptr<string> name{};
  shared_ptr<string> status{};

  GetBlockchainCreateTaskResponseBodyResultBlockchainCreateTasksBlockchainCreateTasks() {}

  explicit GetBlockchainCreateTaskResponseBodyResultBlockchainCreateTasksBlockchainCreateTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (memo) {
      res["Memo"] = boost::any(*memo);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Memo") != m.end() && !m["Memo"].empty()) {
      memo = make_shared<string>(boost::any_cast<string>(m["Memo"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~GetBlockchainCreateTaskResponseBodyResultBlockchainCreateTasksBlockchainCreateTasks() = default;
};
class GetBlockchainCreateTaskResponseBodyResultBlockchainCreateTasks : public Darabonba::Model {
public:
  shared_ptr<vector<GetBlockchainCreateTaskResponseBodyResultBlockchainCreateTasksBlockchainCreateTasks>> blockchainCreateTasks{};

  GetBlockchainCreateTaskResponseBodyResultBlockchainCreateTasks() {}

  explicit GetBlockchainCreateTaskResponseBodyResultBlockchainCreateTasks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockchainCreateTasks) {
      vector<boost::any> temp1;
      for(auto item1:*blockchainCreateTasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BlockchainCreateTasks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockchainCreateTasks") != m.end() && !m["BlockchainCreateTasks"].empty()) {
      if (typeid(vector<boost::any>) == m["BlockchainCreateTasks"].type()) {
        vector<GetBlockchainCreateTaskResponseBodyResultBlockchainCreateTasksBlockchainCreateTasks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BlockchainCreateTasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBlockchainCreateTaskResponseBodyResultBlockchainCreateTasksBlockchainCreateTasks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        blockchainCreateTasks = make_shared<vector<GetBlockchainCreateTaskResponseBodyResultBlockchainCreateTasksBlockchainCreateTasks>>(expect1);
      }
    }
  }


  virtual ~GetBlockchainCreateTaskResponseBodyResultBlockchainCreateTasks() = default;
};
class GetBlockchainCreateTaskResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> current{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> total{};

  GetBlockchainCreateTaskResponseBodyResultPagination() {}

  explicit GetBlockchainCreateTaskResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (current) {
      res["Current"] = boost::any(*current);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Current") != m.end() && !m["Current"].empty()) {
      current = make_shared<long>(boost::any_cast<long>(m["Current"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
  }


  virtual ~GetBlockchainCreateTaskResponseBodyResultPagination() = default;
};
class GetBlockchainCreateTaskResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<GetBlockchainCreateTaskResponseBodyResultBlockchainCreateTasks> blockchainCreateTasks{};
  shared_ptr<GetBlockchainCreateTaskResponseBodyResultPagination> pagination{};

  GetBlockchainCreateTaskResponseBodyResult() {}

  explicit GetBlockchainCreateTaskResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockchainCreateTasks) {
      res["BlockchainCreateTasks"] = blockchainCreateTasks ? boost::any(blockchainCreateTasks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockchainCreateTasks") != m.end() && !m["BlockchainCreateTasks"].empty()) {
      if (typeid(map<string, boost::any>) == m["BlockchainCreateTasks"].type()) {
        GetBlockchainCreateTaskResponseBodyResultBlockchainCreateTasks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["BlockchainCreateTasks"]));
        blockchainCreateTasks = make_shared<GetBlockchainCreateTaskResponseBodyResultBlockchainCreateTasks>(model1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        GetBlockchainCreateTaskResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<GetBlockchainCreateTaskResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~GetBlockchainCreateTaskResponseBodyResult() = default;
};
class GetBlockchainCreateTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetBlockchainCreateTaskResponseBodyResult> result{};

  GetBlockchainCreateTaskResponseBody() {}

  explicit GetBlockchainCreateTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        GetBlockchainCreateTaskResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<GetBlockchainCreateTaskResponseBodyResult>(model1);
      }
    }
  }


  virtual ~GetBlockchainCreateTaskResponseBody() = default;
};
class GetBlockchainCreateTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBlockchainCreateTaskResponseBody> body{};

  GetBlockchainCreateTaskResponse() {}

  explicit GetBlockchainCreateTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBlockchainCreateTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBlockchainCreateTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GetBlockchainCreateTaskResponse() = default;
};
class GetBlockchainInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};

  GetBlockchainInfoRequest() {}

  explicit GetBlockchainInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~GetBlockchainInfoRequest() = default;
};
class GetBlockchainInfoResponseBodyResultNodeInfoList : public Darabonba::Model {
public:
  shared_ptr<long> blockHeight{};
  shared_ptr<string> nodeName{};
  shared_ptr<bool> status{};
  shared_ptr<string> version{};

  GetBlockchainInfoResponseBodyResultNodeInfoList() {}

  explicit GetBlockchainInfoResponseBodyResultNodeInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockHeight) {
      res["BlockHeight"] = boost::any(*blockHeight);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockHeight") != m.end() && !m["BlockHeight"].empty()) {
      blockHeight = make_shared<long>(boost::any_cast<long>(m["BlockHeight"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~GetBlockchainInfoResponseBodyResultNodeInfoList() = default;
};
class GetBlockchainInfoResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> abnormalNodes{};
  shared_ptr<string> bizid{};
  shared_ptr<long> blockHeight{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> isRole{};
  shared_ptr<vector<GetBlockchainInfoResponseBodyResultNodeInfoList>> nodeInfoList{};
  shared_ptr<long> nodeNumber{};
  shared_ptr<bool> normal{};
  shared_ptr<long> transactionSum{};
  shared_ptr<string> version{};

  GetBlockchainInfoResponseBodyResult() {}

  explicit GetBlockchainInfoResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnormalNodes) {
      res["AbnormalNodes"] = boost::any(*abnormalNodes);
    }
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (blockHeight) {
      res["BlockHeight"] = boost::any(*blockHeight);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (isRole) {
      res["IsRole"] = boost::any(*isRole);
    }
    if (nodeInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*nodeInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeInfoList"] = boost::any(temp1);
    }
    if (nodeNumber) {
      res["NodeNumber"] = boost::any(*nodeNumber);
    }
    if (normal) {
      res["Normal"] = boost::any(*normal);
    }
    if (transactionSum) {
      res["TransactionSum"] = boost::any(*transactionSum);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbnormalNodes") != m.end() && !m["AbnormalNodes"].empty()) {
      abnormalNodes = make_shared<long>(boost::any_cast<long>(m["AbnormalNodes"]));
    }
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("BlockHeight") != m.end() && !m["BlockHeight"].empty()) {
      blockHeight = make_shared<long>(boost::any_cast<long>(m["BlockHeight"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("IsRole") != m.end() && !m["IsRole"].empty()) {
      isRole = make_shared<bool>(boost::any_cast<bool>(m["IsRole"]));
    }
    if (m.find("NodeInfoList") != m.end() && !m["NodeInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeInfoList"].type()) {
        vector<GetBlockchainInfoResponseBodyResultNodeInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetBlockchainInfoResponseBodyResultNodeInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeInfoList = make_shared<vector<GetBlockchainInfoResponseBodyResultNodeInfoList>>(expect1);
      }
    }
    if (m.find("NodeNumber") != m.end() && !m["NodeNumber"].empty()) {
      nodeNumber = make_shared<long>(boost::any_cast<long>(m["NodeNumber"]));
    }
    if (m.find("Normal") != m.end() && !m["Normal"].empty()) {
      normal = make_shared<bool>(boost::any_cast<bool>(m["Normal"]));
    }
    if (m.find("TransactionSum") != m.end() && !m["TransactionSum"].empty()) {
      transactionSum = make_shared<long>(boost::any_cast<long>(m["TransactionSum"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~GetBlockchainInfoResponseBodyResult() = default;
};
class GetBlockchainInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetBlockchainInfoResponseBodyResult> result{};

  GetBlockchainInfoResponseBody() {}

  explicit GetBlockchainInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        GetBlockchainInfoResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<GetBlockchainInfoResponseBodyResult>(model1);
      }
    }
  }


  virtual ~GetBlockchainInfoResponseBody() = default;
};
class GetBlockchainInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBlockchainInfoResponseBody> body{};

  GetBlockchainInfoResponse() {}

  explicit GetBlockchainInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBlockchainInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBlockchainInfoResponseBody>(model1);
      }
    }
  }


  virtual ~GetBlockchainInfoResponse() = default;
};
class GetMyBlockchainsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<long> createtime{};
  shared_ptr<long> id{};
  shared_ptr<string> rejectReason{};
  shared_ptr<string> reqAddr{};
  shared_ptr<string> signedAddr{};
  shared_ptr<long> status{};
  shared_ptr<long> updatetime{};
  shared_ptr<string> username{};

  GetMyBlockchainsResponseBodyResult() {}

  explicit GetMyBlockchainsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (createtime) {
      res["Createtime"] = boost::any(*createtime);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (rejectReason) {
      res["RejectReason"] = boost::any(*rejectReason);
    }
    if (reqAddr) {
      res["ReqAddr"] = boost::any(*reqAddr);
    }
    if (signedAddr) {
      res["SignedAddr"] = boost::any(*signedAddr);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updatetime) {
      res["Updatetime"] = boost::any(*updatetime);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Createtime") != m.end() && !m["Createtime"].empty()) {
      createtime = make_shared<long>(boost::any_cast<long>(m["Createtime"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("RejectReason") != m.end() && !m["RejectReason"].empty()) {
      rejectReason = make_shared<string>(boost::any_cast<string>(m["RejectReason"]));
    }
    if (m.find("ReqAddr") != m.end() && !m["ReqAddr"].empty()) {
      reqAddr = make_shared<string>(boost::any_cast<string>(m["ReqAddr"]));
    }
    if (m.find("SignedAddr") != m.end() && !m["SignedAddr"].empty()) {
      signedAddr = make_shared<string>(boost::any_cast<string>(m["SignedAddr"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Updatetime") != m.end() && !m["Updatetime"].empty()) {
      updatetime = make_shared<long>(boost::any_cast<long>(m["Updatetime"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~GetMyBlockchainsResponseBodyResult() = default;
};
class GetMyBlockchainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetMyBlockchainsResponseBodyResult>> result{};

  GetMyBlockchainsResponseBody() {}

  explicit GetMyBlockchainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<GetMyBlockchainsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMyBlockchainsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<GetMyBlockchainsResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~GetMyBlockchainsResponseBody() = default;
};
class GetMyBlockchainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMyBlockchainsResponseBody> body{};

  GetMyBlockchainsResponse() {}

  explicit GetMyBlockchainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMyBlockchainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMyBlockchainsResponseBody>(model1);
      }
    }
  }


  virtual ~GetMyBlockchainsResponse() = default;
};
class GetMySuccessAppliesResponseBodyResultNodeInfoList : public Darabonba::Model {
public:
  shared_ptr<long> blockHeight{};
  shared_ptr<string> nodeName{};
  shared_ptr<bool> status{};
  shared_ptr<string> version{};

  GetMySuccessAppliesResponseBodyResultNodeInfoList() {}

  explicit GetMySuccessAppliesResponseBodyResultNodeInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockHeight) {
      res["BlockHeight"] = boost::any(*blockHeight);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockHeight") != m.end() && !m["BlockHeight"].empty()) {
      blockHeight = make_shared<long>(boost::any_cast<long>(m["BlockHeight"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~GetMySuccessAppliesResponseBodyResultNodeInfoList() = default;
};
class GetMySuccessAppliesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> abnormalNodes{};
  shared_ptr<string> bizid{};
  shared_ptr<long> blockHeight{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> isRole{};
  shared_ptr<string> name{};
  shared_ptr<vector<GetMySuccessAppliesResponseBodyResultNodeInfoList>> nodeInfoList{};
  shared_ptr<long> nodeNumber{};
  shared_ptr<bool> normal{};
  shared_ptr<long> transactionSum{};
  shared_ptr<string> version{};

  GetMySuccessAppliesResponseBodyResult() {}

  explicit GetMySuccessAppliesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnormalNodes) {
      res["AbnormalNodes"] = boost::any(*abnormalNodes);
    }
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (blockHeight) {
      res["BlockHeight"] = boost::any(*blockHeight);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (isRole) {
      res["IsRole"] = boost::any(*isRole);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (nodeInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*nodeInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeInfoList"] = boost::any(temp1);
    }
    if (nodeNumber) {
      res["NodeNumber"] = boost::any(*nodeNumber);
    }
    if (normal) {
      res["Normal"] = boost::any(*normal);
    }
    if (transactionSum) {
      res["TransactionSum"] = boost::any(*transactionSum);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbnormalNodes") != m.end() && !m["AbnormalNodes"].empty()) {
      abnormalNodes = make_shared<long>(boost::any_cast<long>(m["AbnormalNodes"]));
    }
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("BlockHeight") != m.end() && !m["BlockHeight"].empty()) {
      blockHeight = make_shared<long>(boost::any_cast<long>(m["BlockHeight"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("IsRole") != m.end() && !m["IsRole"].empty()) {
      isRole = make_shared<bool>(boost::any_cast<bool>(m["IsRole"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NodeInfoList") != m.end() && !m["NodeInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeInfoList"].type()) {
        vector<GetMySuccessAppliesResponseBodyResultNodeInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMySuccessAppliesResponseBodyResultNodeInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeInfoList = make_shared<vector<GetMySuccessAppliesResponseBodyResultNodeInfoList>>(expect1);
      }
    }
    if (m.find("NodeNumber") != m.end() && !m["NodeNumber"].empty()) {
      nodeNumber = make_shared<long>(boost::any_cast<long>(m["NodeNumber"]));
    }
    if (m.find("Normal") != m.end() && !m["Normal"].empty()) {
      normal = make_shared<bool>(boost::any_cast<bool>(m["Normal"]));
    }
    if (m.find("TransactionSum") != m.end() && !m["TransactionSum"].empty()) {
      transactionSum = make_shared<long>(boost::any_cast<long>(m["TransactionSum"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~GetMySuccessAppliesResponseBodyResult() = default;
};
class GetMySuccessAppliesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetMySuccessAppliesResponseBodyResult>> result{};

  GetMySuccessAppliesResponseBody() {}

  explicit GetMySuccessAppliesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<GetMySuccessAppliesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetMySuccessAppliesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<GetMySuccessAppliesResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~GetMySuccessAppliesResponseBody() = default;
};
class GetMySuccessAppliesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetMySuccessAppliesResponseBody> body{};

  GetMySuccessAppliesResponse() {}

  explicit GetMySuccessAppliesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetMySuccessAppliesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetMySuccessAppliesResponseBody>(model1);
      }
    }
  }


  virtual ~GetMySuccessAppliesResponse() = default;
};
class GetOssPropertiesRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};

  GetOssPropertiesRequest() {}

  explicit GetOssPropertiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~GetOssPropertiesRequest() = default;
};
class GetOssPropertiesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> accessKeyId{};
  shared_ptr<string> accessKeySecret{};
  shared_ptr<string> bucketName{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> folderName{};

  GetOssPropertiesResponseBodyResult() {}

  explicit GetOssPropertiesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKeyId) {
      res["AccessKeyId"] = boost::any(*accessKeyId);
    }
    if (accessKeySecret) {
      res["AccessKeySecret"] = boost::any(*accessKeySecret);
    }
    if (bucketName) {
      res["BucketName"] = boost::any(*bucketName);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (folderName) {
      res["FolderName"] = boost::any(*folderName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessKeyId") != m.end() && !m["AccessKeyId"].empty()) {
      accessKeyId = make_shared<string>(boost::any_cast<string>(m["AccessKeyId"]));
    }
    if (m.find("AccessKeySecret") != m.end() && !m["AccessKeySecret"].empty()) {
      accessKeySecret = make_shared<string>(boost::any_cast<string>(m["AccessKeySecret"]));
    }
    if (m.find("BucketName") != m.end() && !m["BucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["BucketName"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("FolderName") != m.end() && !m["FolderName"].empty()) {
      folderName = make_shared<string>(boost::any_cast<string>(m["FolderName"]));
    }
  }


  virtual ~GetOssPropertiesResponseBodyResult() = default;
};
class GetOssPropertiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetOssPropertiesResponseBodyResult> result{};

  GetOssPropertiesResponseBody() {}

  explicit GetOssPropertiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        GetOssPropertiesResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<GetOssPropertiesResponseBodyResult>(model1);
      }
    }
  }


  virtual ~GetOssPropertiesResponseBody() = default;
};
class GetOssPropertiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetOssPropertiesResponseBody> body{};

  GetOssPropertiesResponse() {}

  explicit GetOssPropertiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOssPropertiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOssPropertiesResponseBody>(model1);
      }
    }
  }


  virtual ~GetOssPropertiesResponse() = default;
};
class GetTemplatesResponseBodyResultSchemaList : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<long> isTemplate{};
  shared_ptr<string> name{};
  shared_ptr<long> updateTime{};
  shared_ptr<long> version{};

  GetTemplatesResponseBodyResultSchemaList() {}

  explicit GetTemplatesResponseBodyResultSchemaList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<long>(boost::any_cast<long>(m["IsTemplate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~GetTemplatesResponseBodyResultSchemaList() = default;
};
class GetTemplatesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<GetTemplatesResponseBodyResultSchemaList>> schemaList{};

  GetTemplatesResponseBodyResult() {}

  explicit GetTemplatesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (schemaList) {
      vector<boost::any> temp1;
      for(auto item1:*schemaList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SchemaList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SchemaList") != m.end() && !m["SchemaList"].empty()) {
      if (typeid(vector<boost::any>) == m["SchemaList"].type()) {
        vector<GetTemplatesResponseBodyResultSchemaList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SchemaList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTemplatesResponseBodyResultSchemaList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        schemaList = make_shared<vector<GetTemplatesResponseBodyResultSchemaList>>(expect1);
      }
    }
  }


  virtual ~GetTemplatesResponseBodyResult() = default;
};
class GetTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetTemplatesResponseBodyResult> result{};

  GetTemplatesResponseBody() {}

  explicit GetTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        GetTemplatesResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<GetTemplatesResponseBodyResult>(model1);
      }
    }
  }


  virtual ~GetTemplatesResponseBody() = default;
};
class GetTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTemplatesResponseBody> body{};

  GetTemplatesResponse() {}

  explicit GetTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~GetTemplatesResponse() = default;
};
class InstallChaincodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};

  InstallChaincodeRequest() {}

  explicit InstallChaincodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~InstallChaincodeRequest() = default;
};
class InstallChaincodeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> channelName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deployTime{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<string> input{};
  shared_ptr<bool> install{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<string> providerId{};
  shared_ptr<string> providerName{};
  shared_ptr<string> state{};
  shared_ptr<long> type{};
  shared_ptr<string> version{};

  InstallChaincodeResponseBodyResult() {}

  explicit InstallChaincodeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deployTime) {
      res["DeployTime"] = boost::any(*deployTime);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (install) {
      res["Install"] = boost::any(*install);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (providerId) {
      res["ProviderId"] = boost::any(*providerId);
    }
    if (providerName) {
      res["ProviderName"] = boost::any(*providerName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeployTime") != m.end() && !m["DeployTime"].empty()) {
      deployTime = make_shared<string>(boost::any_cast<string>(m["DeployTime"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Install") != m.end() && !m["Install"].empty()) {
      install = make_shared<bool>(boost::any_cast<bool>(m["Install"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ProviderId") != m.end() && !m["ProviderId"].empty()) {
      providerId = make_shared<string>(boost::any_cast<string>(m["ProviderId"]));
    }
    if (m.find("ProviderName") != m.end() && !m["ProviderName"].empty()) {
      providerName = make_shared<string>(boost::any_cast<string>(m["ProviderName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~InstallChaincodeResponseBodyResult() = default;
};
class InstallChaincodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<InstallChaincodeResponseBodyResult> result{};
  shared_ptr<bool> success{};

  InstallChaincodeResponseBody() {}

  explicit InstallChaincodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        InstallChaincodeResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<InstallChaincodeResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~InstallChaincodeResponseBody() = default;
};
class InstallChaincodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InstallChaincodeResponseBody> body{};

  InstallChaincodeResponse() {}

  explicit InstallChaincodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstallChaincodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstallChaincodeResponseBody>(model1);
      }
    }
  }


  virtual ~InstallChaincodeResponse() = default;
};
class InstallFabricChaincodePackageRequest : public Darabonba::Model {
public:
  shared_ptr<string> chaincodePackageId{};
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};

  InstallFabricChaincodePackageRequest() {}

  explicit InstallFabricChaincodePackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodePackageId) {
      res["ChaincodePackageId"] = boost::any(*chaincodePackageId);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodePackageId") != m.end() && !m["ChaincodePackageId"].empty()) {
      chaincodePackageId = make_shared<string>(boost::any_cast<string>(m["ChaincodePackageId"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~InstallFabricChaincodePackageRequest() = default;
};
class InstallFabricChaincodePackageResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> chaincodePackageId{};
  shared_ptr<string> checksum{};
  shared_ptr<long> deleteTime{};
  shared_ptr<bool> deleted{};
  shared_ptr<long> installTime{};
  shared_ptr<string> label{};
  shared_ptr<string> md5sum{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossURL{};
  shared_ptr<string> providerBid{};
  shared_ptr<long> providerUid{};
  shared_ptr<string> state{};
  shared_ptr<long> type{};
  shared_ptr<string> typeName_{};
  shared_ptr<long> uploadTime{};

  InstallFabricChaincodePackageResponseBodyResult() {}

  explicit InstallFabricChaincodePackageResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodePackageId) {
      res["ChaincodePackageId"] = boost::any(*chaincodePackageId);
    }
    if (checksum) {
      res["Checksum"] = boost::any(*checksum);
    }
    if (deleteTime) {
      res["DeleteTime"] = boost::any(*deleteTime);
    }
    if (deleted) {
      res["Deleted"] = boost::any(*deleted);
    }
    if (installTime) {
      res["InstallTime"] = boost::any(*installTime);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (md5sum) {
      res["Md5sum"] = boost::any(*md5sum);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossURL) {
      res["OssURL"] = boost::any(*ossURL);
    }
    if (providerBid) {
      res["ProviderBid"] = boost::any(*providerBid);
    }
    if (providerUid) {
      res["ProviderUid"] = boost::any(*providerUid);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (typeName_) {
      res["TypeName"] = boost::any(*typeName_);
    }
    if (uploadTime) {
      res["UploadTime"] = boost::any(*uploadTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodePackageId") != m.end() && !m["ChaincodePackageId"].empty()) {
      chaincodePackageId = make_shared<string>(boost::any_cast<string>(m["ChaincodePackageId"]));
    }
    if (m.find("Checksum") != m.end() && !m["Checksum"].empty()) {
      checksum = make_shared<string>(boost::any_cast<string>(m["Checksum"]));
    }
    if (m.find("DeleteTime") != m.end() && !m["DeleteTime"].empty()) {
      deleteTime = make_shared<long>(boost::any_cast<long>(m["DeleteTime"]));
    }
    if (m.find("Deleted") != m.end() && !m["Deleted"].empty()) {
      deleted = make_shared<bool>(boost::any_cast<bool>(m["Deleted"]));
    }
    if (m.find("InstallTime") != m.end() && !m["InstallTime"].empty()) {
      installTime = make_shared<long>(boost::any_cast<long>(m["InstallTime"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Md5sum") != m.end() && !m["Md5sum"].empty()) {
      md5sum = make_shared<string>(boost::any_cast<string>(m["Md5sum"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssURL") != m.end() && !m["OssURL"].empty()) {
      ossURL = make_shared<string>(boost::any_cast<string>(m["OssURL"]));
    }
    if (m.find("ProviderBid") != m.end() && !m["ProviderBid"].empty()) {
      providerBid = make_shared<string>(boost::any_cast<string>(m["ProviderBid"]));
    }
    if (m.find("ProviderUid") != m.end() && !m["ProviderUid"].empty()) {
      providerUid = make_shared<long>(boost::any_cast<long>(m["ProviderUid"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("TypeName") != m.end() && !m["TypeName"].empty()) {
      typeName_ = make_shared<string>(boost::any_cast<string>(m["TypeName"]));
    }
    if (m.find("UploadTime") != m.end() && !m["UploadTime"].empty()) {
      uploadTime = make_shared<long>(boost::any_cast<long>(m["UploadTime"]));
    }
  }


  virtual ~InstallFabricChaincodePackageResponseBodyResult() = default;
};
class InstallFabricChaincodePackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<InstallFabricChaincodePackageResponseBodyResult> result{};
  shared_ptr<bool> success{};

  InstallFabricChaincodePackageResponseBody() {}

  explicit InstallFabricChaincodePackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        InstallFabricChaincodePackageResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<InstallFabricChaincodePackageResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~InstallFabricChaincodePackageResponseBody() = default;
};
class InstallFabricChaincodePackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InstallFabricChaincodePackageResponseBody> body{};

  InstallFabricChaincodePackageResponse() {}

  explicit InstallFabricChaincodePackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstallFabricChaincodePackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstallFabricChaincodePackageResponseBody>(model1);
      }
    }
  }


  virtual ~InstallFabricChaincodePackageResponse() = default;
};
class InstantiateChaincodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> collectionConfig{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};

  InstantiateChaincodeRequest() {}

  explicit InstantiateChaincodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (collectionConfig) {
      res["CollectionConfig"] = boost::any(*collectionConfig);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("CollectionConfig") != m.end() && !m["CollectionConfig"].empty()) {
      collectionConfig = make_shared<string>(boost::any_cast<string>(m["CollectionConfig"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~InstantiateChaincodeRequest() = default;
};
class InstantiateChaincodeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> channelName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deployTime{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<string> input{};
  shared_ptr<bool> install{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<string> providerId{};
  shared_ptr<string> providerName{};
  shared_ptr<string> state{};
  shared_ptr<long> type{};
  shared_ptr<string> version{};

  InstantiateChaincodeResponseBodyResult() {}

  explicit InstantiateChaincodeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deployTime) {
      res["DeployTime"] = boost::any(*deployTime);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (install) {
      res["Install"] = boost::any(*install);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (providerId) {
      res["ProviderId"] = boost::any(*providerId);
    }
    if (providerName) {
      res["ProviderName"] = boost::any(*providerName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeployTime") != m.end() && !m["DeployTime"].empty()) {
      deployTime = make_shared<string>(boost::any_cast<string>(m["DeployTime"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Install") != m.end() && !m["Install"].empty()) {
      install = make_shared<bool>(boost::any_cast<bool>(m["Install"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ProviderId") != m.end() && !m["ProviderId"].empty()) {
      providerId = make_shared<string>(boost::any_cast<string>(m["ProviderId"]));
    }
    if (m.find("ProviderName") != m.end() && !m["ProviderName"].empty()) {
      providerName = make_shared<string>(boost::any_cast<string>(m["ProviderName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~InstantiateChaincodeResponseBodyResult() = default;
};
class InstantiateChaincodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<InstantiateChaincodeResponseBodyResult> result{};
  shared_ptr<bool> success{};

  InstantiateChaincodeResponseBody() {}

  explicit InstantiateChaincodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        InstantiateChaincodeResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<InstantiateChaincodeResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~InstantiateChaincodeResponseBody() = default;
};
class InstantiateChaincodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InstantiateChaincodeResponseBody> body{};

  InstantiateChaincodeResponse() {}

  explicit InstantiateChaincodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstantiateChaincodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstantiateChaincodeResponseBody>(model1);
      }
    }
  }


  virtual ~InstantiateChaincodeResponse() = default;
};
class InviteUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> bid{};
  shared_ptr<string> bizid{};
  shared_ptr<string> userEmail{};
  shared_ptr<long> userId{};

  InviteUserRequest() {}

  explicit InviteUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bid) {
      res["Bid"] = boost::any(*bid);
    }
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (userEmail) {
      res["UserEmail"] = boost::any(*userEmail);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bid") != m.end() && !m["Bid"].empty()) {
      bid = make_shared<string>(boost::any_cast<string>(m["Bid"]));
    }
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("UserEmail") != m.end() && !m["UserEmail"].empty()) {
      userEmail = make_shared<string>(boost::any_cast<string>(m["UserEmail"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
  }


  virtual ~InviteUserRequest() = default;
};
class InviteUserResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> bid{};
  shared_ptr<string> bizid{};
  shared_ptr<string> code{};
  shared_ptr<long> createTime{};
  shared_ptr<string> email{};
  shared_ptr<string> fromBid{};
  shared_ptr<long> fromUserId{};
  shared_ptr<long> status{};
  shared_ptr<long> updateTime{};
  shared_ptr<long> userId{};

  InviteUserResponseBodyResult() {}

  explicit InviteUserResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bid) {
      res["Bid"] = boost::any(*bid);
    }
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (fromBid) {
      res["FromBid"] = boost::any(*fromBid);
    }
    if (fromUserId) {
      res["FromUserId"] = boost::any(*fromUserId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bid") != m.end() && !m["Bid"].empty()) {
      bid = make_shared<string>(boost::any_cast<string>(m["Bid"]));
    }
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("FromBid") != m.end() && !m["FromBid"].empty()) {
      fromBid = make_shared<string>(boost::any_cast<string>(m["FromBid"]));
    }
    if (m.find("FromUserId") != m.end() && !m["FromUserId"].empty()) {
      fromUserId = make_shared<long>(boost::any_cast<long>(m["FromUserId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
  }


  virtual ~InviteUserResponseBodyResult() = default;
};
class InviteUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<InviteUserResponseBodyResult> result{};

  InviteUserResponseBody() {}

  explicit InviteUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        InviteUserResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<InviteUserResponseBodyResult>(model1);
      }
    }
  }


  virtual ~InviteUserResponseBody() = default;
};
class InviteUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InviteUserResponseBody> body{};

  InviteUserResponse() {}

  explicit InviteUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InviteUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InviteUserResponseBody>(model1);
      }
    }
  }


  virtual ~InviteUserResponse() = default;
};
class JoinChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> do_{};
  shared_ptr<string> location{};

  JoinChannelRequest() {}

  explicit JoinChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (do_) {
      res["Do"] = boost::any(*do_);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Do") != m.end() && !m["Do"].empty()) {
      do_ = make_shared<string>(boost::any_cast<string>(m["Do"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
  }


  virtual ~JoinChannelRequest() = default;
};
class JoinChannelResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> acceptTime{};
  shared_ptr<string> approveTime{};
  shared_ptr<string> channelId{};
  shared_ptr<string> confirmTime{};
  shared_ptr<string> destroyTime{};
  shared_ptr<string> inviteTime{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> state{};
  shared_ptr<bool> withPeer{};

  JoinChannelResponseBodyResult() {}

  explicit JoinChannelResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptTime) {
      res["AcceptTime"] = boost::any(*acceptTime);
    }
    if (approveTime) {
      res["ApproveTime"] = boost::any(*approveTime);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (confirmTime) {
      res["ConfirmTime"] = boost::any(*confirmTime);
    }
    if (destroyTime) {
      res["DestroyTime"] = boost::any(*destroyTime);
    }
    if (inviteTime) {
      res["InviteTime"] = boost::any(*inviteTime);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (withPeer) {
      res["WithPeer"] = boost::any(*withPeer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptTime") != m.end() && !m["AcceptTime"].empty()) {
      acceptTime = make_shared<string>(boost::any_cast<string>(m["AcceptTime"]));
    }
    if (m.find("ApproveTime") != m.end() && !m["ApproveTime"].empty()) {
      approveTime = make_shared<string>(boost::any_cast<string>(m["ApproveTime"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ConfirmTime") != m.end() && !m["ConfirmTime"].empty()) {
      confirmTime = make_shared<string>(boost::any_cast<string>(m["ConfirmTime"]));
    }
    if (m.find("DestroyTime") != m.end() && !m["DestroyTime"].empty()) {
      destroyTime = make_shared<string>(boost::any_cast<string>(m["DestroyTime"]));
    }
    if (m.find("InviteTime") != m.end() && !m["InviteTime"].empty()) {
      inviteTime = make_shared<string>(boost::any_cast<string>(m["InviteTime"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("WithPeer") != m.end() && !m["WithPeer"].empty()) {
      withPeer = make_shared<bool>(boost::any_cast<bool>(m["WithPeer"]));
    }
  }


  virtual ~JoinChannelResponseBodyResult() = default;
};
class JoinChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<JoinChannelResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  JoinChannelResponseBody() {}

  explicit JoinChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<JoinChannelResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            JoinChannelResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<JoinChannelResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~JoinChannelResponseBody() = default;
};
class JoinChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<JoinChannelResponseBody> body{};

  JoinChannelResponse() {}

  explicit JoinChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        JoinChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<JoinChannelResponseBody>(model1);
      }
    }
  }


  virtual ~JoinChannelResponse() = default;
};
class ListTagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTagResourcesRequestTag() {}

  explicit ListTagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTagResourcesRequestTag() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<ListTagResourcesRequestTag>> tag{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListTagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListTagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListTagResourcesResponseBodyTagResources() {}

  explicit ListTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResources() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListTagResourcesResponseBodyTagResources>> tagResources{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      vector<boost::any> temp1;
      for(auto item1:*tagResources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResources"].type()) {
        vector<ListTagResourcesResponseBodyTagResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyTagResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResources = make_shared<vector<ListTagResourcesResponseBodyTagResources>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class ModifyTriggerRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> name{};
  shared_ptr<string> options{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> source{};
  shared_ptr<string> status{};

  ModifyTriggerRequest() {}

  explicit ModifyTriggerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (options) {
      res["Options"] = boost::any(*options);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Options") != m.end() && !m["Options"].empty()) {
      options = make_shared<string>(boost::any_cast<string>(m["Options"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~ModifyTriggerRequest() = default;
};
class ModifyTriggerResponseBodyResultCheckpoint : public Darabonba::Model {
public:
  shared_ptr<long> errorCount{};
  shared_ptr<long> height{};
  shared_ptr<long> index{};
  shared_ptr<string> type{};

  ModifyTriggerResponseBodyResultCheckpoint() {}

  explicit ModifyTriggerResponseBodyResultCheckpoint(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCount) {
      res["ErrorCount"] = boost::any(*errorCount);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCount") != m.end() && !m["ErrorCount"].empty()) {
      errorCount = make_shared<long>(boost::any_cast<long>(m["ErrorCount"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ModifyTriggerResponseBodyResultCheckpoint() = default;
};
class ModifyTriggerResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> channelName{};
  shared_ptr<ModifyTriggerResponseBodyResultCheckpoint> checkpoint{};
  shared_ptr<long> createTime{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> name{};
  shared_ptr<string> options{};
  shared_ptr<string> source{};
  shared_ptr<long> status{};
  shared_ptr<string> type{};

  ModifyTriggerResponseBodyResult() {}

  explicit ModifyTriggerResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (checkpoint) {
      res["Checkpoint"] = checkpoint ? boost::any(checkpoint->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (options) {
      res["Options"] = boost::any(*options);
    }
    if (source) {
      res["Source"] = boost::any(*source);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("Checkpoint") != m.end() && !m["Checkpoint"].empty()) {
      if (typeid(map<string, boost::any>) == m["Checkpoint"].type()) {
        ModifyTriggerResponseBodyResultCheckpoint model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Checkpoint"]));
        checkpoint = make_shared<ModifyTriggerResponseBodyResultCheckpoint>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Options") != m.end() && !m["Options"].empty()) {
      options = make_shared<string>(boost::any_cast<string>(m["Options"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ModifyTriggerResponseBodyResult() = default;
};
class ModifyTriggerResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<ModifyTriggerResponseBodyResult> result{};
  shared_ptr<bool> success{};

  ModifyTriggerResponseBody() {}

  explicit ModifyTriggerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ModifyTriggerResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ModifyTriggerResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifyTriggerResponseBody() = default;
};
class ModifyTriggerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyTriggerResponseBody> body{};

  ModifyTriggerResponse() {}

  explicit ModifyTriggerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyTriggerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyTriggerResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyTriggerResponse() = default;
};
class OperateUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> bid{};
  shared_ptr<string> bizid{};
  shared_ptr<long> operation{};
  shared_ptr<string> userName{};

  OperateUserRequest() {}

  explicit OperateUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bid) {
      res["Bid"] = boost::any(*bid);
    }
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bid") != m.end() && !m["Bid"].empty()) {
      bid = make_shared<string>(boost::any_cast<string>(m["Bid"]));
    }
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<long>(boost::any_cast<long>(m["Operation"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~OperateUserRequest() = default;
};
class OperateUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  OperateUserResponseBody() {}

  explicit OperateUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~OperateUserResponseBody() = default;
};
class OperateUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OperateUserResponseBody> body{};

  OperateUserResponse() {}

  explicit OperateUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OperateUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OperateUserResponseBody>(model1);
      }
    }
  }


  virtual ~OperateUserResponse() = default;
};
class ProcessCloudIDEContractTransactionRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> transaction{};

  ProcessCloudIDEContractTransactionRequest() {}

  explicit ProcessCloudIDEContractTransactionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (transaction) {
      res["Transaction"] = boost::any(*transaction);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("Transaction") != m.end() && !m["Transaction"].empty()) {
      transaction = make_shared<string>(boost::any_cast<string>(m["Transaction"]));
    }
  }


  virtual ~ProcessCloudIDEContractTransactionRequest() = default;
};
class ProcessCloudIDEContractTransactionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  ProcessCloudIDEContractTransactionResponseBody() {}

  explicit ProcessCloudIDEContractTransactionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~ProcessCloudIDEContractTransactionResponseBody() = default;
};
class ProcessCloudIDEContractTransactionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ProcessCloudIDEContractTransactionResponseBody> body{};

  ProcessCloudIDEContractTransactionResponse() {}

  explicit ProcessCloudIDEContractTransactionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ProcessCloudIDEContractTransactionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ProcessCloudIDEContractTransactionResponseBody>(model1);
      }
    }
  }


  virtual ~ProcessCloudIDEContractTransactionResponse() = default;
};
class ProcessPublicCloudIDEContractTransactionRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<string> transaction{};

  ProcessPublicCloudIDEContractTransactionRequest() {}

  explicit ProcessPublicCloudIDEContractTransactionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (transaction) {
      res["Transaction"] = boost::any(*transaction);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Transaction") != m.end() && !m["Transaction"].empty()) {
      transaction = make_shared<string>(boost::any_cast<string>(m["Transaction"]));
    }
  }


  virtual ~ProcessPublicCloudIDEContractTransactionRequest() = default;
};
class ProcessPublicCloudIDEContractTransactionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  ProcessPublicCloudIDEContractTransactionResponseBody() {}

  explicit ProcessPublicCloudIDEContractTransactionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~ProcessPublicCloudIDEContractTransactionResponseBody() = default;
};
class ProcessPublicCloudIDEContractTransactionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ProcessPublicCloudIDEContractTransactionResponseBody> body{};

  ProcessPublicCloudIDEContractTransactionResponse() {}

  explicit ProcessPublicCloudIDEContractTransactionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ProcessPublicCloudIDEContractTransactionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ProcessPublicCloudIDEContractTransactionResponseBody>(model1);
      }
    }
  }


  virtual ~ProcessPublicCloudIDEContractTransactionResponse() = default;
};
class QueryBlockRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<long> height{};

  QueryBlockRequest() {}

  explicit QueryBlockRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
  }


  virtual ~QueryBlockRequest() = default;
};
class QueryBlockResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> blockHash{};
  shared_ptr<long> createTime{};
  shared_ptr<long> height{};
  shared_ptr<string> previousHash{};
  shared_ptr<string> rootTxHash{};
  shared_ptr<string> transSummaryList{};
  shared_ptr<long> transactionSize{};

  QueryBlockResponseBodyResult() {}

  explicit QueryBlockResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (blockHash) {
      res["BlockHash"] = boost::any(*blockHash);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (previousHash) {
      res["PreviousHash"] = boost::any(*previousHash);
    }
    if (rootTxHash) {
      res["RootTxHash"] = boost::any(*rootTxHash);
    }
    if (transSummaryList) {
      res["TransSummaryList"] = boost::any(*transSummaryList);
    }
    if (transactionSize) {
      res["TransactionSize"] = boost::any(*transactionSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("BlockHash") != m.end() && !m["BlockHash"].empty()) {
      blockHash = make_shared<string>(boost::any_cast<string>(m["BlockHash"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("PreviousHash") != m.end() && !m["PreviousHash"].empty()) {
      previousHash = make_shared<string>(boost::any_cast<string>(m["PreviousHash"]));
    }
    if (m.find("RootTxHash") != m.end() && !m["RootTxHash"].empty()) {
      rootTxHash = make_shared<string>(boost::any_cast<string>(m["RootTxHash"]));
    }
    if (m.find("TransSummaryList") != m.end() && !m["TransSummaryList"].empty()) {
      transSummaryList = make_shared<string>(boost::any_cast<string>(m["TransSummaryList"]));
    }
    if (m.find("TransactionSize") != m.end() && !m["TransactionSize"].empty()) {
      transactionSize = make_shared<long>(boost::any_cast<long>(m["TransactionSize"]));
    }
  }


  virtual ~QueryBlockResponseBodyResult() = default;
};
class QueryBlockResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryBlockResponseBodyResult> result{};

  QueryBlockResponseBody() {}

  explicit QueryBlockResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        QueryBlockResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<QueryBlockResponseBodyResult>(model1);
      }
    }
  }


  virtual ~QueryBlockResponseBody() = default;
};
class QueryBlockResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryBlockResponseBody> body{};

  QueryBlockResponse() {}

  explicit QueryBlockResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryBlockResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryBlockResponseBody>(model1);
      }
    }
  }


  virtual ~QueryBlockResponse() = default;
};
class QueryConsortiumDeletableRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> location{};

  QueryConsortiumDeletableRequest() {}

  explicit QueryConsortiumDeletableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
  }


  virtual ~QueryConsortiumDeletableRequest() = default;
};
class QueryConsortiumDeletableResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> codeName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<bool> deletable{};
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};
  shared_ptr<string> state{};
  shared_ptr<string> zoneId{};

  QueryConsortiumDeletableResponseBodyResult() {}

  explicit QueryConsortiumDeletableResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codeName) {
      res["CodeName"] = boost::any(*codeName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (deletable) {
      res["Deletable"] = boost::any(*deletable);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodeName") != m.end() && !m["CodeName"].empty()) {
      codeName = make_shared<string>(boost::any_cast<string>(m["CodeName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Deletable") != m.end() && !m["Deletable"].empty()) {
      deletable = make_shared<bool>(boost::any_cast<bool>(m["Deletable"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~QueryConsortiumDeletableResponseBodyResult() = default;
};
class QueryConsortiumDeletableResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryConsortiumDeletableResponseBodyResult> result{};
  shared_ptr<bool> success{};

  QueryConsortiumDeletableResponseBody() {}

  explicit QueryConsortiumDeletableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        QueryConsortiumDeletableResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<QueryConsortiumDeletableResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryConsortiumDeletableResponseBody() = default;
};
class QueryConsortiumDeletableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryConsortiumDeletableResponseBody> body{};

  QueryConsortiumDeletableResponse() {}

  explicit QueryConsortiumDeletableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryConsortiumDeletableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryConsortiumDeletableResponseBody>(model1);
      }
    }
  }


  virtual ~QueryConsortiumDeletableResponse() = default;
};
class QueryEthereumDeletableRequest : public Darabonba::Model {
public:
  shared_ptr<string> ethereumId{};

  QueryEthereumDeletableRequest() {}

  explicit QueryEthereumDeletableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ethereumId) {
      res["EthereumId"] = boost::any(*ethereumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EthereumId") != m.end() && !m["EthereumId"].empty()) {
      ethereumId = make_shared<string>(boost::any_cast<string>(m["EthereumId"]));
    }
  }


  virtual ~QueryEthereumDeletableRequest() = default;
};
class QueryEthereumDeletableResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> deletable{};
  shared_ptr<string> ethereumId{};

  QueryEthereumDeletableResponseBodyResult() {}

  explicit QueryEthereumDeletableResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deletable) {
      res["Deletable"] = boost::any(*deletable);
    }
    if (ethereumId) {
      res["EthereumId"] = boost::any(*ethereumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Deletable") != m.end() && !m["Deletable"].empty()) {
      deletable = make_shared<bool>(boost::any_cast<bool>(m["Deletable"]));
    }
    if (m.find("EthereumId") != m.end() && !m["EthereumId"].empty()) {
      ethereumId = make_shared<string>(boost::any_cast<string>(m["EthereumId"]));
    }
  }


  virtual ~QueryEthereumDeletableResponseBodyResult() = default;
};
class QueryEthereumDeletableResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryEthereumDeletableResponseBodyResult> result{};
  shared_ptr<bool> success{};

  QueryEthereumDeletableResponseBody() {}

  explicit QueryEthereumDeletableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        QueryEthereumDeletableResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<QueryEthereumDeletableResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryEthereumDeletableResponseBody() = default;
};
class QueryEthereumDeletableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryEthereumDeletableResponseBody> body{};

  QueryEthereumDeletableResponse() {}

  explicit QueryEthereumDeletableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryEthereumDeletableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryEthereumDeletableResponseBody>(model1);
      }
    }
  }


  virtual ~QueryEthereumDeletableResponse() = default;
};
class QueryMetricRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<string> innerIp{};
  shared_ptr<string> metric{};
  shared_ptr<string> period{};
  shared_ptr<string> port{};
  shared_ptr<string> timeArea{};

  QueryMetricRequest() {}

  explicit QueryMetricRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (innerIp) {
      res["InnerIp"] = boost::any(*innerIp);
    }
    if (metric) {
      res["Metric"] = boost::any(*metric);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (timeArea) {
      res["TimeArea"] = boost::any(*timeArea);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("InnerIp") != m.end() && !m["InnerIp"].empty()) {
      innerIp = make_shared<string>(boost::any_cast<string>(m["InnerIp"]));
    }
    if (m.find("Metric") != m.end() && !m["Metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["Metric"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["Period"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["Port"]));
    }
    if (m.find("TimeArea") != m.end() && !m["TimeArea"].empty()) {
      timeArea = make_shared<string>(boost::any_cast<string>(m["TimeArea"]));
    }
  }


  virtual ~QueryMetricRequest() = default;
};
class QueryMetricResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  QueryMetricResponseBody() {}

  explicit QueryMetricResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~QueryMetricResponseBody() = default;
};
class QueryMetricResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryMetricResponseBody> body{};

  QueryMetricResponse() {}

  explicit QueryMetricResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryMetricResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryMetricResponseBody>(model1);
      }
    }
  }


  virtual ~QueryMetricResponse() = default;
};
class QueryOrganizationDeletableRequest : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};

  QueryOrganizationDeletableRequest() {}

  explicit QueryOrganizationDeletableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~QueryOrganizationDeletableRequest() = default;
};
class QueryOrganizationDeletableResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> codeName{};
  shared_ptr<bool> deletable{};
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<string> name{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> state{};
  shared_ptr<string> zoneId{};

  QueryOrganizationDeletableResponseBodyResult() {}

  explicit QueryOrganizationDeletableResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codeName) {
      res["CodeName"] = boost::any(*codeName);
    }
    if (deletable) {
      res["Deletable"] = boost::any(*deletable);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodeName") != m.end() && !m["CodeName"].empty()) {
      codeName = make_shared<string>(boost::any_cast<string>(m["CodeName"]));
    }
    if (m.find("Deletable") != m.end() && !m["Deletable"].empty()) {
      deletable = make_shared<bool>(boost::any_cast<bool>(m["Deletable"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~QueryOrganizationDeletableResponseBodyResult() = default;
};
class QueryOrganizationDeletableResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<QueryOrganizationDeletableResponseBodyResult> result{};
  shared_ptr<bool> success{};

  QueryOrganizationDeletableResponseBody() {}

  explicit QueryOrganizationDeletableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        QueryOrganizationDeletableResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<QueryOrganizationDeletableResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~QueryOrganizationDeletableResponseBody() = default;
};
class QueryOrganizationDeletableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryOrganizationDeletableResponseBody> body{};

  QueryOrganizationDeletableResponse() {}

  explicit QueryOrganizationDeletableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryOrganizationDeletableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryOrganizationDeletableResponseBody>(model1);
      }
    }
  }


  virtual ~QueryOrganizationDeletableResponse() = default;
};
class QueryTransactionRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<string> hash{};

  QueryTransactionRequest() {}

  explicit QueryTransactionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (hash) {
      res["Hash"] = boost::any(*hash);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Hash") != m.end() && !m["Hash"].empty()) {
      hash = make_shared<string>(boost::any_cast<string>(m["Hash"]));
    }
  }


  virtual ~QueryTransactionRequest() = default;
};
class QueryTransactionResponseBodyResultReferenceList : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<long> length{};
  shared_ptr<long> type{};

  QueryTransactionResponseBodyResultReferenceList() {}

  explicit QueryTransactionResponseBodyResultReferenceList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~QueryTransactionResponseBodyResultReferenceList() = default;
};
class QueryTransactionResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> blockHeight{};
  shared_ptr<long> blockVersion{};
  shared_ptr<long> category{};
  shared_ptr<string> content{};
  shared_ptr<string> contentHash{};
  shared_ptr<long> createTime{};
  shared_ptr<string> hash{};
  shared_ptr<string> keyName{};
  shared_ptr<string> keyWrap{};
  shared_ptr<string> nonce{};
  shared_ptr<long> referenceCount{};
  shared_ptr<QueryTransactionResponseBodyResultReferenceList> referenceList{};
  shared_ptr<long> type{};

  QueryTransactionResponseBodyResult() {}

  explicit QueryTransactionResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockHeight) {
      res["BlockHeight"] = boost::any(*blockHeight);
    }
    if (blockVersion) {
      res["BlockVersion"] = boost::any(*blockVersion);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentHash) {
      res["ContentHash"] = boost::any(*contentHash);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (hash) {
      res["Hash"] = boost::any(*hash);
    }
    if (keyName) {
      res["KeyName"] = boost::any(*keyName);
    }
    if (keyWrap) {
      res["KeyWrap"] = boost::any(*keyWrap);
    }
    if (nonce) {
      res["Nonce"] = boost::any(*nonce);
    }
    if (referenceCount) {
      res["ReferenceCount"] = boost::any(*referenceCount);
    }
    if (referenceList) {
      res["ReferenceList"] = referenceList ? boost::any(referenceList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockHeight") != m.end() && !m["BlockHeight"].empty()) {
      blockHeight = make_shared<long>(boost::any_cast<long>(m["BlockHeight"]));
    }
    if (m.find("BlockVersion") != m.end() && !m["BlockVersion"].empty()) {
      blockVersion = make_shared<long>(boost::any_cast<long>(m["BlockVersion"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<long>(boost::any_cast<long>(m["Category"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentHash") != m.end() && !m["ContentHash"].empty()) {
      contentHash = make_shared<string>(boost::any_cast<string>(m["ContentHash"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Hash") != m.end() && !m["Hash"].empty()) {
      hash = make_shared<string>(boost::any_cast<string>(m["Hash"]));
    }
    if (m.find("KeyName") != m.end() && !m["KeyName"].empty()) {
      keyName = make_shared<string>(boost::any_cast<string>(m["KeyName"]));
    }
    if (m.find("KeyWrap") != m.end() && !m["KeyWrap"].empty()) {
      keyWrap = make_shared<string>(boost::any_cast<string>(m["KeyWrap"]));
    }
    if (m.find("Nonce") != m.end() && !m["Nonce"].empty()) {
      nonce = make_shared<string>(boost::any_cast<string>(m["Nonce"]));
    }
    if (m.find("ReferenceCount") != m.end() && !m["ReferenceCount"].empty()) {
      referenceCount = make_shared<long>(boost::any_cast<long>(m["ReferenceCount"]));
    }
    if (m.find("ReferenceList") != m.end() && !m["ReferenceList"].empty()) {
      if (typeid(map<string, boost::any>) == m["ReferenceList"].type()) {
        QueryTransactionResponseBodyResultReferenceList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ReferenceList"]));
        referenceList = make_shared<QueryTransactionResponseBodyResultReferenceList>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~QueryTransactionResponseBodyResult() = default;
};
class QueryTransactionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<QueryTransactionResponseBodyResult> result{};

  QueryTransactionResponseBody() {}

  explicit QueryTransactionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        QueryTransactionResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<QueryTransactionResponseBodyResult>(model1);
      }
    }
  }


  virtual ~QueryTransactionResponseBody() = default;
};
class QueryTransactionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryTransactionResponseBody> body{};

  QueryTransactionResponse() {}

  explicit QueryTransactionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryTransactionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryTransactionResponseBody>(model1);
      }
    }
  }


  virtual ~QueryTransactionResponse() = default;
};
class RejectUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> bid{};
  shared_ptr<string> bizid{};
  shared_ptr<string> reason{};
  shared_ptr<string> userName{};

  RejectUserRequest() {}

  explicit RejectUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bid) {
      res["Bid"] = boost::any(*bid);
    }
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bid") != m.end() && !m["Bid"].empty()) {
      bid = make_shared<string>(boost::any_cast<string>(m["Bid"]));
    }
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~RejectUserRequest() = default;
};
class RejectUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  RejectUserResponseBody() {}

  explicit RejectUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~RejectUserResponseBody() = default;
};
class RejectUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RejectUserResponseBody> body{};

  RejectUserResponse() {}

  explicit RejectUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RejectUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RejectUserResponseBody>(model1);
      }
    }
  }


  virtual ~RejectUserResponse() = default;
};
class RenameBlockchainRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<string> newName{};

  RenameBlockchainRequest() {}

  explicit RenameBlockchainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (newName) {
      res["NewName"] = boost::any(*newName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("NewName") != m.end() && !m["NewName"].empty()) {
      newName = make_shared<string>(boost::any_cast<string>(m["NewName"]));
    }
  }


  virtual ~RenameBlockchainRequest() = default;
};
class RenameBlockchainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  RenameBlockchainResponseBody() {}

  explicit RenameBlockchainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~RenameBlockchainResponseBody() = default;
};
class RenameBlockchainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RenameBlockchainResponseBody> body{};

  RenameBlockchainResponse() {}

  explicit RenameBlockchainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RenameBlockchainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RenameBlockchainResponseBody>(model1);
      }
    }
  }


  virtual ~RenameBlockchainResponse() = default;
};
class ResetAntChainCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};

  ResetAntChainCertificateRequest() {}

  explicit ResetAntChainCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
  }


  virtual ~ResetAntChainCertificateRequest() = default;
};
class ResetAntChainCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  ResetAntChainCertificateResponseBody() {}

  explicit ResetAntChainCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~ResetAntChainCertificateResponseBody() = default;
};
class ResetAntChainCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetAntChainCertificateResponseBody> body{};

  ResetAntChainCertificateResponse() {}

  explicit ResetAntChainCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetAntChainCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetAntChainCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~ResetAntChainCertificateResponse() = default;
};
class ResetAntChainUserCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> bid{};
  shared_ptr<long> operation{};
  shared_ptr<string> username{};

  ResetAntChainUserCertificateRequest() {}

  explicit ResetAntChainUserCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (bid) {
      res["Bid"] = boost::any(*bid);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("Bid") != m.end() && !m["Bid"].empty()) {
      bid = make_shared<string>(boost::any_cast<string>(m["Bid"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<long>(boost::any_cast<long>(m["Operation"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~ResetAntChainUserCertificateRequest() = default;
};
class ResetAntChainUserCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  ResetAntChainUserCertificateResponseBody() {}

  explicit ResetAntChainUserCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~ResetAntChainUserCertificateResponseBody() = default;
};
class ResetAntChainUserCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetAntChainUserCertificateResponseBody> body{};

  ResetAntChainUserCertificateResponse() {}

  explicit ResetAntChainUserCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetAntChainUserCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetAntChainUserCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~ResetAntChainUserCertificateResponse() = default;
};
class ResetCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};

  ResetCertificateRequest() {}

  explicit ResetCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~ResetCertificateRequest() = default;
};
class ResetCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  ResetCertificateResponseBody() {}

  explicit ResetCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~ResetCertificateResponseBody() = default;
};
class ResetCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetCertificateResponseBody> body{};

  ResetCertificateResponse() {}

  explicit ResetCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~ResetCertificateResponse() = default;
};
class ResetOrganizationUserPasswordRequest : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> password{};
  shared_ptr<string> username{};

  ResetOrganizationUserPasswordRequest() {}

  explicit ResetOrganizationUserPasswordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~ResetOrganizationUserPasswordRequest() = default;
};
class ResetOrganizationUserPasswordResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> fullname{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> password{};
  shared_ptr<string> username{};

  ResetOrganizationUserPasswordResponseBodyResult() {}

  explicit ResetOrganizationUserPasswordResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (fullname) {
      res["Fullname"] = boost::any(*fullname);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("Fullname") != m.end() && !m["Fullname"].empty()) {
      fullname = make_shared<string>(boost::any_cast<string>(m["Fullname"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~ResetOrganizationUserPasswordResponseBodyResult() = default;
};
class ResetOrganizationUserPasswordResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<ResetOrganizationUserPasswordResponseBodyResult> result{};
  shared_ptr<bool> success{};

  ResetOrganizationUserPasswordResponseBody() {}

  explicit ResetOrganizationUserPasswordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ResetOrganizationUserPasswordResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ResetOrganizationUserPasswordResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ResetOrganizationUserPasswordResponseBody() = default;
};
class ResetOrganizationUserPasswordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetOrganizationUserPasswordResponseBody> body{};

  ResetOrganizationUserPasswordResponse() {}

  explicit ResetOrganizationUserPasswordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetOrganizationUserPasswordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetOrganizationUserPasswordResponseBody>(model1);
      }
    }
  }


  virtual ~ResetOrganizationUserPasswordResponse() = default;
};
class ResetPublicAntChainCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};

  ResetPublicAntChainCertificateRequest() {}

  explicit ResetPublicAntChainCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~ResetPublicAntChainCertificateRequest() = default;
};
class ResetPublicAntChainCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  ResetPublicAntChainCertificateResponseBody() {}

  explicit ResetPublicAntChainCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~ResetPublicAntChainCertificateResponseBody() = default;
};
class ResetPublicAntChainCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetPublicAntChainCertificateResponseBody> body{};

  ResetPublicAntChainCertificateResponse() {}

  explicit ResetPublicAntChainCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetPublicAntChainCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetPublicAntChainCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~ResetPublicAntChainCertificateResponse() = default;
};
class ResetUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> bid{};
  shared_ptr<string> bizid{};
  shared_ptr<long> operation{};
  shared_ptr<string> userName{};

  ResetUserRequest() {}

  explicit ResetUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bid) {
      res["Bid"] = boost::any(*bid);
    }
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bid") != m.end() && !m["Bid"].empty()) {
      bid = make_shared<string>(boost::any_cast<string>(m["Bid"]));
    }
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<long>(boost::any_cast<long>(m["Operation"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~ResetUserRequest() = default;
};
class ResetUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  ResetUserResponseBody() {}

  explicit ResetUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~ResetUserResponseBody() = default;
};
class ResetUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetUserResponseBody> body{};

  ResetUserResponse() {}

  explicit ResetUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetUserResponseBody>(model1);
      }
    }
  }


  virtual ~ResetUserResponse() = default;
};
class SchemaDetailRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<long> schemaId{};

  SchemaDetailRequest() {}

  explicit SchemaDetailRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (schemaId) {
      res["SchemaId"] = boost::any(*schemaId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("SchemaId") != m.end() && !m["SchemaId"].empty()) {
      schemaId = make_shared<long>(boost::any_cast<long>(m["SchemaId"]));
    }
  }


  virtual ~SchemaDetailRequest() = default;
};
class SchemaDetailResponseBodyResultResponsesPropertiesDataSource : public Darabonba::Model {
public:
  shared_ptr<long> allowNull{};
  shared_ptr<string> annotation{};
  shared_ptr<string> field{};
  shared_ptr<long> indexes{};
  shared_ptr<long> key{};
  shared_ptr<long> length{};
  shared_ptr<string> reg{};
  shared_ptr<string> type{};

  SchemaDetailResponseBodyResultResponsesPropertiesDataSource() {}

  explicit SchemaDetailResponseBodyResultResponsesPropertiesDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowNull) {
      res["AllowNull"] = boost::any(*allowNull);
    }
    if (annotation) {
      res["Annotation"] = boost::any(*annotation);
    }
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (indexes) {
      res["Indexes"] = boost::any(*indexes);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (reg) {
      res["Reg"] = boost::any(*reg);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowNull") != m.end() && !m["AllowNull"].empty()) {
      allowNull = make_shared<long>(boost::any_cast<long>(m["AllowNull"]));
    }
    if (m.find("Annotation") != m.end() && !m["Annotation"].empty()) {
      annotation = make_shared<string>(boost::any_cast<string>(m["Annotation"]));
    }
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("Indexes") != m.end() && !m["Indexes"].empty()) {
      indexes = make_shared<long>(boost::any_cast<long>(m["Indexes"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<long>(boost::any_cast<long>(m["Key"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("Reg") != m.end() && !m["Reg"].empty()) {
      reg = make_shared<string>(boost::any_cast<string>(m["Reg"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~SchemaDetailResponseBodyResultResponsesPropertiesDataSource() = default;
};
class SchemaDetailResponseBodyResultResponsesProperties : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<SchemaDetailResponseBodyResultResponsesPropertiesDataSource>> dataSource{};

  SchemaDetailResponseBodyResultResponsesProperties() {}

  explicit SchemaDetailResponseBodyResultResponsesProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (dataSource) {
      vector<boost::any> temp1;
      for(auto item1:*dataSource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataSource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(vector<boost::any>) == m["DataSource"].type()) {
        vector<SchemaDetailResponseBodyResultResponsesPropertiesDataSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataSource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SchemaDetailResponseBodyResultResponsesPropertiesDataSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataSource = make_shared<vector<SchemaDetailResponseBodyResultResponsesPropertiesDataSource>>(expect1);
      }
    }
  }


  virtual ~SchemaDetailResponseBodyResultResponsesProperties() = default;
};
class SchemaDetailResponseBodyResultResponses : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> categoryName{};
  shared_ptr<string> description{};
  shared_ptr<SchemaDetailResponseBodyResultResponsesProperties> properties{};

  SchemaDetailResponseBodyResultResponses() {}

  explicit SchemaDetailResponseBodyResultResponses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (categoryName) {
      res["CategoryName"] = boost::any(*categoryName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CategoryName") != m.end() && !m["CategoryName"].empty()) {
      categoryName = make_shared<string>(boost::any_cast<string>(m["CategoryName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        SchemaDetailResponseBodyResultResponsesProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<SchemaDetailResponseBodyResultResponsesProperties>(model1);
      }
    }
  }


  virtual ~SchemaDetailResponseBodyResultResponses() = default;
};
class SchemaDetailResponseBodyResultSchema : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<bool> isTemplate{};
  shared_ptr<string> name{};
  shared_ptr<long> updateTime{};
  shared_ptr<long> version{};

  SchemaDetailResponseBodyResultSchema() {}

  explicit SchemaDetailResponseBodyResultSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsTemplate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~SchemaDetailResponseBodyResultSchema() = default;
};
class SchemaDetailResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<SchemaDetailResponseBodyResultResponses>> responses{};
  shared_ptr<SchemaDetailResponseBodyResultSchema> schema{};

  SchemaDetailResponseBodyResult() {}

  explicit SchemaDetailResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (responses) {
      vector<boost::any> temp1;
      for(auto item1:*responses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Responses"] = boost::any(temp1);
    }
    if (schema) {
      res["Schema"] = schema ? boost::any(schema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Responses") != m.end() && !m["Responses"].empty()) {
      if (typeid(vector<boost::any>) == m["Responses"].type()) {
        vector<SchemaDetailResponseBodyResultResponses> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Responses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SchemaDetailResponseBodyResultResponses model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        responses = make_shared<vector<SchemaDetailResponseBodyResultResponses>>(expect1);
      }
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      if (typeid(map<string, boost::any>) == m["Schema"].type()) {
        SchemaDetailResponseBodyResultSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Schema"]));
        schema = make_shared<SchemaDetailResponseBodyResultSchema>(model1);
      }
    }
  }


  virtual ~SchemaDetailResponseBodyResult() = default;
};
class SchemaDetailResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<SchemaDetailResponseBodyResult> result{};

  SchemaDetailResponseBody() {}

  explicit SchemaDetailResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        SchemaDetailResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<SchemaDetailResponseBodyResult>(model1);
      }
    }
  }


  virtual ~SchemaDetailResponseBody() = default;
};
class SchemaDetailResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SchemaDetailResponseBody> body{};

  SchemaDetailResponse() {}

  explicit SchemaDetailResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SchemaDetailResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SchemaDetailResponseBody>(model1);
      }
    }
  }


  virtual ~SchemaDetailResponse() = default;
};
class StartSmartContractJobRequest : public Darabonba::Model {
public:
  shared_ptr<string> jobId{};
  shared_ptr<string> jobName{};
  shared_ptr<string> sourceOpt{};
  shared_ptr<string> sourceType{};

  StartSmartContractJobRequest() {}

  explicit StartSmartContractJobRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (jobId) {
      res["JobId"] = boost::any(*jobId);
    }
    if (jobName) {
      res["JobName"] = boost::any(*jobName);
    }
    if (sourceOpt) {
      res["SourceOpt"] = boost::any(*sourceOpt);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JobId") != m.end() && !m["JobId"].empty()) {
      jobId = make_shared<string>(boost::any_cast<string>(m["JobId"]));
    }
    if (m.find("JobName") != m.end() && !m["JobName"].empty()) {
      jobName = make_shared<string>(boost::any_cast<string>(m["JobName"]));
    }
    if (m.find("SourceOpt") != m.end() && !m["SourceOpt"].empty()) {
      sourceOpt = make_shared<string>(boost::any_cast<string>(m["SourceOpt"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
  }


  virtual ~StartSmartContractJobRequest() = default;
};
class StartSmartContractJobResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  StartSmartContractJobResponseBody() {}

  explicit StartSmartContractJobResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~StartSmartContractJobResponseBody() = default;
};
class StartSmartContractJobResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartSmartContractJobResponseBody> body{};

  StartSmartContractJobResponse() {}

  explicit StartSmartContractJobResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartSmartContractJobResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartSmartContractJobResponseBody>(model1);
      }
    }
  }


  virtual ~StartSmartContractJobResponse() = default;
};
class SubmitFabricChaincodeDefinitionRequest : public Darabonba::Model {
public:
  shared_ptr<string> chaincodePackageId{};
  shared_ptr<string> chaincodeVersion{};
  shared_ptr<string> channelId{};
  shared_ptr<string> collectionConfig{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<bool> initRequired{};
  shared_ptr<string> location{};
  shared_ptr<string> name{};
  shared_ptr<string> organizationId{};

  SubmitFabricChaincodeDefinitionRequest() {}

  explicit SubmitFabricChaincodeDefinitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodePackageId) {
      res["ChaincodePackageId"] = boost::any(*chaincodePackageId);
    }
    if (chaincodeVersion) {
      res["ChaincodeVersion"] = boost::any(*chaincodeVersion);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (collectionConfig) {
      res["CollectionConfig"] = boost::any(*collectionConfig);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (initRequired) {
      res["InitRequired"] = boost::any(*initRequired);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodePackageId") != m.end() && !m["ChaincodePackageId"].empty()) {
      chaincodePackageId = make_shared<string>(boost::any_cast<string>(m["ChaincodePackageId"]));
    }
    if (m.find("ChaincodeVersion") != m.end() && !m["ChaincodeVersion"].empty()) {
      chaincodeVersion = make_shared<string>(boost::any_cast<string>(m["ChaincodeVersion"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("CollectionConfig") != m.end() && !m["CollectionConfig"].empty()) {
      collectionConfig = make_shared<string>(boost::any_cast<string>(m["CollectionConfig"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("InitRequired") != m.end() && !m["InitRequired"].empty()) {
      initRequired = make_shared<bool>(boost::any_cast<bool>(m["InitRequired"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~SubmitFabricChaincodeDefinitionRequest() = default;
};
class SubmitFabricChaincodeDefinitionResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> channelName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deployTime{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<string> input{};
  shared_ptr<bool> install{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<string> providerId{};
  shared_ptr<string> providerName{};
  shared_ptr<string> state{};
  shared_ptr<long> type{};
  shared_ptr<string> version{};

  SubmitFabricChaincodeDefinitionResponseBodyResult() {}

  explicit SubmitFabricChaincodeDefinitionResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deployTime) {
      res["DeployTime"] = boost::any(*deployTime);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (install) {
      res["Install"] = boost::any(*install);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (providerId) {
      res["ProviderId"] = boost::any(*providerId);
    }
    if (providerName) {
      res["ProviderName"] = boost::any(*providerName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeployTime") != m.end() && !m["DeployTime"].empty()) {
      deployTime = make_shared<string>(boost::any_cast<string>(m["DeployTime"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Install") != m.end() && !m["Install"].empty()) {
      install = make_shared<bool>(boost::any_cast<bool>(m["Install"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ProviderId") != m.end() && !m["ProviderId"].empty()) {
      providerId = make_shared<string>(boost::any_cast<string>(m["ProviderId"]));
    }
    if (m.find("ProviderName") != m.end() && !m["ProviderName"].empty()) {
      providerName = make_shared<string>(boost::any_cast<string>(m["ProviderName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~SubmitFabricChaincodeDefinitionResponseBodyResult() = default;
};
class SubmitFabricChaincodeDefinitionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeDefinitionId{};
  shared_ptr<string> chaincodePackageId{};
  shared_ptr<long> errorCode{};
  shared_ptr<bool> initRequired{};
  shared_ptr<string> requestId{};
  shared_ptr<SubmitFabricChaincodeDefinitionResponseBodyResult> result{};
  shared_ptr<bool> success{};

  SubmitFabricChaincodeDefinitionResponseBody() {}

  explicit SubmitFabricChaincodeDefinitionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeDefinitionId) {
      res["ChaincodeDefinitionId"] = boost::any(*chaincodeDefinitionId);
    }
    if (chaincodePackageId) {
      res["ChaincodePackageId"] = boost::any(*chaincodePackageId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (initRequired) {
      res["InitRequired"] = boost::any(*initRequired);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeDefinitionId") != m.end() && !m["ChaincodeDefinitionId"].empty()) {
      chaincodeDefinitionId = make_shared<string>(boost::any_cast<string>(m["ChaincodeDefinitionId"]));
    }
    if (m.find("ChaincodePackageId") != m.end() && !m["ChaincodePackageId"].empty()) {
      chaincodePackageId = make_shared<string>(boost::any_cast<string>(m["ChaincodePackageId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("InitRequired") != m.end() && !m["InitRequired"].empty()) {
      initRequired = make_shared<bool>(boost::any_cast<bool>(m["InitRequired"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        SubmitFabricChaincodeDefinitionResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<SubmitFabricChaincodeDefinitionResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SubmitFabricChaincodeDefinitionResponseBody() = default;
};
class SubmitFabricChaincodeDefinitionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitFabricChaincodeDefinitionResponseBody> body{};

  SubmitFabricChaincodeDefinitionResponse() {}

  explicit SubmitFabricChaincodeDefinitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitFabricChaincodeDefinitionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitFabricChaincodeDefinitionResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitFabricChaincodeDefinitionResponse() = default;
};
class SyncFabricChaincodeStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> organizationId{};

  SyncFabricChaincodeStatusRequest() {}

  explicit SyncFabricChaincodeStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~SyncFabricChaincodeStatusRequest() = default;
};
class SyncFabricChaincodeStatusResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> input{};
  shared_ptr<string> name{};
  shared_ptr<long> path{};
  shared_ptr<string> state{};
  shared_ptr<long> type{};
  shared_ptr<string> version{};

  SyncFabricChaincodeStatusResponseBodyResult() {}

  explicit SyncFabricChaincodeStatusResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<long>(boost::any_cast<long>(m["Path"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~SyncFabricChaincodeStatusResponseBodyResult() = default;
};
class SyncFabricChaincodeStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<SyncFabricChaincodeStatusResponseBodyResult> result{};
  shared_ptr<bool> success{};

  SyncFabricChaincodeStatusResponseBody() {}

  explicit SyncFabricChaincodeStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        SyncFabricChaincodeStatusResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<SyncFabricChaincodeStatusResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SyncFabricChaincodeStatusResponseBody() = default;
};
class SyncFabricChaincodeStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SyncFabricChaincodeStatusResponseBody> body{};

  SyncFabricChaincodeStatusResponse() {}

  explicit SyncFabricChaincodeStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SyncFabricChaincodeStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SyncFabricChaincodeStatusResponseBody>(model1);
      }
    }
  }


  virtual ~SyncFabricChaincodeStatusResponse() = default;
};
class SynchronizeChaincodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> organizationId{};

  SynchronizeChaincodeRequest() {}

  explicit SynchronizeChaincodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~SynchronizeChaincodeRequest() = default;
};
class SynchronizeChaincodeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> channelName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deployTime{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<string> input{};
  shared_ptr<bool> install{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<string> providerId{};
  shared_ptr<string> providerName{};
  shared_ptr<string> state{};
  shared_ptr<long> type{};
  shared_ptr<string> version{};

  SynchronizeChaincodeResponseBodyResult() {}

  explicit SynchronizeChaincodeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deployTime) {
      res["DeployTime"] = boost::any(*deployTime);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (install) {
      res["Install"] = boost::any(*install);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (providerId) {
      res["ProviderId"] = boost::any(*providerId);
    }
    if (providerName) {
      res["ProviderName"] = boost::any(*providerName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeployTime") != m.end() && !m["DeployTime"].empty()) {
      deployTime = make_shared<string>(boost::any_cast<string>(m["DeployTime"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Install") != m.end() && !m["Install"].empty()) {
      install = make_shared<bool>(boost::any_cast<bool>(m["Install"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ProviderId") != m.end() && !m["ProviderId"].empty()) {
      providerId = make_shared<string>(boost::any_cast<string>(m["ProviderId"]));
    }
    if (m.find("ProviderName") != m.end() && !m["ProviderName"].empty()) {
      providerName = make_shared<string>(boost::any_cast<string>(m["ProviderName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~SynchronizeChaincodeResponseBodyResult() = default;
};
class SynchronizeChaincodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<SynchronizeChaincodeResponseBodyResult> result{};
  shared_ptr<bool> success{};

  SynchronizeChaincodeResponseBody() {}

  explicit SynchronizeChaincodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        SynchronizeChaincodeResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<SynchronizeChaincodeResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SynchronizeChaincodeResponseBody() = default;
};
class SynchronizeChaincodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SynchronizeChaincodeResponseBody> body{};

  SynchronizeChaincodeResponse() {}

  explicit SynchronizeChaincodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SynchronizeChaincodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SynchronizeChaincodeResponseBody>(model1);
      }
    }
  }


  virtual ~SynchronizeChaincodeResponse() = default;
};
class TagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagResourcesRequestTag() {}

  explicit TagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagResourcesRequestTag() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<TagResourcesRequestTag>> tag{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};
  shared_ptr<bool> success{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class UnfreezeAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> bizid{};

  UnfreezeAccountRequest() {}

  explicit UnfreezeAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~UnfreezeAccountRequest() = default;
};
class UnfreezeAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  UnfreezeAccountResponseBody() {}

  explicit UnfreezeAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~UnfreezeAccountResponseBody() = default;
};
class UnfreezeAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnfreezeAccountResponseBody> body{};

  UnfreezeAccountResponse() {}

  explicit UnfreezeAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnfreezeAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnfreezeAccountResponseBody>(model1);
      }
    }
  }


  virtual ~UnfreezeAccountResponse() = default;
};
class UnfreezeAntChainAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> antChainId{};

  UnfreezeAntChainAccountRequest() {}

  explicit UnfreezeAntChainAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
  }


  virtual ~UnfreezeAntChainAccountRequest() = default;
};
class UnfreezeAntChainAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  UnfreezeAntChainAccountResponseBody() {}

  explicit UnfreezeAntChainAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~UnfreezeAntChainAccountResponseBody() = default;
};
class UnfreezeAntChainAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnfreezeAntChainAccountResponseBody> body{};

  UnfreezeAntChainAccountResponse() {}

  explicit UnfreezeAntChainAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnfreezeAntChainAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnfreezeAntChainAccountResponseBody>(model1);
      }
    }
  }


  virtual ~UnfreezeAntChainAccountResponse() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> tagKey{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};
  shared_ptr<bool> success{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class UpdateAntChainRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> antChainName{};

  UpdateAntChainRequest() {}

  explicit UpdateAntChainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (antChainName) {
      res["AntChainName"] = boost::any(*antChainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("AntChainName") != m.end() && !m["AntChainName"].empty()) {
      antChainName = make_shared<string>(boost::any_cast<string>(m["AntChainName"]));
    }
  }


  virtual ~UpdateAntChainRequest() = default;
};
class UpdateAntChainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  UpdateAntChainResponseBody() {}

  explicit UpdateAntChainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~UpdateAntChainResponseBody() = default;
};
class UpdateAntChainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAntChainResponseBody> body{};

  UpdateAntChainResponse() {}

  explicit UpdateAntChainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAntChainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAntChainResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAntChainResponse() = default;
};
class UpdateAntChainConsortiumRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumDescription{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> consortiumName{};

  UpdateAntChainConsortiumRequest() {}

  explicit UpdateAntChainConsortiumRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumDescription) {
      res["ConsortiumDescription"] = boost::any(*consortiumDescription);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (consortiumName) {
      res["ConsortiumName"] = boost::any(*consortiumName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumDescription") != m.end() && !m["ConsortiumDescription"].empty()) {
      consortiumDescription = make_shared<string>(boost::any_cast<string>(m["ConsortiumDescription"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("ConsortiumName") != m.end() && !m["ConsortiumName"].empty()) {
      consortiumName = make_shared<string>(boost::any_cast<string>(m["ConsortiumName"]));
    }
  }


  virtual ~UpdateAntChainConsortiumRequest() = default;
};
class UpdateAntChainConsortiumResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  UpdateAntChainConsortiumResponseBody() {}

  explicit UpdateAntChainConsortiumResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~UpdateAntChainConsortiumResponseBody() = default;
};
class UpdateAntChainConsortiumResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAntChainConsortiumResponseBody> body{};

  UpdateAntChainConsortiumResponse() {}

  explicit UpdateAntChainConsortiumResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAntChainConsortiumResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAntChainConsortiumResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAntChainConsortiumResponse() = default;
};
class UpdateAntChainContractContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentId{};
  shared_ptr<string> contentName{};
  shared_ptr<string> parentContentId{};

  UpdateAntChainContractContentRequest() {}

  explicit UpdateAntChainContractContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentId) {
      res["ContentId"] = boost::any(*contentId);
    }
    if (contentName) {
      res["ContentName"] = boost::any(*contentName);
    }
    if (parentContentId) {
      res["ParentContentId"] = boost::any(*parentContentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentId") != m.end() && !m["ContentId"].empty()) {
      contentId = make_shared<string>(boost::any_cast<string>(m["ContentId"]));
    }
    if (m.find("ContentName") != m.end() && !m["ContentName"].empty()) {
      contentName = make_shared<string>(boost::any_cast<string>(m["ContentName"]));
    }
    if (m.find("ParentContentId") != m.end() && !m["ParentContentId"].empty()) {
      parentContentId = make_shared<string>(boost::any_cast<string>(m["ParentContentId"]));
    }
  }


  virtual ~UpdateAntChainContractContentRequest() = default;
};
class UpdateAntChainContractContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  UpdateAntChainContractContentResponseBody() {}

  explicit UpdateAntChainContractContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~UpdateAntChainContractContentResponseBody() = default;
};
class UpdateAntChainContractContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAntChainContractContentResponseBody> body{};

  UpdateAntChainContractContentResponse() {}

  explicit UpdateAntChainContractContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAntChainContractContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAntChainContractContentResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAntChainContractContentResponse() = default;
};
class UpdateAntChainContractProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectDescription{};
  shared_ptr<string> projectId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> projectVersion{};

  UpdateAntChainContractProjectRequest() {}

  explicit UpdateAntChainContractProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectDescription) {
      res["ProjectDescription"] = boost::any(*projectDescription);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (projectVersion) {
      res["ProjectVersion"] = boost::any(*projectVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectDescription") != m.end() && !m["ProjectDescription"].empty()) {
      projectDescription = make_shared<string>(boost::any_cast<string>(m["ProjectDescription"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProjectVersion") != m.end() && !m["ProjectVersion"].empty()) {
      projectVersion = make_shared<string>(boost::any_cast<string>(m["ProjectVersion"]));
    }
  }


  virtual ~UpdateAntChainContractProjectRequest() = default;
};
class UpdateAntChainContractProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  UpdateAntChainContractProjectResponseBody() {}

  explicit UpdateAntChainContractProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~UpdateAntChainContractProjectResponseBody() = default;
};
class UpdateAntChainContractProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAntChainContractProjectResponseBody> body{};

  UpdateAntChainContractProjectResponse() {}

  explicit UpdateAntChainContractProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAntChainContractProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAntChainContractProjectResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAntChainContractProjectResponse() = default;
};
class UpdateAntChainMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> memberId{};
  shared_ptr<string> memberName{};

  UpdateAntChainMemberRequest() {}

  explicit UpdateAntChainMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (memberId) {
      res["MemberId"] = boost::any(*memberId);
    }
    if (memberName) {
      res["MemberName"] = boost::any(*memberName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("MemberId") != m.end() && !m["MemberId"].empty()) {
      memberId = make_shared<string>(boost::any_cast<string>(m["MemberId"]));
    }
    if (m.find("MemberName") != m.end() && !m["MemberName"].empty()) {
      memberName = make_shared<string>(boost::any_cast<string>(m["MemberName"]));
    }
  }


  virtual ~UpdateAntChainMemberRequest() = default;
};
class UpdateAntChainMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  UpdateAntChainMemberResponseBody() {}

  explicit UpdateAntChainMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~UpdateAntChainMemberResponseBody() = default;
};
class UpdateAntChainMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAntChainMemberResponseBody> body{};

  UpdateAntChainMemberResponse() {}

  explicit UpdateAntChainMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAntChainMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAntChainMemberResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAntChainMemberResponse() = default;
};
class UpdateAntChainQRCodeAuthorizationRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> authorizationType{};
  shared_ptr<string> QRCodeType{};

  UpdateAntChainQRCodeAuthorizationRequest() {}

  explicit UpdateAntChainQRCodeAuthorizationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (authorizationType) {
      res["AuthorizationType"] = boost::any(*authorizationType);
    }
    if (QRCodeType) {
      res["QRCodeType"] = boost::any(*QRCodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("AuthorizationType") != m.end() && !m["AuthorizationType"].empty()) {
      authorizationType = make_shared<string>(boost::any_cast<string>(m["AuthorizationType"]));
    }
    if (m.find("QRCodeType") != m.end() && !m["QRCodeType"].empty()) {
      QRCodeType = make_shared<string>(boost::any_cast<string>(m["QRCodeType"]));
    }
  }


  virtual ~UpdateAntChainQRCodeAuthorizationRequest() = default;
};
class UpdateAntChainQRCodeAuthorizationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  UpdateAntChainQRCodeAuthorizationResponseBody() {}

  explicit UpdateAntChainQRCodeAuthorizationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~UpdateAntChainQRCodeAuthorizationResponseBody() = default;
};
class UpdateAntChainQRCodeAuthorizationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAntChainQRCodeAuthorizationResponseBody> body{};

  UpdateAntChainQRCodeAuthorizationResponse() {}

  explicit UpdateAntChainQRCodeAuthorizationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAntChainQRCodeAuthorizationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAntChainQRCodeAuthorizationResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAntChainQRCodeAuthorizationResponse() = default;
};
class UpdateBlockchainSchemaRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<string> categoryConfigs{};
  shared_ptr<string> description{};
  shared_ptr<long> schemaId{};
  shared_ptr<string> schemaName{};

  UpdateBlockchainSchemaRequest() {}

  explicit UpdateBlockchainSchemaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (categoryConfigs) {
      res["CategoryConfigs"] = boost::any(*categoryConfigs);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (schemaId) {
      res["SchemaId"] = boost::any(*schemaId);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("CategoryConfigs") != m.end() && !m["CategoryConfigs"].empty()) {
      categoryConfigs = make_shared<string>(boost::any_cast<string>(m["CategoryConfigs"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SchemaId") != m.end() && !m["SchemaId"].empty()) {
      schemaId = make_shared<long>(boost::any_cast<long>(m["SchemaId"]));
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
  }


  virtual ~UpdateBlockchainSchemaRequest() = default;
};
class UpdateBlockchainSchemaResponseBodyResultResponsesPropertiesDataSource : public Darabonba::Model {
public:
  shared_ptr<long> allowNull{};
  shared_ptr<string> annotation{};
  shared_ptr<string> field{};
  shared_ptr<long> indexes{};
  shared_ptr<long> key{};
  shared_ptr<long> length{};
  shared_ptr<string> reg{};
  shared_ptr<string> type{};

  UpdateBlockchainSchemaResponseBodyResultResponsesPropertiesDataSource() {}

  explicit UpdateBlockchainSchemaResponseBodyResultResponsesPropertiesDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowNull) {
      res["AllowNull"] = boost::any(*allowNull);
    }
    if (annotation) {
      res["Annotation"] = boost::any(*annotation);
    }
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (indexes) {
      res["Indexes"] = boost::any(*indexes);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (reg) {
      res["Reg"] = boost::any(*reg);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowNull") != m.end() && !m["AllowNull"].empty()) {
      allowNull = make_shared<long>(boost::any_cast<long>(m["AllowNull"]));
    }
    if (m.find("Annotation") != m.end() && !m["Annotation"].empty()) {
      annotation = make_shared<string>(boost::any_cast<string>(m["Annotation"]));
    }
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("Indexes") != m.end() && !m["Indexes"].empty()) {
      indexes = make_shared<long>(boost::any_cast<long>(m["Indexes"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<long>(boost::any_cast<long>(m["Key"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("Reg") != m.end() && !m["Reg"].empty()) {
      reg = make_shared<string>(boost::any_cast<string>(m["Reg"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateBlockchainSchemaResponseBodyResultResponsesPropertiesDataSource() = default;
};
class UpdateBlockchainSchemaResponseBodyResultResponsesProperties : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<UpdateBlockchainSchemaResponseBodyResultResponsesPropertiesDataSource>> dataSource{};

  UpdateBlockchainSchemaResponseBodyResultResponsesProperties() {}

  explicit UpdateBlockchainSchemaResponseBodyResultResponsesProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (dataSource) {
      vector<boost::any> temp1;
      for(auto item1:*dataSource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataSource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(vector<boost::any>) == m["DataSource"].type()) {
        vector<UpdateBlockchainSchemaResponseBodyResultResponsesPropertiesDataSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataSource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateBlockchainSchemaResponseBodyResultResponsesPropertiesDataSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataSource = make_shared<vector<UpdateBlockchainSchemaResponseBodyResultResponsesPropertiesDataSource>>(expect1);
      }
    }
  }


  virtual ~UpdateBlockchainSchemaResponseBodyResultResponsesProperties() = default;
};
class UpdateBlockchainSchemaResponseBodyResultResponses : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> categoryName{};
  shared_ptr<string> description{};
  shared_ptr<UpdateBlockchainSchemaResponseBodyResultResponsesProperties> properties{};

  UpdateBlockchainSchemaResponseBodyResultResponses() {}

  explicit UpdateBlockchainSchemaResponseBodyResultResponses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (categoryName) {
      res["CategoryName"] = boost::any(*categoryName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CategoryName") != m.end() && !m["CategoryName"].empty()) {
      categoryName = make_shared<string>(boost::any_cast<string>(m["CategoryName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        UpdateBlockchainSchemaResponseBodyResultResponsesProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<UpdateBlockchainSchemaResponseBodyResultResponsesProperties>(model1);
      }
    }
  }


  virtual ~UpdateBlockchainSchemaResponseBodyResultResponses() = default;
};
class UpdateBlockchainSchemaResponseBodyResultSchema : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<bool> isTemplate{};
  shared_ptr<string> name{};
  shared_ptr<long> updateTime{};
  shared_ptr<long> version{};

  UpdateBlockchainSchemaResponseBodyResultSchema() {}

  explicit UpdateBlockchainSchemaResponseBodyResultSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsTemplate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~UpdateBlockchainSchemaResponseBodyResultSchema() = default;
};
class UpdateBlockchainSchemaResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateBlockchainSchemaResponseBodyResultResponses>> responses{};
  shared_ptr<UpdateBlockchainSchemaResponseBodyResultSchema> schema{};

  UpdateBlockchainSchemaResponseBodyResult() {}

  explicit UpdateBlockchainSchemaResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (responses) {
      vector<boost::any> temp1;
      for(auto item1:*responses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Responses"] = boost::any(temp1);
    }
    if (schema) {
      res["Schema"] = schema ? boost::any(schema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Responses") != m.end() && !m["Responses"].empty()) {
      if (typeid(vector<boost::any>) == m["Responses"].type()) {
        vector<UpdateBlockchainSchemaResponseBodyResultResponses> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Responses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateBlockchainSchemaResponseBodyResultResponses model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        responses = make_shared<vector<UpdateBlockchainSchemaResponseBodyResultResponses>>(expect1);
      }
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      if (typeid(map<string, boost::any>) == m["Schema"].type()) {
        UpdateBlockchainSchemaResponseBodyResultSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Schema"]));
        schema = make_shared<UpdateBlockchainSchemaResponseBodyResultSchema>(model1);
      }
    }
  }


  virtual ~UpdateBlockchainSchemaResponseBodyResult() = default;
};
class UpdateBlockchainSchemaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateBlockchainSchemaResponseBodyResult> result{};

  UpdateBlockchainSchemaResponseBody() {}

  explicit UpdateBlockchainSchemaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        UpdateBlockchainSchemaResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<UpdateBlockchainSchemaResponseBodyResult>(model1);
      }
    }
  }


  virtual ~UpdateBlockchainSchemaResponseBody() = default;
};
class UpdateBlockchainSchemaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateBlockchainSchemaResponseBody> body{};

  UpdateBlockchainSchemaResponse() {}

  explicit UpdateBlockchainSchemaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateBlockchainSchemaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateBlockchainSchemaResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateBlockchainSchemaResponse() = default;
};
class UpdateChannelConfigRequest : public Darabonba::Model {
public:
  shared_ptr<long> batchTimeout{};
  shared_ptr<string> channelId{};
  shared_ptr<long> maxMessageCount{};
  shared_ptr<string> organizationId{};
  shared_ptr<long> preferredMaxBytes{};

  UpdateChannelConfigRequest() {}

  explicit UpdateChannelConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchTimeout) {
      res["BatchTimeout"] = boost::any(*batchTimeout);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (maxMessageCount) {
      res["MaxMessageCount"] = boost::any(*maxMessageCount);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (preferredMaxBytes) {
      res["PreferredMaxBytes"] = boost::any(*preferredMaxBytes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchTimeout") != m.end() && !m["BatchTimeout"].empty()) {
      batchTimeout = make_shared<long>(boost::any_cast<long>(m["BatchTimeout"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("MaxMessageCount") != m.end() && !m["MaxMessageCount"].empty()) {
      maxMessageCount = make_shared<long>(boost::any_cast<long>(m["MaxMessageCount"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("PreferredMaxBytes") != m.end() && !m["PreferredMaxBytes"].empty()) {
      preferredMaxBytes = make_shared<long>(boost::any_cast<long>(m["PreferredMaxBytes"]));
    }
  }


  virtual ~UpdateChannelConfigRequest() = default;
};
class UpdateChannelConfigResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> batchTimeout{};
  shared_ptr<long> blockCount{};
  shared_ptr<long> chaincodeCount{};
  shared_ptr<string> channelId{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> consortiumName{};
  shared_ptr<string> createTime{};
  shared_ptr<long> maxMessageCount{};
  shared_ptr<long> memberCount{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerBid{};
  shared_ptr<string> ownerName{};
  shared_ptr<long> ownerUid{};
  shared_ptr<long> preferredMaxBytes{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};
  shared_ptr<bool> supportConfig{};
  shared_ptr<string> updateTime{};

  UpdateChannelConfigResponseBodyResult() {}

  explicit UpdateChannelConfigResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchTimeout) {
      res["BatchTimeout"] = boost::any(*batchTimeout);
    }
    if (blockCount) {
      res["BlockCount"] = boost::any(*blockCount);
    }
    if (chaincodeCount) {
      res["ChaincodeCount"] = boost::any(*chaincodeCount);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (consortiumName) {
      res["ConsortiumName"] = boost::any(*consortiumName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (maxMessageCount) {
      res["MaxMessageCount"] = boost::any(*maxMessageCount);
    }
    if (memberCount) {
      res["MemberCount"] = boost::any(*memberCount);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerBid) {
      res["OwnerBid"] = boost::any(*ownerBid);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUid) {
      res["OwnerUid"] = boost::any(*ownerUid);
    }
    if (preferredMaxBytes) {
      res["PreferredMaxBytes"] = boost::any(*preferredMaxBytes);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (supportConfig) {
      res["SupportConfig"] = boost::any(*supportConfig);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchTimeout") != m.end() && !m["BatchTimeout"].empty()) {
      batchTimeout = make_shared<long>(boost::any_cast<long>(m["BatchTimeout"]));
    }
    if (m.find("BlockCount") != m.end() && !m["BlockCount"].empty()) {
      blockCount = make_shared<long>(boost::any_cast<long>(m["BlockCount"]));
    }
    if (m.find("ChaincodeCount") != m.end() && !m["ChaincodeCount"].empty()) {
      chaincodeCount = make_shared<long>(boost::any_cast<long>(m["ChaincodeCount"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("ConsortiumName") != m.end() && !m["ConsortiumName"].empty()) {
      consortiumName = make_shared<string>(boost::any_cast<string>(m["ConsortiumName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("MaxMessageCount") != m.end() && !m["MaxMessageCount"].empty()) {
      maxMessageCount = make_shared<long>(boost::any_cast<long>(m["MaxMessageCount"]));
    }
    if (m.find("MemberCount") != m.end() && !m["MemberCount"].empty()) {
      memberCount = make_shared<long>(boost::any_cast<long>(m["MemberCount"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerBid") != m.end() && !m["OwnerBid"].empty()) {
      ownerBid = make_shared<string>(boost::any_cast<string>(m["OwnerBid"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUid") != m.end() && !m["OwnerUid"].empty()) {
      ownerUid = make_shared<long>(boost::any_cast<long>(m["OwnerUid"]));
    }
    if (m.find("PreferredMaxBytes") != m.end() && !m["PreferredMaxBytes"].empty()) {
      preferredMaxBytes = make_shared<long>(boost::any_cast<long>(m["PreferredMaxBytes"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("SupportConfig") != m.end() && !m["SupportConfig"].empty()) {
      supportConfig = make_shared<bool>(boost::any_cast<bool>(m["SupportConfig"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~UpdateChannelConfigResponseBodyResult() = default;
};
class UpdateChannelConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<UpdateChannelConfigResponseBodyResult> result{};
  shared_ptr<bool> success{};

  UpdateChannelConfigResponseBody() {}

  explicit UpdateChannelConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        UpdateChannelConfigResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<UpdateChannelConfigResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateChannelConfigResponseBody() = default;
};
class UpdateChannelConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateChannelConfigResponseBody> body{};

  UpdateChannelConfigResponse() {}

  explicit UpdateChannelConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateChannelConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateChannelConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateChannelConfigResponse() = default;
};
class UpdateEthereumRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> ethereumId{};
  shared_ptr<string> name{};

  UpdateEthereumRequest() {}

  explicit UpdateEthereumRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ethereumId) {
      res["EthereumId"] = boost::any(*ethereumId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EthereumId") != m.end() && !m["EthereumId"].empty()) {
      ethereumId = make_shared<string>(boost::any_cast<string>(m["EthereumId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~UpdateEthereumRequest() = default;
};
class UpdateEthereumResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> consensus{};
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};
  shared_ptr<string> networkId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> state{};

  UpdateEthereumResponseBodyResult() {}

  explicit UpdateEthereumResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consensus) {
      res["Consensus"] = boost::any(*consensus);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Consensus") != m.end() && !m["Consensus"].empty()) {
      consensus = make_shared<string>(boost::any_cast<string>(m["Consensus"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~UpdateEthereumResponseBodyResult() = default;
};
class UpdateEthereumResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<UpdateEthereumResponseBodyResult> result{};
  shared_ptr<bool> success{};

  UpdateEthereumResponseBody() {}

  explicit UpdateEthereumResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        UpdateEthereumResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<UpdateEthereumResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateEthereumResponseBody() = default;
};
class UpdateEthereumResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateEthereumResponseBody> body{};

  UpdateEthereumResponse() {}

  explicit UpdateEthereumResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEthereumResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEthereumResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEthereumResponse() = default;
};
class UpdateEthereumClientUserPasswordRequest : public Darabonba::Model {
public:
  shared_ptr<string> nodeId{};
  shared_ptr<string> password{};
  shared_ptr<string> username{};

  UpdateEthereumClientUserPasswordRequest() {}

  explicit UpdateEthereumClientUserPasswordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~UpdateEthereumClientUserPasswordRequest() = default;
};
class UpdateEthereumClientUserPasswordResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  UpdateEthereumClientUserPasswordResponseBody() {}

  explicit UpdateEthereumClientUserPasswordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateEthereumClientUserPasswordResponseBody() = default;
};
class UpdateEthereumClientUserPasswordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateEthereumClientUserPasswordResponseBody> body{};

  UpdateEthereumClientUserPasswordResponse() {}

  explicit UpdateEthereumClientUserPasswordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEthereumClientUserPasswordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEthereumClientUserPasswordResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEthereumClientUserPasswordResponse() = default;
};
class UpdateEthereumNodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodeName{};

  UpdateEthereumNodeRequest() {}

  explicit UpdateEthereumNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
  }


  virtual ~UpdateEthereumNodeRequest() = default;
};
class UpdateEthereumNodeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<string> ethereumId{};
  shared_ptr<string> ethereumName{};
  shared_ptr<string> id{};
  shared_ptr<string> networkId{};
  shared_ptr<string> nodeName{};
  shared_ptr<string> publicIp{};
  shared_ptr<string> regionId{};
  shared_ptr<long> rpcPort{};
  shared_ptr<string> state{};
  shared_ptr<long> wsPort{};

  UpdateEthereumNodeResponseBodyResult() {}

  explicit UpdateEthereumNodeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ethereumId) {
      res["EthereumId"] = boost::any(*ethereumId);
    }
    if (ethereumName) {
      res["EthereumName"] = boost::any(*ethereumName);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (networkId) {
      res["NetworkId"] = boost::any(*networkId);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (publicIp) {
      res["PublicIp"] = boost::any(*publicIp);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (rpcPort) {
      res["RpcPort"] = boost::any(*rpcPort);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (wsPort) {
      res["WsPort"] = boost::any(*wsPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EthereumId") != m.end() && !m["EthereumId"].empty()) {
      ethereumId = make_shared<string>(boost::any_cast<string>(m["EthereumId"]));
    }
    if (m.find("EthereumName") != m.end() && !m["EthereumName"].empty()) {
      ethereumName = make_shared<string>(boost::any_cast<string>(m["EthereumName"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("NetworkId") != m.end() && !m["NetworkId"].empty()) {
      networkId = make_shared<string>(boost::any_cast<string>(m["NetworkId"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("PublicIp") != m.end() && !m["PublicIp"].empty()) {
      publicIp = make_shared<string>(boost::any_cast<string>(m["PublicIp"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RpcPort") != m.end() && !m["RpcPort"].empty()) {
      rpcPort = make_shared<long>(boost::any_cast<long>(m["RpcPort"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("WsPort") != m.end() && !m["WsPort"].empty()) {
      wsPort = make_shared<long>(boost::any_cast<long>(m["WsPort"]));
    }
  }


  virtual ~UpdateEthereumNodeResponseBodyResult() = default;
};
class UpdateEthereumNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<UpdateEthereumNodeResponseBodyResult> result{};
  shared_ptr<bool> success{};

  UpdateEthereumNodeResponseBody() {}

  explicit UpdateEthereumNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        UpdateEthereumNodeResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<UpdateEthereumNodeResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateEthereumNodeResponseBody() = default;
};
class UpdateEthereumNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateEthereumNodeResponseBody> body{};

  UpdateEthereumNodeResponse() {}

  explicit UpdateEthereumNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEthereumNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEthereumNodeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEthereumNodeResponse() = default;
};
class UpdateEthereumNodeConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> IP{};
  shared_ptr<string> nodeId{};
  shared_ptr<string> nodePub{};
  shared_ptr<long> p2pPort{};
  shared_ptr<long> raftPort{};
  shared_ptr<long> rpcPort{};
  shared_ptr<long> TMPort{};
  shared_ptr<string> TMPub{};
  shared_ptr<long> WSPort{};

  UpdateEthereumNodeConfigurationRequest() {}

  explicit UpdateEthereumNodeConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (nodeId) {
      res["NodeId"] = boost::any(*nodeId);
    }
    if (nodePub) {
      res["NodePub"] = boost::any(*nodePub);
    }
    if (p2pPort) {
      res["P2pPort"] = boost::any(*p2pPort);
    }
    if (raftPort) {
      res["RaftPort"] = boost::any(*raftPort);
    }
    if (rpcPort) {
      res["RpcPort"] = boost::any(*rpcPort);
    }
    if (TMPort) {
      res["TMPort"] = boost::any(*TMPort);
    }
    if (TMPub) {
      res["TMPub"] = boost::any(*TMPub);
    }
    if (WSPort) {
      res["WSPort"] = boost::any(*WSPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("NodeId") != m.end() && !m["NodeId"].empty()) {
      nodeId = make_shared<string>(boost::any_cast<string>(m["NodeId"]));
    }
    if (m.find("NodePub") != m.end() && !m["NodePub"].empty()) {
      nodePub = make_shared<string>(boost::any_cast<string>(m["NodePub"]));
    }
    if (m.find("P2pPort") != m.end() && !m["P2pPort"].empty()) {
      p2pPort = make_shared<long>(boost::any_cast<long>(m["P2pPort"]));
    }
    if (m.find("RaftPort") != m.end() && !m["RaftPort"].empty()) {
      raftPort = make_shared<long>(boost::any_cast<long>(m["RaftPort"]));
    }
    if (m.find("RpcPort") != m.end() && !m["RpcPort"].empty()) {
      rpcPort = make_shared<long>(boost::any_cast<long>(m["RpcPort"]));
    }
    if (m.find("TMPort") != m.end() && !m["TMPort"].empty()) {
      TMPort = make_shared<long>(boost::any_cast<long>(m["TMPort"]));
    }
    if (m.find("TMPub") != m.end() && !m["TMPub"].empty()) {
      TMPub = make_shared<string>(boost::any_cast<string>(m["TMPub"]));
    }
    if (m.find("WSPort") != m.end() && !m["WSPort"].empty()) {
      WSPort = make_shared<long>(boost::any_cast<long>(m["WSPort"]));
    }
  }


  virtual ~UpdateEthereumNodeConfigurationRequest() = default;
};
class UpdateEthereumNodeConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  UpdateEthereumNodeConfigurationResponseBody() {}

  explicit UpdateEthereumNodeConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateEthereumNodeConfigurationResponseBody() = default;
};
class UpdateEthereumNodeConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateEthereumNodeConfigurationResponseBody> body{};

  UpdateEthereumNodeConfigurationResponse() {}

  explicit UpdateEthereumNodeConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEthereumNodeConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEthereumNodeConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEthereumNodeConfigurationResponse() = default;
};
class UpdateGovernanceTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> taskAction{};
  shared_ptr<string> taskId{};

  UpdateGovernanceTaskRequest() {}

  explicit UpdateGovernanceTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (taskAction) {
      res["TaskAction"] = boost::any(*taskAction);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("TaskAction") != m.end() && !m["TaskAction"].empty()) {
      taskAction = make_shared<string>(boost::any_cast<string>(m["TaskAction"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~UpdateGovernanceTaskRequest() = default;
};
class UpdateGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<long> port{};

  UpdateGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers() {}

  explicit UpdateGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
  }


  virtual ~UpdateGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers() = default;
};
class UpdateGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> certificate{};
  shared_ptr<string> key{};
  shared_ptr<string> tlsroot{};

  UpdateGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes() {}

  explicit UpdateGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (tlsroot) {
      res["Tlsroot"] = boost::any(*tlsroot);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Tlsroot") != m.end() && !m["Tlsroot"].empty()) {
      tlsroot = make_shared<string>(boost::any_cast<string>(m["Tlsroot"]));
    }
  }


  virtual ~UpdateGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes() = default;
};
class UpdateGovernanceTaskResponseBodyResultContentAddedOrganizations : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers>> anchorPeers{};
  shared_ptr<string> crls{};
  shared_ptr<string> mspId{};
  shared_ptr<string> mspType{};
  shared_ptr<bool> orderer{};
  shared_ptr<vector<UpdateGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes>> ordererNodes{};
  shared_ptr<string> rootCertificates{};
  shared_ptr<string> tlsRootCertificates{};

  UpdateGovernanceTaskResponseBodyResultContentAddedOrganizations() {}

  explicit UpdateGovernanceTaskResponseBodyResultContentAddedOrganizations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (anchorPeers) {
      vector<boost::any> temp1;
      for(auto item1:*anchorPeers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnchorPeers"] = boost::any(temp1);
    }
    if (crls) {
      res["Crls"] = boost::any(*crls);
    }
    if (mspId) {
      res["MspId"] = boost::any(*mspId);
    }
    if (mspType) {
      res["MspType"] = boost::any(*mspType);
    }
    if (orderer) {
      res["Orderer"] = boost::any(*orderer);
    }
    if (ordererNodes) {
      vector<boost::any> temp1;
      for(auto item1:*ordererNodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OrdererNodes"] = boost::any(temp1);
    }
    if (rootCertificates) {
      res["RootCertificates"] = boost::any(*rootCertificates);
    }
    if (tlsRootCertificates) {
      res["TlsRootCertificates"] = boost::any(*tlsRootCertificates);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnchorPeers") != m.end() && !m["AnchorPeers"].empty()) {
      if (typeid(vector<boost::any>) == m["AnchorPeers"].type()) {
        vector<UpdateGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnchorPeers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        anchorPeers = make_shared<vector<UpdateGovernanceTaskResponseBodyResultContentAddedOrganizationsAnchorPeers>>(expect1);
      }
    }
    if (m.find("Crls") != m.end() && !m["Crls"].empty()) {
      crls = make_shared<string>(boost::any_cast<string>(m["Crls"]));
    }
    if (m.find("MspId") != m.end() && !m["MspId"].empty()) {
      mspId = make_shared<string>(boost::any_cast<string>(m["MspId"]));
    }
    if (m.find("MspType") != m.end() && !m["MspType"].empty()) {
      mspType = make_shared<string>(boost::any_cast<string>(m["MspType"]));
    }
    if (m.find("Orderer") != m.end() && !m["Orderer"].empty()) {
      orderer = make_shared<bool>(boost::any_cast<bool>(m["Orderer"]));
    }
    if (m.find("OrdererNodes") != m.end() && !m["OrdererNodes"].empty()) {
      if (typeid(vector<boost::any>) == m["OrdererNodes"].type()) {
        vector<UpdateGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OrdererNodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ordererNodes = make_shared<vector<UpdateGovernanceTaskResponseBodyResultContentAddedOrganizationsOrdererNodes>>(expect1);
      }
    }
    if (m.find("RootCertificates") != m.end() && !m["RootCertificates"].empty()) {
      rootCertificates = make_shared<string>(boost::any_cast<string>(m["RootCertificates"]));
    }
    if (m.find("TlsRootCertificates") != m.end() && !m["TlsRootCertificates"].empty()) {
      tlsRootCertificates = make_shared<string>(boost::any_cast<string>(m["TlsRootCertificates"]));
    }
  }


  virtual ~UpdateGovernanceTaskResponseBodyResultContentAddedOrganizations() = default;
};
class UpdateGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs : public Darabonba::Model {
public:
  shared_ptr<string> input{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<long> type{};
  shared_ptr<string> version{};

  UpdateGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs() {}

  explicit UpdateGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~UpdateGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs() = default;
};
class UpdateGovernanceTaskResponseBodyResultContentChaincodeSpecPkg : public Darabonba::Model {
public:
  shared_ptr<UpdateGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs> cs{};
  shared_ptr<string> policy{};
  shared_ptr<string> sha256{};

  UpdateGovernanceTaskResponseBodyResultContentChaincodeSpecPkg() {}

  explicit UpdateGovernanceTaskResponseBodyResultContentChaincodeSpecPkg(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cs) {
      res["Cs"] = cs ? boost::any(cs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (sha256) {
      res["Sha256"] = boost::any(*sha256);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cs") != m.end() && !m["Cs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cs"].type()) {
        UpdateGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cs"]));
        cs = make_shared<UpdateGovernanceTaskResponseBodyResultContentChaincodeSpecPkgCs>(model1);
      }
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Sha256") != m.end() && !m["Sha256"].empty()) {
      sha256 = make_shared<string>(boost::any_cast<string>(m["Sha256"]));
    }
  }


  virtual ~UpdateGovernanceTaskResponseBodyResultContentChaincodeSpecPkg() = default;
};
class UpdateGovernanceTaskResponseBodyResultContentOrdererConfig : public Darabonba::Model {
public:
  shared_ptr<string> batchTimeout{};
  shared_ptr<long> maxMessageCount{};
  shared_ptr<long> preferredMaxBytes{};

  UpdateGovernanceTaskResponseBodyResultContentOrdererConfig() {}

  explicit UpdateGovernanceTaskResponseBodyResultContentOrdererConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchTimeout) {
      res["BatchTimeout"] = boost::any(*batchTimeout);
    }
    if (maxMessageCount) {
      res["MaxMessageCount"] = boost::any(*maxMessageCount);
    }
    if (preferredMaxBytes) {
      res["PreferredMaxBytes"] = boost::any(*preferredMaxBytes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchTimeout") != m.end() && !m["BatchTimeout"].empty()) {
      batchTimeout = make_shared<string>(boost::any_cast<string>(m["BatchTimeout"]));
    }
    if (m.find("MaxMessageCount") != m.end() && !m["MaxMessageCount"].empty()) {
      maxMessageCount = make_shared<long>(boost::any_cast<long>(m["MaxMessageCount"]));
    }
    if (m.find("PreferredMaxBytes") != m.end() && !m["PreferredMaxBytes"].empty()) {
      preferredMaxBytes = make_shared<long>(boost::any_cast<long>(m["PreferredMaxBytes"]));
    }
  }


  virtual ~UpdateGovernanceTaskResponseBodyResultContentOrdererConfig() = default;
};
class UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<long> port{};

  UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers() {}

  explicit UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
  }


  virtual ~UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers() = default;
};
class UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes : public Darabonba::Model {
public:
  shared_ptr<string> address{};
  shared_ptr<string> certificate{};
  shared_ptr<string> key{};
  shared_ptr<string> tlsroot{};

  UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes() {}

  explicit UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = boost::any(*address);
    }
    if (certificate) {
      res["Certificate"] = boost::any(*certificate);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (tlsroot) {
      res["Tlsroot"] = boost::any(*tlsroot);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      address = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("Certificate") != m.end() && !m["Certificate"].empty()) {
      certificate = make_shared<string>(boost::any_cast<string>(m["Certificate"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Tlsroot") != m.end() && !m["Tlsroot"].empty()) {
      tlsroot = make_shared<string>(boost::any_cast<string>(m["Tlsroot"]));
    }
  }


  virtual ~UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes() = default;
};
class UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizations : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers>> anchorPeers{};
  shared_ptr<string> crls{};
  shared_ptr<string> mspId{};
  shared_ptr<string> mspType{};
  shared_ptr<bool> orderer{};
  shared_ptr<vector<UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes>> ordererNodes{};
  shared_ptr<string> rootCertificates{};
  shared_ptr<string> tlsRootCertificates{};

  UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizations() {}

  explicit UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (anchorPeers) {
      vector<boost::any> temp1;
      for(auto item1:*anchorPeers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AnchorPeers"] = boost::any(temp1);
    }
    if (crls) {
      res["Crls"] = boost::any(*crls);
    }
    if (mspId) {
      res["MspId"] = boost::any(*mspId);
    }
    if (mspType) {
      res["MspType"] = boost::any(*mspType);
    }
    if (orderer) {
      res["Orderer"] = boost::any(*orderer);
    }
    if (ordererNodes) {
      vector<boost::any> temp1;
      for(auto item1:*ordererNodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OrdererNodes"] = boost::any(temp1);
    }
    if (rootCertificates) {
      res["RootCertificates"] = boost::any(*rootCertificates);
    }
    if (tlsRootCertificates) {
      res["TlsRootCertificates"] = boost::any(*tlsRootCertificates);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AnchorPeers") != m.end() && !m["AnchorPeers"].empty()) {
      if (typeid(vector<boost::any>) == m["AnchorPeers"].type()) {
        vector<UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AnchorPeers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        anchorPeers = make_shared<vector<UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizationsAnchorPeers>>(expect1);
      }
    }
    if (m.find("Crls") != m.end() && !m["Crls"].empty()) {
      crls = make_shared<string>(boost::any_cast<string>(m["Crls"]));
    }
    if (m.find("MspId") != m.end() && !m["MspId"].empty()) {
      mspId = make_shared<string>(boost::any_cast<string>(m["MspId"]));
    }
    if (m.find("MspType") != m.end() && !m["MspType"].empty()) {
      mspType = make_shared<string>(boost::any_cast<string>(m["MspType"]));
    }
    if (m.find("Orderer") != m.end() && !m["Orderer"].empty()) {
      orderer = make_shared<bool>(boost::any_cast<bool>(m["Orderer"]));
    }
    if (m.find("OrdererNodes") != m.end() && !m["OrdererNodes"].empty()) {
      if (typeid(vector<boost::any>) == m["OrdererNodes"].type()) {
        vector<UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OrdererNodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ordererNodes = make_shared<vector<UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizationsOrdererNodes>>(expect1);
      }
    }
    if (m.find("RootCertificates") != m.end() && !m["RootCertificates"].empty()) {
      rootCertificates = make_shared<string>(boost::any_cast<string>(m["RootCertificates"]));
    }
    if (m.find("TlsRootCertificates") != m.end() && !m["TlsRootCertificates"].empty()) {
      tlsRootCertificates = make_shared<string>(boost::any_cast<string>(m["TlsRootCertificates"]));
    }
  }


  virtual ~UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizations() = default;
};
class UpdateGovernanceTaskResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateGovernanceTaskResponseBodyResultContentAddedOrganizations>> addedOrganizations{};
  shared_ptr<UpdateGovernanceTaskResponseBodyResultContentChaincodeSpecPkg> chaincodeSpecPkg{};
  shared_ptr<UpdateGovernanceTaskResponseBodyResultContentOrdererConfig> ordererConfig{};
  shared_ptr<string> raw{};
  shared_ptr<vector<UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizations>> removedOrganizations{};
  shared_ptr<string> rwSets{};

  UpdateGovernanceTaskResponseBodyResultContent() {}

  explicit UpdateGovernanceTaskResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addedOrganizations) {
      vector<boost::any> temp1;
      for(auto item1:*addedOrganizations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AddedOrganizations"] = boost::any(temp1);
    }
    if (chaincodeSpecPkg) {
      res["ChaincodeSpecPkg"] = chaincodeSpecPkg ? boost::any(chaincodeSpecPkg->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ordererConfig) {
      res["OrdererConfig"] = ordererConfig ? boost::any(ordererConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (raw) {
      res["Raw"] = boost::any(*raw);
    }
    if (removedOrganizations) {
      vector<boost::any> temp1;
      for(auto item1:*removedOrganizations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RemovedOrganizations"] = boost::any(temp1);
    }
    if (rwSets) {
      res["RwSets"] = boost::any(*rwSets);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddedOrganizations") != m.end() && !m["AddedOrganizations"].empty()) {
      if (typeid(vector<boost::any>) == m["AddedOrganizations"].type()) {
        vector<UpdateGovernanceTaskResponseBodyResultContentAddedOrganizations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AddedOrganizations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateGovernanceTaskResponseBodyResultContentAddedOrganizations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addedOrganizations = make_shared<vector<UpdateGovernanceTaskResponseBodyResultContentAddedOrganizations>>(expect1);
      }
    }
    if (m.find("ChaincodeSpecPkg") != m.end() && !m["ChaincodeSpecPkg"].empty()) {
      if (typeid(map<string, boost::any>) == m["ChaincodeSpecPkg"].type()) {
        UpdateGovernanceTaskResponseBodyResultContentChaincodeSpecPkg model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ChaincodeSpecPkg"]));
        chaincodeSpecPkg = make_shared<UpdateGovernanceTaskResponseBodyResultContentChaincodeSpecPkg>(model1);
      }
    }
    if (m.find("OrdererConfig") != m.end() && !m["OrdererConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["OrdererConfig"].type()) {
        UpdateGovernanceTaskResponseBodyResultContentOrdererConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OrdererConfig"]));
        ordererConfig = make_shared<UpdateGovernanceTaskResponseBodyResultContentOrdererConfig>(model1);
      }
    }
    if (m.find("Raw") != m.end() && !m["Raw"].empty()) {
      raw = make_shared<string>(boost::any_cast<string>(m["Raw"]));
    }
    if (m.find("RemovedOrganizations") != m.end() && !m["RemovedOrganizations"].empty()) {
      if (typeid(vector<boost::any>) == m["RemovedOrganizations"].type()) {
        vector<UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RemovedOrganizations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        removedOrganizations = make_shared<vector<UpdateGovernanceTaskResponseBodyResultContentRemovedOrganizations>>(expect1);
      }
    }
    if (m.find("RwSets") != m.end() && !m["RwSets"].empty()) {
      rwSets = make_shared<string>(boost::any_cast<string>(m["RwSets"]));
    }
  }


  virtual ~UpdateGovernanceTaskResponseBodyResultContent() = default;
};
class UpdateGovernanceTaskResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> channelName{};
  shared_ptr<UpdateGovernanceTaskResponseBodyResultContent> content{};
  shared_ptr<long> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> type{};

  UpdateGovernanceTaskResponseBodyResult() {}

  explicit UpdateGovernanceTaskResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        UpdateGovernanceTaskResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<UpdateGovernanceTaskResponseBodyResultContent>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateGovernanceTaskResponseBodyResult() = default;
};
class UpdateGovernanceTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<UpdateGovernanceTaskResponseBodyResult> result{};
  shared_ptr<bool> success{};

  UpdateGovernanceTaskResponseBody() {}

  explicit UpdateGovernanceTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        UpdateGovernanceTaskResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<UpdateGovernanceTaskResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpdateGovernanceTaskResponseBody() = default;
};
class UpdateGovernanceTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateGovernanceTaskResponseBody> body{};

  UpdateGovernanceTaskResponse() {}

  explicit UpdateGovernanceTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateGovernanceTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateGovernanceTaskResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateGovernanceTaskResponse() = default;
};
class UpdateMemberRoleRequest : public Darabonba::Model {
public:
  shared_ptr<string> bid{};
  shared_ptr<string> bizid{};
  shared_ptr<long> role{};
  shared_ptr<long> userId{};

  UpdateMemberRoleRequest() {}

  explicit UpdateMemberRoleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bid) {
      res["Bid"] = boost::any(*bid);
    }
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bid") != m.end() && !m["Bid"].empty()) {
      bid = make_shared<string>(boost::any_cast<string>(m["Bid"]));
    }
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<long>(boost::any_cast<long>(m["Role"]));
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["UserId"]));
    }
  }


  virtual ~UpdateMemberRoleRequest() = default;
};
class UpdateMemberRoleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  UpdateMemberRoleResponseBody() {}

  explicit UpdateMemberRoleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~UpdateMemberRoleResponseBody() = default;
};
class UpdateMemberRoleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateMemberRoleResponseBody> body{};

  UpdateMemberRoleResponse() {}

  explicit UpdateMemberRoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateMemberRoleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateMemberRoleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateMemberRoleResponse() = default;
};
class UpdateQRCodeAuthorityRequest : public Darabonba::Model {
public:
  shared_ptr<bool> authorized{};
  shared_ptr<string> bizid{};

  UpdateQRCodeAuthorityRequest() {}

  explicit UpdateQRCodeAuthorityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (authorized) {
      res["Authorized"] = boost::any(*authorized);
    }
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Authorized") != m.end() && !m["Authorized"].empty()) {
      authorized = make_shared<bool>(boost::any_cast<bool>(m["Authorized"]));
    }
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
  }


  virtual ~UpdateQRCodeAuthorityRequest() = default;
};
class UpdateQRCodeAuthorityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  UpdateQRCodeAuthorityResponseBody() {}

  explicit UpdateQRCodeAuthorityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~UpdateQRCodeAuthorityResponseBody() = default;
};
class UpdateQRCodeAuthorityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateQRCodeAuthorityResponseBody> body{};

  UpdateQRCodeAuthorityResponse() {}

  explicit UpdateQRCodeAuthorityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateQRCodeAuthorityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateQRCodeAuthorityResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateQRCodeAuthorityResponse() = default;
};
class UpdateSchemaRequest : public Darabonba::Model {
public:
  shared_ptr<string> bizid{};
  shared_ptr<string> categoryConfigs{};
  shared_ptr<string> description{};
  shared_ptr<long> schemaId{};
  shared_ptr<string> schemaName{};

  UpdateSchemaRequest() {}

  explicit UpdateSchemaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizid) {
      res["Bizid"] = boost::any(*bizid);
    }
    if (categoryConfigs) {
      res["CategoryConfigs"] = boost::any(*categoryConfigs);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (schemaId) {
      res["SchemaId"] = boost::any(*schemaId);
    }
    if (schemaName) {
      res["SchemaName"] = boost::any(*schemaName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bizid") != m.end() && !m["Bizid"].empty()) {
      bizid = make_shared<string>(boost::any_cast<string>(m["Bizid"]));
    }
    if (m.find("CategoryConfigs") != m.end() && !m["CategoryConfigs"].empty()) {
      categoryConfigs = make_shared<string>(boost::any_cast<string>(m["CategoryConfigs"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SchemaId") != m.end() && !m["SchemaId"].empty()) {
      schemaId = make_shared<long>(boost::any_cast<long>(m["SchemaId"]));
    }
    if (m.find("SchemaName") != m.end() && !m["SchemaName"].empty()) {
      schemaName = make_shared<string>(boost::any_cast<string>(m["SchemaName"]));
    }
  }


  virtual ~UpdateSchemaRequest() = default;
};
class UpdateSchemaResponseBodyResultResponsesPropertiesDataSource : public Darabonba::Model {
public:
  shared_ptr<long> allowNull{};
  shared_ptr<string> annotation{};
  shared_ptr<string> field{};
  shared_ptr<long> indexes{};
  shared_ptr<long> key{};
  shared_ptr<long> length{};
  shared_ptr<string> reg{};
  shared_ptr<string> type{};

  UpdateSchemaResponseBodyResultResponsesPropertiesDataSource() {}

  explicit UpdateSchemaResponseBodyResultResponsesPropertiesDataSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allowNull) {
      res["AllowNull"] = boost::any(*allowNull);
    }
    if (annotation) {
      res["Annotation"] = boost::any(*annotation);
    }
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (indexes) {
      res["Indexes"] = boost::any(*indexes);
    }
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (length) {
      res["Length"] = boost::any(*length);
    }
    if (reg) {
      res["Reg"] = boost::any(*reg);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AllowNull") != m.end() && !m["AllowNull"].empty()) {
      allowNull = make_shared<long>(boost::any_cast<long>(m["AllowNull"]));
    }
    if (m.find("Annotation") != m.end() && !m["Annotation"].empty()) {
      annotation = make_shared<string>(boost::any_cast<string>(m["Annotation"]));
    }
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("Indexes") != m.end() && !m["Indexes"].empty()) {
      indexes = make_shared<long>(boost::any_cast<long>(m["Indexes"]));
    }
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<long>(boost::any_cast<long>(m["Key"]));
    }
    if (m.find("Length") != m.end() && !m["Length"].empty()) {
      length = make_shared<long>(boost::any_cast<long>(m["Length"]));
    }
    if (m.find("Reg") != m.end() && !m["Reg"].empty()) {
      reg = make_shared<string>(boost::any_cast<string>(m["Reg"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~UpdateSchemaResponseBodyResultResponsesPropertiesDataSource() = default;
};
class UpdateSchemaResponseBodyResultResponsesProperties : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<UpdateSchemaResponseBodyResultResponsesPropertiesDataSource>> dataSource{};

  UpdateSchemaResponseBodyResultResponsesProperties() {}

  explicit UpdateSchemaResponseBodyResultResponsesProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (dataSource) {
      vector<boost::any> temp1;
      for(auto item1:*dataSource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DataSource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("DataSource") != m.end() && !m["DataSource"].empty()) {
      if (typeid(vector<boost::any>) == m["DataSource"].type()) {
        vector<UpdateSchemaResponseBodyResultResponsesPropertiesDataSource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DataSource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSchemaResponseBodyResultResponsesPropertiesDataSource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataSource = make_shared<vector<UpdateSchemaResponseBodyResultResponsesPropertiesDataSource>>(expect1);
      }
    }
  }


  virtual ~UpdateSchemaResponseBodyResultResponsesProperties() = default;
};
class UpdateSchemaResponseBodyResultResponses : public Darabonba::Model {
public:
  shared_ptr<string> category{};
  shared_ptr<string> categoryName{};
  shared_ptr<string> description{};
  shared_ptr<UpdateSchemaResponseBodyResultResponsesProperties> properties{};

  UpdateSchemaResponseBodyResultResponses() {}

  explicit UpdateSchemaResponseBodyResultResponses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (categoryName) {
      res["CategoryName"] = boost::any(*categoryName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (properties) {
      res["Properties"] = properties ? boost::any(properties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<string>(boost::any_cast<string>(m["Category"]));
    }
    if (m.find("CategoryName") != m.end() && !m["CategoryName"].empty()) {
      categoryName = make_shared<string>(boost::any_cast<string>(m["CategoryName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(map<string, boost::any>) == m["Properties"].type()) {
        UpdateSchemaResponseBodyResultResponsesProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Properties"]));
        properties = make_shared<UpdateSchemaResponseBodyResultResponsesProperties>(model1);
      }
    }
  }


  virtual ~UpdateSchemaResponseBodyResultResponses() = default;
};
class UpdateSchemaResponseBodyResultSchema : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> description{};
  shared_ptr<long> id{};
  shared_ptr<bool> isTemplate{};
  shared_ptr<string> name{};
  shared_ptr<long> updateTime{};
  shared_ptr<long> version{};

  UpdateSchemaResponseBodyResultSchema() {}

  explicit UpdateSchemaResponseBodyResultSchema(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (isTemplate) {
      res["IsTemplate"] = boost::any(*isTemplate);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
    if (m.find("IsTemplate") != m.end() && !m["IsTemplate"].empty()) {
      isTemplate = make_shared<bool>(boost::any_cast<bool>(m["IsTemplate"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~UpdateSchemaResponseBodyResultSchema() = default;
};
class UpdateSchemaResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateSchemaResponseBodyResultResponses>> responses{};
  shared_ptr<UpdateSchemaResponseBodyResultSchema> schema{};

  UpdateSchemaResponseBodyResult() {}

  explicit UpdateSchemaResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (responses) {
      vector<boost::any> temp1;
      for(auto item1:*responses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Responses"] = boost::any(temp1);
    }
    if (schema) {
      res["Schema"] = schema ? boost::any(schema->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Responses") != m.end() && !m["Responses"].empty()) {
      if (typeid(vector<boost::any>) == m["Responses"].type()) {
        vector<UpdateSchemaResponseBodyResultResponses> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Responses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSchemaResponseBodyResultResponses model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        responses = make_shared<vector<UpdateSchemaResponseBodyResultResponses>>(expect1);
      }
    }
    if (m.find("Schema") != m.end() && !m["Schema"].empty()) {
      if (typeid(map<string, boost::any>) == m["Schema"].type()) {
        UpdateSchemaResponseBodyResultSchema model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Schema"]));
        schema = make_shared<UpdateSchemaResponseBodyResultSchema>(model1);
      }
    }
  }


  virtual ~UpdateSchemaResponseBodyResult() = default;
};
class UpdateSchemaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateSchemaResponseBodyResult> result{};

  UpdateSchemaResponseBody() {}

  explicit UpdateSchemaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        UpdateSchemaResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<UpdateSchemaResponseBodyResult>(model1);
      }
    }
  }


  virtual ~UpdateSchemaResponseBody() = default;
};
class UpdateSchemaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSchemaResponseBody> body{};

  UpdateSchemaResponse() {}

  explicit UpdateSchemaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSchemaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSchemaResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSchemaResponse() = default;
};
class UpgradeChaincodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> collectionConfig{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};

  UpgradeChaincodeRequest() {}

  explicit UpgradeChaincodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (collectionConfig) {
      res["CollectionConfig"] = boost::any(*collectionConfig);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("CollectionConfig") != m.end() && !m["CollectionConfig"].empty()) {
      collectionConfig = make_shared<string>(boost::any_cast<string>(m["CollectionConfig"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~UpgradeChaincodeRequest() = default;
};
class UpgradeChaincodeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> channelName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deployTime{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<string> input{};
  shared_ptr<bool> install{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<string> providerId{};
  shared_ptr<string> providerName{};
  shared_ptr<string> state{};
  shared_ptr<long> type{};
  shared_ptr<string> version{};

  UpgradeChaincodeResponseBodyResult() {}

  explicit UpgradeChaincodeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deployTime) {
      res["DeployTime"] = boost::any(*deployTime);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (install) {
      res["Install"] = boost::any(*install);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (providerId) {
      res["ProviderId"] = boost::any(*providerId);
    }
    if (providerName) {
      res["ProviderName"] = boost::any(*providerName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeployTime") != m.end() && !m["DeployTime"].empty()) {
      deployTime = make_shared<string>(boost::any_cast<string>(m["DeployTime"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Install") != m.end() && !m["Install"].empty()) {
      install = make_shared<bool>(boost::any_cast<bool>(m["Install"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ProviderId") != m.end() && !m["ProviderId"].empty()) {
      providerId = make_shared<string>(boost::any_cast<string>(m["ProviderId"]));
    }
    if (m.find("ProviderName") != m.end() && !m["ProviderName"].empty()) {
      providerName = make_shared<string>(boost::any_cast<string>(m["ProviderName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~UpgradeChaincodeResponseBodyResult() = default;
};
class UpgradeChaincodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<UpgradeChaincodeResponseBodyResult> result{};
  shared_ptr<bool> success{};

  UpgradeChaincodeResponseBody() {}

  explicit UpgradeChaincodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        UpgradeChaincodeResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<UpgradeChaincodeResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpgradeChaincodeResponseBody() = default;
};
class UpgradeChaincodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpgradeChaincodeResponseBody> body{};

  UpgradeChaincodeResponse() {}

  explicit UpgradeChaincodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpgradeChaincodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpgradeChaincodeResponseBody>(model1);
      }
    }
  }


  virtual ~UpgradeChaincodeResponse() = default;
};
class UpgradeFabricChaincodeDefinitionRequest : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> chaincodePackageId{};
  shared_ptr<string> chaincodeVersion{};
  shared_ptr<string> channelId{};
  shared_ptr<string> collectionConfig{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<bool> initRequired{};
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};

  UpgradeFabricChaincodeDefinitionRequest() {}

  explicit UpgradeFabricChaincodeDefinitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (chaincodePackageId) {
      res["ChaincodePackageId"] = boost::any(*chaincodePackageId);
    }
    if (chaincodeVersion) {
      res["ChaincodeVersion"] = boost::any(*chaincodeVersion);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (collectionConfig) {
      res["CollectionConfig"] = boost::any(*collectionConfig);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (initRequired) {
      res["InitRequired"] = boost::any(*initRequired);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("ChaincodePackageId") != m.end() && !m["ChaincodePackageId"].empty()) {
      chaincodePackageId = make_shared<string>(boost::any_cast<string>(m["ChaincodePackageId"]));
    }
    if (m.find("ChaincodeVersion") != m.end() && !m["ChaincodeVersion"].empty()) {
      chaincodeVersion = make_shared<string>(boost::any_cast<string>(m["ChaincodeVersion"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("CollectionConfig") != m.end() && !m["CollectionConfig"].empty()) {
      collectionConfig = make_shared<string>(boost::any_cast<string>(m["CollectionConfig"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("InitRequired") != m.end() && !m["InitRequired"].empty()) {
      initRequired = make_shared<bool>(boost::any_cast<bool>(m["InitRequired"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~UpgradeFabricChaincodeDefinitionRequest() = default;
};
class UpgradeFabricChaincodeDefinitionResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> chaincodeVersion{};
  shared_ptr<string> channelName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deployTime{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<string> input{};
  shared_ptr<bool> install{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<string> providerId{};
  shared_ptr<string> providerName{};
  shared_ptr<string> state{};
  shared_ptr<long> type{};

  UpgradeFabricChaincodeDefinitionResponseBodyResult() {}

  explicit UpgradeFabricChaincodeDefinitionResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (chaincodeVersion) {
      res["ChaincodeVersion"] = boost::any(*chaincodeVersion);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deployTime) {
      res["DeployTime"] = boost::any(*deployTime);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (install) {
      res["Install"] = boost::any(*install);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (providerId) {
      res["ProviderId"] = boost::any(*providerId);
    }
    if (providerName) {
      res["ProviderName"] = boost::any(*providerName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("ChaincodeVersion") != m.end() && !m["ChaincodeVersion"].empty()) {
      chaincodeVersion = make_shared<string>(boost::any_cast<string>(m["ChaincodeVersion"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeployTime") != m.end() && !m["DeployTime"].empty()) {
      deployTime = make_shared<string>(boost::any_cast<string>(m["DeployTime"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Install") != m.end() && !m["Install"].empty()) {
      install = make_shared<bool>(boost::any_cast<bool>(m["Install"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ProviderId") != m.end() && !m["ProviderId"].empty()) {
      providerId = make_shared<string>(boost::any_cast<string>(m["ProviderId"]));
    }
    if (m.find("ProviderName") != m.end() && !m["ProviderName"].empty()) {
      providerName = make_shared<string>(boost::any_cast<string>(m["ProviderName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~UpgradeFabricChaincodeDefinitionResponseBodyResult() = default;
};
class UpgradeFabricChaincodeDefinitionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeDefinitionId{};
  shared_ptr<string> chaincodePackageId{};
  shared_ptr<long> errorCode{};
  shared_ptr<bool> initRequired{};
  shared_ptr<string> requestId{};
  shared_ptr<UpgradeFabricChaincodeDefinitionResponseBodyResult> result{};
  shared_ptr<bool> success{};

  UpgradeFabricChaincodeDefinitionResponseBody() {}

  explicit UpgradeFabricChaincodeDefinitionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeDefinitionId) {
      res["ChaincodeDefinitionId"] = boost::any(*chaincodeDefinitionId);
    }
    if (chaincodePackageId) {
      res["ChaincodePackageId"] = boost::any(*chaincodePackageId);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (initRequired) {
      res["InitRequired"] = boost::any(*initRequired);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeDefinitionId") != m.end() && !m["ChaincodeDefinitionId"].empty()) {
      chaincodeDefinitionId = make_shared<string>(boost::any_cast<string>(m["ChaincodeDefinitionId"]));
    }
    if (m.find("ChaincodePackageId") != m.end() && !m["ChaincodePackageId"].empty()) {
      chaincodePackageId = make_shared<string>(boost::any_cast<string>(m["ChaincodePackageId"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("InitRequired") != m.end() && !m["InitRequired"].empty()) {
      initRequired = make_shared<bool>(boost::any_cast<bool>(m["InitRequired"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        UpgradeFabricChaincodeDefinitionResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<UpgradeFabricChaincodeDefinitionResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpgradeFabricChaincodeDefinitionResponseBody() = default;
};
class UpgradeFabricChaincodeDefinitionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpgradeFabricChaincodeDefinitionResponseBody> body{};

  UpgradeFabricChaincodeDefinitionResponse() {}

  explicit UpgradeFabricChaincodeDefinitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpgradeFabricChaincodeDefinitionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpgradeFabricChaincodeDefinitionResponseBody>(model1);
      }
    }
  }


  virtual ~UpgradeFabricChaincodeDefinitionResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AcceptEthereumInvitationResponse acceptEthereumInvitationWithOptions(shared_ptr<AcceptEthereumInvitationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AcceptEthereumInvitationResponse acceptEthereumInvitation(shared_ptr<AcceptEthereumInvitationRequest> request);
  AcceptInvitationResponse acceptInvitationWithOptions(shared_ptr<AcceptInvitationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AcceptInvitationResponse acceptInvitation(shared_ptr<AcceptInvitationRequest> request);
  AddAntChainSubnetMemberCheckResponse addAntChainSubnetMemberCheckWithOptions(shared_ptr<AddAntChainSubnetMemberCheckRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddAntChainSubnetMemberCheckResponse addAntChainSubnetMemberCheck(shared_ptr<AddAntChainSubnetMemberCheckRequest> request);
  AddAntChainSubnetNodeCheckResponse addAntChainSubnetNodeCheckWithOptions(shared_ptr<AddAntChainSubnetNodeCheckRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddAntChainSubnetNodeCheckResponse addAntChainSubnetNodeCheck(shared_ptr<AddAntChainSubnetNodeCheckRequest> request);
  AddEthereumNodeResponse addEthereumNodeWithOptions(shared_ptr<AddEthereumNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddEthereumNodeResponse addEthereumNode(shared_ptr<AddEthereumNodeRequest> request);
  AddFabricExternalOrganizationToChannelResponse addFabricExternalOrganizationToChannelWithOptions(shared_ptr<AddFabricExternalOrganizationToChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddFabricExternalOrganizationToChannelResponse addFabricExternalOrganizationToChannel(shared_ptr<AddFabricExternalOrganizationToChannelRequest> request);
  AddFabricOrganizationToExternalChannelResponse addFabricOrganizationToExternalChannelWithOptions(shared_ptr<AddFabricOrganizationToExternalChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddFabricOrganizationToExternalChannelResponse addFabricOrganizationToExternalChannel(shared_ptr<AddFabricOrganizationToExternalChannelRequest> request);
  ApplyAntChainResponse applyAntChainWithOptions(shared_ptr<ApplyAntChainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyAntChainResponse applyAntChain(shared_ptr<ApplyAntChainRequest> request);
  ApplyAntChainCertificateResponse applyAntChainCertificateWithOptions(shared_ptr<ApplyAntChainCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyAntChainCertificateResponse applyAntChainCertificate(shared_ptr<ApplyAntChainCertificateRequest> request);
  ApplyAntChainCertificateWithKeyAutoCreationResponse applyAntChainCertificateWithKeyAutoCreationWithOptions(shared_ptr<ApplyAntChainCertificateWithKeyAutoCreationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyAntChainCertificateWithKeyAutoCreationResponse applyAntChainCertificateWithKeyAutoCreation(shared_ptr<ApplyAntChainCertificateWithKeyAutoCreationRequest> request);
  ApplyAntChainWithKeyAutoCreationResponse applyAntChainWithKeyAutoCreationWithOptions(shared_ptr<ApplyAntChainWithKeyAutoCreationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyAntChainWithKeyAutoCreationResponse applyAntChainWithKeyAutoCreation(shared_ptr<ApplyAntChainWithKeyAutoCreationRequest> request);
  ApplyBlockchainResponse applyBlockchainWithOptions(shared_ptr<ApplyBlockchainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyBlockchainResponse applyBlockchain(shared_ptr<ApplyBlockchainRequest> request);
  ApplyBlockchainWithKeyAutoCreationResponse applyBlockchainWithKeyAutoCreationWithOptions(shared_ptr<ApplyBlockchainWithKeyAutoCreationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyBlockchainWithKeyAutoCreationResponse applyBlockchainWithKeyAutoCreation(shared_ptr<ApplyBlockchainWithKeyAutoCreationRequest> request);
  ApplyPublicAntChainResponse applyPublicAntChainWithOptions(shared_ptr<ApplyPublicAntChainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyPublicAntChainResponse applyPublicAntChain(shared_ptr<ApplyPublicAntChainRequest> request);
  ApplyPublicAntChainWithKeyAutoCreationResponse applyPublicAntChainWithKeyAutoCreationWithOptions(shared_ptr<ApplyPublicAntChainWithKeyAutoCreationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyPublicAntChainWithKeyAutoCreationResponse applyPublicAntChainWithKeyAutoCreation(shared_ptr<ApplyPublicAntChainWithKeyAutoCreationRequest> request);
  ApproveEthereumInviteeResponse approveEthereumInviteeWithOptions(shared_ptr<ApproveEthereumInviteeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApproveEthereumInviteeResponse approveEthereumInvitee(shared_ptr<ApproveEthereumInviteeRequest> request);
  ApproveFabricChaincodeDefinitionResponse approveFabricChaincodeDefinitionWithOptions(shared_ptr<ApproveFabricChaincodeDefinitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApproveFabricChaincodeDefinitionResponse approveFabricChaincodeDefinition(shared_ptr<ApproveFabricChaincodeDefinitionRequest> request);
  BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponse batchAddAntChainMiniAppQRCodeAuthorizedUsersWithOptions(shared_ptr<BatchAddAntChainMiniAppQRCodeAuthorizedUsersRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponse batchAddAntChainMiniAppQRCodeAuthorizedUsers(shared_ptr<BatchAddAntChainMiniAppQRCodeAuthorizedUsersRequest> request);
  BindFabricManagementChaincodeResponse bindFabricManagementChaincodeWithOptions(shared_ptr<BindFabricManagementChaincodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindFabricManagementChaincodeResponse bindFabricManagementChaincode(shared_ptr<BindFabricManagementChaincodeRequest> request);
  CheckConsortiumDomainResponse checkConsortiumDomainWithOptions(shared_ptr<CheckConsortiumDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckConsortiumDomainResponse checkConsortiumDomain(shared_ptr<CheckConsortiumDomainRequest> request);
  CheckOrganizationDomainResponse checkOrganizationDomainWithOptions(shared_ptr<CheckOrganizationDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckOrganizationDomainResponse checkOrganizationDomain(shared_ptr<CheckOrganizationDomainRequest> request);
  ConfirmConsortiumMemberResponse confirmConsortiumMemberWithOptions(shared_ptr<ConfirmConsortiumMemberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfirmConsortiumMemberResponse confirmConsortiumMember(shared_ptr<ConfirmConsortiumMemberRequest> request);
  CopyAntChainContractProjectResponse copyAntChainContractProjectWithOptions(shared_ptr<CopyAntChainContractProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CopyAntChainContractProjectResponse copyAntChainContractProject(shared_ptr<CopyAntChainContractProjectRequest> request);
  CreateAccessTokenResponse createAccessTokenWithOptions(shared_ptr<CreateAccessTokenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAccessTokenResponse createAccessToken(shared_ptr<CreateAccessTokenRequest> request);
  CreateAccountResponse createAccountWithOptions(shared_ptr<CreateAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAccountResponse createAccount(shared_ptr<CreateAccountRequest> request);
  CreateAccountWithKeyPairAutoCreationResponse createAccountWithKeyPairAutoCreationWithOptions(shared_ptr<CreateAccountWithKeyPairAutoCreationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAccountWithKeyPairAutoCreationResponse createAccountWithKeyPairAutoCreation(shared_ptr<CreateAccountWithKeyPairAutoCreationRequest> request);
  CreateAntChainResponse createAntChainWithOptions(shared_ptr<CreateAntChainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAntChainResponse createAntChain(shared_ptr<CreateAntChainRequest> request);
  CreateAntChainAccountResponse createAntChainAccountWithOptions(shared_ptr<CreateAntChainAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAntChainAccountResponse createAntChainAccount(shared_ptr<CreateAntChainAccountRequest> request);
  CreateAntChainAccountWithKeyPairAutoCreationResponse createAntChainAccountWithKeyPairAutoCreationWithOptions(shared_ptr<CreateAntChainAccountWithKeyPairAutoCreationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAntChainAccountWithKeyPairAutoCreationResponse createAntChainAccountWithKeyPairAutoCreation(shared_ptr<CreateAntChainAccountWithKeyPairAutoCreationRequest> request);
  CreateAntChainConsortiumResponse createAntChainConsortiumWithOptions(shared_ptr<CreateAntChainConsortiumRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAntChainConsortiumResponse createAntChainConsortium(shared_ptr<CreateAntChainConsortiumRequest> request);
  CreateAntChainContractContentResponse createAntChainContractContentWithOptions(shared_ptr<CreateAntChainContractContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAntChainContractContentResponse createAntChainContractContent(shared_ptr<CreateAntChainContractContentRequest> request);
  CreateAntChainContractProjectResponse createAntChainContractProjectWithOptions(shared_ptr<CreateAntChainContractProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAntChainContractProjectResponse createAntChainContractProject(shared_ptr<CreateAntChainContractProjectRequest> request);
  CreateBlockchainResponse createBlockchainWithOptions(shared_ptr<CreateBlockchainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBlockchainResponse createBlockchain(shared_ptr<CreateBlockchainRequest> request);
  CreateBlockchainApplicationResponse createBlockchainApplicationWithOptions(shared_ptr<CreateBlockchainApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBlockchainApplicationResponse createBlockchainApplication(shared_ptr<CreateBlockchainApplicationRequest> request);
  CreateBlockchainApplyResponse createBlockchainApplyWithOptions(shared_ptr<CreateBlockchainApplyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBlockchainApplyResponse createBlockchainApply(shared_ptr<CreateBlockchainApplyRequest> request);
  CreateChaincodeResponse createChaincodeWithOptions(shared_ptr<CreateChaincodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateChaincodeResponse createChaincode(shared_ptr<CreateChaincodeRequest> request);
  CreateChannelResponse createChannelWithOptions(shared_ptr<CreateChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateChannelResponse createChannel(shared_ptr<CreateChannelRequest> request);
  CreateChannelMemberResponse createChannelMemberWithOptions(shared_ptr<CreateChannelMemberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateChannelMemberResponse createChannelMember(shared_ptr<CreateChannelMemberRequest> request);
  CreateCloudIntegrationServiceTokenResponse createCloudIntegrationServiceTokenWithOptions(shared_ptr<CreateCloudIntegrationServiceTokenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCloudIntegrationServiceTokenResponse createCloudIntegrationServiceToken(shared_ptr<CreateCloudIntegrationServiceTokenRequest> request);
  CreateCloudServiceIntegrationResponse createCloudServiceIntegrationWithOptions(shared_ptr<CreateCloudServiceIntegrationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCloudServiceIntegrationResponse createCloudServiceIntegration(shared_ptr<CreateCloudServiceIntegrationRequest> request);
  CreateCloudServiceSessionResponse createCloudServiceSessionWithOptions(shared_ptr<CreateCloudServiceSessionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCloudServiceSessionResponse createCloudServiceSession(shared_ptr<CreateCloudServiceSessionRequest> request);
  CreateConsortiumResponse createConsortiumWithOptions(shared_ptr<CreateConsortiumRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateConsortiumResponse createConsortium(shared_ptr<CreateConsortiumRequest> request);
  CreateConsortiumMemberResponse createConsortiumMemberWithOptions(shared_ptr<CreateConsortiumMemberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateConsortiumMemberResponse createConsortiumMember(shared_ptr<CreateConsortiumMemberRequest> request);
  CreateEcosphereResponse createEcosphereWithOptions(shared_ptr<CreateEcosphereRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEcosphereResponse createEcosphere(shared_ptr<CreateEcosphereRequest> request);
  CreateEthereumResponse createEthereumWithOptions(shared_ptr<CreateEthereumRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEthereumResponse createEthereum(shared_ptr<CreateEthereumRequest> request);
  CreateEthereumInvitationResponse createEthereumInvitationWithOptions(shared_ptr<CreateEthereumInvitationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEthereumInvitationResponse createEthereumInvitation(shared_ptr<CreateEthereumInvitationRequest> request);
  CreateFabricChaincodePackageResponse createFabricChaincodePackageWithOptions(shared_ptr<CreateFabricChaincodePackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFabricChaincodePackageResponse createFabricChaincodePackage(shared_ptr<CreateFabricChaincodePackageRequest> request);
  CreateOrganizationResponse createOrganizationWithOptions(shared_ptr<CreateOrganizationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrganizationResponse createOrganization(shared_ptr<CreateOrganizationRequest> request);
  CreateOrganizationUserResponse createOrganizationUserWithOptions(shared_ptr<CreateOrganizationUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOrganizationUserResponse createOrganizationUser(shared_ptr<CreateOrganizationUserRequest> request);
  CreateOwnAccountResponse createOwnAccountWithOptions(shared_ptr<CreateOwnAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOwnAccountResponse createOwnAccount(shared_ptr<CreateOwnAccountRequest> request);
  CreatePublicAccountWithKeyPairAutoCreationResponse createPublicAccountWithKeyPairAutoCreationWithOptions(shared_ptr<CreatePublicAccountWithKeyPairAutoCreationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePublicAccountWithKeyPairAutoCreationResponse createPublicAccountWithKeyPairAutoCreation(shared_ptr<CreatePublicAccountWithKeyPairAutoCreationRequest> request);
  CreatePublicAntChainAccountResponse createPublicAntChainAccountWithOptions(shared_ptr<CreatePublicAntChainAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePublicAntChainAccountResponse createPublicAntChainAccount(shared_ptr<CreatePublicAntChainAccountRequest> request);
  CreateSmartContractJobResponse createSmartContractJobWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSmartContractJobResponse createSmartContractJob();
  CreateTriggerResponse createTriggerWithOptions(shared_ptr<CreateTriggerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTriggerResponse createTrigger(shared_ptr<CreateTriggerRequest> request);
  DeleteAntChainConsortiumResponse deleteAntChainConsortiumWithOptions(shared_ptr<DeleteAntChainConsortiumRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAntChainConsortiumResponse deleteAntChainConsortium(shared_ptr<DeleteAntChainConsortiumRequest> request);
  DeleteAntChainContractContentResponse deleteAntChainContractContentWithOptions(shared_ptr<DeleteAntChainContractContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAntChainContractContentResponse deleteAntChainContractContent(shared_ptr<DeleteAntChainContractContentRequest> request);
  DeleteAntChainContractProjectResponse deleteAntChainContractProjectWithOptions(shared_ptr<DeleteAntChainContractProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAntChainContractProjectResponse deleteAntChainContractProject(shared_ptr<DeleteAntChainContractProjectRequest> request);
  DeleteAntChainMiniAppQRCodeAuthorizedUserResponse deleteAntChainMiniAppQRCodeAuthorizedUserWithOptions(shared_ptr<DeleteAntChainMiniAppQRCodeAuthorizedUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAntChainMiniAppQRCodeAuthorizedUserResponse deleteAntChainMiniAppQRCodeAuthorizedUser(shared_ptr<DeleteAntChainMiniAppQRCodeAuthorizedUserRequest> request);
  DeleteChaincodeResponse deleteChaincodeWithOptions(shared_ptr<DeleteChaincodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteChaincodeResponse deleteChaincode(shared_ptr<DeleteChaincodeRequest> request);
  DeleteGovernanceTaskResponse deleteGovernanceTaskWithOptions(shared_ptr<DeleteGovernanceTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteGovernanceTaskResponse deleteGovernanceTask(shared_ptr<DeleteGovernanceTaskRequest> request);
  DeleteTriggerResponse deleteTriggerWithOptions(shared_ptr<DeleteTriggerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTriggerResponse deleteTrigger(shared_ptr<DeleteTriggerRequest> request);
  DescribeAntChainAccountsResponse describeAntChainAccountsWithOptions(shared_ptr<DescribeAntChainAccountsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainAccountsResponse describeAntChainAccounts(shared_ptr<DescribeAntChainAccountsRequest> request);
  DescribeAntChainAccountsNewResponse describeAntChainAccountsNewWithOptions(shared_ptr<DescribeAntChainAccountsNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainAccountsNewResponse describeAntChainAccountsNew(shared_ptr<DescribeAntChainAccountsNewRequest> request);
  DescribeAntChainApplicationsResponse describeAntChainApplicationsWithOptions(shared_ptr<DescribeAntChainApplicationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainApplicationsResponse describeAntChainApplications(shared_ptr<DescribeAntChainApplicationsRequest> request);
  DescribeAntChainBlockResponse describeAntChainBlockWithOptions(shared_ptr<DescribeAntChainBlockRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainBlockResponse describeAntChainBlock(shared_ptr<DescribeAntChainBlockRequest> request);
  DescribeAntChainBlockNewResponse describeAntChainBlockNewWithOptions(shared_ptr<DescribeAntChainBlockNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainBlockNewResponse describeAntChainBlockNew(shared_ptr<DescribeAntChainBlockNewRequest> request);
  DescribeAntChainCertificateApplicationsResponse describeAntChainCertificateApplicationsWithOptions(shared_ptr<DescribeAntChainCertificateApplicationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainCertificateApplicationsResponse describeAntChainCertificateApplications(shared_ptr<DescribeAntChainCertificateApplicationsRequest> request);
  DescribeAntChainCertificateApplicationsNewResponse describeAntChainCertificateApplicationsNewWithOptions(shared_ptr<DescribeAntChainCertificateApplicationsNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainCertificateApplicationsNewResponse describeAntChainCertificateApplicationsNew(shared_ptr<DescribeAntChainCertificateApplicationsNewRequest> request);
  DescribeAntChainConfigOptionsResponse describeAntChainConfigOptionsWithOptions(shared_ptr<DescribeAntChainConfigOptionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainConfigOptionsResponse describeAntChainConfigOptions(shared_ptr<DescribeAntChainConfigOptionsRequest> request);
  DescribeAntChainConsortiumsResponse describeAntChainConsortiumsWithOptions(shared_ptr<DescribeAntChainConsortiumsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainConsortiumsResponse describeAntChainConsortiums(shared_ptr<DescribeAntChainConsortiumsRequest> request);
  DescribeAntChainConsortiumsNewResponse describeAntChainConsortiumsNewWithOptions(shared_ptr<DescribeAntChainConsortiumsNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainConsortiumsNewResponse describeAntChainConsortiumsNew(shared_ptr<DescribeAntChainConsortiumsNewRequest> request);
  DescribeAntChainContractProjectContentTreeResponse describeAntChainContractProjectContentTreeWithOptions(shared_ptr<DescribeAntChainContractProjectContentTreeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainContractProjectContentTreeResponse describeAntChainContractProjectContentTree(shared_ptr<DescribeAntChainContractProjectContentTreeRequest> request);
  DescribeAntChainContractProjectContentTreeNewResponse describeAntChainContractProjectContentTreeNewWithOptions(shared_ptr<DescribeAntChainContractProjectContentTreeNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainContractProjectContentTreeNewResponse describeAntChainContractProjectContentTreeNew(shared_ptr<DescribeAntChainContractProjectContentTreeNewRequest> request);
  DescribeAntChainContractProjectsResponse describeAntChainContractProjectsWithOptions(shared_ptr<DescribeAntChainContractProjectsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainContractProjectsResponse describeAntChainContractProjects(shared_ptr<DescribeAntChainContractProjectsRequest> request);
  DescribeAntChainContractProjectsNewResponse describeAntChainContractProjectsNewWithOptions(shared_ptr<DescribeAntChainContractProjectsNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainContractProjectsNewResponse describeAntChainContractProjectsNew(shared_ptr<DescribeAntChainContractProjectsNewRequest> request);
  DescribeAntChainDownloadPathsResponse describeAntChainDownloadPathsWithOptions(shared_ptr<DescribeAntChainDownloadPathsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainDownloadPathsResponse describeAntChainDownloadPaths(shared_ptr<DescribeAntChainDownloadPathsRequest> request);
  DescribeAntChainDownloadPathsNewResponse describeAntChainDownloadPathsNewWithOptions(shared_ptr<DescribeAntChainDownloadPathsNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainDownloadPathsNewResponse describeAntChainDownloadPathsNew(shared_ptr<DescribeAntChainDownloadPathsNewRequest> request);
  DescribeAntChainInformationResponse describeAntChainInformationWithOptions(shared_ptr<DescribeAntChainInformationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainInformationResponse describeAntChainInformation(shared_ptr<DescribeAntChainInformationRequest> request);
  DescribeAntChainInformationNewResponse describeAntChainInformationNewWithOptions(shared_ptr<DescribeAntChainInformationNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainInformationNewResponse describeAntChainInformationNew(shared_ptr<DescribeAntChainInformationNewRequest> request);
  DescribeAntChainLatestBlocksResponse describeAntChainLatestBlocksWithOptions(shared_ptr<DescribeAntChainLatestBlocksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainLatestBlocksResponse describeAntChainLatestBlocks(shared_ptr<DescribeAntChainLatestBlocksRequest> request);
  DescribeAntChainLatestBlocksNewResponse describeAntChainLatestBlocksNewWithOptions(shared_ptr<DescribeAntChainLatestBlocksNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainLatestBlocksNewResponse describeAntChainLatestBlocksNew(shared_ptr<DescribeAntChainLatestBlocksNewRequest> request);
  DescribeAntChainLatestTransactionDigestsResponse describeAntChainLatestTransactionDigestsWithOptions(shared_ptr<DescribeAntChainLatestTransactionDigestsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainLatestTransactionDigestsResponse describeAntChainLatestTransactionDigests(shared_ptr<DescribeAntChainLatestTransactionDigestsRequest> request);
  DescribeAntChainLatestTransactionDigestsNewResponse describeAntChainLatestTransactionDigestsNewWithOptions(shared_ptr<DescribeAntChainLatestTransactionDigestsNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainLatestTransactionDigestsNewResponse describeAntChainLatestTransactionDigestsNew(shared_ptr<DescribeAntChainLatestTransactionDigestsNewRequest> request);
  DescribeAntChainMembersResponse describeAntChainMembersWithOptions(shared_ptr<DescribeAntChainMembersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainMembersResponse describeAntChainMembers(shared_ptr<DescribeAntChainMembersRequest> request);
  DescribeAntChainMembersNewResponse describeAntChainMembersNewWithOptions(shared_ptr<DescribeAntChainMembersNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainMembersNewResponse describeAntChainMembersNew(shared_ptr<DescribeAntChainMembersNewRequest> request);
  DescribeAntChainMiniAppBrowserQRCodeAccessLogResponse describeAntChainMiniAppBrowserQRCodeAccessLogWithOptions(shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAccessLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainMiniAppBrowserQRCodeAccessLogResponse describeAntChainMiniAppBrowserQRCodeAccessLog(shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAccessLogRequest> request);
  DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponse describeAntChainMiniAppBrowserQRCodeAccessLogNewWithOptions(shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAccessLogNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainMiniAppBrowserQRCodeAccessLogNewResponse describeAntChainMiniAppBrowserQRCodeAccessLogNew(shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAccessLogNewRequest> request);
  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponse describeAntChainMiniAppBrowserQRCodeAuthorizedUsersWithOptions(shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponse describeAntChainMiniAppBrowserQRCodeAuthorizedUsers(shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersRequest> request);
  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponse describeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewWithOptions(shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewResponse describeAntChainMiniAppBrowserQRCodeAuthorizedUsersNew(shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersNewRequest> request);
  DescribeAntChainMiniAppBrowserTransactionQRCodeResponse describeAntChainMiniAppBrowserTransactionQRCodeWithOptions(shared_ptr<DescribeAntChainMiniAppBrowserTransactionQRCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainMiniAppBrowserTransactionQRCodeResponse describeAntChainMiniAppBrowserTransactionQRCode(shared_ptr<DescribeAntChainMiniAppBrowserTransactionQRCodeRequest> request);
  DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponse describeAntChainMiniAppBrowserTransactionQRCodeNewWithOptions(shared_ptr<DescribeAntChainMiniAppBrowserTransactionQRCodeNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponse describeAntChainMiniAppBrowserTransactionQRCodeNew(shared_ptr<DescribeAntChainMiniAppBrowserTransactionQRCodeNewRequest> request);
  DescribeAntChainNodesNewResponse describeAntChainNodesNewWithOptions(shared_ptr<DescribeAntChainNodesNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainNodesNewResponse describeAntChainNodesNew(shared_ptr<DescribeAntChainNodesNewRequest> request);
  DescribeAntChainQRCodeAuthorizationResponse describeAntChainQRCodeAuthorizationWithOptions(shared_ptr<DescribeAntChainQRCodeAuthorizationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainQRCodeAuthorizationResponse describeAntChainQRCodeAuthorization(shared_ptr<DescribeAntChainQRCodeAuthorizationRequest> request);
  DescribeAntChainQRCodeAuthorizationNewResponse describeAntChainQRCodeAuthorizationNewWithOptions(shared_ptr<DescribeAntChainQRCodeAuthorizationNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainQRCodeAuthorizationNewResponse describeAntChainQRCodeAuthorizationNew(shared_ptr<DescribeAntChainQRCodeAuthorizationNewRequest> request);
  DescribeAntChainRegionNamesResponse describeAntChainRegionNamesWithOptions(shared_ptr<DescribeAntChainRegionNamesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainRegionNamesResponse describeAntChainRegionNames(shared_ptr<DescribeAntChainRegionNamesRequest> request);
  DescribeAntChainRegionsForSaleResponse describeAntChainRegionsForSaleWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainRegionsForSaleResponse describeAntChainRegionsForSale();
  DescribeAntChainResourceTypesResponse describeAntChainResourceTypesWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainResourceTypesResponse describeAntChainResourceTypes();
  DescribeAntChainRestResponse describeAntChainRestWithOptions(shared_ptr<DescribeAntChainRestRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainRestResponse describeAntChainRest(shared_ptr<DescribeAntChainRestRequest> request);
  DescribeAntChainSubnetListResponse describeAntChainSubnetListWithOptions(shared_ptr<DescribeAntChainSubnetListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainSubnetListResponse describeAntChainSubnetList(shared_ptr<DescribeAntChainSubnetListRequest> request);
  DescribeAntChainSubnetMemberListResponse describeAntChainSubnetMemberListWithOptions(shared_ptr<DescribeAntChainSubnetMemberListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainSubnetMemberListResponse describeAntChainSubnetMemberList(shared_ptr<DescribeAntChainSubnetMemberListRequest> request);
  DescribeAntChainSubnetNodeListResponse describeAntChainSubnetNodeListWithOptions(shared_ptr<DescribeAntChainSubnetNodeListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainSubnetNodeListResponse describeAntChainSubnetNodeList(shared_ptr<DescribeAntChainSubnetNodeListRequest> request);
  DescribeAntChainTransactionResponse describeAntChainTransactionWithOptions(shared_ptr<DescribeAntChainTransactionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainTransactionResponse describeAntChainTransaction(shared_ptr<DescribeAntChainTransactionRequest> request);
  DescribeAntChainTransactionNewResponse describeAntChainTransactionNewWithOptions(shared_ptr<DescribeAntChainTransactionNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainTransactionNewResponse describeAntChainTransactionNew(shared_ptr<DescribeAntChainTransactionNewRequest> request);
  DescribeAntChainTransactionReceiptNewResponse describeAntChainTransactionReceiptNewWithOptions(shared_ptr<DescribeAntChainTransactionReceiptNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainTransactionReceiptNewResponse describeAntChainTransactionReceiptNew(shared_ptr<DescribeAntChainTransactionReceiptNewRequest> request);
  DescribeAntChainTransactionStatisticsResponse describeAntChainTransactionStatisticsWithOptions(shared_ptr<DescribeAntChainTransactionStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainTransactionStatisticsResponse describeAntChainTransactionStatistics(shared_ptr<DescribeAntChainTransactionStatisticsRequest> request);
  DescribeAntChainTransactionStatisticsNewResponse describeAntChainTransactionStatisticsNewWithOptions(shared_ptr<DescribeAntChainTransactionStatisticsNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainTransactionStatisticsNewResponse describeAntChainTransactionStatisticsNew(shared_ptr<DescribeAntChainTransactionStatisticsNewRequest> request);
  DescribeAntChainsResponse describeAntChainsWithOptions(shared_ptr<DescribeAntChainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainsResponse describeAntChains(shared_ptr<DescribeAntChainsRequest> request);
  DescribeAntChainsNewResponse describeAntChainsNewWithOptions(shared_ptr<DescribeAntChainsNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainsNewResponse describeAntChainsNew(shared_ptr<DescribeAntChainsNewRequest> request);
  DescribeAntRegionsResponse describeAntRegionsWithOptions(shared_ptr<DescribeAntRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntRegionsResponse describeAntRegions(shared_ptr<DescribeAntRegionsRequest> request);
  DescribeAppliesResponse describeAppliesWithOptions(shared_ptr<DescribeAppliesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAppliesResponse describeApplies(shared_ptr<DescribeAppliesRequest> request);
  DescribeBcSchemaResponse describeBcSchemaWithOptions(shared_ptr<DescribeBcSchemaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBcSchemaResponse describeBcSchema(shared_ptr<DescribeBcSchemaRequest> request);
  DescribeBlockResponse describeBlockWithOptions(shared_ptr<DescribeBlockRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBlockResponse describeBlock(shared_ptr<DescribeBlockRequest> request);
  DescribeBlockchainApplicationResponse describeBlockchainApplicationWithOptions(shared_ptr<DescribeBlockchainApplicationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBlockchainApplicationResponse describeBlockchainApplication(shared_ptr<DescribeBlockchainApplicationRequest> request);
  DescribeBlockchainConfigOptionResponse describeBlockchainConfigOptionWithOptions(shared_ptr<DescribeBlockchainConfigOptionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBlockchainConfigOptionResponse describeBlockchainConfigOption(shared_ptr<DescribeBlockchainConfigOptionRequest> request);
  DescribeBlockchainCreateTaskResponse describeBlockchainCreateTaskWithOptions(shared_ptr<DescribeBlockchainCreateTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBlockchainCreateTaskResponse describeBlockchainCreateTask(shared_ptr<DescribeBlockchainCreateTaskRequest> request);
  DescribeBlockchainCreationConfigOptionsResponse describeBlockchainCreationConfigOptionsWithOptions(shared_ptr<DescribeBlockchainCreationConfigOptionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBlockchainCreationConfigOptionsResponse describeBlockchainCreationConfigOptions(shared_ptr<DescribeBlockchainCreationConfigOptionsRequest> request);
  DescribeBlockchainInfoResponse describeBlockchainInfoWithOptions(shared_ptr<DescribeBlockchainInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBlockchainInfoResponse describeBlockchainInfo(shared_ptr<DescribeBlockchainInfoRequest> request);
  DescribeBlockchainSchemaResponse describeBlockchainSchemaWithOptions(shared_ptr<DescribeBlockchainSchemaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBlockchainSchemaResponse describeBlockchainSchema(shared_ptr<DescribeBlockchainSchemaRequest> request);
  DescribeBlockchainSchemaDetailResponse describeBlockchainSchemaDetailWithOptions(shared_ptr<DescribeBlockchainSchemaDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBlockchainSchemaDetailResponse describeBlockchainSchemaDetail(shared_ptr<DescribeBlockchainSchemaDetailRequest> request);
  DescribeBlockchainSchemaFileOSSPropertiesResponse describeBlockchainSchemaFileOSSPropertiesWithOptions(shared_ptr<DescribeBlockchainSchemaFileOSSPropertiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBlockchainSchemaFileOSSPropertiesResponse describeBlockchainSchemaFileOSSProperties(shared_ptr<DescribeBlockchainSchemaFileOSSPropertiesRequest> request);
  DescribeBlockchainSchemaTemplatesResponse describeBlockchainSchemaTemplatesWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBlockchainSchemaTemplatesResponse describeBlockchainSchemaTemplates();
  DescribeCSIGatewayEndpointResponse describeCSIGatewayEndpointWithOptions(shared_ptr<DescribeCSIGatewayEndpointRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCSIGatewayEndpointResponse describeCSIGatewayEndpoint(shared_ptr<DescribeCSIGatewayEndpointRequest> request);
  DescribeCandidateOrganizationsResponse describeCandidateOrganizationsWithOptions(shared_ptr<DescribeCandidateOrganizationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCandidateOrganizationsResponse describeCandidateOrganizations(shared_ptr<DescribeCandidateOrganizationsRequest> request);
  DescribeChaincodeCollectionConfigResponse describeChaincodeCollectionConfigWithOptions(shared_ptr<DescribeChaincodeCollectionConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeChaincodeCollectionConfigResponse describeChaincodeCollectionConfig(shared_ptr<DescribeChaincodeCollectionConfigRequest> request);
  DescribeChaincodeDefinitionTaskResponse describeChaincodeDefinitionTaskWithOptions(shared_ptr<DescribeChaincodeDefinitionTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeChaincodeDefinitionTaskResponse describeChaincodeDefinitionTask(shared_ptr<DescribeChaincodeDefinitionTaskRequest> request);
  DescribeChaincodeUploadPolicyResponse describeChaincodeUploadPolicyWithOptions(shared_ptr<DescribeChaincodeUploadPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeChaincodeUploadPolicyResponse describeChaincodeUploadPolicy(shared_ptr<DescribeChaincodeUploadPolicyRequest> request);
  DescribeChannelChaincodesResponse describeChannelChaincodesWithOptions(shared_ptr<DescribeChannelChaincodesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeChannelChaincodesResponse describeChannelChaincodes(shared_ptr<DescribeChannelChaincodesRequest> request);
  DescribeChannelMembersResponse describeChannelMembersWithOptions(shared_ptr<DescribeChannelMembersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeChannelMembersResponse describeChannelMembers(shared_ptr<DescribeChannelMembersRequest> request);
  DescribeChannelTriggersResponse describeChannelTriggersWithOptions(shared_ptr<DescribeChannelTriggersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeChannelTriggersResponse describeChannelTriggers(shared_ptr<DescribeChannelTriggersRequest> request);
  DescribeCloudIntegrationServiceTokenResponse describeCloudIntegrationServiceTokenWithOptions(shared_ptr<DescribeCloudIntegrationServiceTokenRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudIntegrationServiceTokenResponse describeCloudIntegrationServiceToken(shared_ptr<DescribeCloudIntegrationServiceTokenRequest> request);
  DescribeCloudServiceOrganizationStatusResponse describeCloudServiceOrganizationStatusWithOptions(shared_ptr<DescribeCloudServiceOrganizationStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudServiceOrganizationStatusResponse describeCloudServiceOrganizationStatus(shared_ptr<DescribeCloudServiceOrganizationStatusRequest> request);
  DescribeCloudServiceTypeStatusResponse describeCloudServiceTypeStatusWithOptions(shared_ptr<DescribeCloudServiceTypeStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudServiceTypeStatusResponse describeCloudServiceTypeStatus(shared_ptr<DescribeCloudServiceTypeStatusRequest> request);
  DescribeConsortiumAdminStatusResponse describeConsortiumAdminStatusWithOptions(shared_ptr<DescribeConsortiumAdminStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeConsortiumAdminStatusResponse describeConsortiumAdminStatus(shared_ptr<DescribeConsortiumAdminStatusRequest> request);
  DescribeConsortiumChaincodesResponse describeConsortiumChaincodesWithOptions(shared_ptr<DescribeConsortiumChaincodesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeConsortiumChaincodesResponse describeConsortiumChaincodes(shared_ptr<DescribeConsortiumChaincodesRequest> request);
  DescribeConsortiumChannelsResponse describeConsortiumChannelsWithOptions(shared_ptr<DescribeConsortiumChannelsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeConsortiumChannelsResponse describeConsortiumChannels(shared_ptr<DescribeConsortiumChannelsRequest> request);
  DescribeConsortiumConfigResponse describeConsortiumConfigWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeConsortiumConfigResponse describeConsortiumConfig();
  DescribeConsortiumDeletableResponse describeConsortiumDeletableWithOptions(shared_ptr<DescribeConsortiumDeletableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeConsortiumDeletableResponse describeConsortiumDeletable(shared_ptr<DescribeConsortiumDeletableRequest> request);
  DescribeConsortiumMemberApprovalResponse describeConsortiumMemberApprovalWithOptions(shared_ptr<DescribeConsortiumMemberApprovalRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeConsortiumMemberApprovalResponse describeConsortiumMemberApproval(shared_ptr<DescribeConsortiumMemberApprovalRequest> request);
  DescribeConsortiumMembersResponse describeConsortiumMembersWithOptions(shared_ptr<DescribeConsortiumMembersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeConsortiumMembersResponse describeConsortiumMembers(shared_ptr<DescribeConsortiumMembersRequest> request);
  DescribeConsortiumOrderersResponse describeConsortiumOrderersWithOptions(shared_ptr<DescribeConsortiumOrderersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeConsortiumOrderersResponse describeConsortiumOrderers(shared_ptr<DescribeConsortiumOrderersRequest> request);
  DescribeConsortiumSpecsResponse describeConsortiumSpecsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeConsortiumSpecsResponse describeConsortiumSpecs();
  DescribeConsortiumsResponse describeConsortiumsWithOptions(shared_ptr<DescribeConsortiumsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeConsortiumsResponse describeConsortiums(shared_ptr<DescribeConsortiumsRequest> request);
  DescribeDownloadPathsResponse describeDownloadPathsWithOptions(shared_ptr<DescribeDownloadPathsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDownloadPathsResponse describeDownloadPaths(shared_ptr<DescribeDownloadPathsRequest> request);
  DescribeDownloadPathsOfContractChainResponse describeDownloadPathsOfContractChainWithOptions(shared_ptr<DescribeDownloadPathsOfContractChainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDownloadPathsOfContractChainResponse describeDownloadPathsOfContractChain(shared_ptr<DescribeDownloadPathsOfContractChainRequest> request);
  DescribeDownloadPathsOfNotaryChainResponse describeDownloadPathsOfNotaryChainWithOptions(shared_ptr<DescribeDownloadPathsOfNotaryChainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDownloadPathsOfNotaryChainResponse describeDownloadPathsOfNotaryChain(shared_ptr<DescribeDownloadPathsOfNotaryChainRequest> request);
  DescribeEcosphereSpecsResponse describeEcosphereSpecsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEcosphereSpecsResponse describeEcosphereSpecs();
  DescribeEthereumResponse describeEthereumWithOptions(shared_ptr<DescribeEthereumRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEthereumResponse describeEthereum(shared_ptr<DescribeEthereumRequest> request);
  DescribeEthereumClientUsersResponse describeEthereumClientUsersWithOptions(shared_ptr<DescribeEthereumClientUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEthereumClientUsersResponse describeEthereumClientUsers(shared_ptr<DescribeEthereumClientUsersRequest> request);
  DescribeEthereumDeletableResponse describeEthereumDeletableWithOptions(shared_ptr<DescribeEthereumDeletableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEthereumDeletableResponse describeEthereumDeletable(shared_ptr<DescribeEthereumDeletableRequest> request);
  DescribeEthereumInvitaionResponse describeEthereumInvitaionWithOptions(shared_ptr<DescribeEthereumInvitaionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEthereumInvitaionResponse describeEthereumInvitaion(shared_ptr<DescribeEthereumInvitaionRequest> request);
  DescribeEthereumInviteeResponse describeEthereumInviteeWithOptions(shared_ptr<DescribeEthereumInviteeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEthereumInviteeResponse describeEthereumInvitee(shared_ptr<DescribeEthereumInviteeRequest> request);
  DescribeEthereumNodeResponse describeEthereumNodeWithOptions(shared_ptr<DescribeEthereumNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEthereumNodeResponse describeEthereumNode(shared_ptr<DescribeEthereumNodeRequest> request);
  DescribeEthereumNodeConfigurationResponse describeEthereumNodeConfigurationWithOptions(shared_ptr<DescribeEthereumNodeConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEthereumNodeConfigurationResponse describeEthereumNodeConfiguration(shared_ptr<DescribeEthereumNodeConfigurationRequest> request);
  DescribeEthereumNodeInfoResponse describeEthereumNodeInfoWithOptions(shared_ptr<DescribeEthereumNodeInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEthereumNodeInfoResponse describeEthereumNodeInfo(shared_ptr<DescribeEthereumNodeInfoRequest> request);
  DescribeEthereumNodeLogsResponse describeEthereumNodeLogsWithOptions(shared_ptr<DescribeEthereumNodeLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEthereumNodeLogsResponse describeEthereumNodeLogs(shared_ptr<DescribeEthereumNodeLogsRequest> request);
  DescribeEthereumNodesResponse describeEthereumNodesWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEthereumNodesResponse describeEthereumNodes();
  DescribeEthereumsResponse describeEthereumsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEthereumsResponse describeEthereums();
  DescribeExplorerResponse describeExplorerWithOptions(shared_ptr<DescribeExplorerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExplorerResponse describeExplorer(shared_ptr<DescribeExplorerRequest> request);
  DescribeExplorerURLResponse describeExplorerURLWithOptions(shared_ptr<DescribeExplorerURLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeExplorerURLResponse describeExplorerURL(shared_ptr<DescribeExplorerURLRequest> request);
  DescribeFabricChaincodeEndorsePolicyResponse describeFabricChaincodeEndorsePolicyWithOptions(shared_ptr<DescribeFabricChaincodeEndorsePolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricChaincodeEndorsePolicyResponse describeFabricChaincodeEndorsePolicy(shared_ptr<DescribeFabricChaincodeEndorsePolicyRequest> request);
  DescribeFabricChaincodeLogsResponse describeFabricChaincodeLogsWithOptions(shared_ptr<DescribeFabricChaincodeLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricChaincodeLogsResponse describeFabricChaincodeLogs(shared_ptr<DescribeFabricChaincodeLogsRequest> request);
  DescribeFabricChannelConfigResponse describeFabricChannelConfigWithOptions(shared_ptr<DescribeFabricChannelConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricChannelConfigResponse describeFabricChannelConfig(shared_ptr<DescribeFabricChannelConfigRequest> request);
  DescribeFabricChannelOrdererResponse describeFabricChannelOrdererWithOptions(shared_ptr<DescribeFabricChannelOrdererRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricChannelOrdererResponse describeFabricChannelOrderer(shared_ptr<DescribeFabricChannelOrdererRequest> request);
  DescribeFabricChannelOrganizationsResponse describeFabricChannelOrganizationsWithOptions(shared_ptr<DescribeFabricChannelOrganizationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricChannelOrganizationsResponse describeFabricChannelOrganizations(shared_ptr<DescribeFabricChannelOrganizationsRequest> request);
  DescribeFabricJoinRequestResponse describeFabricJoinRequestWithOptions(shared_ptr<DescribeFabricJoinRequestRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricJoinRequestResponse describeFabricJoinRequest(shared_ptr<DescribeFabricJoinRequestRequest> request);
  DescribeFabricJoinResponseResponse describeFabricJoinResponseWithOptions(shared_ptr<DescribeFabricJoinResponseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricJoinResponseResponse describeFabricJoinResponse(shared_ptr<DescribeFabricJoinResponseRequest> request);
  DescribeFabricManagementChaincodesResponse describeFabricManagementChaincodesWithOptions(shared_ptr<DescribeFabricManagementChaincodesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricManagementChaincodesResponse describeFabricManagementChaincodes(shared_ptr<DescribeFabricManagementChaincodesRequest> request);
  DescribeFabricOrganizationChaincodePackageResponse describeFabricOrganizationChaincodePackageWithOptions(shared_ptr<DescribeFabricOrganizationChaincodePackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricOrganizationChaincodePackageResponse describeFabricOrganizationChaincodePackage(shared_ptr<DescribeFabricOrganizationChaincodePackageRequest> request);
  DescribeFabricOrganizationEgressResponse describeFabricOrganizationEgressWithOptions(shared_ptr<DescribeFabricOrganizationEgressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricOrganizationEgressResponse describeFabricOrganizationEgress(shared_ptr<DescribeFabricOrganizationEgressRequest> request);
  DescribeFabricPeerChannelsResponse describeFabricPeerChannelsWithOptions(shared_ptr<DescribeFabricPeerChannelsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricPeerChannelsResponse describeFabricPeerChannels(shared_ptr<DescribeFabricPeerChannelsRequest> request);
  DescribeGovernanceTaskResponse describeGovernanceTaskWithOptions(shared_ptr<DescribeGovernanceTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGovernanceTaskResponse describeGovernanceTask(shared_ptr<DescribeGovernanceTaskRequest> request);
  DescribeGovernanceTasksResponse describeGovernanceTasksWithOptions(shared_ptr<DescribeGovernanceTasksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGovernanceTasksResponse describeGovernanceTasks(shared_ptr<DescribeGovernanceTasksRequest> request);
  DescribeInvitationCodeResponse describeInvitationCodeWithOptions(shared_ptr<DescribeInvitationCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInvitationCodeResponse describeInvitationCode(shared_ptr<DescribeInvitationCodeRequest> request);
  DescribeInvitationListResponse describeInvitationListWithOptions(shared_ptr<DescribeInvitationListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInvitationListResponse describeInvitationList(shared_ptr<DescribeInvitationListRequest> request);
  DescribeInviterResponse describeInviterWithOptions(shared_ptr<DescribeInviterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInviterResponse describeInviter(shared_ptr<DescribeInviterRequest> request);
  DescribeLatest15BlocksResponse describeLatest15BlocksWithOptions(shared_ptr<DescribeLatest15BlocksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLatest15BlocksResponse describeLatest15Blocks(shared_ptr<DescribeLatest15BlocksRequest> request);
  DescribeLatest15TransDigestsResponse describeLatest15TransDigestsWithOptions(shared_ptr<DescribeLatest15TransDigestsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLatest15TransDigestsResponse describeLatest15TransDigests(shared_ptr<DescribeLatest15TransDigestsRequest> request);
  DescribeLatestBlocksResponse describeLatestBlocksWithOptions(shared_ptr<DescribeLatestBlocksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLatestBlocksResponse describeLatestBlocks(shared_ptr<DescribeLatestBlocksRequest> request);
  DescribeLatestTransactionDigestsResponse describeLatestTransactionDigestsWithOptions(shared_ptr<DescribeLatestTransactionDigestsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLatestTransactionDigestsResponse describeLatestTransactionDigests(shared_ptr<DescribeLatestTransactionDigestsRequest> request);
  DescribeMemberRoleResponse describeMemberRoleWithOptions(shared_ptr<DescribeMemberRoleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMemberRoleResponse describeMemberRole(shared_ptr<DescribeMemberRoleRequest> request);
  DescribeMembersResponse describeMembersWithOptions(shared_ptr<DescribeMembersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMembersResponse describeMembers(shared_ptr<DescribeMembersRequest> request);
  DescribeMetricResponse describeMetricWithOptions(shared_ptr<DescribeMetricRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMetricResponse describeMetric(shared_ptr<DescribeMetricRequest> request);
  DescribeMyBlockchainsResponse describeMyBlockchainsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMyBlockchainsResponse describeMyBlockchains();
  DescribeMyBlockchanInfosResponse describeMyBlockchanInfosWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMyBlockchanInfosResponse describeMyBlockchanInfos();
  DescribeMySuccessAppliesResponse describeMySuccessAppliesWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMySuccessAppliesResponse describeMySuccessApplies();
  DescribeMySuccessfulApplicationResponse describeMySuccessfulApplicationWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeMySuccessfulApplicationResponse describeMySuccessfulApplication();
  DescribeNetstatURLResponse describeNetstatURLWithOptions(shared_ptr<DescribeNetstatURLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeNetstatURLResponse describeNetstatURL(shared_ptr<DescribeNetstatURLRequest> request);
  DescribeOrdererLogsResponse describeOrdererLogsWithOptions(shared_ptr<DescribeOrdererLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOrdererLogsResponse describeOrdererLogs(shared_ptr<DescribeOrdererLogsRequest> request);
  DescribeOrganizationResponse describeOrganizationWithOptions(shared_ptr<DescribeOrganizationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOrganizationResponse describeOrganization(shared_ptr<DescribeOrganizationRequest> request);
  DescribeOrganizationChaincodesResponse describeOrganizationChaincodesWithOptions(shared_ptr<DescribeOrganizationChaincodesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOrganizationChaincodesResponse describeOrganizationChaincodes(shared_ptr<DescribeOrganizationChaincodesRequest> request);
  DescribeOrganizationChannelsResponse describeOrganizationChannelsWithOptions(shared_ptr<DescribeOrganizationChannelsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOrganizationChannelsResponse describeOrganizationChannels(shared_ptr<DescribeOrganizationChannelsRequest> request);
  DescribeOrganizationDeletableResponse describeOrganizationDeletableWithOptions(shared_ptr<DescribeOrganizationDeletableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOrganizationDeletableResponse describeOrganizationDeletable(shared_ptr<DescribeOrganizationDeletableRequest> request);
  DescribeOrganizationMembersResponse describeOrganizationMembersWithOptions(shared_ptr<DescribeOrganizationMembersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOrganizationMembersResponse describeOrganizationMembers(shared_ptr<DescribeOrganizationMembersRequest> request);
  DescribeOrganizationPeersResponse describeOrganizationPeersWithOptions(shared_ptr<DescribeOrganizationPeersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOrganizationPeersResponse describeOrganizationPeers(shared_ptr<DescribeOrganizationPeersRequest> request);
  DescribeOrganizationSpecsResponse describeOrganizationSpecsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOrganizationSpecsResponse describeOrganizationSpecs();
  DescribeOrganizationTriggersResponse describeOrganizationTriggersWithOptions(shared_ptr<DescribeOrganizationTriggersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOrganizationTriggersResponse describeOrganizationTriggers(shared_ptr<DescribeOrganizationTriggersRequest> request);
  DescribeOrganizationUserCertsResponse describeOrganizationUserCertsWithOptions(shared_ptr<DescribeOrganizationUserCertsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOrganizationUserCertsResponse describeOrganizationUserCerts(shared_ptr<DescribeOrganizationUserCertsRequest> request);
  DescribeOrganizationUsersResponse describeOrganizationUsersWithOptions(shared_ptr<DescribeOrganizationUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOrganizationUsersResponse describeOrganizationUsers(shared_ptr<DescribeOrganizationUsersRequest> request);
  DescribeOrganizationsResponse describeOrganizationsWithOptions(shared_ptr<DescribeOrganizationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOrganizationsResponse describeOrganizations(shared_ptr<DescribeOrganizationsRequest> request);
  DescribeOrgnaizationChaincodesResponse describeOrgnaizationChaincodesWithOptions(shared_ptr<DescribeOrgnaizationChaincodesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOrgnaizationChaincodesResponse describeOrgnaizationChaincodes(shared_ptr<DescribeOrgnaizationChaincodesRequest> request);
  DescribeOssPropertiesResponse describeOssPropertiesWithOptions(shared_ptr<DescribeOssPropertiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeOssPropertiesResponse describeOssProperties(shared_ptr<DescribeOssPropertiesRequest> request);
  DescribePeerLogsResponse describePeerLogsWithOptions(shared_ptr<DescribePeerLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePeerLogsResponse describePeerLogs(shared_ptr<DescribePeerLogsRequest> request);
  DescribePublicAntChainContractProjectContentTreeResponse describePublicAntChainContractProjectContentTreeWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePublicAntChainContractProjectContentTreeResponse describePublicAntChainContractProjectContentTree();
  DescribePublicAntChainDownloadPathsResponse describePublicAntChainDownloadPathsWithOptions(shared_ptr<DescribePublicAntChainDownloadPathsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePublicAntChainDownloadPathsResponse describePublicAntChainDownloadPaths(shared_ptr<DescribePublicAntChainDownloadPathsRequest> request);
  DescribePublicCloudIDEEnvConfigsResponse describePublicCloudIDEEnvConfigsWithOptions(shared_ptr<DescribePublicCloudIDEEnvConfigsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePublicCloudIDEEnvConfigsResponse describePublicCloudIDEEnvConfigs(shared_ptr<DescribePublicCloudIDEEnvConfigsRequest> request);
  DescribeQRCodeAccessLogResponse describeQRCodeAccessLogWithOptions(shared_ptr<DescribeQRCodeAccessLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeQRCodeAccessLogResponse describeQRCodeAccessLog(shared_ptr<DescribeQRCodeAccessLogRequest> request);
  DescribeQRCodeAuthorityResponse describeQRCodeAuthorityWithOptions(shared_ptr<DescribeQRCodeAuthorityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeQRCodeAuthorityResponse describeQRCodeAuthority(shared_ptr<DescribeQRCodeAuthorityRequest> request);
  DescribeRegionsResponse describeRegionsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRegionsResponse describeRegions();
  DescribeResourceTypeResponse describeResourceTypeWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeResourceTypeResponse describeResourceType();
  DescribeResourceTypesResponse describeResourceTypesWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeResourceTypesResponse describeResourceTypes();
  DescribeRootDomainResponse describeRootDomainWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRootDomainResponse describeRootDomain();
  DescribeSchemaDetailResponse describeSchemaDetailWithOptions(shared_ptr<DescribeSchemaDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSchemaDetailResponse describeSchemaDetail(shared_ptr<DescribeSchemaDetailRequest> request);
  DescribeSmartContractJobStatusResponse describeSmartContractJobStatusWithOptions(shared_ptr<DescribeSmartContractJobStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSmartContractJobStatusResponse describeSmartContractJobStatus(shared_ptr<DescribeSmartContractJobStatusRequest> request);
  DescribeSmartContractJobsResponse describeSmartContractJobsWithOptions(shared_ptr<DescribeSmartContractJobsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSmartContractJobsResponse describeSmartContractJobs(shared_ptr<DescribeSmartContractJobsRequest> request);
  DescribeSmartContractJobsByNameResponse describeSmartContractJobsByNameWithOptions(shared_ptr<DescribeSmartContractJobsByNameRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSmartContractJobsByNameResponse describeSmartContractJobsByName(shared_ptr<DescribeSmartContractJobsByNameRequest> request);
  DescribeSmartContractResultResponse describeSmartContractResultWithOptions(shared_ptr<DescribeSmartContractResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSmartContractResultResponse describeSmartContractResult(shared_ptr<DescribeSmartContractResultRequest> request);
  DescribeSmartContractResultContentResponse describeSmartContractResultContentWithOptions(shared_ptr<DescribeSmartContractResultContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSmartContractResultContentResponse describeSmartContractResultContent(shared_ptr<DescribeSmartContractResultContentRequest> request);
  DescribeSubscribeCloudServiceIntegrationStateResponse describeSubscribeCloudServiceIntegrationStateWithOptions(shared_ptr<DescribeSubscribeCloudServiceIntegrationStateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSubscribeCloudServiceIntegrationStateResponse describeSubscribeCloudServiceIntegrationState(shared_ptr<DescribeSubscribeCloudServiceIntegrationStateRequest> request);
  DescribeTasksResponse describeTasksWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTasksResponse describeTasks();
  DescribeTemplatesResponse describeTemplatesWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTemplatesResponse describeTemplates();
  DescribeTransactionResponse describeTransactionWithOptions(shared_ptr<DescribeTransactionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTransactionResponse describeTransaction(shared_ptr<DescribeTransactionRequest> request);
  DescribeTransactionFor2CBrowserResponse describeTransactionFor2CBrowserWithOptions(shared_ptr<DescribeTransactionFor2CBrowserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTransactionFor2CBrowserResponse describeTransactionFor2CBrowser(shared_ptr<DescribeTransactionFor2CBrowserRequest> request);
  DescribeTransactionQRCodeResponse describeTransactionQRCodeWithOptions(shared_ptr<DescribeTransactionQRCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTransactionQRCodeResponse describeTransactionQRCode(shared_ptr<DescribeTransactionQRCodeRequest> request);
  DescribeTransactionReceiptFor2CBrowserResponse describeTransactionReceiptFor2CBrowserWithOptions(shared_ptr<DescribeTransactionReceiptFor2CBrowserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTransactionReceiptFor2CBrowserResponse describeTransactionReceiptFor2CBrowser(shared_ptr<DescribeTransactionReceiptFor2CBrowserRequest> request);
  DescribeTriggerResponse describeTriggerWithOptions(shared_ptr<DescribeTriggerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTriggerResponse describeTrigger(shared_ptr<DescribeTriggerRequest> request);
  DestroyConsortiumResponse destroyConsortiumWithOptions(shared_ptr<DestroyConsortiumRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DestroyConsortiumResponse destroyConsortium(shared_ptr<DestroyConsortiumRequest> request);
  DestroyEthereumResponse destroyEthereumWithOptions(shared_ptr<DestroyEthereumRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DestroyEthereumResponse destroyEthereum(shared_ptr<DestroyEthereumRequest> request);
  DestroyOrganizationResponse destroyOrganizationWithOptions(shared_ptr<DestroyOrganizationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DestroyOrganizationResponse destroyOrganization(shared_ptr<DestroyOrganizationRequest> request);
  DownloadAllResponse downloadAllWithOptions(shared_ptr<DownloadAllRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DownloadAllResponse downloadAll(shared_ptr<DownloadAllRequest> request);
  DownloadBizviewResponse downloadBizviewWithOptions(shared_ptr<DownloadBizviewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DownloadBizviewResponse downloadBizview(shared_ptr<DownloadBizviewRequest> request);
  DownloadFabricChannelSDKResponse downloadFabricChannelSDKWithOptions(shared_ptr<DownloadFabricChannelSDKRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DownloadFabricChannelSDKResponse downloadFabricChannelSDK(shared_ptr<DownloadFabricChannelSDKRequest> request);
  DownloadOrganizationSDKResponse downloadOrganizationSDKWithOptions(shared_ptr<DownloadOrganizationSDKRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DownloadOrganizationSDKResponse downloadOrganizationSDK(shared_ptr<DownloadOrganizationSDKRequest> request);
  DownloadSDK2Response downloadSDK2WithOptions(shared_ptr<DownloadSDK2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DownloadSDK2Response downloadSDK2(shared_ptr<DownloadSDK2Request> request);
  DownloadSdkResponse downloadSdkWithOptions(shared_ptr<DownloadSdkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DownloadSdkResponse downloadSdk(shared_ptr<DownloadSdkRequest> request);
  DownloadSignedDataResponse downloadSignedDataWithOptions(shared_ptr<DownloadSignedDataRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DownloadSignedDataResponse downloadSignedData(shared_ptr<DownloadSignedDataRequest> request);
  DuplicateAntChainContractProjectResponse duplicateAntChainContractProjectWithOptions(shared_ptr<DuplicateAntChainContractProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DuplicateAntChainContractProjectResponse duplicateAntChainContractProject(shared_ptr<DuplicateAntChainContractProjectRequest> request);
  FreezeAccountResponse freezeAccountWithOptions(shared_ptr<FreezeAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FreezeAccountResponse freezeAccount(shared_ptr<FreezeAccountRequest> request);
  FreezeAntChainAccountResponse freezeAntChainAccountWithOptions(shared_ptr<FreezeAntChainAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FreezeAntChainAccountResponse freezeAntChainAccount(shared_ptr<FreezeAntChainAccountRequest> request);
  GetAppliesResponse getAppliesWithOptions(shared_ptr<GetAppliesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAppliesResponse getApplies(shared_ptr<GetAppliesRequest> request);
  GetBcSchemaResponse getBcSchemaWithOptions(shared_ptr<GetBcSchemaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBcSchemaResponse getBcSchema(shared_ptr<GetBcSchemaRequest> request);
  GetBlockchainCreateTaskResponse getBlockchainCreateTaskWithOptions(shared_ptr<GetBlockchainCreateTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBlockchainCreateTaskResponse getBlockchainCreateTask(shared_ptr<GetBlockchainCreateTaskRequest> request);
  GetBlockchainInfoResponse getBlockchainInfoWithOptions(shared_ptr<GetBlockchainInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBlockchainInfoResponse getBlockchainInfo(shared_ptr<GetBlockchainInfoRequest> request);
  GetMyBlockchainsResponse getMyBlockchainsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMyBlockchainsResponse getMyBlockchains();
  GetMySuccessAppliesResponse getMySuccessAppliesWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetMySuccessAppliesResponse getMySuccessApplies();
  GetOssPropertiesResponse getOssPropertiesWithOptions(shared_ptr<GetOssPropertiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOssPropertiesResponse getOssProperties(shared_ptr<GetOssPropertiesRequest> request);
  GetTemplatesResponse getTemplatesWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTemplatesResponse getTemplates();
  InstallChaincodeResponse installChaincodeWithOptions(shared_ptr<InstallChaincodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstallChaincodeResponse installChaincode(shared_ptr<InstallChaincodeRequest> request);
  InstallFabricChaincodePackageResponse installFabricChaincodePackageWithOptions(shared_ptr<InstallFabricChaincodePackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstallFabricChaincodePackageResponse installFabricChaincodePackage(shared_ptr<InstallFabricChaincodePackageRequest> request);
  InstantiateChaincodeResponse instantiateChaincodeWithOptions(shared_ptr<InstantiateChaincodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstantiateChaincodeResponse instantiateChaincode(shared_ptr<InstantiateChaincodeRequest> request);
  InviteUserResponse inviteUserWithOptions(shared_ptr<InviteUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InviteUserResponse inviteUser(shared_ptr<InviteUserRequest> request);
  JoinChannelResponse joinChannelWithOptions(shared_ptr<JoinChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  JoinChannelResponse joinChannel(shared_ptr<JoinChannelRequest> request);
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  ModifyTriggerResponse modifyTriggerWithOptions(shared_ptr<ModifyTriggerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyTriggerResponse modifyTrigger(shared_ptr<ModifyTriggerRequest> request);
  OperateUserResponse operateUserWithOptions(shared_ptr<OperateUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OperateUserResponse operateUser(shared_ptr<OperateUserRequest> request);
  ProcessCloudIDEContractTransactionResponse processCloudIDEContractTransactionWithOptions(shared_ptr<ProcessCloudIDEContractTransactionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ProcessCloudIDEContractTransactionResponse processCloudIDEContractTransaction(shared_ptr<ProcessCloudIDEContractTransactionRequest> request);
  ProcessPublicCloudIDEContractTransactionResponse processPublicCloudIDEContractTransactionWithOptions(shared_ptr<ProcessPublicCloudIDEContractTransactionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ProcessPublicCloudIDEContractTransactionResponse processPublicCloudIDEContractTransaction(shared_ptr<ProcessPublicCloudIDEContractTransactionRequest> request);
  QueryBlockResponse queryBlockWithOptions(shared_ptr<QueryBlockRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryBlockResponse queryBlock(shared_ptr<QueryBlockRequest> request);
  QueryConsortiumDeletableResponse queryConsortiumDeletableWithOptions(shared_ptr<QueryConsortiumDeletableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryConsortiumDeletableResponse queryConsortiumDeletable(shared_ptr<QueryConsortiumDeletableRequest> request);
  QueryEthereumDeletableResponse queryEthereumDeletableWithOptions(shared_ptr<QueryEthereumDeletableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryEthereumDeletableResponse queryEthereumDeletable(shared_ptr<QueryEthereumDeletableRequest> request);
  QueryMetricResponse queryMetricWithOptions(shared_ptr<QueryMetricRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryMetricResponse queryMetric(shared_ptr<QueryMetricRequest> request);
  QueryOrganizationDeletableResponse queryOrganizationDeletableWithOptions(shared_ptr<QueryOrganizationDeletableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryOrganizationDeletableResponse queryOrganizationDeletable(shared_ptr<QueryOrganizationDeletableRequest> request);
  QueryTransactionResponse queryTransactionWithOptions(shared_ptr<QueryTransactionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryTransactionResponse queryTransaction(shared_ptr<QueryTransactionRequest> request);
  RejectUserResponse rejectUserWithOptions(shared_ptr<RejectUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RejectUserResponse rejectUser(shared_ptr<RejectUserRequest> request);
  RenameBlockchainResponse renameBlockchainWithOptions(shared_ptr<RenameBlockchainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RenameBlockchainResponse renameBlockchain(shared_ptr<RenameBlockchainRequest> request);
  ResetAntChainCertificateResponse resetAntChainCertificateWithOptions(shared_ptr<ResetAntChainCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetAntChainCertificateResponse resetAntChainCertificate(shared_ptr<ResetAntChainCertificateRequest> request);
  ResetAntChainUserCertificateResponse resetAntChainUserCertificateWithOptions(shared_ptr<ResetAntChainUserCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetAntChainUserCertificateResponse resetAntChainUserCertificate(shared_ptr<ResetAntChainUserCertificateRequest> request);
  ResetCertificateResponse resetCertificateWithOptions(shared_ptr<ResetCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetCertificateResponse resetCertificate(shared_ptr<ResetCertificateRequest> request);
  ResetOrganizationUserPasswordResponse resetOrganizationUserPasswordWithOptions(shared_ptr<ResetOrganizationUserPasswordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetOrganizationUserPasswordResponse resetOrganizationUserPassword(shared_ptr<ResetOrganizationUserPasswordRequest> request);
  ResetPublicAntChainCertificateResponse resetPublicAntChainCertificateWithOptions(shared_ptr<ResetPublicAntChainCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetPublicAntChainCertificateResponse resetPublicAntChainCertificate(shared_ptr<ResetPublicAntChainCertificateRequest> request);
  ResetUserResponse resetUserWithOptions(shared_ptr<ResetUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetUserResponse resetUser(shared_ptr<ResetUserRequest> request);
  SchemaDetailResponse schemaDetailWithOptions(shared_ptr<SchemaDetailRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SchemaDetailResponse schemaDetail(shared_ptr<SchemaDetailRequest> request);
  StartSmartContractJobResponse startSmartContractJobWithOptions(shared_ptr<StartSmartContractJobRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartSmartContractJobResponse startSmartContractJob(shared_ptr<StartSmartContractJobRequest> request);
  SubmitFabricChaincodeDefinitionResponse submitFabricChaincodeDefinitionWithOptions(shared_ptr<SubmitFabricChaincodeDefinitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitFabricChaincodeDefinitionResponse submitFabricChaincodeDefinition(shared_ptr<SubmitFabricChaincodeDefinitionRequest> request);
  SyncFabricChaincodeStatusResponse syncFabricChaincodeStatusWithOptions(shared_ptr<SyncFabricChaincodeStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SyncFabricChaincodeStatusResponse syncFabricChaincodeStatus(shared_ptr<SyncFabricChaincodeStatusRequest> request);
  SynchronizeChaincodeResponse synchronizeChaincodeWithOptions(shared_ptr<SynchronizeChaincodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SynchronizeChaincodeResponse synchronizeChaincode(shared_ptr<SynchronizeChaincodeRequest> request);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  UnfreezeAccountResponse unfreezeAccountWithOptions(shared_ptr<UnfreezeAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnfreezeAccountResponse unfreezeAccount(shared_ptr<UnfreezeAccountRequest> request);
  UnfreezeAntChainAccountResponse unfreezeAntChainAccountWithOptions(shared_ptr<UnfreezeAntChainAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnfreezeAntChainAccountResponse unfreezeAntChainAccount(shared_ptr<UnfreezeAntChainAccountRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);
  UpdateAntChainResponse updateAntChainWithOptions(shared_ptr<UpdateAntChainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAntChainResponse updateAntChain(shared_ptr<UpdateAntChainRequest> request);
  UpdateAntChainConsortiumResponse updateAntChainConsortiumWithOptions(shared_ptr<UpdateAntChainConsortiumRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAntChainConsortiumResponse updateAntChainConsortium(shared_ptr<UpdateAntChainConsortiumRequest> request);
  UpdateAntChainContractContentResponse updateAntChainContractContentWithOptions(shared_ptr<UpdateAntChainContractContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAntChainContractContentResponse updateAntChainContractContent(shared_ptr<UpdateAntChainContractContentRequest> request);
  UpdateAntChainContractProjectResponse updateAntChainContractProjectWithOptions(shared_ptr<UpdateAntChainContractProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAntChainContractProjectResponse updateAntChainContractProject(shared_ptr<UpdateAntChainContractProjectRequest> request);
  UpdateAntChainMemberResponse updateAntChainMemberWithOptions(shared_ptr<UpdateAntChainMemberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAntChainMemberResponse updateAntChainMember(shared_ptr<UpdateAntChainMemberRequest> request);
  UpdateAntChainQRCodeAuthorizationResponse updateAntChainQRCodeAuthorizationWithOptions(shared_ptr<UpdateAntChainQRCodeAuthorizationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAntChainQRCodeAuthorizationResponse updateAntChainQRCodeAuthorization(shared_ptr<UpdateAntChainQRCodeAuthorizationRequest> request);
  UpdateBlockchainSchemaResponse updateBlockchainSchemaWithOptions(shared_ptr<UpdateBlockchainSchemaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateBlockchainSchemaResponse updateBlockchainSchema(shared_ptr<UpdateBlockchainSchemaRequest> request);
  UpdateChannelConfigResponse updateChannelConfigWithOptions(shared_ptr<UpdateChannelConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateChannelConfigResponse updateChannelConfig(shared_ptr<UpdateChannelConfigRequest> request);
  UpdateEthereumResponse updateEthereumWithOptions(shared_ptr<UpdateEthereumRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEthereumResponse updateEthereum(shared_ptr<UpdateEthereumRequest> request);
  UpdateEthereumClientUserPasswordResponse updateEthereumClientUserPasswordWithOptions(shared_ptr<UpdateEthereumClientUserPasswordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEthereumClientUserPasswordResponse updateEthereumClientUserPassword(shared_ptr<UpdateEthereumClientUserPasswordRequest> request);
  UpdateEthereumNodeResponse updateEthereumNodeWithOptions(shared_ptr<UpdateEthereumNodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEthereumNodeResponse updateEthereumNode(shared_ptr<UpdateEthereumNodeRequest> request);
  UpdateEthereumNodeConfigurationResponse updateEthereumNodeConfigurationWithOptions(shared_ptr<UpdateEthereumNodeConfigurationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEthereumNodeConfigurationResponse updateEthereumNodeConfiguration(shared_ptr<UpdateEthereumNodeConfigurationRequest> request);
  UpdateGovernanceTaskResponse updateGovernanceTaskWithOptions(shared_ptr<UpdateGovernanceTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateGovernanceTaskResponse updateGovernanceTask(shared_ptr<UpdateGovernanceTaskRequest> request);
  UpdateMemberRoleResponse updateMemberRoleWithOptions(shared_ptr<UpdateMemberRoleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateMemberRoleResponse updateMemberRole(shared_ptr<UpdateMemberRoleRequest> request);
  UpdateQRCodeAuthorityResponse updateQRCodeAuthorityWithOptions(shared_ptr<UpdateQRCodeAuthorityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateQRCodeAuthorityResponse updateQRCodeAuthority(shared_ptr<UpdateQRCodeAuthorityRequest> request);
  UpdateSchemaResponse updateSchemaWithOptions(shared_ptr<UpdateSchemaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSchemaResponse updateSchema(shared_ptr<UpdateSchemaRequest> request);
  UpgradeChaincodeResponse upgradeChaincodeWithOptions(shared_ptr<UpgradeChaincodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpgradeChaincodeResponse upgradeChaincode(shared_ptr<UpgradeChaincodeRequest> request);
  UpgradeFabricChaincodeDefinitionResponse upgradeFabricChaincodeDefinitionWithOptions(shared_ptr<UpgradeFabricChaincodeDefinitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpgradeFabricChaincodeDefinitionResponse upgradeFabricChaincodeDefinition(shared_ptr<UpgradeFabricChaincodeDefinitionRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Baas20180731

#endif
