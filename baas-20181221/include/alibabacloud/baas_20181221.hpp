// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_BAAS20181221_H_
#define ALIBABACLOUD_BAAS20181221_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Baas20181221 {
class ChaincodePackage : public Darabonba::Model {
public:
  shared_ptr<string> chaincodePackageId{};
  shared_ptr<string> checksum{};
  shared_ptr<string> deleteTime{};
  shared_ptr<bool> deleted{};
  shared_ptr<string> installTime{};
  shared_ptr<string> label{};
  shared_ptr<string> md5sum{};
  shared_ptr<string> message{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> ossURL{};
  shared_ptr<string> providerBid{};
  shared_ptr<string> providerUid{};
  shared_ptr<string> state{};
  shared_ptr<long> type{};
  shared_ptr<string> typeName_{};
  shared_ptr<string> uploadTime{};

  ChaincodePackage() {}

  explicit ChaincodePackage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodePackageId) {
      res["ChaincodePackageId"] = boost::any(*chaincodePackageId);
    }
    if (checksum) {
      res["Checksum"] = boost::any(*checksum);
    }
    if (deleteTime) {
      res["DeleteTime"] = boost::any(*deleteTime);
    }
    if (deleted) {
      res["Deleted"] = boost::any(*deleted);
    }
    if (installTime) {
      res["InstallTime"] = boost::any(*installTime);
    }
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (md5sum) {
      res["Md5sum"] = boost::any(*md5sum);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (ossURL) {
      res["OssURL"] = boost::any(*ossURL);
    }
    if (providerBid) {
      res["ProviderBid"] = boost::any(*providerBid);
    }
    if (providerUid) {
      res["ProviderUid"] = boost::any(*providerUid);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (typeName_) {
      res["TypeName"] = boost::any(*typeName_);
    }
    if (uploadTime) {
      res["UploadTime"] = boost::any(*uploadTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodePackageId") != m.end() && !m["ChaincodePackageId"].empty()) {
      chaincodePackageId = make_shared<string>(boost::any_cast<string>(m["ChaincodePackageId"]));
    }
    if (m.find("Checksum") != m.end() && !m["Checksum"].empty()) {
      checksum = make_shared<string>(boost::any_cast<string>(m["Checksum"]));
    }
    if (m.find("DeleteTime") != m.end() && !m["DeleteTime"].empty()) {
      deleteTime = make_shared<string>(boost::any_cast<string>(m["DeleteTime"]));
    }
    if (m.find("Deleted") != m.end() && !m["Deleted"].empty()) {
      deleted = make_shared<bool>(boost::any_cast<bool>(m["Deleted"]));
    }
    if (m.find("InstallTime") != m.end() && !m["InstallTime"].empty()) {
      installTime = make_shared<string>(boost::any_cast<string>(m["InstallTime"]));
    }
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Md5sum") != m.end() && !m["Md5sum"].empty()) {
      md5sum = make_shared<string>(boost::any_cast<string>(m["Md5sum"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("OssURL") != m.end() && !m["OssURL"].empty()) {
      ossURL = make_shared<string>(boost::any_cast<string>(m["OssURL"]));
    }
    if (m.find("ProviderBid") != m.end() && !m["ProviderBid"].empty()) {
      providerBid = make_shared<string>(boost::any_cast<string>(m["ProviderBid"]));
    }
    if (m.find("ProviderUid") != m.end() && !m["ProviderUid"].empty()) {
      providerUid = make_shared<string>(boost::any_cast<string>(m["ProviderUid"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("TypeName") != m.end() && !m["TypeName"].empty()) {
      typeName_ = make_shared<string>(boost::any_cast<string>(m["TypeName"]));
    }
    if (m.find("UploadTime") != m.end() && !m["UploadTime"].empty()) {
      uploadTime = make_shared<string>(boost::any_cast<string>(m["UploadTime"]));
    }
  }


  virtual ~ChaincodePackage() = default;
};
class ChaincodeVO : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeDefinitionId{};
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> chaincodePackageId{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deployTime{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<bool> initRequired{};
  shared_ptr<string> input{};
  shared_ptr<bool> install{};
  shared_ptr<bool> management{};
  shared_ptr<string> message{};
  shared_ptr<string> name{};
  shared_ptr<string> path{};
  shared_ptr<string> providerId{};
  shared_ptr<string> providerName{};
  shared_ptr<string> state{};
  shared_ptr<long> type{};
  shared_ptr<string> version{};

  ChaincodeVO() {}

  explicit ChaincodeVO(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeDefinitionId) {
      res["ChaincodeDefinitionId"] = boost::any(*chaincodeDefinitionId);
    }
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (chaincodePackageId) {
      res["ChaincodePackageId"] = boost::any(*chaincodePackageId);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deployTime) {
      res["DeployTime"] = boost::any(*deployTime);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (initRequired) {
      res["InitRequired"] = boost::any(*initRequired);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (install) {
      res["Install"] = boost::any(*install);
    }
    if (management) {
      res["Management"] = boost::any(*management);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (providerId) {
      res["ProviderId"] = boost::any(*providerId);
    }
    if (providerName) {
      res["ProviderName"] = boost::any(*providerName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeDefinitionId") != m.end() && !m["ChaincodeDefinitionId"].empty()) {
      chaincodeDefinitionId = make_shared<string>(boost::any_cast<string>(m["ChaincodeDefinitionId"]));
    }
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("ChaincodePackageId") != m.end() && !m["ChaincodePackageId"].empty()) {
      chaincodePackageId = make_shared<string>(boost::any_cast<string>(m["ChaincodePackageId"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeployTime") != m.end() && !m["DeployTime"].empty()) {
      deployTime = make_shared<string>(boost::any_cast<string>(m["DeployTime"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("InitRequired") != m.end() && !m["InitRequired"].empty()) {
      initRequired = make_shared<bool>(boost::any_cast<bool>(m["InitRequired"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Install") != m.end() && !m["Install"].empty()) {
      install = make_shared<bool>(boost::any_cast<bool>(m["Install"]));
    }
    if (m.find("Management") != m.end() && !m["Management"].empty()) {
      management = make_shared<bool>(boost::any_cast<bool>(m["Management"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ProviderId") != m.end() && !m["ProviderId"].empty()) {
      providerId = make_shared<string>(boost::any_cast<string>(m["ProviderId"]));
    }
    if (m.find("ProviderName") != m.end() && !m["ProviderName"].empty()) {
      providerName = make_shared<string>(boost::any_cast<string>(m["ProviderName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~ChaincodeVO() = default;
};
class AcceptFabricInvitationRequest : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<bool> isAccepted{};

  AcceptFabricInvitationRequest() {}

  explicit AcceptFabricInvitationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (isAccepted) {
      res["IsAccepted"] = boost::any(*isAccepted);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("IsAccepted") != m.end() && !m["IsAccepted"].empty()) {
      isAccepted = make_shared<bool>(boost::any_cast<bool>(m["IsAccepted"]));
    }
  }


  virtual ~AcceptFabricInvitationRequest() = default;
};
class AcceptFabricInvitationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  AcceptFabricInvitationResponseBody() {}

  explicit AcceptFabricInvitationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~AcceptFabricInvitationResponseBody() = default;
};
class AcceptFabricInvitationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AcceptFabricInvitationResponseBody> body{};

  AcceptFabricInvitationResponse() {}

  explicit AcceptFabricInvitationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AcceptFabricInvitationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AcceptFabricInvitationResponseBody>(model1);
      }
    }
  }


  virtual ~AcceptFabricInvitationResponse() = default;
};
class ApplyAntChainCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> uploadReq{};

  ApplyAntChainCertificateRequest() {}

  explicit ApplyAntChainCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (uploadReq) {
      res["UploadReq"] = boost::any(*uploadReq);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("UploadReq") != m.end() && !m["UploadReq"].empty()) {
      uploadReq = make_shared<string>(boost::any_cast<string>(m["UploadReq"]));
    }
  }


  virtual ~ApplyAntChainCertificateRequest() = default;
};
class ApplyAntChainCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  ApplyAntChainCertificateResponseBody() {}

  explicit ApplyAntChainCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~ApplyAntChainCertificateResponseBody() = default;
};
class ApplyAntChainCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyAntChainCertificateResponseBody> body{};

  ApplyAntChainCertificateResponse() {}

  explicit ApplyAntChainCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyAntChainCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyAntChainCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyAntChainCertificateResponse() = default;
};
class ApplyAntChainCertificateWithKeyAutoCreationRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> commonName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> countryName{};
  shared_ptr<string> localityName{};
  shared_ptr<string> organizationName{};
  shared_ptr<string> organizationUnitName{};
  shared_ptr<string> password{};
  shared_ptr<string> stateOrProvinceName{};

  ApplyAntChainCertificateWithKeyAutoCreationRequest() {}

  explicit ApplyAntChainCertificateWithKeyAutoCreationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (commonName) {
      res["CommonName"] = boost::any(*commonName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (countryName) {
      res["CountryName"] = boost::any(*countryName);
    }
    if (localityName) {
      res["LocalityName"] = boost::any(*localityName);
    }
    if (organizationName) {
      res["OrganizationName"] = boost::any(*organizationName);
    }
    if (organizationUnitName) {
      res["OrganizationUnitName"] = boost::any(*organizationUnitName);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (stateOrProvinceName) {
      res["StateOrProvinceName"] = boost::any(*stateOrProvinceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("CommonName") != m.end() && !m["CommonName"].empty()) {
      commonName = make_shared<string>(boost::any_cast<string>(m["CommonName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CountryName") != m.end() && !m["CountryName"].empty()) {
      countryName = make_shared<string>(boost::any_cast<string>(m["CountryName"]));
    }
    if (m.find("LocalityName") != m.end() && !m["LocalityName"].empty()) {
      localityName = make_shared<string>(boost::any_cast<string>(m["LocalityName"]));
    }
    if (m.find("OrganizationName") != m.end() && !m["OrganizationName"].empty()) {
      organizationName = make_shared<string>(boost::any_cast<string>(m["OrganizationName"]));
    }
    if (m.find("OrganizationUnitName") != m.end() && !m["OrganizationUnitName"].empty()) {
      organizationUnitName = make_shared<string>(boost::any_cast<string>(m["OrganizationUnitName"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("StateOrProvinceName") != m.end() && !m["StateOrProvinceName"].empty()) {
      stateOrProvinceName = make_shared<string>(boost::any_cast<string>(m["StateOrProvinceName"]));
    }
  }


  virtual ~ApplyAntChainCertificateWithKeyAutoCreationRequest() = default;
};
class ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResultDownloadPath : public Darabonba::Model {
public:
  shared_ptr<string> caCrtUrl{};
  shared_ptr<string> clientCrtUrl{};
  shared_ptr<string> sdkUrl{};
  shared_ptr<string> trustCaUrl{};

  ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResultDownloadPath() {}

  explicit ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResultDownloadPath(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caCrtUrl) {
      res["CaCrtUrl"] = boost::any(*caCrtUrl);
    }
    if (clientCrtUrl) {
      res["ClientCrtUrl"] = boost::any(*clientCrtUrl);
    }
    if (sdkUrl) {
      res["SdkUrl"] = boost::any(*sdkUrl);
    }
    if (trustCaUrl) {
      res["TrustCaUrl"] = boost::any(*trustCaUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaCrtUrl") != m.end() && !m["CaCrtUrl"].empty()) {
      caCrtUrl = make_shared<string>(boost::any_cast<string>(m["CaCrtUrl"]));
    }
    if (m.find("ClientCrtUrl") != m.end() && !m["ClientCrtUrl"].empty()) {
      clientCrtUrl = make_shared<string>(boost::any_cast<string>(m["ClientCrtUrl"]));
    }
    if (m.find("SdkUrl") != m.end() && !m["SdkUrl"].empty()) {
      sdkUrl = make_shared<string>(boost::any_cast<string>(m["SdkUrl"]));
    }
    if (m.find("TrustCaUrl") != m.end() && !m["TrustCaUrl"].empty()) {
      trustCaUrl = make_shared<string>(boost::any_cast<string>(m["TrustCaUrl"]));
    }
  }


  virtual ~ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResultDownloadPath() = default;
};
class ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResultDownloadPath> downloadPath{};
  shared_ptr<string> privateKey{};

  ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResult() {}

  explicit ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadPath) {
      res["DownloadPath"] = downloadPath ? boost::any(downloadPath->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (privateKey) {
      res["PrivateKey"] = boost::any(*privateKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DownloadPath") != m.end() && !m["DownloadPath"].empty()) {
      if (typeid(map<string, boost::any>) == m["DownloadPath"].type()) {
        ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResultDownloadPath model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DownloadPath"]));
        downloadPath = make_shared<ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResultDownloadPath>(model1);
      }
    }
    if (m.find("PrivateKey") != m.end() && !m["PrivateKey"].empty()) {
      privateKey = make_shared<string>(boost::any_cast<string>(m["PrivateKey"]));
    }
  }


  virtual ~ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResult() = default;
};
class ApplyAntChainCertificateWithKeyAutoCreationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResult> result{};

  ApplyAntChainCertificateWithKeyAutoCreationResponseBody() {}

  explicit ApplyAntChainCertificateWithKeyAutoCreationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ApplyAntChainCertificateWithKeyAutoCreationResponseBodyResult>(model1);
      }
    }
  }


  virtual ~ApplyAntChainCertificateWithKeyAutoCreationResponseBody() = default;
};
class ApplyAntChainCertificateWithKeyAutoCreationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApplyAntChainCertificateWithKeyAutoCreationResponseBody> body{};

  ApplyAntChainCertificateWithKeyAutoCreationResponse() {}

  explicit ApplyAntChainCertificateWithKeyAutoCreationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApplyAntChainCertificateWithKeyAutoCreationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApplyAntChainCertificateWithKeyAutoCreationResponseBody>(model1);
      }
    }
  }


  virtual ~ApplyAntChainCertificateWithKeyAutoCreationResponse() = default;
};
class ApproveFabricChaincodeDefinitionRequest : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> chaincodePackageId{};
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};

  ApproveFabricChaincodeDefinitionRequest() {}

  explicit ApproveFabricChaincodeDefinitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (chaincodePackageId) {
      res["ChaincodePackageId"] = boost::any(*chaincodePackageId);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("ChaincodePackageId") != m.end() && !m["ChaincodePackageId"].empty()) {
      chaincodePackageId = make_shared<string>(boost::any_cast<string>(m["ChaincodePackageId"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~ApproveFabricChaincodeDefinitionRequest() = default;
};
class ApproveFabricChaincodeDefinitionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ChaincodeVO> result{};
  shared_ptr<bool> success{};

  ApproveFabricChaincodeDefinitionResponseBody() {}

  explicit ApproveFabricChaincodeDefinitionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ChaincodeVO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ChaincodeVO>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ApproveFabricChaincodeDefinitionResponseBody() = default;
};
class ApproveFabricChaincodeDefinitionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ApproveFabricChaincodeDefinitionResponseBody> body{};

  ApproveFabricChaincodeDefinitionResponse() {}

  explicit ApproveFabricChaincodeDefinitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ApproveFabricChaincodeDefinitionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ApproveFabricChaincodeDefinitionResponseBody>(model1);
      }
    }
  }


  virtual ~ApproveFabricChaincodeDefinitionResponse() = default;
};
class BatchAddAntChainMiniAppQRCodeAuthorizedUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<map<string, boost::any>> phoneList{};

  BatchAddAntChainMiniAppQRCodeAuthorizedUsersRequest() {}

  explicit BatchAddAntChainMiniAppQRCodeAuthorizedUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (phoneList) {
      res["PhoneList"] = boost::any(*phoneList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("PhoneList") != m.end() && !m["PhoneList"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["PhoneList"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      phoneList = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~BatchAddAntChainMiniAppQRCodeAuthorizedUsersRequest() = default;
};
class BatchAddAntChainMiniAppQRCodeAuthorizedUsersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> phoneListShrink{};

  BatchAddAntChainMiniAppQRCodeAuthorizedUsersShrinkRequest() {}

  explicit BatchAddAntChainMiniAppQRCodeAuthorizedUsersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (phoneListShrink) {
      res["PhoneList"] = boost::any(*phoneListShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("PhoneList") != m.end() && !m["PhoneList"].empty()) {
      phoneListShrink = make_shared<string>(boost::any_cast<string>(m["PhoneList"]));
    }
  }


  virtual ~BatchAddAntChainMiniAppQRCodeAuthorizedUsersShrinkRequest() = default;
};
class BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponseBody() {}

  explicit BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponseBody() = default;
};
class BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponseBody> body{};

  BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponse() {}

  explicit BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponseBody>(model1);
      }
    }
  }


  virtual ~BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponse() = default;
};
class CheckFabricConsortiumDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domainCode{};

  CheckFabricConsortiumDomainRequest() {}

  explicit CheckFabricConsortiumDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domainCode) {
      res["DomainCode"] = boost::any(*domainCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DomainCode") != m.end() && !m["DomainCode"].empty()) {
      domainCode = make_shared<string>(boost::any_cast<string>(m["DomainCode"]));
    }
  }


  virtual ~CheckFabricConsortiumDomainRequest() = default;
};
class CheckFabricConsortiumDomainResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> prompt{};
  shared_ptr<bool> valid{};

  CheckFabricConsortiumDomainResponseBodyResult() {}

  explicit CheckFabricConsortiumDomainResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (valid) {
      res["Valid"] = boost::any(*valid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("Valid") != m.end() && !m["Valid"].empty()) {
      valid = make_shared<bool>(boost::any_cast<bool>(m["Valid"]));
    }
  }


  virtual ~CheckFabricConsortiumDomainResponseBodyResult() = default;
};
class CheckFabricConsortiumDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<CheckFabricConsortiumDomainResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CheckFabricConsortiumDomainResponseBody() {}

  explicit CheckFabricConsortiumDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CheckFabricConsortiumDomainResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CheckFabricConsortiumDomainResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CheckFabricConsortiumDomainResponseBody() = default;
};
class CheckFabricConsortiumDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckFabricConsortiumDomainResponseBody> body{};

  CheckFabricConsortiumDomainResponse() {}

  explicit CheckFabricConsortiumDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckFabricConsortiumDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckFabricConsortiumDomainResponseBody>(model1);
      }
    }
  }


  virtual ~CheckFabricConsortiumDomainResponse() = default;
};
class CheckFabricOrganizationDomainRequest : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> domainCode{};

  CheckFabricOrganizationDomainRequest() {}

  explicit CheckFabricOrganizationDomainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (domainCode) {
      res["DomainCode"] = boost::any(*domainCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("DomainCode") != m.end() && !m["DomainCode"].empty()) {
      domainCode = make_shared<string>(boost::any_cast<string>(m["DomainCode"]));
    }
  }


  virtual ~CheckFabricOrganizationDomainRequest() = default;
};
class CheckFabricOrganizationDomainResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> domain{};
  shared_ptr<string> prompt{};
  shared_ptr<bool> valid{};

  CheckFabricOrganizationDomainResponseBodyResult() {}

  explicit CheckFabricOrganizationDomainResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (prompt) {
      res["Prompt"] = boost::any(*prompt);
    }
    if (valid) {
      res["Valid"] = boost::any(*valid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Prompt") != m.end() && !m["Prompt"].empty()) {
      prompt = make_shared<string>(boost::any_cast<string>(m["Prompt"]));
    }
    if (m.find("Valid") != m.end() && !m["Valid"].empty()) {
      valid = make_shared<bool>(boost::any_cast<bool>(m["Valid"]));
    }
  }


  virtual ~CheckFabricOrganizationDomainResponseBodyResult() = default;
};
class CheckFabricOrganizationDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<CheckFabricOrganizationDomainResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CheckFabricOrganizationDomainResponseBody() {}

  explicit CheckFabricOrganizationDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CheckFabricOrganizationDomainResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CheckFabricOrganizationDomainResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CheckFabricOrganizationDomainResponseBody() = default;
};
class CheckFabricOrganizationDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckFabricOrganizationDomainResponseBody> body{};

  CheckFabricOrganizationDomainResponse() {}

  explicit CheckFabricOrganizationDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckFabricOrganizationDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckFabricOrganizationDomainResponseBody>(model1);
      }
    }
  }


  virtual ~CheckFabricOrganizationDomainResponse() = default;
};
class ConfirmFabricConsortiumMemberRequestOrganization : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};

  ConfirmFabricConsortiumMemberRequestOrganization() {}

  explicit ConfirmFabricConsortiumMemberRequestOrganization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~ConfirmFabricConsortiumMemberRequestOrganization() = default;
};
class ConfirmFabricConsortiumMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<vector<ConfirmFabricConsortiumMemberRequestOrganization>> organization{};

  ConfirmFabricConsortiumMemberRequest() {}

  explicit ConfirmFabricConsortiumMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (organization) {
      vector<boost::any> temp1;
      for(auto item1:*organization){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Organization"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Organization") != m.end() && !m["Organization"].empty()) {
      if (typeid(vector<boost::any>) == m["Organization"].type()) {
        vector<ConfirmFabricConsortiumMemberRequestOrganization> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Organization"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ConfirmFabricConsortiumMemberRequestOrganization model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        organization = make_shared<vector<ConfirmFabricConsortiumMemberRequestOrganization>>(expect1);
      }
    }
  }


  virtual ~ConfirmFabricConsortiumMemberRequest() = default;
};
class ConfirmFabricConsortiumMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};
  shared_ptr<bool> success{};

  ConfirmFabricConsortiumMemberResponseBody() {}

  explicit ConfirmFabricConsortiumMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ConfirmFabricConsortiumMemberResponseBody() = default;
};
class ConfirmFabricConsortiumMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfirmFabricConsortiumMemberResponseBody> body{};

  ConfirmFabricConsortiumMemberResponse() {}

  explicit ConfirmFabricConsortiumMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfirmFabricConsortiumMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfirmFabricConsortiumMemberResponseBody>(model1);
      }
    }
  }


  virtual ~ConfirmFabricConsortiumMemberResponse() = default;
};
class CopyAntChainContractProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectDescription{};
  shared_ptr<string> projectId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> projectVersion{};

  CopyAntChainContractProjectRequest() {}

  explicit CopyAntChainContractProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectDescription) {
      res["ProjectDescription"] = boost::any(*projectDescription);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (projectVersion) {
      res["ProjectVersion"] = boost::any(*projectVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectDescription") != m.end() && !m["ProjectDescription"].empty()) {
      projectDescription = make_shared<string>(boost::any_cast<string>(m["ProjectDescription"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProjectVersion") != m.end() && !m["ProjectVersion"].empty()) {
      projectVersion = make_shared<string>(boost::any_cast<string>(m["ProjectVersion"]));
    }
  }


  virtual ~CopyAntChainContractProjectRequest() = default;
};
class CopyAntChainContractProjectResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> projectDescription{};
  shared_ptr<string> projectId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> projectVersion{};
  shared_ptr<long> updateTime{};

  CopyAntChainContractProjectResponseBodyResult() {}

  explicit CopyAntChainContractProjectResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (projectDescription) {
      res["ProjectDescription"] = boost::any(*projectDescription);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (projectVersion) {
      res["ProjectVersion"] = boost::any(*projectVersion);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ProjectDescription") != m.end() && !m["ProjectDescription"].empty()) {
      projectDescription = make_shared<string>(boost::any_cast<string>(m["ProjectDescription"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProjectVersion") != m.end() && !m["ProjectVersion"].empty()) {
      projectVersion = make_shared<string>(boost::any_cast<string>(m["ProjectVersion"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~CopyAntChainContractProjectResponseBodyResult() = default;
};
class CopyAntChainContractProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CopyAntChainContractProjectResponseBodyResult> result{};

  CopyAntChainContractProjectResponseBody() {}

  explicit CopyAntChainContractProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CopyAntChainContractProjectResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CopyAntChainContractProjectResponseBodyResult>(model1);
      }
    }
  }


  virtual ~CopyAntChainContractProjectResponseBody() = default;
};
class CopyAntChainContractProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CopyAntChainContractProjectResponseBody> body{};

  CopyAntChainContractProjectResponse() {}

  explicit CopyAntChainContractProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CopyAntChainContractProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CopyAntChainContractProjectResponseBody>(model1);
      }
    }
  }


  virtual ~CopyAntChainContractProjectResponse() = default;
};
class CreateAntChainAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> accountPubKey{};
  shared_ptr<string> accountRecoverPubKey{};
  shared_ptr<string> antChainId{};

  CreateAntChainAccountRequest() {}

  explicit CreateAntChainAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (accountPubKey) {
      res["AccountPubKey"] = boost::any(*accountPubKey);
    }
    if (accountRecoverPubKey) {
      res["AccountRecoverPubKey"] = boost::any(*accountRecoverPubKey);
    }
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("AccountPubKey") != m.end() && !m["AccountPubKey"].empty()) {
      accountPubKey = make_shared<string>(boost::any_cast<string>(m["AccountPubKey"]));
    }
    if (m.find("AccountRecoverPubKey") != m.end() && !m["AccountRecoverPubKey"].empty()) {
      accountRecoverPubKey = make_shared<string>(boost::any_cast<string>(m["AccountRecoverPubKey"]));
    }
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
  }


  virtual ~CreateAntChainAccountRequest() = default;
};
class CreateAntChainAccountResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> antChainId{};

  CreateAntChainAccountResponseBodyResult() {}

  explicit CreateAntChainAccountResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
  }


  virtual ~CreateAntChainAccountResponseBodyResult() = default;
};
class CreateAntChainAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateAntChainAccountResponseBodyResult> result{};

  CreateAntChainAccountResponseBody() {}

  explicit CreateAntChainAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateAntChainAccountResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateAntChainAccountResponseBodyResult>(model1);
      }
    }
  }


  virtual ~CreateAntChainAccountResponseBody() = default;
};
class CreateAntChainAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAntChainAccountResponseBody> body{};

  CreateAntChainAccountResponse() {}

  explicit CreateAntChainAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAntChainAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAntChainAccountResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAntChainAccountResponse() = default;
};
class CreateAntChainAccountWithKeyPairAutoCreationRequest : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> antChainId{};
  shared_ptr<string> password{};
  shared_ptr<string> recoverPassword{};

  CreateAntChainAccountWithKeyPairAutoCreationRequest() {}

  explicit CreateAntChainAccountWithKeyPairAutoCreationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (recoverPassword) {
      res["RecoverPassword"] = boost::any(*recoverPassword);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("RecoverPassword") != m.end() && !m["RecoverPassword"].empty()) {
      recoverPassword = make_shared<string>(boost::any_cast<string>(m["RecoverPassword"]));
    }
  }


  virtual ~CreateAntChainAccountWithKeyPairAutoCreationRequest() = default;
};
class CreateAntChainAccountWithKeyPairAutoCreationResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> accountPrivateKey{};
  shared_ptr<string> accountPublicKey{};
  shared_ptr<string> accountRecoverPrivateKey{};
  shared_ptr<string> accountRecoverPublicKey{};
  shared_ptr<string> antChainId{};

  CreateAntChainAccountWithKeyPairAutoCreationResponseBodyResult() {}

  explicit CreateAntChainAccountWithKeyPairAutoCreationResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (accountPrivateKey) {
      res["AccountPrivateKey"] = boost::any(*accountPrivateKey);
    }
    if (accountPublicKey) {
      res["AccountPublicKey"] = boost::any(*accountPublicKey);
    }
    if (accountRecoverPrivateKey) {
      res["AccountRecoverPrivateKey"] = boost::any(*accountRecoverPrivateKey);
    }
    if (accountRecoverPublicKey) {
      res["AccountRecoverPublicKey"] = boost::any(*accountRecoverPublicKey);
    }
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("AccountPrivateKey") != m.end() && !m["AccountPrivateKey"].empty()) {
      accountPrivateKey = make_shared<string>(boost::any_cast<string>(m["AccountPrivateKey"]));
    }
    if (m.find("AccountPublicKey") != m.end() && !m["AccountPublicKey"].empty()) {
      accountPublicKey = make_shared<string>(boost::any_cast<string>(m["AccountPublicKey"]));
    }
    if (m.find("AccountRecoverPrivateKey") != m.end() && !m["AccountRecoverPrivateKey"].empty()) {
      accountRecoverPrivateKey = make_shared<string>(boost::any_cast<string>(m["AccountRecoverPrivateKey"]));
    }
    if (m.find("AccountRecoverPublicKey") != m.end() && !m["AccountRecoverPublicKey"].empty()) {
      accountRecoverPublicKey = make_shared<string>(boost::any_cast<string>(m["AccountRecoverPublicKey"]));
    }
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
  }


  virtual ~CreateAntChainAccountWithKeyPairAutoCreationResponseBodyResult() = default;
};
class CreateAntChainAccountWithKeyPairAutoCreationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateAntChainAccountWithKeyPairAutoCreationResponseBodyResult> result{};

  CreateAntChainAccountWithKeyPairAutoCreationResponseBody() {}

  explicit CreateAntChainAccountWithKeyPairAutoCreationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateAntChainAccountWithKeyPairAutoCreationResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateAntChainAccountWithKeyPairAutoCreationResponseBodyResult>(model1);
      }
    }
  }


  virtual ~CreateAntChainAccountWithKeyPairAutoCreationResponseBody() = default;
};
class CreateAntChainAccountWithKeyPairAutoCreationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAntChainAccountWithKeyPairAutoCreationResponseBody> body{};

  CreateAntChainAccountWithKeyPairAutoCreationResponse() {}

  explicit CreateAntChainAccountWithKeyPairAutoCreationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAntChainAccountWithKeyPairAutoCreationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAntChainAccountWithKeyPairAutoCreationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAntChainAccountWithKeyPairAutoCreationResponse() = default;
};
class CreateAntChainConsortiumRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumDescription{};
  shared_ptr<string> consortiumName{};

  CreateAntChainConsortiumRequest() {}

  explicit CreateAntChainConsortiumRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumDescription) {
      res["ConsortiumDescription"] = boost::any(*consortiumDescription);
    }
    if (consortiumName) {
      res["ConsortiumName"] = boost::any(*consortiumName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumDescription") != m.end() && !m["ConsortiumDescription"].empty()) {
      consortiumDescription = make_shared<string>(boost::any_cast<string>(m["ConsortiumDescription"]));
    }
    if (m.find("ConsortiumName") != m.end() && !m["ConsortiumName"].empty()) {
      consortiumName = make_shared<string>(boost::any_cast<string>(m["ConsortiumName"]));
    }
  }


  virtual ~CreateAntChainConsortiumRequest() = default;
};
class CreateAntChainConsortiumResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};

  CreateAntChainConsortiumResponseBodyResult() {}

  explicit CreateAntChainConsortiumResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
  }


  virtual ~CreateAntChainConsortiumResponseBodyResult() = default;
};
class CreateAntChainConsortiumResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateAntChainConsortiumResponseBodyResult> result{};

  CreateAntChainConsortiumResponseBody() {}

  explicit CreateAntChainConsortiumResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateAntChainConsortiumResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateAntChainConsortiumResponseBodyResult>(model1);
      }
    }
  }


  virtual ~CreateAntChainConsortiumResponseBody() = default;
};
class CreateAntChainConsortiumResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAntChainConsortiumResponseBody> body{};

  CreateAntChainConsortiumResponse() {}

  explicit CreateAntChainConsortiumResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAntChainConsortiumResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAntChainConsortiumResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAntChainConsortiumResponse() = default;
};
class CreateAntChainContractContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentName{};
  shared_ptr<bool> isDirectory{};
  shared_ptr<string> parentContentId{};
  shared_ptr<string> projectId{};

  CreateAntChainContractContentRequest() {}

  explicit CreateAntChainContractContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentName) {
      res["ContentName"] = boost::any(*contentName);
    }
    if (isDirectory) {
      res["IsDirectory"] = boost::any(*isDirectory);
    }
    if (parentContentId) {
      res["ParentContentId"] = boost::any(*parentContentId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentName") != m.end() && !m["ContentName"].empty()) {
      contentName = make_shared<string>(boost::any_cast<string>(m["ContentName"]));
    }
    if (m.find("IsDirectory") != m.end() && !m["IsDirectory"].empty()) {
      isDirectory = make_shared<bool>(boost::any_cast<bool>(m["IsDirectory"]));
    }
    if (m.find("ParentContentId") != m.end() && !m["ParentContentId"].empty()) {
      parentContentId = make_shared<string>(boost::any_cast<string>(m["ParentContentId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~CreateAntChainContractContentRequest() = default;
};
class CreateAntChainContractContentResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentId{};
  shared_ptr<string> contentName{};
  shared_ptr<string> createTime{};
  shared_ptr<bool> isDirectory{};
  shared_ptr<string> parentContentId{};
  shared_ptr<string> projectId{};
  shared_ptr<string> updateTime{};

  CreateAntChainContractContentResponseBodyResult() {}

  explicit CreateAntChainContractContentResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentId) {
      res["ContentId"] = boost::any(*contentId);
    }
    if (contentName) {
      res["ContentName"] = boost::any(*contentName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (isDirectory) {
      res["IsDirectory"] = boost::any(*isDirectory);
    }
    if (parentContentId) {
      res["ParentContentId"] = boost::any(*parentContentId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentId") != m.end() && !m["ContentId"].empty()) {
      contentId = make_shared<string>(boost::any_cast<string>(m["ContentId"]));
    }
    if (m.find("ContentName") != m.end() && !m["ContentName"].empty()) {
      contentName = make_shared<string>(boost::any_cast<string>(m["ContentName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("IsDirectory") != m.end() && !m["IsDirectory"].empty()) {
      isDirectory = make_shared<bool>(boost::any_cast<bool>(m["IsDirectory"]));
    }
    if (m.find("ParentContentId") != m.end() && !m["ParentContentId"].empty()) {
      parentContentId = make_shared<string>(boost::any_cast<string>(m["ParentContentId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~CreateAntChainContractContentResponseBodyResult() = default;
};
class CreateAntChainContractContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateAntChainContractContentResponseBodyResult> result{};

  CreateAntChainContractContentResponseBody() {}

  explicit CreateAntChainContractContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateAntChainContractContentResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateAntChainContractContentResponseBodyResult>(model1);
      }
    }
  }


  virtual ~CreateAntChainContractContentResponseBody() = default;
};
class CreateAntChainContractContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAntChainContractContentResponseBody> body{};

  CreateAntChainContractContentResponse() {}

  explicit CreateAntChainContractContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAntChainContractContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAntChainContractContentResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAntChainContractContentResponse() = default;
};
class CreateAntChainContractProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> projectDescription{};
  shared_ptr<string> projectName{};
  shared_ptr<string> projectVersion{};

  CreateAntChainContractProjectRequest() {}

  explicit CreateAntChainContractProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (projectDescription) {
      res["ProjectDescription"] = boost::any(*projectDescription);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (projectVersion) {
      res["ProjectVersion"] = boost::any(*projectVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("ProjectDescription") != m.end() && !m["ProjectDescription"].empty()) {
      projectDescription = make_shared<string>(boost::any_cast<string>(m["ProjectDescription"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProjectVersion") != m.end() && !m["ProjectVersion"].empty()) {
      projectVersion = make_shared<string>(boost::any_cast<string>(m["ProjectVersion"]));
    }
  }


  virtual ~CreateAntChainContractProjectRequest() = default;
};
class CreateAntChainContractProjectResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> projectDescription{};
  shared_ptr<string> projectId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> projectVersion{};
  shared_ptr<long> updateTime{};

  CreateAntChainContractProjectResponseBodyResult() {}

  explicit CreateAntChainContractProjectResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (projectDescription) {
      res["ProjectDescription"] = boost::any(*projectDescription);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (projectVersion) {
      res["ProjectVersion"] = boost::any(*projectVersion);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ProjectDescription") != m.end() && !m["ProjectDescription"].empty()) {
      projectDescription = make_shared<string>(boost::any_cast<string>(m["ProjectDescription"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProjectVersion") != m.end() && !m["ProjectVersion"].empty()) {
      projectVersion = make_shared<string>(boost::any_cast<string>(m["ProjectVersion"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~CreateAntChainContractProjectResponseBodyResult() = default;
};
class CreateAntChainContractProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateAntChainContractProjectResponseBodyResult> result{};

  CreateAntChainContractProjectResponseBody() {}

  explicit CreateAntChainContractProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateAntChainContractProjectResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateAntChainContractProjectResponseBodyResult>(model1);
      }
    }
  }


  virtual ~CreateAntChainContractProjectResponseBody() = default;
};
class CreateAntChainContractProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAntChainContractProjectResponseBody> body{};

  CreateAntChainContractProjectResponse() {}

  explicit CreateAntChainContractProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAntChainContractProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAntChainContractProjectResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAntChainContractProjectResponse() = default;
};
class CreateAntChainKmsAccountNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> antChainId{};

  CreateAntChainKmsAccountNewRequest() {}

  explicit CreateAntChainKmsAccountNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
  }


  virtual ~CreateAntChainKmsAccountNewRequest() = default;
};
class CreateAntChainKmsAccountNewResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> myKmsKeyId{};
  shared_ptr<string> pubKey{};

  CreateAntChainKmsAccountNewResponseBodyResult() {}

  explicit CreateAntChainKmsAccountNewResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (myKmsKeyId) {
      res["MyKmsKeyId"] = boost::any(*myKmsKeyId);
    }
    if (pubKey) {
      res["PubKey"] = boost::any(*pubKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MyKmsKeyId") != m.end() && !m["MyKmsKeyId"].empty()) {
      myKmsKeyId = make_shared<string>(boost::any_cast<string>(m["MyKmsKeyId"]));
    }
    if (m.find("PubKey") != m.end() && !m["PubKey"].empty()) {
      pubKey = make_shared<string>(boost::any_cast<string>(m["PubKey"]));
    }
  }


  virtual ~CreateAntChainKmsAccountNewResponseBodyResult() = default;
};
class CreateAntChainKmsAccountNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateAntChainKmsAccountNewResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  CreateAntChainKmsAccountNewResponseBody() {}

  explicit CreateAntChainKmsAccountNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateAntChainKmsAccountNewResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateAntChainKmsAccountNewResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateAntChainKmsAccountNewResponseBody() = default;
};
class CreateAntChainKmsAccountNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateAntChainKmsAccountNewResponseBody> body{};

  CreateAntChainKmsAccountNewResponse() {}

  explicit CreateAntChainKmsAccountNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateAntChainKmsAccountNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateAntChainKmsAccountNewResponseBody>(model1);
      }
    }
  }


  virtual ~CreateAntChainKmsAccountNewResponse() = default;
};
class CreateFabricChaincodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> ossBucket{};
  shared_ptr<string> ossUrl{};

  CreateFabricChaincodeRequest() {}

  explicit CreateFabricChaincodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (ossBucket) {
      res["OssBucket"] = boost::any(*ossBucket);
    }
    if (ossUrl) {
      res["OssUrl"] = boost::any(*ossUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("OssBucket") != m.end() && !m["OssBucket"].empty()) {
      ossBucket = make_shared<string>(boost::any_cast<string>(m["OssBucket"]));
    }
    if (m.find("OssUrl") != m.end() && !m["OssUrl"].empty()) {
      ossUrl = make_shared<string>(boost::any_cast<string>(m["OssUrl"]));
    }
  }


  virtual ~CreateFabricChaincodeRequest() = default;
};
class CreateFabricChaincodeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> chaincodeName{};
  shared_ptr<string> chaincodeVersion{};
  shared_ptr<string> channelName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deployTime{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<string> input{};
  shared_ptr<bool> install{};
  shared_ptr<string> message{};
  shared_ptr<string> path{};
  shared_ptr<string> providerId{};
  shared_ptr<string> providerName{};
  shared_ptr<string> state{};
  shared_ptr<long> type{};

  CreateFabricChaincodeResponseBodyResult() {}

  explicit CreateFabricChaincodeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (chaincodeName) {
      res["ChaincodeName"] = boost::any(*chaincodeName);
    }
    if (chaincodeVersion) {
      res["ChaincodeVersion"] = boost::any(*chaincodeVersion);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deployTime) {
      res["DeployTime"] = boost::any(*deployTime);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (install) {
      res["Install"] = boost::any(*install);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (providerId) {
      res["ProviderId"] = boost::any(*providerId);
    }
    if (providerName) {
      res["ProviderName"] = boost::any(*providerName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("ChaincodeName") != m.end() && !m["ChaincodeName"].empty()) {
      chaincodeName = make_shared<string>(boost::any_cast<string>(m["ChaincodeName"]));
    }
    if (m.find("ChaincodeVersion") != m.end() && !m["ChaincodeVersion"].empty()) {
      chaincodeVersion = make_shared<string>(boost::any_cast<string>(m["ChaincodeVersion"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeployTime") != m.end() && !m["DeployTime"].empty()) {
      deployTime = make_shared<string>(boost::any_cast<string>(m["DeployTime"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Install") != m.end() && !m["Install"].empty()) {
      install = make_shared<bool>(boost::any_cast<bool>(m["Install"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ProviderId") != m.end() && !m["ProviderId"].empty()) {
      providerId = make_shared<string>(boost::any_cast<string>(m["ProviderId"]));
    }
    if (m.find("ProviderName") != m.end() && !m["ProviderName"].empty()) {
      providerName = make_shared<string>(boost::any_cast<string>(m["ProviderName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~CreateFabricChaincodeResponseBodyResult() = default;
};
class CreateFabricChaincodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateFabricChaincodeResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateFabricChaincodeResponseBody() {}

  explicit CreateFabricChaincodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateFabricChaincodeResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateFabricChaincodeResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateFabricChaincodeResponseBody() = default;
};
class CreateFabricChaincodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFabricChaincodeResponseBody> body{};

  CreateFabricChaincodeResponse() {}

  explicit CreateFabricChaincodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFabricChaincodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFabricChaincodeResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFabricChaincodeResponse() = default;
};
class CreateFabricChaincodePackageRequest : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> ossUrl{};

  CreateFabricChaincodePackageRequest() {}

  explicit CreateFabricChaincodePackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (ossUrl) {
      res["OssUrl"] = boost::any(*ossUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("OssUrl") != m.end() && !m["OssUrl"].empty()) {
      ossUrl = make_shared<string>(boost::any_cast<string>(m["OssUrl"]));
    }
  }


  virtual ~CreateFabricChaincodePackageRequest() = default;
};
class CreateFabricChaincodePackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ChaincodePackage> result{};
  shared_ptr<bool> success{};

  CreateFabricChaincodePackageResponseBody() {}

  explicit CreateFabricChaincodePackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ChaincodePackage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ChaincodePackage>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateFabricChaincodePackageResponseBody() = default;
};
class CreateFabricChaincodePackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFabricChaincodePackageResponseBody> body{};

  CreateFabricChaincodePackageResponse() {}

  explicit CreateFabricChaincodePackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFabricChaincodePackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFabricChaincodePackageResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFabricChaincodePackageResponse() = default;
};
class CreateFabricChannelRequestOrganization : public Darabonba::Model {
public:
  shared_ptr<string> id{};

  CreateFabricChannelRequestOrganization() {}

  explicit CreateFabricChannelRequestOrganization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
  }


  virtual ~CreateFabricChannelRequestOrganization() = default;
};
class CreateFabricChannelRequest : public Darabonba::Model {
public:
  shared_ptr<long> batchTimeout{};
  shared_ptr<string> channelName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<long> maxMessageCount{};
  shared_ptr<vector<CreateFabricChannelRequestOrganization>> organization{};
  shared_ptr<long> preferredMaxBytes{};

  CreateFabricChannelRequest() {}

  explicit CreateFabricChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchTimeout) {
      res["BatchTimeout"] = boost::any(*batchTimeout);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (maxMessageCount) {
      res["MaxMessageCount"] = boost::any(*maxMessageCount);
    }
    if (organization) {
      vector<boost::any> temp1;
      for(auto item1:*organization){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Organization"] = boost::any(temp1);
    }
    if (preferredMaxBytes) {
      res["PreferredMaxBytes"] = boost::any(*preferredMaxBytes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchTimeout") != m.end() && !m["BatchTimeout"].empty()) {
      batchTimeout = make_shared<long>(boost::any_cast<long>(m["BatchTimeout"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("MaxMessageCount") != m.end() && !m["MaxMessageCount"].empty()) {
      maxMessageCount = make_shared<long>(boost::any_cast<long>(m["MaxMessageCount"]));
    }
    if (m.find("Organization") != m.end() && !m["Organization"].empty()) {
      if (typeid(vector<boost::any>) == m["Organization"].type()) {
        vector<CreateFabricChannelRequestOrganization> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Organization"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateFabricChannelRequestOrganization model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        organization = make_shared<vector<CreateFabricChannelRequestOrganization>>(expect1);
      }
    }
    if (m.find("PreferredMaxBytes") != m.end() && !m["PreferredMaxBytes"].empty()) {
      preferredMaxBytes = make_shared<long>(boost::any_cast<long>(m["PreferredMaxBytes"]));
    }
  }


  virtual ~CreateFabricChannelRequest() = default;
};
class CreateFabricChannelResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> batchTimeout{};
  shared_ptr<long> blockCount{};
  shared_ptr<long> chaincodeCount{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> consortiumName{};
  shared_ptr<string> createTime{};
  shared_ptr<long> maxMessageCount{};
  shared_ptr<long> memberCount{};
  shared_ptr<string> ownerBid{};
  shared_ptr<string> ownerName{};
  shared_ptr<long> ownerUid{};
  shared_ptr<long> preferredMaxBytes{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};
  shared_ptr<bool> supportConfig{};
  shared_ptr<string> updateTime{};

  CreateFabricChannelResponseBodyResult() {}

  explicit CreateFabricChannelResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchTimeout) {
      res["BatchTimeout"] = boost::any(*batchTimeout);
    }
    if (blockCount) {
      res["BlockCount"] = boost::any(*blockCount);
    }
    if (chaincodeCount) {
      res["ChaincodeCount"] = boost::any(*chaincodeCount);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (consortiumName) {
      res["ConsortiumName"] = boost::any(*consortiumName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (maxMessageCount) {
      res["MaxMessageCount"] = boost::any(*maxMessageCount);
    }
    if (memberCount) {
      res["MemberCount"] = boost::any(*memberCount);
    }
    if (ownerBid) {
      res["OwnerBid"] = boost::any(*ownerBid);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUid) {
      res["OwnerUid"] = boost::any(*ownerUid);
    }
    if (preferredMaxBytes) {
      res["PreferredMaxBytes"] = boost::any(*preferredMaxBytes);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (supportConfig) {
      res["SupportConfig"] = boost::any(*supportConfig);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchTimeout") != m.end() && !m["BatchTimeout"].empty()) {
      batchTimeout = make_shared<long>(boost::any_cast<long>(m["BatchTimeout"]));
    }
    if (m.find("BlockCount") != m.end() && !m["BlockCount"].empty()) {
      blockCount = make_shared<long>(boost::any_cast<long>(m["BlockCount"]));
    }
    if (m.find("ChaincodeCount") != m.end() && !m["ChaincodeCount"].empty()) {
      chaincodeCount = make_shared<long>(boost::any_cast<long>(m["ChaincodeCount"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("ConsortiumName") != m.end() && !m["ConsortiumName"].empty()) {
      consortiumName = make_shared<string>(boost::any_cast<string>(m["ConsortiumName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("MaxMessageCount") != m.end() && !m["MaxMessageCount"].empty()) {
      maxMessageCount = make_shared<long>(boost::any_cast<long>(m["MaxMessageCount"]));
    }
    if (m.find("MemberCount") != m.end() && !m["MemberCount"].empty()) {
      memberCount = make_shared<long>(boost::any_cast<long>(m["MemberCount"]));
    }
    if (m.find("OwnerBid") != m.end() && !m["OwnerBid"].empty()) {
      ownerBid = make_shared<string>(boost::any_cast<string>(m["OwnerBid"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUid") != m.end() && !m["OwnerUid"].empty()) {
      ownerUid = make_shared<long>(boost::any_cast<long>(m["OwnerUid"]));
    }
    if (m.find("PreferredMaxBytes") != m.end() && !m["PreferredMaxBytes"].empty()) {
      preferredMaxBytes = make_shared<long>(boost::any_cast<long>(m["PreferredMaxBytes"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("SupportConfig") != m.end() && !m["SupportConfig"].empty()) {
      supportConfig = make_shared<bool>(boost::any_cast<bool>(m["SupportConfig"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~CreateFabricChannelResponseBodyResult() = default;
};
class CreateFabricChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateFabricChannelResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateFabricChannelResponseBody() {}

  explicit CreateFabricChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateFabricChannelResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateFabricChannelResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateFabricChannelResponseBody() = default;
};
class CreateFabricChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFabricChannelResponseBody> body{};

  CreateFabricChannelResponse() {}

  explicit CreateFabricChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFabricChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFabricChannelResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFabricChannelResponse() = default;
};
class CreateFabricChannelMemberRequestOrganization : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};

  CreateFabricChannelMemberRequestOrganization() {}

  explicit CreateFabricChannelMemberRequestOrganization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~CreateFabricChannelMemberRequestOrganization() = default;
};
class CreateFabricChannelMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<vector<CreateFabricChannelMemberRequestOrganization>> organization{};

  CreateFabricChannelMemberRequest() {}

  explicit CreateFabricChannelMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (organization) {
      vector<boost::any> temp1;
      for(auto item1:*organization){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Organization"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Organization") != m.end() && !m["Organization"].empty()) {
      if (typeid(vector<boost::any>) == m["Organization"].type()) {
        vector<CreateFabricChannelMemberRequestOrganization> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Organization"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateFabricChannelMemberRequestOrganization model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        organization = make_shared<vector<CreateFabricChannelMemberRequestOrganization>>(expect1);
      }
    }
  }


  virtual ~CreateFabricChannelMemberRequest() = default;
};
class CreateFabricChannelMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};
  shared_ptr<bool> success{};

  CreateFabricChannelMemberResponseBody() {}

  explicit CreateFabricChannelMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateFabricChannelMemberResponseBody() = default;
};
class CreateFabricChannelMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFabricChannelMemberResponseBody> body{};

  CreateFabricChannelMemberResponse() {}

  explicit CreateFabricChannelMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFabricChannelMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFabricChannelMemberResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFabricChannelMemberResponse() = default;
};
class CreateFabricConsortiumRequestOrganization : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};

  CreateFabricConsortiumRequestOrganization() {}

  explicit CreateFabricConsortiumRequestOrganization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~CreateFabricConsortiumRequestOrganization() = default;
};
class CreateFabricConsortiumRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelPolicy{};
  shared_ptr<string> consortiumDescription{};
  shared_ptr<string> consortiumName{};
  shared_ptr<string> domain{};
  shared_ptr<string> location{};
  shared_ptr<string> ordererType{};
  shared_ptr<long> orderersCount{};
  shared_ptr<vector<CreateFabricConsortiumRequestOrganization>> organization{};
  shared_ptr<long> paymentDuration{};
  shared_ptr<string> paymentDurationUnit{};
  shared_ptr<long> peersCount{};
  shared_ptr<string> specName{};
  shared_ptr<string> zoneId{};

  CreateFabricConsortiumRequest() {}

  explicit CreateFabricConsortiumRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelPolicy) {
      res["ChannelPolicy"] = boost::any(*channelPolicy);
    }
    if (consortiumDescription) {
      res["ConsortiumDescription"] = boost::any(*consortiumDescription);
    }
    if (consortiumName) {
      res["ConsortiumName"] = boost::any(*consortiumName);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (ordererType) {
      res["OrdererType"] = boost::any(*ordererType);
    }
    if (orderersCount) {
      res["OrderersCount"] = boost::any(*orderersCount);
    }
    if (organization) {
      vector<boost::any> temp1;
      for(auto item1:*organization){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Organization"] = boost::any(temp1);
    }
    if (paymentDuration) {
      res["PaymentDuration"] = boost::any(*paymentDuration);
    }
    if (paymentDurationUnit) {
      res["PaymentDurationUnit"] = boost::any(*paymentDurationUnit);
    }
    if (peersCount) {
      res["PeersCount"] = boost::any(*peersCount);
    }
    if (specName) {
      res["SpecName"] = boost::any(*specName);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelPolicy") != m.end() && !m["ChannelPolicy"].empty()) {
      channelPolicy = make_shared<string>(boost::any_cast<string>(m["ChannelPolicy"]));
    }
    if (m.find("ConsortiumDescription") != m.end() && !m["ConsortiumDescription"].empty()) {
      consortiumDescription = make_shared<string>(boost::any_cast<string>(m["ConsortiumDescription"]));
    }
    if (m.find("ConsortiumName") != m.end() && !m["ConsortiumName"].empty()) {
      consortiumName = make_shared<string>(boost::any_cast<string>(m["ConsortiumName"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrdererType") != m.end() && !m["OrdererType"].empty()) {
      ordererType = make_shared<string>(boost::any_cast<string>(m["OrdererType"]));
    }
    if (m.find("OrderersCount") != m.end() && !m["OrderersCount"].empty()) {
      orderersCount = make_shared<long>(boost::any_cast<long>(m["OrderersCount"]));
    }
    if (m.find("Organization") != m.end() && !m["Organization"].empty()) {
      if (typeid(vector<boost::any>) == m["Organization"].type()) {
        vector<CreateFabricConsortiumRequestOrganization> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Organization"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateFabricConsortiumRequestOrganization model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        organization = make_shared<vector<CreateFabricConsortiumRequestOrganization>>(expect1);
      }
    }
    if (m.find("PaymentDuration") != m.end() && !m["PaymentDuration"].empty()) {
      paymentDuration = make_shared<long>(boost::any_cast<long>(m["PaymentDuration"]));
    }
    if (m.find("PaymentDurationUnit") != m.end() && !m["PaymentDurationUnit"].empty()) {
      paymentDurationUnit = make_shared<string>(boost::any_cast<string>(m["PaymentDurationUnit"]));
    }
    if (m.find("PeersCount") != m.end() && !m["PeersCount"].empty()) {
      peersCount = make_shared<long>(boost::any_cast<long>(m["PeersCount"]));
    }
    if (m.find("SpecName") != m.end() && !m["SpecName"].empty()) {
      specName = make_shared<string>(boost::any_cast<string>(m["SpecName"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateFabricConsortiumRequest() = default;
};
class CreateFabricConsortiumResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> channelCount{};
  shared_ptr<string> channelPolicy{};
  shared_ptr<string> clusterState{};
  shared_ptr<string> codeName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> consortiumName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<long> memberCount{};
  shared_ptr<long> ordererCount{};
  shared_ptr<string> ordererType{};
  shared_ptr<string> ownerBid{};
  shared_ptr<long> ownerUid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> serviceState{};
  shared_ptr<string> specName{};
  shared_ptr<string> zoneId{};

  CreateFabricConsortiumResponseBodyResult() {}

  explicit CreateFabricConsortiumResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelCount) {
      res["ChannelCount"] = boost::any(*channelCount);
    }
    if (channelPolicy) {
      res["ChannelPolicy"] = boost::any(*channelPolicy);
    }
    if (clusterState) {
      res["ClusterState"] = boost::any(*clusterState);
    }
    if (codeName) {
      res["CodeName"] = boost::any(*codeName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (consortiumName) {
      res["ConsortiumName"] = boost::any(*consortiumName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (memberCount) {
      res["MemberCount"] = boost::any(*memberCount);
    }
    if (ordererCount) {
      res["OrdererCount"] = boost::any(*ordererCount);
    }
    if (ordererType) {
      res["OrdererType"] = boost::any(*ordererType);
    }
    if (ownerBid) {
      res["OwnerBid"] = boost::any(*ownerBid);
    }
    if (ownerUid) {
      res["OwnerUid"] = boost::any(*ownerUid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (serviceState) {
      res["ServiceState"] = boost::any(*serviceState);
    }
    if (specName) {
      res["SpecName"] = boost::any(*specName);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelCount") != m.end() && !m["ChannelCount"].empty()) {
      channelCount = make_shared<long>(boost::any_cast<long>(m["ChannelCount"]));
    }
    if (m.find("ChannelPolicy") != m.end() && !m["ChannelPolicy"].empty()) {
      channelPolicy = make_shared<string>(boost::any_cast<string>(m["ChannelPolicy"]));
    }
    if (m.find("ClusterState") != m.end() && !m["ClusterState"].empty()) {
      clusterState = make_shared<string>(boost::any_cast<string>(m["ClusterState"]));
    }
    if (m.find("CodeName") != m.end() && !m["CodeName"].empty()) {
      codeName = make_shared<string>(boost::any_cast<string>(m["CodeName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("ConsortiumName") != m.end() && !m["ConsortiumName"].empty()) {
      consortiumName = make_shared<string>(boost::any_cast<string>(m["ConsortiumName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("MemberCount") != m.end() && !m["MemberCount"].empty()) {
      memberCount = make_shared<long>(boost::any_cast<long>(m["MemberCount"]));
    }
    if (m.find("OrdererCount") != m.end() && !m["OrdererCount"].empty()) {
      ordererCount = make_shared<long>(boost::any_cast<long>(m["OrdererCount"]));
    }
    if (m.find("OrdererType") != m.end() && !m["OrdererType"].empty()) {
      ordererType = make_shared<string>(boost::any_cast<string>(m["OrdererType"]));
    }
    if (m.find("OwnerBid") != m.end() && !m["OwnerBid"].empty()) {
      ownerBid = make_shared<string>(boost::any_cast<string>(m["OwnerBid"]));
    }
    if (m.find("OwnerUid") != m.end() && !m["OwnerUid"].empty()) {
      ownerUid = make_shared<long>(boost::any_cast<long>(m["OwnerUid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ServiceState") != m.end() && !m["ServiceState"].empty()) {
      serviceState = make_shared<string>(boost::any_cast<string>(m["ServiceState"]));
    }
    if (m.find("SpecName") != m.end() && !m["SpecName"].empty()) {
      specName = make_shared<string>(boost::any_cast<string>(m["SpecName"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateFabricConsortiumResponseBodyResult() = default;
};
class CreateFabricConsortiumResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateFabricConsortiumResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateFabricConsortiumResponseBody() {}

  explicit CreateFabricConsortiumResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateFabricConsortiumResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateFabricConsortiumResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateFabricConsortiumResponseBody() = default;
};
class CreateFabricConsortiumResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFabricConsortiumResponseBody> body{};

  CreateFabricConsortiumResponse() {}

  explicit CreateFabricConsortiumResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFabricConsortiumResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFabricConsortiumResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFabricConsortiumResponse() = default;
};
class CreateFabricConsortiumMemberRequestOrganization : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};

  CreateFabricConsortiumMemberRequestOrganization() {}

  explicit CreateFabricConsortiumMemberRequestOrganization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~CreateFabricConsortiumMemberRequestOrganization() = default;
};
class CreateFabricConsortiumMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> consortiumId{};
  shared_ptr<vector<CreateFabricConsortiumMemberRequestOrganization>> organization{};

  CreateFabricConsortiumMemberRequest() {}

  explicit CreateFabricConsortiumMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (organization) {
      vector<boost::any> temp1;
      for(auto item1:*organization){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Organization"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Organization") != m.end() && !m["Organization"].empty()) {
      if (typeid(vector<boost::any>) == m["Organization"].type()) {
        vector<CreateFabricConsortiumMemberRequestOrganization> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Organization"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateFabricConsortiumMemberRequestOrganization model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        organization = make_shared<vector<CreateFabricConsortiumMemberRequestOrganization>>(expect1);
      }
    }
  }


  virtual ~CreateFabricConsortiumMemberRequest() = default;
};
class CreateFabricConsortiumMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};
  shared_ptr<bool> success{};

  CreateFabricConsortiumMemberResponseBody() {}

  explicit CreateFabricConsortiumMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateFabricConsortiumMemberResponseBody() = default;
};
class CreateFabricConsortiumMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFabricConsortiumMemberResponseBody> body{};

  CreateFabricConsortiumMemberResponse() {}

  explicit CreateFabricConsortiumMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFabricConsortiumMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFabricConsortiumMemberResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFabricConsortiumMemberResponse() = default;
};
class CreateFabricOrganizationRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<string> location{};
  shared_ptr<string> organizationName{};
  shared_ptr<long> paymentDuration{};
  shared_ptr<string> paymentDurationUnit{};
  shared_ptr<long> peersCount{};
  shared_ptr<string> specName{};

  CreateFabricOrganizationRequest() {}

  explicit CreateFabricOrganizationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationName) {
      res["OrganizationName"] = boost::any(*organizationName);
    }
    if (paymentDuration) {
      res["PaymentDuration"] = boost::any(*paymentDuration);
    }
    if (paymentDurationUnit) {
      res["PaymentDurationUnit"] = boost::any(*paymentDurationUnit);
    }
    if (peersCount) {
      res["PeersCount"] = boost::any(*peersCount);
    }
    if (specName) {
      res["SpecName"] = boost::any(*specName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationName") != m.end() && !m["OrganizationName"].empty()) {
      organizationName = make_shared<string>(boost::any_cast<string>(m["OrganizationName"]));
    }
    if (m.find("PaymentDuration") != m.end() && !m["PaymentDuration"].empty()) {
      paymentDuration = make_shared<long>(boost::any_cast<long>(m["PaymentDuration"]));
    }
    if (m.find("PaymentDurationUnit") != m.end() && !m["PaymentDurationUnit"].empty()) {
      paymentDurationUnit = make_shared<string>(boost::any_cast<string>(m["PaymentDurationUnit"]));
    }
    if (m.find("PeersCount") != m.end() && !m["PeersCount"].empty()) {
      peersCount = make_shared<long>(boost::any_cast<long>(m["PeersCount"]));
    }
    if (m.find("SpecName") != m.end() && !m["SpecName"].empty()) {
      specName = make_shared<string>(boost::any_cast<string>(m["SpecName"]));
    }
  }


  virtual ~CreateFabricOrganizationRequest() = default;
};
class CreateFabricOrganizationResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> clusterState{};
  shared_ptr<string> codeName{};
  shared_ptr<long> consortiumCount{};
  shared_ptr<string> createTime{};
  shared_ptr<string> domain{};
  shared_ptr<string> organizationDescription{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> organizationName{};
  shared_ptr<string> ownerBid{};
  shared_ptr<string> ownerName{};
  shared_ptr<long> ownerUid{};
  shared_ptr<long> peerCount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> serviceState{};
  shared_ptr<string> specName{};
  shared_ptr<long> userCount{};
  shared_ptr<string> zoneId{};

  CreateFabricOrganizationResponseBodyResult() {}

  explicit CreateFabricOrganizationResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterState) {
      res["ClusterState"] = boost::any(*clusterState);
    }
    if (codeName) {
      res["CodeName"] = boost::any(*codeName);
    }
    if (consortiumCount) {
      res["ConsortiumCount"] = boost::any(*consortiumCount);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (organizationDescription) {
      res["OrganizationDescription"] = boost::any(*organizationDescription);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (organizationName) {
      res["OrganizationName"] = boost::any(*organizationName);
    }
    if (ownerBid) {
      res["OwnerBid"] = boost::any(*ownerBid);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUid) {
      res["OwnerUid"] = boost::any(*ownerUid);
    }
    if (peerCount) {
      res["PeerCount"] = boost::any(*peerCount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (serviceState) {
      res["ServiceState"] = boost::any(*serviceState);
    }
    if (specName) {
      res["SpecName"] = boost::any(*specName);
    }
    if (userCount) {
      res["UserCount"] = boost::any(*userCount);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterState") != m.end() && !m["ClusterState"].empty()) {
      clusterState = make_shared<string>(boost::any_cast<string>(m["ClusterState"]));
    }
    if (m.find("CodeName") != m.end() && !m["CodeName"].empty()) {
      codeName = make_shared<string>(boost::any_cast<string>(m["CodeName"]));
    }
    if (m.find("ConsortiumCount") != m.end() && !m["ConsortiumCount"].empty()) {
      consortiumCount = make_shared<long>(boost::any_cast<long>(m["ConsortiumCount"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("OrganizationDescription") != m.end() && !m["OrganizationDescription"].empty()) {
      organizationDescription = make_shared<string>(boost::any_cast<string>(m["OrganizationDescription"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("OrganizationName") != m.end() && !m["OrganizationName"].empty()) {
      organizationName = make_shared<string>(boost::any_cast<string>(m["OrganizationName"]));
    }
    if (m.find("OwnerBid") != m.end() && !m["OwnerBid"].empty()) {
      ownerBid = make_shared<string>(boost::any_cast<string>(m["OwnerBid"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUid") != m.end() && !m["OwnerUid"].empty()) {
      ownerUid = make_shared<long>(boost::any_cast<long>(m["OwnerUid"]));
    }
    if (m.find("PeerCount") != m.end() && !m["PeerCount"].empty()) {
      peerCount = make_shared<long>(boost::any_cast<long>(m["PeerCount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ServiceState") != m.end() && !m["ServiceState"].empty()) {
      serviceState = make_shared<string>(boost::any_cast<string>(m["ServiceState"]));
    }
    if (m.find("SpecName") != m.end() && !m["SpecName"].empty()) {
      specName = make_shared<string>(boost::any_cast<string>(m["SpecName"]));
    }
    if (m.find("UserCount") != m.end() && !m["UserCount"].empty()) {
      userCount = make_shared<long>(boost::any_cast<long>(m["UserCount"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~CreateFabricOrganizationResponseBodyResult() = default;
};
class CreateFabricOrganizationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateFabricOrganizationResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateFabricOrganizationResponseBody() {}

  explicit CreateFabricOrganizationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateFabricOrganizationResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateFabricOrganizationResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateFabricOrganizationResponseBody() = default;
};
class CreateFabricOrganizationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFabricOrganizationResponseBody> body{};

  CreateFabricOrganizationResponse() {}

  explicit CreateFabricOrganizationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFabricOrganizationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFabricOrganizationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFabricOrganizationResponse() = default;
};
class CreateFabricOrganizationUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> attrs{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> password{};
  shared_ptr<string> username{};

  CreateFabricOrganizationUserRequest() {}

  explicit CreateFabricOrganizationUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attrs) {
      res["Attrs"] = boost::any(*attrs);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attrs") != m.end() && !m["Attrs"].empty()) {
      attrs = make_shared<string>(boost::any_cast<string>(m["Attrs"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~CreateFabricOrganizationUserRequest() = default;
};
class CreateFabricOrganizationUserResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> fullname{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> password{};
  shared_ptr<string> username{};

  CreateFabricOrganizationUserResponseBodyResult() {}

  explicit CreateFabricOrganizationUserResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (fullname) {
      res["Fullname"] = boost::any(*fullname);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("Fullname") != m.end() && !m["Fullname"].empty()) {
      fullname = make_shared<string>(boost::any_cast<string>(m["Fullname"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~CreateFabricOrganizationUserResponseBodyResult() = default;
};
class CreateFabricOrganizationUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<CreateFabricOrganizationUserResponseBodyResult> result{};
  shared_ptr<bool> success{};

  CreateFabricOrganizationUserResponseBody() {}

  explicit CreateFabricOrganizationUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateFabricOrganizationUserResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateFabricOrganizationUserResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~CreateFabricOrganizationUserResponseBody() = default;
};
class CreateFabricOrganizationUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFabricOrganizationUserResponseBody> body{};

  CreateFabricOrganizationUserResponse() {}

  explicit CreateFabricOrganizationUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFabricOrganizationUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFabricOrganizationUserResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFabricOrganizationUserResponse() = default;
};
class DeleteAntChainConsortiumRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};

  DeleteAntChainConsortiumRequest() {}

  explicit DeleteAntChainConsortiumRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
  }


  virtual ~DeleteAntChainConsortiumRequest() = default;
};
class DeleteAntChainConsortiumResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  DeleteAntChainConsortiumResponseBody() {}

  explicit DeleteAntChainConsortiumResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~DeleteAntChainConsortiumResponseBody() = default;
};
class DeleteAntChainConsortiumResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAntChainConsortiumResponseBody> body{};

  DeleteAntChainConsortiumResponse() {}

  explicit DeleteAntChainConsortiumResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAntChainConsortiumResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAntChainConsortiumResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAntChainConsortiumResponse() = default;
};
class DeleteAntChainContractContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> contentId{};

  DeleteAntChainContractContentRequest() {}

  explicit DeleteAntChainContractContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentId) {
      res["ContentId"] = boost::any(*contentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentId") != m.end() && !m["ContentId"].empty()) {
      contentId = make_shared<string>(boost::any_cast<string>(m["ContentId"]));
    }
  }


  virtual ~DeleteAntChainContractContentRequest() = default;
};
class DeleteAntChainContractContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  DeleteAntChainContractContentResponseBody() {}

  explicit DeleteAntChainContractContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~DeleteAntChainContractContentResponseBody() = default;
};
class DeleteAntChainContractContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAntChainContractContentResponseBody> body{};

  DeleteAntChainContractContentResponse() {}

  explicit DeleteAntChainContractContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAntChainContractContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAntChainContractContentResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAntChainContractContentResponse() = default;
};
class DeleteAntChainContractProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};

  DeleteAntChainContractProjectRequest() {}

  explicit DeleteAntChainContractProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~DeleteAntChainContractProjectRequest() = default;
};
class DeleteAntChainContractProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  DeleteAntChainContractProjectResponseBody() {}

  explicit DeleteAntChainContractProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~DeleteAntChainContractProjectResponseBody() = default;
};
class DeleteAntChainContractProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAntChainContractProjectResponseBody> body{};

  DeleteAntChainContractProjectResponse() {}

  explicit DeleteAntChainContractProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAntChainContractProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAntChainContractProjectResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAntChainContractProjectResponse() = default;
};
class DeleteAntChainMiniAppQRCodeAuthorizedUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> phone{};

  DeleteAntChainMiniAppQRCodeAuthorizedUserRequest() {}

  explicit DeleteAntChainMiniAppQRCodeAuthorizedUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
  }


  virtual ~DeleteAntChainMiniAppQRCodeAuthorizedUserRequest() = default;
};
class DeleteAntChainMiniAppQRCodeAuthorizedUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  DeleteAntChainMiniAppQRCodeAuthorizedUserResponseBody() {}

  explicit DeleteAntChainMiniAppQRCodeAuthorizedUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~DeleteAntChainMiniAppQRCodeAuthorizedUserResponseBody() = default;
};
class DeleteAntChainMiniAppQRCodeAuthorizedUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteAntChainMiniAppQRCodeAuthorizedUserResponseBody> body{};

  DeleteAntChainMiniAppQRCodeAuthorizedUserResponse() {}

  explicit DeleteAntChainMiniAppQRCodeAuthorizedUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteAntChainMiniAppQRCodeAuthorizedUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteAntChainMiniAppQRCodeAuthorizedUserResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteAntChainMiniAppQRCodeAuthorizedUserResponse() = default;
};
class DeleteFabricChaincodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};

  DeleteFabricChaincodeRequest() {}

  explicit DeleteFabricChaincodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
  }


  virtual ~DeleteFabricChaincodeRequest() = default;
};
class DeleteFabricChaincodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DeleteFabricChaincodeResponseBody() {}

  explicit DeleteFabricChaincodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DeleteFabricChaincodeResponseBody() = default;
};
class DeleteFabricChaincodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteFabricChaincodeResponseBody> body{};

  DeleteFabricChaincodeResponse() {}

  explicit DeleteFabricChaincodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFabricChaincodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFabricChaincodeResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFabricChaincodeResponse() = default;
};
class DescribeAntChainAccountsRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeAntChainAccountsRequest() {}

  explicit DescribeAntChainAccountsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeAntChainAccountsRequest() = default;
};
class DescribeAntChainAccountsResponseBodyResultAccounts : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> accountPublicKey{};
  shared_ptr<string> accountRecoveryKey{};
  shared_ptr<string> accountStatus{};
  shared_ptr<string> antChainId{};

  DescribeAntChainAccountsResponseBodyResultAccounts() {}

  explicit DescribeAntChainAccountsResponseBodyResultAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (accountPublicKey) {
      res["AccountPublicKey"] = boost::any(*accountPublicKey);
    }
    if (accountRecoveryKey) {
      res["AccountRecoveryKey"] = boost::any(*accountRecoveryKey);
    }
    if (accountStatus) {
      res["AccountStatus"] = boost::any(*accountStatus);
    }
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("AccountPublicKey") != m.end() && !m["AccountPublicKey"].empty()) {
      accountPublicKey = make_shared<string>(boost::any_cast<string>(m["AccountPublicKey"]));
    }
    if (m.find("AccountRecoveryKey") != m.end() && !m["AccountRecoveryKey"].empty()) {
      accountRecoveryKey = make_shared<string>(boost::any_cast<string>(m["AccountRecoveryKey"]));
    }
    if (m.find("AccountStatus") != m.end() && !m["AccountStatus"].empty()) {
      accountStatus = make_shared<string>(boost::any_cast<string>(m["AccountStatus"]));
    }
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
  }


  virtual ~DescribeAntChainAccountsResponseBodyResultAccounts() = default;
};
class DescribeAntChainAccountsResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainAccountsResponseBodyResultPagination() {}

  explicit DescribeAntChainAccountsResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainAccountsResponseBodyResultPagination() = default;
};
class DescribeAntChainAccountsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAntChainAccountsResponseBodyResultAccounts>> accounts{};
  shared_ptr<DescribeAntChainAccountsResponseBodyResultPagination> pagination{};

  DescribeAntChainAccountsResponseBodyResult() {}

  explicit DescribeAntChainAccountsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accounts) {
      vector<boost::any> temp1;
      for(auto item1:*accounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Accounts"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Accounts") != m.end() && !m["Accounts"].empty()) {
      if (typeid(vector<boost::any>) == m["Accounts"].type()) {
        vector<DescribeAntChainAccountsResponseBodyResultAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Accounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainAccountsResponseBodyResultAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accounts = make_shared<vector<DescribeAntChainAccountsResponseBodyResultAccounts>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainAccountsResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainAccountsResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeAntChainAccountsResponseBodyResult() = default;
};
class DescribeAntChainAccountsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainAccountsResponseBodyResult> result{};

  DescribeAntChainAccountsResponseBody() {}

  explicit DescribeAntChainAccountsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainAccountsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainAccountsResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainAccountsResponseBody() = default;
};
class DescribeAntChainAccountsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainAccountsResponseBody> body{};

  DescribeAntChainAccountsResponse() {}

  explicit DescribeAntChainAccountsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainAccountsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainAccountsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainAccountsResponse() = default;
};
class DescribeAntChainAccountsV2Request : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> consortiumId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeAntChainAccountsV2Request() {}

  explicit DescribeAntChainAccountsV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeAntChainAccountsV2Request() = default;
};
class DescribeAntChainAccountsV2ResponseBodyResultAccounts : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> accountPublicKey{};
  shared_ptr<string> accountRecoveryKey{};
  shared_ptr<string> accountStatus{};
  shared_ptr<string> antChainId{};

  DescribeAntChainAccountsV2ResponseBodyResultAccounts() {}

  explicit DescribeAntChainAccountsV2ResponseBodyResultAccounts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (accountPublicKey) {
      res["AccountPublicKey"] = boost::any(*accountPublicKey);
    }
    if (accountRecoveryKey) {
      res["AccountRecoveryKey"] = boost::any(*accountRecoveryKey);
    }
    if (accountStatus) {
      res["AccountStatus"] = boost::any(*accountStatus);
    }
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("AccountPublicKey") != m.end() && !m["AccountPublicKey"].empty()) {
      accountPublicKey = make_shared<string>(boost::any_cast<string>(m["AccountPublicKey"]));
    }
    if (m.find("AccountRecoveryKey") != m.end() && !m["AccountRecoveryKey"].empty()) {
      accountRecoveryKey = make_shared<string>(boost::any_cast<string>(m["AccountRecoveryKey"]));
    }
    if (m.find("AccountStatus") != m.end() && !m["AccountStatus"].empty()) {
      accountStatus = make_shared<string>(boost::any_cast<string>(m["AccountStatus"]));
    }
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
  }


  virtual ~DescribeAntChainAccountsV2ResponseBodyResultAccounts() = default;
};
class DescribeAntChainAccountsV2ResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainAccountsV2ResponseBodyResultPagination() {}

  explicit DescribeAntChainAccountsV2ResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainAccountsV2ResponseBodyResultPagination() = default;
};
class DescribeAntChainAccountsV2ResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAntChainAccountsV2ResponseBodyResultAccounts>> accounts{};
  shared_ptr<DescribeAntChainAccountsV2ResponseBodyResultPagination> pagination{};

  DescribeAntChainAccountsV2ResponseBodyResult() {}

  explicit DescribeAntChainAccountsV2ResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accounts) {
      vector<boost::any> temp1;
      for(auto item1:*accounts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Accounts"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Accounts") != m.end() && !m["Accounts"].empty()) {
      if (typeid(vector<boost::any>) == m["Accounts"].type()) {
        vector<DescribeAntChainAccountsV2ResponseBodyResultAccounts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Accounts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainAccountsV2ResponseBodyResultAccounts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accounts = make_shared<vector<DescribeAntChainAccountsV2ResponseBodyResultAccounts>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainAccountsV2ResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainAccountsV2ResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeAntChainAccountsV2ResponseBodyResult() = default;
};
class DescribeAntChainAccountsV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainAccountsV2ResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainAccountsV2ResponseBody() {}

  explicit DescribeAntChainAccountsV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainAccountsV2ResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainAccountsV2ResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainAccountsV2ResponseBody() = default;
};
class DescribeAntChainAccountsV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainAccountsV2ResponseBody> body{};

  DescribeAntChainAccountsV2Response() {}

  explicit DescribeAntChainAccountsV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainAccountsV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainAccountsV2ResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainAccountsV2Response() = default;
};
class DescribeAntChainBlockRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<long> height{};

  DescribeAntChainBlockRequest() {}

  explicit DescribeAntChainBlockRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
  }


  virtual ~DescribeAntChainBlockRequest() = default;
};
class DescribeAntChainBlockResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> blockHash{};
  shared_ptr<long> createTime{};
  shared_ptr<long> height{};
  shared_ptr<string> previousHash{};
  shared_ptr<string> rootTxHash{};
  shared_ptr<string> transSummaryList{};
  shared_ptr<long> transactionSize{};
  shared_ptr<long> version{};

  DescribeAntChainBlockResponseBodyResult() {}

  explicit DescribeAntChainBlockResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (blockHash) {
      res["BlockHash"] = boost::any(*blockHash);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (previousHash) {
      res["PreviousHash"] = boost::any(*previousHash);
    }
    if (rootTxHash) {
      res["RootTxHash"] = boost::any(*rootTxHash);
    }
    if (transSummaryList) {
      res["TransSummaryList"] = boost::any(*transSummaryList);
    }
    if (transactionSize) {
      res["TransactionSize"] = boost::any(*transactionSize);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("BlockHash") != m.end() && !m["BlockHash"].empty()) {
      blockHash = make_shared<string>(boost::any_cast<string>(m["BlockHash"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("PreviousHash") != m.end() && !m["PreviousHash"].empty()) {
      previousHash = make_shared<string>(boost::any_cast<string>(m["PreviousHash"]));
    }
    if (m.find("RootTxHash") != m.end() && !m["RootTxHash"].empty()) {
      rootTxHash = make_shared<string>(boost::any_cast<string>(m["RootTxHash"]));
    }
    if (m.find("TransSummaryList") != m.end() && !m["TransSummaryList"].empty()) {
      transSummaryList = make_shared<string>(boost::any_cast<string>(m["TransSummaryList"]));
    }
    if (m.find("TransactionSize") != m.end() && !m["TransactionSize"].empty()) {
      transactionSize = make_shared<long>(boost::any_cast<long>(m["TransactionSize"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~DescribeAntChainBlockResponseBodyResult() = default;
};
class DescribeAntChainBlockResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainBlockResponseBodyResult> result{};

  DescribeAntChainBlockResponseBody() {}

  explicit DescribeAntChainBlockResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainBlockResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainBlockResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainBlockResponseBody() = default;
};
class DescribeAntChainBlockResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainBlockResponseBody> body{};

  DescribeAntChainBlockResponse() {}

  explicit DescribeAntChainBlockResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainBlockResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainBlockResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainBlockResponse() = default;
};
class DescribeAntChainBlockV2Request : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> consortiumId{};
  shared_ptr<long> height{};

  DescribeAntChainBlockV2Request() {}

  explicit DescribeAntChainBlockV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
  }


  virtual ~DescribeAntChainBlockV2Request() = default;
};
class DescribeAntChainBlockV2ResponseBodyResultTransSummaryList : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> blockHash{};
  shared_ptr<long> category{};
  shared_ptr<long> createTime{};
  shared_ptr<string> from{};
  shared_ptr<long> gasUsed{};
  shared_ptr<string> hash{};
  shared_ptr<long> height{};
  shared_ptr<long> referenceCount{};
  shared_ptr<string> to{};
  shared_ptr<string> transTypeV10{};
  shared_ptr<string> transTypeV6{};

  DescribeAntChainBlockV2ResponseBodyResultTransSummaryList() {}

  explicit DescribeAntChainBlockV2ResponseBodyResultTransSummaryList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (blockHash) {
      res["BlockHash"] = boost::any(*blockHash);
    }
    if (category) {
      res["Category"] = boost::any(*category);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (gasUsed) {
      res["GasUsed"] = boost::any(*gasUsed);
    }
    if (hash) {
      res["Hash"] = boost::any(*hash);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (referenceCount) {
      res["ReferenceCount"] = boost::any(*referenceCount);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    if (transTypeV10) {
      res["TransTypeV10"] = boost::any(*transTypeV10);
    }
    if (transTypeV6) {
      res["TransTypeV6"] = boost::any(*transTypeV6);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("BlockHash") != m.end() && !m["BlockHash"].empty()) {
      blockHash = make_shared<string>(boost::any_cast<string>(m["BlockHash"]));
    }
    if (m.find("Category") != m.end() && !m["Category"].empty()) {
      category = make_shared<long>(boost::any_cast<long>(m["Category"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("GasUsed") != m.end() && !m["GasUsed"].empty()) {
      gasUsed = make_shared<long>(boost::any_cast<long>(m["GasUsed"]));
    }
    if (m.find("Hash") != m.end() && !m["Hash"].empty()) {
      hash = make_shared<string>(boost::any_cast<string>(m["Hash"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("ReferenceCount") != m.end() && !m["ReferenceCount"].empty()) {
      referenceCount = make_shared<long>(boost::any_cast<long>(m["ReferenceCount"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<string>(boost::any_cast<string>(m["To"]));
    }
    if (m.find("TransTypeV10") != m.end() && !m["TransTypeV10"].empty()) {
      transTypeV10 = make_shared<string>(boost::any_cast<string>(m["TransTypeV10"]));
    }
    if (m.find("TransTypeV6") != m.end() && !m["TransTypeV6"].empty()) {
      transTypeV6 = make_shared<string>(boost::any_cast<string>(m["TransTypeV6"]));
    }
  }


  virtual ~DescribeAntChainBlockV2ResponseBodyResultTransSummaryList() = default;
};
class DescribeAntChainBlockV2ResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> blockHash{};
  shared_ptr<long> createTime{};
  shared_ptr<long> height{};
  shared_ptr<string> previousHash{};
  shared_ptr<string> rootTxHash{};
  shared_ptr<vector<DescribeAntChainBlockV2ResponseBodyResultTransSummaryList>> transSummaryList{};
  shared_ptr<long> transactionSize{};
  shared_ptr<long> version{};

  DescribeAntChainBlockV2ResponseBodyResult() {}

  explicit DescribeAntChainBlockV2ResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (blockHash) {
      res["BlockHash"] = boost::any(*blockHash);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (previousHash) {
      res["PreviousHash"] = boost::any(*previousHash);
    }
    if (rootTxHash) {
      res["RootTxHash"] = boost::any(*rootTxHash);
    }
    if (transSummaryList) {
      vector<boost::any> temp1;
      for(auto item1:*transSummaryList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TransSummaryList"] = boost::any(temp1);
    }
    if (transactionSize) {
      res["TransactionSize"] = boost::any(*transactionSize);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("BlockHash") != m.end() && !m["BlockHash"].empty()) {
      blockHash = make_shared<string>(boost::any_cast<string>(m["BlockHash"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("PreviousHash") != m.end() && !m["PreviousHash"].empty()) {
      previousHash = make_shared<string>(boost::any_cast<string>(m["PreviousHash"]));
    }
    if (m.find("RootTxHash") != m.end() && !m["RootTxHash"].empty()) {
      rootTxHash = make_shared<string>(boost::any_cast<string>(m["RootTxHash"]));
    }
    if (m.find("TransSummaryList") != m.end() && !m["TransSummaryList"].empty()) {
      if (typeid(vector<boost::any>) == m["TransSummaryList"].type()) {
        vector<DescribeAntChainBlockV2ResponseBodyResultTransSummaryList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TransSummaryList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainBlockV2ResponseBodyResultTransSummaryList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transSummaryList = make_shared<vector<DescribeAntChainBlockV2ResponseBodyResultTransSummaryList>>(expect1);
      }
    }
    if (m.find("TransactionSize") != m.end() && !m["TransactionSize"].empty()) {
      transactionSize = make_shared<long>(boost::any_cast<long>(m["TransactionSize"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~DescribeAntChainBlockV2ResponseBodyResult() = default;
};
class DescribeAntChainBlockV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainBlockV2ResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainBlockV2ResponseBody() {}

  explicit DescribeAntChainBlockV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainBlockV2ResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainBlockV2ResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainBlockV2ResponseBody() = default;
};
class DescribeAntChainBlockV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainBlockV2ResponseBody> body{};

  DescribeAntChainBlockV2Response() {}

  explicit DescribeAntChainBlockV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainBlockV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainBlockV2ResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainBlockV2Response() = default;
};
class DescribeAntChainCertificateApplicationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> status{};

  DescribeAntChainCertificateApplicationsRequest() {}

  explicit DescribeAntChainCertificateApplicationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeAntChainCertificateApplicationsRequest() = default;
};
class DescribeAntChainCertificateApplicationsResponseBodyResultCertificateApplications : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> bid{};
  shared_ptr<long> createtime{};
  shared_ptr<string> status{};
  shared_ptr<long> updatetime{};
  shared_ptr<string> username{};

  DescribeAntChainCertificateApplicationsResponseBodyResultCertificateApplications() {}

  explicit DescribeAntChainCertificateApplicationsResponseBodyResultCertificateApplications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (bid) {
      res["Bid"] = boost::any(*bid);
    }
    if (createtime) {
      res["Createtime"] = boost::any(*createtime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updatetime) {
      res["Updatetime"] = boost::any(*updatetime);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("Bid") != m.end() && !m["Bid"].empty()) {
      bid = make_shared<string>(boost::any_cast<string>(m["Bid"]));
    }
    if (m.find("Createtime") != m.end() && !m["Createtime"].empty()) {
      createtime = make_shared<long>(boost::any_cast<long>(m["Createtime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Updatetime") != m.end() && !m["Updatetime"].empty()) {
      updatetime = make_shared<long>(boost::any_cast<long>(m["Updatetime"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~DescribeAntChainCertificateApplicationsResponseBodyResultCertificateApplications() = default;
};
class DescribeAntChainCertificateApplicationsResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainCertificateApplicationsResponseBodyResultPagination() {}

  explicit DescribeAntChainCertificateApplicationsResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainCertificateApplicationsResponseBodyResultPagination() = default;
};
class DescribeAntChainCertificateApplicationsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAntChainCertificateApplicationsResponseBodyResultCertificateApplications>> certificateApplications{};
  shared_ptr<DescribeAntChainCertificateApplicationsResponseBodyResultPagination> pagination{};

  DescribeAntChainCertificateApplicationsResponseBodyResult() {}

  explicit DescribeAntChainCertificateApplicationsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateApplications) {
      vector<boost::any> temp1;
      for(auto item1:*certificateApplications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CertificateApplications"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateApplications") != m.end() && !m["CertificateApplications"].empty()) {
      if (typeid(vector<boost::any>) == m["CertificateApplications"].type()) {
        vector<DescribeAntChainCertificateApplicationsResponseBodyResultCertificateApplications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CertificateApplications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainCertificateApplicationsResponseBodyResultCertificateApplications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certificateApplications = make_shared<vector<DescribeAntChainCertificateApplicationsResponseBodyResultCertificateApplications>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainCertificateApplicationsResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainCertificateApplicationsResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeAntChainCertificateApplicationsResponseBodyResult() = default;
};
class DescribeAntChainCertificateApplicationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainCertificateApplicationsResponseBodyResult> result{};

  DescribeAntChainCertificateApplicationsResponseBody() {}

  explicit DescribeAntChainCertificateApplicationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainCertificateApplicationsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainCertificateApplicationsResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainCertificateApplicationsResponseBody() = default;
};
class DescribeAntChainCertificateApplicationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainCertificateApplicationsResponseBody> body{};

  DescribeAntChainCertificateApplicationsResponse() {}

  explicit DescribeAntChainCertificateApplicationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainCertificateApplicationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainCertificateApplicationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainCertificateApplicationsResponse() = default;
};
class DescribeAntChainCertificateApplicationsV2Request : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> consortiumId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> status{};

  DescribeAntChainCertificateApplicationsV2Request() {}

  explicit DescribeAntChainCertificateApplicationsV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeAntChainCertificateApplicationsV2Request() = default;
};
class DescribeAntChainCertificateApplicationsV2ResponseBodyResultCertificateApplications : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> bid{};
  shared_ptr<long> createtime{};
  shared_ptr<string> status{};
  shared_ptr<long> updatetime{};
  shared_ptr<string> username{};

  DescribeAntChainCertificateApplicationsV2ResponseBodyResultCertificateApplications() {}

  explicit DescribeAntChainCertificateApplicationsV2ResponseBodyResultCertificateApplications(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (bid) {
      res["Bid"] = boost::any(*bid);
    }
    if (createtime) {
      res["Createtime"] = boost::any(*createtime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (updatetime) {
      res["Updatetime"] = boost::any(*updatetime);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("Bid") != m.end() && !m["Bid"].empty()) {
      bid = make_shared<string>(boost::any_cast<string>(m["Bid"]));
    }
    if (m.find("Createtime") != m.end() && !m["Createtime"].empty()) {
      createtime = make_shared<long>(boost::any_cast<long>(m["Createtime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Updatetime") != m.end() && !m["Updatetime"].empty()) {
      updatetime = make_shared<long>(boost::any_cast<long>(m["Updatetime"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~DescribeAntChainCertificateApplicationsV2ResponseBodyResultCertificateApplications() = default;
};
class DescribeAntChainCertificateApplicationsV2ResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainCertificateApplicationsV2ResponseBodyResultPagination() {}

  explicit DescribeAntChainCertificateApplicationsV2ResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainCertificateApplicationsV2ResponseBodyResultPagination() = default;
};
class DescribeAntChainCertificateApplicationsV2ResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAntChainCertificateApplicationsV2ResponseBodyResultCertificateApplications>> certificateApplications{};
  shared_ptr<DescribeAntChainCertificateApplicationsV2ResponseBodyResultPagination> pagination{};

  DescribeAntChainCertificateApplicationsV2ResponseBodyResult() {}

  explicit DescribeAntChainCertificateApplicationsV2ResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (certificateApplications) {
      vector<boost::any> temp1;
      for(auto item1:*certificateApplications){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CertificateApplications"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CertificateApplications") != m.end() && !m["CertificateApplications"].empty()) {
      if (typeid(vector<boost::any>) == m["CertificateApplications"].type()) {
        vector<DescribeAntChainCertificateApplicationsV2ResponseBodyResultCertificateApplications> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CertificateApplications"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainCertificateApplicationsV2ResponseBodyResultCertificateApplications model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        certificateApplications = make_shared<vector<DescribeAntChainCertificateApplicationsV2ResponseBodyResultCertificateApplications>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainCertificateApplicationsV2ResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainCertificateApplicationsV2ResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeAntChainCertificateApplicationsV2ResponseBodyResult() = default;
};
class DescribeAntChainCertificateApplicationsV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainCertificateApplicationsV2ResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainCertificateApplicationsV2ResponseBody() {}

  explicit DescribeAntChainCertificateApplicationsV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainCertificateApplicationsV2ResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainCertificateApplicationsV2ResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainCertificateApplicationsV2ResponseBody() = default;
};
class DescribeAntChainCertificateApplicationsV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainCertificateApplicationsV2ResponseBody> body{};

  DescribeAntChainCertificateApplicationsV2Response() {}

  explicit DescribeAntChainCertificateApplicationsV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainCertificateApplicationsV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainCertificateApplicationsV2ResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainCertificateApplicationsV2Response() = default;
};
class DescribeAntChainConsortiumsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeAntChainConsortiumsRequest() {}

  explicit DescribeAntChainConsortiumsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeAntChainConsortiumsRequest() = default;
};
class DescribeAntChainConsortiumsResponseBodyResultAntConsortiums : public Darabonba::Model {
public:
  shared_ptr<long> chainNum{};
  shared_ptr<string> consortiumDescription{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> consortiumName{};
  shared_ptr<long> createTime{};
  shared_ptr<long> memberNum{};
  shared_ptr<string> role{};
  shared_ptr<string> status{};

  DescribeAntChainConsortiumsResponseBodyResultAntConsortiums() {}

  explicit DescribeAntChainConsortiumsResponseBodyResultAntConsortiums(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chainNum) {
      res["ChainNum"] = boost::any(*chainNum);
    }
    if (consortiumDescription) {
      res["ConsortiumDescription"] = boost::any(*consortiumDescription);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (consortiumName) {
      res["ConsortiumName"] = boost::any(*consortiumName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (memberNum) {
      res["MemberNum"] = boost::any(*memberNum);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChainNum") != m.end() && !m["ChainNum"].empty()) {
      chainNum = make_shared<long>(boost::any_cast<long>(m["ChainNum"]));
    }
    if (m.find("ConsortiumDescription") != m.end() && !m["ConsortiumDescription"].empty()) {
      consortiumDescription = make_shared<string>(boost::any_cast<string>(m["ConsortiumDescription"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("ConsortiumName") != m.end() && !m["ConsortiumName"].empty()) {
      consortiumName = make_shared<string>(boost::any_cast<string>(m["ConsortiumName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("MemberNum") != m.end() && !m["MemberNum"].empty()) {
      memberNum = make_shared<long>(boost::any_cast<long>(m["MemberNum"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeAntChainConsortiumsResponseBodyResultAntConsortiums() = default;
};
class DescribeAntChainConsortiumsResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainConsortiumsResponseBodyResultPagination() {}

  explicit DescribeAntChainConsortiumsResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainConsortiumsResponseBodyResultPagination() = default;
};
class DescribeAntChainConsortiumsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAntChainConsortiumsResponseBodyResultAntConsortiums>> antConsortiums{};
  shared_ptr<DescribeAntChainConsortiumsResponseBodyResultPagination> pagination{};

  DescribeAntChainConsortiumsResponseBodyResult() {}

  explicit DescribeAntChainConsortiumsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antConsortiums) {
      vector<boost::any> temp1;
      for(auto item1:*antConsortiums){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AntConsortiums"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntConsortiums") != m.end() && !m["AntConsortiums"].empty()) {
      if (typeid(vector<boost::any>) == m["AntConsortiums"].type()) {
        vector<DescribeAntChainConsortiumsResponseBodyResultAntConsortiums> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AntConsortiums"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainConsortiumsResponseBodyResultAntConsortiums model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        antConsortiums = make_shared<vector<DescribeAntChainConsortiumsResponseBodyResultAntConsortiums>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainConsortiumsResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainConsortiumsResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeAntChainConsortiumsResponseBodyResult() = default;
};
class DescribeAntChainConsortiumsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainConsortiumsResponseBodyResult> result{};

  DescribeAntChainConsortiumsResponseBody() {}

  explicit DescribeAntChainConsortiumsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainConsortiumsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainConsortiumsResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainConsortiumsResponseBody() = default;
};
class DescribeAntChainConsortiumsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainConsortiumsResponseBody> body{};

  DescribeAntChainConsortiumsResponse() {}

  explicit DescribeAntChainConsortiumsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainConsortiumsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainConsortiumsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainConsortiumsResponse() = default;
};
class DescribeAntChainConsortiumsV2Request : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeAntChainConsortiumsV2Request() {}

  explicit DescribeAntChainConsortiumsV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeAntChainConsortiumsV2Request() = default;
};
class DescribeAntChainConsortiumsV2ResponseBodyResultAntConsortiums : public Darabonba::Model {
public:
  shared_ptr<long> chainNum{};
  shared_ptr<string> consortiumDescription{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> consortiumName{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> isEmptyConsortium{};
  shared_ptr<long> memberNum{};
  shared_ptr<string> role{};
  shared_ptr<string> status{};

  DescribeAntChainConsortiumsV2ResponseBodyResultAntConsortiums() {}

  explicit DescribeAntChainConsortiumsV2ResponseBodyResultAntConsortiums(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chainNum) {
      res["ChainNum"] = boost::any(*chainNum);
    }
    if (consortiumDescription) {
      res["ConsortiumDescription"] = boost::any(*consortiumDescription);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (consortiumName) {
      res["ConsortiumName"] = boost::any(*consortiumName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (isEmptyConsortium) {
      res["IsEmptyConsortium"] = boost::any(*isEmptyConsortium);
    }
    if (memberNum) {
      res["MemberNum"] = boost::any(*memberNum);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChainNum") != m.end() && !m["ChainNum"].empty()) {
      chainNum = make_shared<long>(boost::any_cast<long>(m["ChainNum"]));
    }
    if (m.find("ConsortiumDescription") != m.end() && !m["ConsortiumDescription"].empty()) {
      consortiumDescription = make_shared<string>(boost::any_cast<string>(m["ConsortiumDescription"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("ConsortiumName") != m.end() && !m["ConsortiumName"].empty()) {
      consortiumName = make_shared<string>(boost::any_cast<string>(m["ConsortiumName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("IsEmptyConsortium") != m.end() && !m["IsEmptyConsortium"].empty()) {
      isEmptyConsortium = make_shared<bool>(boost::any_cast<bool>(m["IsEmptyConsortium"]));
    }
    if (m.find("MemberNum") != m.end() && !m["MemberNum"].empty()) {
      memberNum = make_shared<long>(boost::any_cast<long>(m["MemberNum"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeAntChainConsortiumsV2ResponseBodyResultAntConsortiums() = default;
};
class DescribeAntChainConsortiumsV2ResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainConsortiumsV2ResponseBodyResultPagination() {}

  explicit DescribeAntChainConsortiumsV2ResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainConsortiumsV2ResponseBodyResultPagination() = default;
};
class DescribeAntChainConsortiumsV2ResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAntChainConsortiumsV2ResponseBodyResultAntConsortiums>> antConsortiums{};
  shared_ptr<DescribeAntChainConsortiumsV2ResponseBodyResultPagination> pagination{};

  DescribeAntChainConsortiumsV2ResponseBodyResult() {}

  explicit DescribeAntChainConsortiumsV2ResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antConsortiums) {
      vector<boost::any> temp1;
      for(auto item1:*antConsortiums){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AntConsortiums"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntConsortiums") != m.end() && !m["AntConsortiums"].empty()) {
      if (typeid(vector<boost::any>) == m["AntConsortiums"].type()) {
        vector<DescribeAntChainConsortiumsV2ResponseBodyResultAntConsortiums> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AntConsortiums"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainConsortiumsV2ResponseBodyResultAntConsortiums model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        antConsortiums = make_shared<vector<DescribeAntChainConsortiumsV2ResponseBodyResultAntConsortiums>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainConsortiumsV2ResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainConsortiumsV2ResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeAntChainConsortiumsV2ResponseBodyResult() = default;
};
class DescribeAntChainConsortiumsV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainConsortiumsV2ResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainConsortiumsV2ResponseBody() {}

  explicit DescribeAntChainConsortiumsV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainConsortiumsV2ResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainConsortiumsV2ResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainConsortiumsV2ResponseBody() = default;
};
class DescribeAntChainConsortiumsV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainConsortiumsV2ResponseBody> body{};

  DescribeAntChainConsortiumsV2Response() {}

  explicit DescribeAntChainConsortiumsV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainConsortiumsV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainConsortiumsV2ResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainConsortiumsV2Response() = default;
};
class DescribeAntChainContractProjectContentTreeRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectId{};

  DescribeAntChainContractProjectContentTreeRequest() {}

  explicit DescribeAntChainContractProjectContentTreeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~DescribeAntChainContractProjectContentTreeRequest() = default;
};
class DescribeAntChainContractProjectContentTreeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<map<string, boost::any>>> children{};
  shared_ptr<string> projectDescription{};
  shared_ptr<string> projectId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> projectVersion{};

  DescribeAntChainContractProjectContentTreeResponseBodyResult() {}

  explicit DescribeAntChainContractProjectContentTreeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (children) {
      res["Children"] = boost::any(*children);
    }
    if (projectDescription) {
      res["ProjectDescription"] = boost::any(*projectDescription);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (projectVersion) {
      res["ProjectVersion"] = boost::any(*projectVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Children") != m.end() && !m["Children"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Children"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Children"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      children = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("ProjectDescription") != m.end() && !m["ProjectDescription"].empty()) {
      projectDescription = make_shared<string>(boost::any_cast<string>(m["ProjectDescription"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProjectVersion") != m.end() && !m["ProjectVersion"].empty()) {
      projectVersion = make_shared<string>(boost::any_cast<string>(m["ProjectVersion"]));
    }
  }


  virtual ~DescribeAntChainContractProjectContentTreeResponseBodyResult() = default;
};
class DescribeAntChainContractProjectContentTreeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainContractProjectContentTreeResponseBodyResult> result{};

  DescribeAntChainContractProjectContentTreeResponseBody() {}

  explicit DescribeAntChainContractProjectContentTreeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainContractProjectContentTreeResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainContractProjectContentTreeResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainContractProjectContentTreeResponseBody() = default;
};
class DescribeAntChainContractProjectContentTreeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainContractProjectContentTreeResponseBody> body{};

  DescribeAntChainContractProjectContentTreeResponse() {}

  explicit DescribeAntChainContractProjectContentTreeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainContractProjectContentTreeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainContractProjectContentTreeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainContractProjectContentTreeResponse() = default;
};
class DescribeAntChainContractProjectContentTreeV2Request : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> projectId{};

  DescribeAntChainContractProjectContentTreeV2Request() {}

  explicit DescribeAntChainContractProjectContentTreeV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
  }


  virtual ~DescribeAntChainContractProjectContentTreeV2Request() = default;
};
class DescribeAntChainContractProjectContentTreeV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainContractProjectContentTreeV2ResponseBody() {}

  explicit DescribeAntChainContractProjectContentTreeV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainContractProjectContentTreeV2ResponseBody() = default;
};
class DescribeAntChainContractProjectContentTreeV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainContractProjectContentTreeV2ResponseBody> body{};

  DescribeAntChainContractProjectContentTreeV2Response() {}

  explicit DescribeAntChainContractProjectContentTreeV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainContractProjectContentTreeV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainContractProjectContentTreeV2ResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainContractProjectContentTreeV2Response() = default;
};
class DescribeAntChainContractProjectsRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeAntChainContractProjectsRequest() {}

  explicit DescribeAntChainContractProjectsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeAntChainContractProjectsRequest() = default;
};
class DescribeAntChainContractProjectsResponseBodyResultContractProjects : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> projectDescription{};
  shared_ptr<string> projectId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> projectVersion{};
  shared_ptr<long> updateTime{};

  DescribeAntChainContractProjectsResponseBodyResultContractProjects() {}

  explicit DescribeAntChainContractProjectsResponseBodyResultContractProjects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (projectDescription) {
      res["ProjectDescription"] = boost::any(*projectDescription);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (projectVersion) {
      res["ProjectVersion"] = boost::any(*projectVersion);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ProjectDescription") != m.end() && !m["ProjectDescription"].empty()) {
      projectDescription = make_shared<string>(boost::any_cast<string>(m["ProjectDescription"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProjectVersion") != m.end() && !m["ProjectVersion"].empty()) {
      projectVersion = make_shared<string>(boost::any_cast<string>(m["ProjectVersion"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeAntChainContractProjectsResponseBodyResultContractProjects() = default;
};
class DescribeAntChainContractProjectsResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainContractProjectsResponseBodyResultPagination() {}

  explicit DescribeAntChainContractProjectsResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainContractProjectsResponseBodyResultPagination() = default;
};
class DescribeAntChainContractProjectsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAntChainContractProjectsResponseBodyResultContractProjects>> contractProjects{};
  shared_ptr<DescribeAntChainContractProjectsResponseBodyResultPagination> pagination{};

  DescribeAntChainContractProjectsResponseBodyResult() {}

  explicit DescribeAntChainContractProjectsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contractProjects) {
      vector<boost::any> temp1;
      for(auto item1:*contractProjects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ContractProjects"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContractProjects") != m.end() && !m["ContractProjects"].empty()) {
      if (typeid(vector<boost::any>) == m["ContractProjects"].type()) {
        vector<DescribeAntChainContractProjectsResponseBodyResultContractProjects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ContractProjects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainContractProjectsResponseBodyResultContractProjects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contractProjects = make_shared<vector<DescribeAntChainContractProjectsResponseBodyResultContractProjects>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainContractProjectsResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainContractProjectsResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeAntChainContractProjectsResponseBodyResult() = default;
};
class DescribeAntChainContractProjectsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainContractProjectsResponseBodyResult> result{};

  DescribeAntChainContractProjectsResponseBody() {}

  explicit DescribeAntChainContractProjectsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainContractProjectsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainContractProjectsResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainContractProjectsResponseBody() = default;
};
class DescribeAntChainContractProjectsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainContractProjectsResponseBody> body{};

  DescribeAntChainContractProjectsResponse() {}

  explicit DescribeAntChainContractProjectsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainContractProjectsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainContractProjectsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainContractProjectsResponse() = default;
};
class DescribeAntChainContractProjectsV2Request : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeAntChainContractProjectsV2Request() {}

  explicit DescribeAntChainContractProjectsV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeAntChainContractProjectsV2Request() = default;
};
class DescribeAntChainContractProjectsV2ResponseBodyResultContractProjects : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> projectDescription{};
  shared_ptr<string> projectId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> projectVersion{};
  shared_ptr<long> updateTime{};

  DescribeAntChainContractProjectsV2ResponseBodyResultContractProjects() {}

  explicit DescribeAntChainContractProjectsV2ResponseBodyResultContractProjects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (projectDescription) {
      res["ProjectDescription"] = boost::any(*projectDescription);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (projectVersion) {
      res["ProjectVersion"] = boost::any(*projectVersion);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ProjectDescription") != m.end() && !m["ProjectDescription"].empty()) {
      projectDescription = make_shared<string>(boost::any_cast<string>(m["ProjectDescription"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProjectVersion") != m.end() && !m["ProjectVersion"].empty()) {
      projectVersion = make_shared<string>(boost::any_cast<string>(m["ProjectVersion"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeAntChainContractProjectsV2ResponseBodyResultContractProjects() = default;
};
class DescribeAntChainContractProjectsV2ResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainContractProjectsV2ResponseBodyResultPagination() {}

  explicit DescribeAntChainContractProjectsV2ResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainContractProjectsV2ResponseBodyResultPagination() = default;
};
class DescribeAntChainContractProjectsV2ResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAntChainContractProjectsV2ResponseBodyResultContractProjects>> contractProjects{};
  shared_ptr<DescribeAntChainContractProjectsV2ResponseBodyResultPagination> pagination{};

  DescribeAntChainContractProjectsV2ResponseBodyResult() {}

  explicit DescribeAntChainContractProjectsV2ResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contractProjects) {
      vector<boost::any> temp1;
      for(auto item1:*contractProjects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ContractProjects"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContractProjects") != m.end() && !m["ContractProjects"].empty()) {
      if (typeid(vector<boost::any>) == m["ContractProjects"].type()) {
        vector<DescribeAntChainContractProjectsV2ResponseBodyResultContractProjects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ContractProjects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainContractProjectsV2ResponseBodyResultContractProjects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        contractProjects = make_shared<vector<DescribeAntChainContractProjectsV2ResponseBodyResultContractProjects>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainContractProjectsV2ResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainContractProjectsV2ResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeAntChainContractProjectsV2ResponseBodyResult() = default;
};
class DescribeAntChainContractProjectsV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainContractProjectsV2ResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainContractProjectsV2ResponseBody() {}

  explicit DescribeAntChainContractProjectsV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainContractProjectsV2ResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainContractProjectsV2ResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainContractProjectsV2ResponseBody() = default;
};
class DescribeAntChainContractProjectsV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainContractProjectsV2ResponseBody> body{};

  DescribeAntChainContractProjectsV2Response() {}

  explicit DescribeAntChainContractProjectsV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainContractProjectsV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainContractProjectsV2ResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainContractProjectsV2Response() = default;
};
class DescribeAntChainDownloadPathsRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};

  DescribeAntChainDownloadPathsRequest() {}

  explicit DescribeAntChainDownloadPathsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
  }


  virtual ~DescribeAntChainDownloadPathsRequest() = default;
};
class DescribeAntChainDownloadPathsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> caCrtUrl{};
  shared_ptr<string> clientCrtUrl{};
  shared_ptr<string> sdkUrl{};
  shared_ptr<string> trustCaUrl{};

  DescribeAntChainDownloadPathsResponseBodyResult() {}

  explicit DescribeAntChainDownloadPathsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caCrtUrl) {
      res["CaCrtUrl"] = boost::any(*caCrtUrl);
    }
    if (clientCrtUrl) {
      res["ClientCrtUrl"] = boost::any(*clientCrtUrl);
    }
    if (sdkUrl) {
      res["SdkUrl"] = boost::any(*sdkUrl);
    }
    if (trustCaUrl) {
      res["TrustCaUrl"] = boost::any(*trustCaUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaCrtUrl") != m.end() && !m["CaCrtUrl"].empty()) {
      caCrtUrl = make_shared<string>(boost::any_cast<string>(m["CaCrtUrl"]));
    }
    if (m.find("ClientCrtUrl") != m.end() && !m["ClientCrtUrl"].empty()) {
      clientCrtUrl = make_shared<string>(boost::any_cast<string>(m["ClientCrtUrl"]));
    }
    if (m.find("SdkUrl") != m.end() && !m["SdkUrl"].empty()) {
      sdkUrl = make_shared<string>(boost::any_cast<string>(m["SdkUrl"]));
    }
    if (m.find("TrustCaUrl") != m.end() && !m["TrustCaUrl"].empty()) {
      trustCaUrl = make_shared<string>(boost::any_cast<string>(m["TrustCaUrl"]));
    }
  }


  virtual ~DescribeAntChainDownloadPathsResponseBodyResult() = default;
};
class DescribeAntChainDownloadPathsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainDownloadPathsResponseBodyResult> result{};

  DescribeAntChainDownloadPathsResponseBody() {}

  explicit DescribeAntChainDownloadPathsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainDownloadPathsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainDownloadPathsResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainDownloadPathsResponseBody() = default;
};
class DescribeAntChainDownloadPathsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainDownloadPathsResponseBody> body{};

  DescribeAntChainDownloadPathsResponse() {}

  explicit DescribeAntChainDownloadPathsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainDownloadPathsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainDownloadPathsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainDownloadPathsResponse() = default;
};
class DescribeAntChainDownloadPathsV2Request : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> consortiumId{};

  DescribeAntChainDownloadPathsV2Request() {}

  explicit DescribeAntChainDownloadPathsV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
  }


  virtual ~DescribeAntChainDownloadPathsV2Request() = default;
};
class DescribeAntChainDownloadPathsV2ResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> caCrtUrl{};
  shared_ptr<string> clientCrtUrl{};
  shared_ptr<string> sdkUrl{};
  shared_ptr<string> trustCaUrl{};

  DescribeAntChainDownloadPathsV2ResponseBodyResult() {}

  explicit DescribeAntChainDownloadPathsV2ResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (caCrtUrl) {
      res["CaCrtUrl"] = boost::any(*caCrtUrl);
    }
    if (clientCrtUrl) {
      res["ClientCrtUrl"] = boost::any(*clientCrtUrl);
    }
    if (sdkUrl) {
      res["SdkUrl"] = boost::any(*sdkUrl);
    }
    if (trustCaUrl) {
      res["TrustCaUrl"] = boost::any(*trustCaUrl);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CaCrtUrl") != m.end() && !m["CaCrtUrl"].empty()) {
      caCrtUrl = make_shared<string>(boost::any_cast<string>(m["CaCrtUrl"]));
    }
    if (m.find("ClientCrtUrl") != m.end() && !m["ClientCrtUrl"].empty()) {
      clientCrtUrl = make_shared<string>(boost::any_cast<string>(m["ClientCrtUrl"]));
    }
    if (m.find("SdkUrl") != m.end() && !m["SdkUrl"].empty()) {
      sdkUrl = make_shared<string>(boost::any_cast<string>(m["SdkUrl"]));
    }
    if (m.find("TrustCaUrl") != m.end() && !m["TrustCaUrl"].empty()) {
      trustCaUrl = make_shared<string>(boost::any_cast<string>(m["TrustCaUrl"]));
    }
  }


  virtual ~DescribeAntChainDownloadPathsV2ResponseBodyResult() = default;
};
class DescribeAntChainDownloadPathsV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainDownloadPathsV2ResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainDownloadPathsV2ResponseBody() {}

  explicit DescribeAntChainDownloadPathsV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainDownloadPathsV2ResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainDownloadPathsV2ResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainDownloadPathsV2ResponseBody() = default;
};
class DescribeAntChainDownloadPathsV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainDownloadPathsV2ResponseBody> body{};

  DescribeAntChainDownloadPathsV2Response() {}

  explicit DescribeAntChainDownloadPathsV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainDownloadPathsV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainDownloadPathsV2ResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainDownloadPathsV2Response() = default;
};
class DescribeAntChainInformationRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};

  DescribeAntChainInformationRequest() {}

  explicit DescribeAntChainInformationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
  }


  virtual ~DescribeAntChainInformationRequest() = default;
};
class DescribeAntChainInformationResponseBodyResultNodeInfos : public Darabonba::Model {
public:
  shared_ptr<long> blockHeight{};
  shared_ptr<string> nodeName{};
  shared_ptr<bool> status{};
  shared_ptr<string> version{};

  DescribeAntChainInformationResponseBodyResultNodeInfos() {}

  explicit DescribeAntChainInformationResponseBodyResultNodeInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockHeight) {
      res["BlockHeight"] = boost::any(*blockHeight);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockHeight") != m.end() && !m["BlockHeight"].empty()) {
      blockHeight = make_shared<long>(boost::any_cast<long>(m["BlockHeight"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeAntChainInformationResponseBodyResultNodeInfos() = default;
};
class DescribeAntChainInformationResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> abnormalNodes{};
  shared_ptr<string> antChainId{};
  shared_ptr<long> blockHeight{};
  shared_ptr<long> createTime{};
  shared_ptr<vector<DescribeAntChainInformationResponseBodyResultNodeInfos>> nodeInfos{};
  shared_ptr<long> nodeNumber{};
  shared_ptr<bool> normal{};
  shared_ptr<long> transactionSum{};
  shared_ptr<string> version{};

  DescribeAntChainInformationResponseBodyResult() {}

  explicit DescribeAntChainInformationResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnormalNodes) {
      res["AbnormalNodes"] = boost::any(*abnormalNodes);
    }
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (blockHeight) {
      res["BlockHeight"] = boost::any(*blockHeight);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (nodeInfos) {
      vector<boost::any> temp1;
      for(auto item1:*nodeInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeInfos"] = boost::any(temp1);
    }
    if (nodeNumber) {
      res["NodeNumber"] = boost::any(*nodeNumber);
    }
    if (normal) {
      res["Normal"] = boost::any(*normal);
    }
    if (transactionSum) {
      res["TransactionSum"] = boost::any(*transactionSum);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbnormalNodes") != m.end() && !m["AbnormalNodes"].empty()) {
      abnormalNodes = make_shared<long>(boost::any_cast<long>(m["AbnormalNodes"]));
    }
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("BlockHeight") != m.end() && !m["BlockHeight"].empty()) {
      blockHeight = make_shared<long>(boost::any_cast<long>(m["BlockHeight"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("NodeInfos") != m.end() && !m["NodeInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeInfos"].type()) {
        vector<DescribeAntChainInformationResponseBodyResultNodeInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainInformationResponseBodyResultNodeInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeInfos = make_shared<vector<DescribeAntChainInformationResponseBodyResultNodeInfos>>(expect1);
      }
    }
    if (m.find("NodeNumber") != m.end() && !m["NodeNumber"].empty()) {
      nodeNumber = make_shared<long>(boost::any_cast<long>(m["NodeNumber"]));
    }
    if (m.find("Normal") != m.end() && !m["Normal"].empty()) {
      normal = make_shared<bool>(boost::any_cast<bool>(m["Normal"]));
    }
    if (m.find("TransactionSum") != m.end() && !m["TransactionSum"].empty()) {
      transactionSum = make_shared<long>(boost::any_cast<long>(m["TransactionSum"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeAntChainInformationResponseBodyResult() = default;
};
class DescribeAntChainInformationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainInformationResponseBodyResult> result{};

  DescribeAntChainInformationResponseBody() {}

  explicit DescribeAntChainInformationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainInformationResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainInformationResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainInformationResponseBody() = default;
};
class DescribeAntChainInformationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainInformationResponseBody> body{};

  DescribeAntChainInformationResponse() {}

  explicit DescribeAntChainInformationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainInformationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainInformationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainInformationResponse() = default;
};
class DescribeAntChainInformationV2Request : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> consortiumId{};

  DescribeAntChainInformationV2Request() {}

  explicit DescribeAntChainInformationV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
  }


  virtual ~DescribeAntChainInformationV2Request() = default;
};
class DescribeAntChainInformationV2ResponseBodyResultNodeInfos : public Darabonba::Model {
public:
  shared_ptr<long> blockHeight{};
  shared_ptr<string> nodeName{};
  shared_ptr<bool> status{};
  shared_ptr<string> version{};

  DescribeAntChainInformationV2ResponseBodyResultNodeInfos() {}

  explicit DescribeAntChainInformationV2ResponseBodyResultNodeInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockHeight) {
      res["BlockHeight"] = boost::any(*blockHeight);
    }
    if (nodeName) {
      res["NodeName"] = boost::any(*nodeName);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockHeight") != m.end() && !m["BlockHeight"].empty()) {
      blockHeight = make_shared<long>(boost::any_cast<long>(m["BlockHeight"]));
    }
    if (m.find("NodeName") != m.end() && !m["NodeName"].empty()) {
      nodeName = make_shared<string>(boost::any_cast<string>(m["NodeName"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<bool>(boost::any_cast<bool>(m["Status"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeAntChainInformationV2ResponseBodyResultNodeInfos() = default;
};
class DescribeAntChainInformationV2ResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> abnormalNodes{};
  shared_ptr<string> antChainId{};
  shared_ptr<long> blockHeight{};
  shared_ptr<long> createTime{};
  shared_ptr<bool> isRole{};
  shared_ptr<vector<DescribeAntChainInformationV2ResponseBodyResultNodeInfos>> nodeInfos{};
  shared_ptr<long> nodeNumber{};
  shared_ptr<bool> normal{};
  shared_ptr<long> transactionSum{};
  shared_ptr<string> version{};

  DescribeAntChainInformationV2ResponseBodyResult() {}

  explicit DescribeAntChainInformationV2ResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (abnormalNodes) {
      res["AbnormalNodes"] = boost::any(*abnormalNodes);
    }
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (blockHeight) {
      res["BlockHeight"] = boost::any(*blockHeight);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (isRole) {
      res["IsRole"] = boost::any(*isRole);
    }
    if (nodeInfos) {
      vector<boost::any> temp1;
      for(auto item1:*nodeInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeInfos"] = boost::any(temp1);
    }
    if (nodeNumber) {
      res["NodeNumber"] = boost::any(*nodeNumber);
    }
    if (normal) {
      res["Normal"] = boost::any(*normal);
    }
    if (transactionSum) {
      res["TransactionSum"] = boost::any(*transactionSum);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AbnormalNodes") != m.end() && !m["AbnormalNodes"].empty()) {
      abnormalNodes = make_shared<long>(boost::any_cast<long>(m["AbnormalNodes"]));
    }
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("BlockHeight") != m.end() && !m["BlockHeight"].empty()) {
      blockHeight = make_shared<long>(boost::any_cast<long>(m["BlockHeight"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("IsRole") != m.end() && !m["IsRole"].empty()) {
      isRole = make_shared<bool>(boost::any_cast<bool>(m["IsRole"]));
    }
    if (m.find("NodeInfos") != m.end() && !m["NodeInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeInfos"].type()) {
        vector<DescribeAntChainInformationV2ResponseBodyResultNodeInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainInformationV2ResponseBodyResultNodeInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeInfos = make_shared<vector<DescribeAntChainInformationV2ResponseBodyResultNodeInfos>>(expect1);
      }
    }
    if (m.find("NodeNumber") != m.end() && !m["NodeNumber"].empty()) {
      nodeNumber = make_shared<long>(boost::any_cast<long>(m["NodeNumber"]));
    }
    if (m.find("Normal") != m.end() && !m["Normal"].empty()) {
      normal = make_shared<bool>(boost::any_cast<bool>(m["Normal"]));
    }
    if (m.find("TransactionSum") != m.end() && !m["TransactionSum"].empty()) {
      transactionSum = make_shared<long>(boost::any_cast<long>(m["TransactionSum"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeAntChainInformationV2ResponseBodyResult() = default;
};
class DescribeAntChainInformationV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainInformationV2ResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainInformationV2ResponseBody() {}

  explicit DescribeAntChainInformationV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainInformationV2ResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainInformationV2ResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainInformationV2ResponseBody() = default;
};
class DescribeAntChainInformationV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainInformationV2ResponseBody> body{};

  DescribeAntChainInformationV2Response() {}

  explicit DescribeAntChainInformationV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainInformationV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainInformationV2ResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainInformationV2Response() = default;
};
class DescribeAntChainLatestBlocksRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};

  DescribeAntChainLatestBlocksRequest() {}

  explicit DescribeAntChainLatestBlocksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
  }


  virtual ~DescribeAntChainLatestBlocksRequest() = default;
};
class DescribeAntChainLatestBlocksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<map<string, boost::any>>> result{};

  DescribeAntChainLatestBlocksResponseBody() {}

  explicit DescribeAntChainLatestBlocksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Result"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      result = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
  }


  virtual ~DescribeAntChainLatestBlocksResponseBody() = default;
};
class DescribeAntChainLatestBlocksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainLatestBlocksResponseBody> body{};

  DescribeAntChainLatestBlocksResponse() {}

  explicit DescribeAntChainLatestBlocksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainLatestBlocksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainLatestBlocksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainLatestBlocksResponse() = default;
};
class DescribeAntChainLatestBlocksV2Request : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> consortiumId{};

  DescribeAntChainLatestBlocksV2Request() {}

  explicit DescribeAntChainLatestBlocksV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
  }


  virtual ~DescribeAntChainLatestBlocksV2Request() = default;
};
class DescribeAntChainLatestBlocksV2ResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> bizData{};
  shared_ptr<string> blockHash{};
  shared_ptr<long> createTime{};
  shared_ptr<long> height{};
  shared_ptr<string> previousHash{};
  shared_ptr<string> rootTxHash{};
  shared_ptr<long> size{};
  shared_ptr<long> transactionSize{};
  shared_ptr<long> version{};

  DescribeAntChainLatestBlocksV2ResponseBodyResult() {}

  explicit DescribeAntChainLatestBlocksV2ResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (bizData) {
      res["BizData"] = boost::any(*bizData);
    }
    if (blockHash) {
      res["BlockHash"] = boost::any(*blockHash);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (previousHash) {
      res["PreviousHash"] = boost::any(*previousHash);
    }
    if (rootTxHash) {
      res["RootTxHash"] = boost::any(*rootTxHash);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (transactionSize) {
      res["TransactionSize"] = boost::any(*transactionSize);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("BizData") != m.end() && !m["BizData"].empty()) {
      bizData = make_shared<string>(boost::any_cast<string>(m["BizData"]));
    }
    if (m.find("BlockHash") != m.end() && !m["BlockHash"].empty()) {
      blockHash = make_shared<string>(boost::any_cast<string>(m["BlockHash"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("PreviousHash") != m.end() && !m["PreviousHash"].empty()) {
      previousHash = make_shared<string>(boost::any_cast<string>(m["PreviousHash"]));
    }
    if (m.find("RootTxHash") != m.end() && !m["RootTxHash"].empty()) {
      rootTxHash = make_shared<string>(boost::any_cast<string>(m["RootTxHash"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("TransactionSize") != m.end() && !m["TransactionSize"].empty()) {
      transactionSize = make_shared<long>(boost::any_cast<long>(m["TransactionSize"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["Version"]));
    }
  }


  virtual ~DescribeAntChainLatestBlocksV2ResponseBodyResult() = default;
};
class DescribeAntChainLatestBlocksV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeAntChainLatestBlocksV2ResponseBodyResult>> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainLatestBlocksV2ResponseBody() {}

  explicit DescribeAntChainLatestBlocksV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeAntChainLatestBlocksV2ResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainLatestBlocksV2ResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeAntChainLatestBlocksV2ResponseBodyResult>>(expect1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainLatestBlocksV2ResponseBody() = default;
};
class DescribeAntChainLatestBlocksV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainLatestBlocksV2ResponseBody> body{};

  DescribeAntChainLatestBlocksV2Response() {}

  explicit DescribeAntChainLatestBlocksV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainLatestBlocksV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainLatestBlocksV2ResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainLatestBlocksV2Response() = default;
};
class DescribeAntChainLatestTransactionDigestsRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};

  DescribeAntChainLatestTransactionDigestsRequest() {}

  explicit DescribeAntChainLatestTransactionDigestsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
  }


  virtual ~DescribeAntChainLatestTransactionDigestsRequest() = default;
};
class DescribeAntChainLatestTransactionDigestsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<map<string, boost::any>>> result{};

  DescribeAntChainLatestTransactionDigestsResponseBody() {}

  explicit DescribeAntChainLatestTransactionDigestsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Result"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      result = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
  }


  virtual ~DescribeAntChainLatestTransactionDigestsResponseBody() = default;
};
class DescribeAntChainLatestTransactionDigestsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainLatestTransactionDigestsResponseBody> body{};

  DescribeAntChainLatestTransactionDigestsResponse() {}

  explicit DescribeAntChainLatestTransactionDigestsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainLatestTransactionDigestsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainLatestTransactionDigestsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainLatestTransactionDigestsResponse() = default;
};
class DescribeAntChainLatestTransactionDigestsV2Request : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> consortiumId{};

  DescribeAntChainLatestTransactionDigestsV2Request() {}

  explicit DescribeAntChainLatestTransactionDigestsV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
  }


  virtual ~DescribeAntChainLatestTransactionDigestsV2Request() = default;
};
class DescribeAntChainLatestTransactionDigestsV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainLatestTransactionDigestsV2ResponseBody() {}

  explicit DescribeAntChainLatestTransactionDigestsV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Result"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      result = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainLatestTransactionDigestsV2ResponseBody() = default;
};
class DescribeAntChainLatestTransactionDigestsV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainLatestTransactionDigestsV2ResponseBody> body{};

  DescribeAntChainLatestTransactionDigestsV2Response() {}

  explicit DescribeAntChainLatestTransactionDigestsV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainLatestTransactionDigestsV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainLatestTransactionDigestsV2ResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainLatestTransactionDigestsV2Response() = default;
};
class DescribeAntChainMembersRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeAntChainMembersRequest() {}

  explicit DescribeAntChainMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeAntChainMembersRequest() = default;
};
class DescribeAntChainMembersResponseBodyResultMembers : public Darabonba::Model {
public:
  shared_ptr<long> joinTime{};
  shared_ptr<string> memberId{};
  shared_ptr<string> memberName{};
  shared_ptr<string> role{};
  shared_ptr<string> status{};

  DescribeAntChainMembersResponseBodyResultMembers() {}

  explicit DescribeAntChainMembersResponseBodyResultMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (joinTime) {
      res["JoinTime"] = boost::any(*joinTime);
    }
    if (memberId) {
      res["MemberId"] = boost::any(*memberId);
    }
    if (memberName) {
      res["MemberName"] = boost::any(*memberName);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JoinTime") != m.end() && !m["JoinTime"].empty()) {
      joinTime = make_shared<long>(boost::any_cast<long>(m["JoinTime"]));
    }
    if (m.find("MemberId") != m.end() && !m["MemberId"].empty()) {
      memberId = make_shared<string>(boost::any_cast<string>(m["MemberId"]));
    }
    if (m.find("MemberName") != m.end() && !m["MemberName"].empty()) {
      memberName = make_shared<string>(boost::any_cast<string>(m["MemberName"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeAntChainMembersResponseBodyResultMembers() = default;
};
class DescribeAntChainMembersResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainMembersResponseBodyResultPagination() {}

  explicit DescribeAntChainMembersResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainMembersResponseBodyResultPagination() = default;
};
class DescribeAntChainMembersResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAntChainMembersResponseBodyResultMembers>> members{};
  shared_ptr<DescribeAntChainMembersResponseBodyResultPagination> pagination{};

  DescribeAntChainMembersResponseBodyResult() {}

  explicit DescribeAntChainMembersResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (members) {
      vector<boost::any> temp1;
      for(auto item1:*members){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Members"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      if (typeid(vector<boost::any>) == m["Members"].type()) {
        vector<DescribeAntChainMembersResponseBodyResultMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Members"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainMembersResponseBodyResultMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        members = make_shared<vector<DescribeAntChainMembersResponseBodyResultMembers>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainMembersResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainMembersResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeAntChainMembersResponseBodyResult() = default;
};
class DescribeAntChainMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainMembersResponseBodyResult> result{};

  DescribeAntChainMembersResponseBody() {}

  explicit DescribeAntChainMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainMembersResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainMembersResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainMembersResponseBody() = default;
};
class DescribeAntChainMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainMembersResponseBody> body{};

  DescribeAntChainMembersResponse() {}

  explicit DescribeAntChainMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainMembersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainMembersResponse() = default;
};
class DescribeAntChainMembersV2Request : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeAntChainMembersV2Request() {}

  explicit DescribeAntChainMembersV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeAntChainMembersV2Request() = default;
};
class DescribeAntChainMembersV2ResponseBodyResultMembers : public Darabonba::Model {
public:
  shared_ptr<long> joinTime{};
  shared_ptr<string> memberId{};
  shared_ptr<string> memberName{};
  shared_ptr<string> role{};
  shared_ptr<string> status{};

  DescribeAntChainMembersV2ResponseBodyResultMembers() {}

  explicit DescribeAntChainMembersV2ResponseBodyResultMembers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (joinTime) {
      res["JoinTime"] = boost::any(*joinTime);
    }
    if (memberId) {
      res["MemberId"] = boost::any(*memberId);
    }
    if (memberName) {
      res["MemberName"] = boost::any(*memberName);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("JoinTime") != m.end() && !m["JoinTime"].empty()) {
      joinTime = make_shared<long>(boost::any_cast<long>(m["JoinTime"]));
    }
    if (m.find("MemberId") != m.end() && !m["MemberId"].empty()) {
      memberId = make_shared<string>(boost::any_cast<string>(m["MemberId"]));
    }
    if (m.find("MemberName") != m.end() && !m["MemberName"].empty()) {
      memberName = make_shared<string>(boost::any_cast<string>(m["MemberName"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DescribeAntChainMembersV2ResponseBodyResultMembers() = default;
};
class DescribeAntChainMembersV2ResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainMembersV2ResponseBodyResultPagination() {}

  explicit DescribeAntChainMembersV2ResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainMembersV2ResponseBodyResultPagination() = default;
};
class DescribeAntChainMembersV2ResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAntChainMembersV2ResponseBodyResultMembers>> members{};
  shared_ptr<DescribeAntChainMembersV2ResponseBodyResultPagination> pagination{};

  DescribeAntChainMembersV2ResponseBodyResult() {}

  explicit DescribeAntChainMembersV2ResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (members) {
      vector<boost::any> temp1;
      for(auto item1:*members){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Members"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Members") != m.end() && !m["Members"].empty()) {
      if (typeid(vector<boost::any>) == m["Members"].type()) {
        vector<DescribeAntChainMembersV2ResponseBodyResultMembers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Members"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainMembersV2ResponseBodyResultMembers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        members = make_shared<vector<DescribeAntChainMembersV2ResponseBodyResultMembers>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainMembersV2ResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainMembersV2ResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeAntChainMembersV2ResponseBodyResult() = default;
};
class DescribeAntChainMembersV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainMembersV2ResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainMembersV2ResponseBody() {}

  explicit DescribeAntChainMembersV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainMembersV2ResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainMembersV2ResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainMembersV2ResponseBody() = default;
};
class DescribeAntChainMembersV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainMembersV2ResponseBody> body{};

  DescribeAntChainMembersV2Response() {}

  explicit DescribeAntChainMembersV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainMembersV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainMembersV2ResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainMembersV2Response() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAccessLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> QRCodeType{};

  DescribeAntChainMiniAppBrowserQRCodeAccessLogRequest() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAccessLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (QRCodeType) {
      res["QRCodeType"] = boost::any(*QRCodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("QRCodeType") != m.end() && !m["QRCodeType"].empty()) {
      QRCodeType = make_shared<string>(boost::any_cast<string>(m["QRCodeType"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAccessLogRequest() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> accessAlipayAccountCount{};
  shared_ptr<long> accessCount{};

  DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBodyResult() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessAlipayAccountCount) {
      res["AccessAlipayAccountCount"] = boost::any(*accessAlipayAccountCount);
    }
    if (accessCount) {
      res["AccessCount"] = boost::any(*accessCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessAlipayAccountCount") != m.end() && !m["AccessAlipayAccountCount"].empty()) {
      accessAlipayAccountCount = make_shared<long>(boost::any_cast<long>(m["AccessAlipayAccountCount"]));
    }
    if (m.find("AccessCount") != m.end() && !m["AccessCount"].empty()) {
      accessCount = make_shared<long>(boost::any_cast<long>(m["AccessCount"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBodyResult() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBodyResult> result{};

  DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBody() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBody() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAccessLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBody> body{};

  DescribeAntChainMiniAppBrowserQRCodeAccessLogResponse() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAccessLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainMiniAppBrowserQRCodeAccessLogResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAccessLogResponse() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAccessLogV2Request : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> QRCodeType{};

  DescribeAntChainMiniAppBrowserQRCodeAccessLogV2Request() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAccessLogV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (QRCodeType) {
      res["QRCodeType"] = boost::any(*QRCodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("QRCodeType") != m.end() && !m["QRCodeType"].empty()) {
      QRCodeType = make_shared<string>(boost::any_cast<string>(m["QRCodeType"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAccessLogV2Request() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAccessLogV2ResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> accessAlipayAccountCount{};
  shared_ptr<long> accessCount{};

  DescribeAntChainMiniAppBrowserQRCodeAccessLogV2ResponseBodyResult() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAccessLogV2ResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessAlipayAccountCount) {
      res["AccessAlipayAccountCount"] = boost::any(*accessAlipayAccountCount);
    }
    if (accessCount) {
      res["AccessCount"] = boost::any(*accessCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessAlipayAccountCount") != m.end() && !m["AccessAlipayAccountCount"].empty()) {
      accessAlipayAccountCount = make_shared<long>(boost::any_cast<long>(m["AccessAlipayAccountCount"]));
    }
    if (m.find("AccessCount") != m.end() && !m["AccessCount"].empty()) {
      accessCount = make_shared<long>(boost::any_cast<long>(m["AccessCount"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAccessLogV2ResponseBodyResult() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAccessLogV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAccessLogV2ResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainMiniAppBrowserQRCodeAccessLogV2ResponseBody() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAccessLogV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainMiniAppBrowserQRCodeAccessLogV2ResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainMiniAppBrowserQRCodeAccessLogV2ResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAccessLogV2ResponseBody() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAccessLogV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAccessLogV2ResponseBody> body{};

  DescribeAntChainMiniAppBrowserQRCodeAccessLogV2Response() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAccessLogV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainMiniAppBrowserQRCodeAccessLogV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainMiniAppBrowserQRCodeAccessLogV2ResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAccessLogV2Response() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> QRCodeType{};

  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersRequest() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (QRCodeType) {
      res["QRCodeType"] = boost::any(*QRCodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QRCodeType") != m.end() && !m["QRCodeType"].empty()) {
      QRCodeType = make_shared<string>(boost::any_cast<string>(m["QRCodeType"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersRequest() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultAuthorizedUserList : public Darabonba::Model {
public:
  shared_ptr<string> gmtAuthorized{};
  shared_ptr<string> phone{};

  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultAuthorizedUserList() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultAuthorizedUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtAuthorized) {
      res["GmtAuthorized"] = boost::any(*gmtAuthorized);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtAuthorized") != m.end() && !m["GmtAuthorized"].empty()) {
      gmtAuthorized = make_shared<string>(boost::any_cast<string>(m["GmtAuthorized"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultAuthorizedUserList() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultPagination() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultPagination() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> authorizationType{};
  shared_ptr<vector<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultAuthorizedUserList>> authorizedUserList{};
  shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultPagination> pagination{};
  shared_ptr<string> QRCodeType{};

  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResult() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (authorizationType) {
      res["AuthorizationType"] = boost::any(*authorizationType);
    }
    if (authorizedUserList) {
      vector<boost::any> temp1;
      for(auto item1:*authorizedUserList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizedUserList"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (QRCodeType) {
      res["QRCodeType"] = boost::any(*QRCodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("AuthorizationType") != m.end() && !m["AuthorizationType"].empty()) {
      authorizationType = make_shared<string>(boost::any_cast<string>(m["AuthorizationType"]));
    }
    if (m.find("AuthorizedUserList") != m.end() && !m["AuthorizedUserList"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizedUserList"].type()) {
        vector<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultAuthorizedUserList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizedUserList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultAuthorizedUserList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizedUserList = make_shared<vector<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultAuthorizedUserList>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResultPagination>(model1);
      }
    }
    if (m.find("QRCodeType") != m.end() && !m["QRCodeType"].empty()) {
      QRCodeType = make_shared<string>(boost::any_cast<string>(m["QRCodeType"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResult() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResult> result{};

  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody> body{};

  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponse() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponse() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2Request : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> QRCodeType{};

  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2Request() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (QRCodeType) {
      res["QRCodeType"] = boost::any(*QRCodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("QRCodeType") != m.end() && !m["QRCodeType"].empty()) {
      QRCodeType = make_shared<string>(boost::any_cast<string>(m["QRCodeType"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2Request() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBodyResultAuthorizedUserList : public Darabonba::Model {
public:
  shared_ptr<string> gmtAuthorized{};
  shared_ptr<string> phone{};

  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBodyResultAuthorizedUserList() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBodyResultAuthorizedUserList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtAuthorized) {
      res["GmtAuthorized"] = boost::any(*gmtAuthorized);
    }
    if (phone) {
      res["Phone"] = boost::any(*phone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GmtAuthorized") != m.end() && !m["GmtAuthorized"].empty()) {
      gmtAuthorized = make_shared<string>(boost::any_cast<string>(m["GmtAuthorized"]));
    }
    if (m.find("Phone") != m.end() && !m["Phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["Phone"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBodyResultAuthorizedUserList() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBodyResultPagination() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBodyResultPagination() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> authorizationType{};
  shared_ptr<vector<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBodyResultAuthorizedUserList>> authorizedUserList{};
  shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBodyResultPagination> pagination{};
  shared_ptr<string> QRCodeType{};

  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBodyResult() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (authorizationType) {
      res["AuthorizationType"] = boost::any(*authorizationType);
    }
    if (authorizedUserList) {
      vector<boost::any> temp1;
      for(auto item1:*authorizedUserList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AuthorizedUserList"] = boost::any(temp1);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (QRCodeType) {
      res["QRCodeType"] = boost::any(*QRCodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("AuthorizationType") != m.end() && !m["AuthorizationType"].empty()) {
      authorizationType = make_shared<string>(boost::any_cast<string>(m["AuthorizationType"]));
    }
    if (m.find("AuthorizedUserList") != m.end() && !m["AuthorizedUserList"].empty()) {
      if (typeid(vector<boost::any>) == m["AuthorizedUserList"].type()) {
        vector<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBodyResultAuthorizedUserList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AuthorizedUserList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBodyResultAuthorizedUserList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        authorizedUserList = make_shared<vector<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBodyResultAuthorizedUserList>>(expect1);
      }
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBodyResultPagination>(model1);
      }
    }
    if (m.find("QRCodeType") != m.end() && !m["QRCodeType"].empty()) {
      QRCodeType = make_shared<string>(boost::any_cast<string>(m["QRCodeType"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBodyResult() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBody() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBody() = default;
};
class DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBody> body{};

  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2Response() {}

  explicit DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2ResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2Response() = default;
};
class DescribeAntChainMiniAppBrowserTransactionQRCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> transactionHash{};

  DescribeAntChainMiniAppBrowserTransactionQRCodeRequest() {}

  explicit DescribeAntChainMiniAppBrowserTransactionQRCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (transactionHash) {
      res["TransactionHash"] = boost::any(*transactionHash);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("TransactionHash") != m.end() && !m["TransactionHash"].empty()) {
      transactionHash = make_shared<string>(boost::any_cast<string>(m["TransactionHash"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserTransactionQRCodeRequest() = default;
};
class DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> base64QRCodePNG{};
  shared_ptr<string> QRCodeContent{};
  shared_ptr<string> transactionHash{};

  DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBodyResult() {}

  explicit DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (base64QRCodePNG) {
      res["Base64QRCodePNG"] = boost::any(*base64QRCodePNG);
    }
    if (QRCodeContent) {
      res["QRCodeContent"] = boost::any(*QRCodeContent);
    }
    if (transactionHash) {
      res["TransactionHash"] = boost::any(*transactionHash);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("Base64QRCodePNG") != m.end() && !m["Base64QRCodePNG"].empty()) {
      base64QRCodePNG = make_shared<string>(boost::any_cast<string>(m["Base64QRCodePNG"]));
    }
    if (m.find("QRCodeContent") != m.end() && !m["QRCodeContent"].empty()) {
      QRCodeContent = make_shared<string>(boost::any_cast<string>(m["QRCodeContent"]));
    }
    if (m.find("TransactionHash") != m.end() && !m["TransactionHash"].empty()) {
      transactionHash = make_shared<string>(boost::any_cast<string>(m["TransactionHash"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBodyResult() = default;
};
class DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBodyResult> result{};

  DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBody() {}

  explicit DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBody() = default;
};
class DescribeAntChainMiniAppBrowserTransactionQRCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBody> body{};

  DescribeAntChainMiniAppBrowserTransactionQRCodeResponse() {}

  explicit DescribeAntChainMiniAppBrowserTransactionQRCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainMiniAppBrowserTransactionQRCodeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserTransactionQRCodeResponse() = default;
};
class DescribeAntChainMiniAppBrowserTransactionQRCodeNewRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> contractId{};
  shared_ptr<string> transactionHash{};

  DescribeAntChainMiniAppBrowserTransactionQRCodeNewRequest() {}

  explicit DescribeAntChainMiniAppBrowserTransactionQRCodeNewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (contractId) {
      res["ContractId"] = boost::any(*contractId);
    }
    if (transactionHash) {
      res["TransactionHash"] = boost::any(*transactionHash);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ContractId") != m.end() && !m["ContractId"].empty()) {
      contractId = make_shared<string>(boost::any_cast<string>(m["ContractId"]));
    }
    if (m.find("TransactionHash") != m.end() && !m["TransactionHash"].empty()) {
      transactionHash = make_shared<string>(boost::any_cast<string>(m["TransactionHash"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserTransactionQRCodeNewRequest() = default;
};
class DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> base64QRCodePNG{};
  shared_ptr<string> QRCodeContent{};
  shared_ptr<string> transactionHash{};

  DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBodyResult() {}

  explicit DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (base64QRCodePNG) {
      res["Base64QRCodePNG"] = boost::any(*base64QRCodePNG);
    }
    if (QRCodeContent) {
      res["QRCodeContent"] = boost::any(*QRCodeContent);
    }
    if (transactionHash) {
      res["TransactionHash"] = boost::any(*transactionHash);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("Base64QRCodePNG") != m.end() && !m["Base64QRCodePNG"].empty()) {
      base64QRCodePNG = make_shared<string>(boost::any_cast<string>(m["Base64QRCodePNG"]));
    }
    if (m.find("QRCodeContent") != m.end() && !m["QRCodeContent"].empty()) {
      QRCodeContent = make_shared<string>(boost::any_cast<string>(m["QRCodeContent"]));
    }
    if (m.find("TransactionHash") != m.end() && !m["TransactionHash"].empty()) {
      transactionHash = make_shared<string>(boost::any_cast<string>(m["TransactionHash"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBodyResult() = default;
};
class DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBody() {}

  explicit DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBody() = default;
};
class DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBody> body{};

  DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponse() {}

  explicit DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponse() = default;
};
class DescribeAntChainNodesRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};

  DescribeAntChainNodesRequest() {}

  explicit DescribeAntChainNodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
  }


  virtual ~DescribeAntChainNodesRequest() = default;
};
class DescribeAntChainNodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<map<string, boost::any>>> result{};

  DescribeAntChainNodesResponseBody() {}

  explicit DescribeAntChainNodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Result"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      result = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
  }


  virtual ~DescribeAntChainNodesResponseBody() = default;
};
class DescribeAntChainNodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainNodesResponseBody> body{};

  DescribeAntChainNodesResponse() {}

  explicit DescribeAntChainNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainNodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainNodesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainNodesResponse() = default;
};
class DescribeAntChainNodesV2Request : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> consortiumId{};

  DescribeAntChainNodesV2Request() {}

  explicit DescribeAntChainNodesV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
  }


  virtual ~DescribeAntChainNodesV2Request() = default;
};
class DescribeAntChainNodesV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainNodesV2ResponseBody() {}

  explicit DescribeAntChainNodesV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Result"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      result = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainNodesV2ResponseBody() = default;
};
class DescribeAntChainNodesV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainNodesV2ResponseBody> body{};

  DescribeAntChainNodesV2Response() {}

  explicit DescribeAntChainNodesV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainNodesV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainNodesV2ResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainNodesV2Response() = default;
};
class DescribeAntChainQRCodeAuthorizationRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> QRCodeType{};

  DescribeAntChainQRCodeAuthorizationRequest() {}

  explicit DescribeAntChainQRCodeAuthorizationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (QRCodeType) {
      res["QRCodeType"] = boost::any(*QRCodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("QRCodeType") != m.end() && !m["QRCodeType"].empty()) {
      QRCodeType = make_shared<string>(boost::any_cast<string>(m["QRCodeType"]));
    }
  }


  virtual ~DescribeAntChainQRCodeAuthorizationRequest() = default;
};
class DescribeAntChainQRCodeAuthorizationResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> authorizationType{};
  shared_ptr<string> QRCodeType{};

  DescribeAntChainQRCodeAuthorizationResponseBodyResult() {}

  explicit DescribeAntChainQRCodeAuthorizationResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (authorizationType) {
      res["AuthorizationType"] = boost::any(*authorizationType);
    }
    if (QRCodeType) {
      res["QRCodeType"] = boost::any(*QRCodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("AuthorizationType") != m.end() && !m["AuthorizationType"].empty()) {
      authorizationType = make_shared<string>(boost::any_cast<string>(m["AuthorizationType"]));
    }
    if (m.find("QRCodeType") != m.end() && !m["QRCodeType"].empty()) {
      QRCodeType = make_shared<string>(boost::any_cast<string>(m["QRCodeType"]));
    }
  }


  virtual ~DescribeAntChainQRCodeAuthorizationResponseBodyResult() = default;
};
class DescribeAntChainQRCodeAuthorizationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainQRCodeAuthorizationResponseBodyResult> result{};

  DescribeAntChainQRCodeAuthorizationResponseBody() {}

  explicit DescribeAntChainQRCodeAuthorizationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainQRCodeAuthorizationResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainQRCodeAuthorizationResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainQRCodeAuthorizationResponseBody() = default;
};
class DescribeAntChainQRCodeAuthorizationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainQRCodeAuthorizationResponseBody> body{};

  DescribeAntChainQRCodeAuthorizationResponse() {}

  explicit DescribeAntChainQRCodeAuthorizationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainQRCodeAuthorizationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainQRCodeAuthorizationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainQRCodeAuthorizationResponse() = default;
};
class DescribeAntChainQRCodeAuthorizationV2Request : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> QRCodeType{};

  DescribeAntChainQRCodeAuthorizationV2Request() {}

  explicit DescribeAntChainQRCodeAuthorizationV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (QRCodeType) {
      res["QRCodeType"] = boost::any(*QRCodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("QRCodeType") != m.end() && !m["QRCodeType"].empty()) {
      QRCodeType = make_shared<string>(boost::any_cast<string>(m["QRCodeType"]));
    }
  }


  virtual ~DescribeAntChainQRCodeAuthorizationV2Request() = default;
};
class DescribeAntChainQRCodeAuthorizationV2ResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> authorizationType{};
  shared_ptr<string> QRCodeType{};

  DescribeAntChainQRCodeAuthorizationV2ResponseBodyResult() {}

  explicit DescribeAntChainQRCodeAuthorizationV2ResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (authorizationType) {
      res["AuthorizationType"] = boost::any(*authorizationType);
    }
    if (QRCodeType) {
      res["QRCodeType"] = boost::any(*QRCodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("AuthorizationType") != m.end() && !m["AuthorizationType"].empty()) {
      authorizationType = make_shared<string>(boost::any_cast<string>(m["AuthorizationType"]));
    }
    if (m.find("QRCodeType") != m.end() && !m["QRCodeType"].empty()) {
      QRCodeType = make_shared<string>(boost::any_cast<string>(m["QRCodeType"]));
    }
  }


  virtual ~DescribeAntChainQRCodeAuthorizationV2ResponseBodyResult() = default;
};
class DescribeAntChainQRCodeAuthorizationV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainQRCodeAuthorizationV2ResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainQRCodeAuthorizationV2ResponseBody() {}

  explicit DescribeAntChainQRCodeAuthorizationV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainQRCodeAuthorizationV2ResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainQRCodeAuthorizationV2ResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainQRCodeAuthorizationV2ResponseBody() = default;
};
class DescribeAntChainQRCodeAuthorizationV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainQRCodeAuthorizationV2ResponseBody> body{};

  DescribeAntChainQRCodeAuthorizationV2Response() {}

  explicit DescribeAntChainQRCodeAuthorizationV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainQRCodeAuthorizationV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainQRCodeAuthorizationV2ResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainQRCodeAuthorizationV2Response() = default;
};
class DescribeAntChainTransactionRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> hash{};

  DescribeAntChainTransactionRequest() {}

  explicit DescribeAntChainTransactionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (hash) {
      res["Hash"] = boost::any(*hash);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("Hash") != m.end() && !m["Hash"].empty()) {
      hash = make_shared<string>(boost::any_cast<string>(m["Hash"]));
    }
  }


  virtual ~DescribeAntChainTransactionRequest() = default;
};
class DescribeAntChainTransactionResponseBodyResultTransaction : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<vector<string>> extentions{};
  shared_ptr<string> from{};
  shared_ptr<string> gas{};
  shared_ptr<string> hash{};
  shared_ptr<string> nonce{};
  shared_ptr<long> period{};
  shared_ptr<vector<string>> signatures{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> to{};
  shared_ptr<string> txType{};
  shared_ptr<string> value{};

  DescribeAntChainTransactionResponseBodyResultTransaction() {}

  explicit DescribeAntChainTransactionResponseBodyResultTransaction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (extentions) {
      res["Extentions"] = boost::any(*extentions);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (gas) {
      res["Gas"] = boost::any(*gas);
    }
    if (hash) {
      res["Hash"] = boost::any(*hash);
    }
    if (nonce) {
      res["Nonce"] = boost::any(*nonce);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (signatures) {
      res["Signatures"] = boost::any(*signatures);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    if (txType) {
      res["TxType"] = boost::any(*txType);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Extentions") != m.end() && !m["Extentions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Extentions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Extentions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      extentions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("Gas") != m.end() && !m["Gas"].empty()) {
      gas = make_shared<string>(boost::any_cast<string>(m["Gas"]));
    }
    if (m.find("Hash") != m.end() && !m["Hash"].empty()) {
      hash = make_shared<string>(boost::any_cast<string>(m["Hash"]));
    }
    if (m.find("Nonce") != m.end() && !m["Nonce"].empty()) {
      nonce = make_shared<string>(boost::any_cast<string>(m["Nonce"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("Signatures") != m.end() && !m["Signatures"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Signatures"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Signatures"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signatures = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<string>(boost::any_cast<string>(m["To"]));
    }
    if (m.find("TxType") != m.end() && !m["TxType"].empty()) {
      txType = make_shared<string>(boost::any_cast<string>(m["TxType"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeAntChainTransactionResponseBodyResultTransaction() = default;
};
class DescribeAntChainTransactionResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> blockHash{};
  shared_ptr<long> blockHeight{};
  shared_ptr<string> blockVersion{};
  shared_ptr<long> createTime{};
  shared_ptr<string> hash{};
  shared_ptr<DescribeAntChainTransactionResponseBodyResultTransaction> transaction{};

  DescribeAntChainTransactionResponseBodyResult() {}

  explicit DescribeAntChainTransactionResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockHash) {
      res["BlockHash"] = boost::any(*blockHash);
    }
    if (blockHeight) {
      res["BlockHeight"] = boost::any(*blockHeight);
    }
    if (blockVersion) {
      res["BlockVersion"] = boost::any(*blockVersion);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (hash) {
      res["Hash"] = boost::any(*hash);
    }
    if (transaction) {
      res["Transaction"] = transaction ? boost::any(transaction->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockHash") != m.end() && !m["BlockHash"].empty()) {
      blockHash = make_shared<string>(boost::any_cast<string>(m["BlockHash"]));
    }
    if (m.find("BlockHeight") != m.end() && !m["BlockHeight"].empty()) {
      blockHeight = make_shared<long>(boost::any_cast<long>(m["BlockHeight"]));
    }
    if (m.find("BlockVersion") != m.end() && !m["BlockVersion"].empty()) {
      blockVersion = make_shared<string>(boost::any_cast<string>(m["BlockVersion"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Hash") != m.end() && !m["Hash"].empty()) {
      hash = make_shared<string>(boost::any_cast<string>(m["Hash"]));
    }
    if (m.find("Transaction") != m.end() && !m["Transaction"].empty()) {
      if (typeid(map<string, boost::any>) == m["Transaction"].type()) {
        DescribeAntChainTransactionResponseBodyResultTransaction model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Transaction"]));
        transaction = make_shared<DescribeAntChainTransactionResponseBodyResultTransaction>(model1);
      }
    }
  }


  virtual ~DescribeAntChainTransactionResponseBodyResult() = default;
};
class DescribeAntChainTransactionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainTransactionResponseBodyResult> result{};

  DescribeAntChainTransactionResponseBody() {}

  explicit DescribeAntChainTransactionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainTransactionResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainTransactionResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainTransactionResponseBody() = default;
};
class DescribeAntChainTransactionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainTransactionResponseBody> body{};

  DescribeAntChainTransactionResponse() {}

  explicit DescribeAntChainTransactionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainTransactionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainTransactionResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainTransactionResponse() = default;
};
class DescribeAntChainTransactionReceiptRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> hash{};

  DescribeAntChainTransactionReceiptRequest() {}

  explicit DescribeAntChainTransactionReceiptRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (hash) {
      res["Hash"] = boost::any(*hash);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("Hash") != m.end() && !m["Hash"].empty()) {
      hash = make_shared<string>(boost::any_cast<string>(m["Hash"]));
    }
  }


  virtual ~DescribeAntChainTransactionReceiptRequest() = default;
};
class DescribeAntChainTransactionReceiptResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> gasUsed{};
  shared_ptr<vector<string>> logs{};
  shared_ptr<long> result{};

  DescribeAntChainTransactionReceiptResponseBodyResult() {}

  explicit DescribeAntChainTransactionReceiptResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (gasUsed) {
      res["GasUsed"] = boost::any(*gasUsed);
    }
    if (logs) {
      res["Logs"] = boost::any(*logs);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("GasUsed") != m.end() && !m["GasUsed"].empty()) {
      gasUsed = make_shared<string>(boost::any_cast<string>(m["GasUsed"]));
    }
    if (m.find("Logs") != m.end() && !m["Logs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Logs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Logs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      logs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<long>(boost::any_cast<long>(m["Result"]));
    }
  }


  virtual ~DescribeAntChainTransactionReceiptResponseBodyResult() = default;
};
class DescribeAntChainTransactionReceiptResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainTransactionReceiptResponseBodyResult> result{};

  DescribeAntChainTransactionReceiptResponseBody() {}

  explicit DescribeAntChainTransactionReceiptResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainTransactionReceiptResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainTransactionReceiptResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainTransactionReceiptResponseBody() = default;
};
class DescribeAntChainTransactionReceiptResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainTransactionReceiptResponseBody> body{};

  DescribeAntChainTransactionReceiptResponse() {}

  explicit DescribeAntChainTransactionReceiptResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainTransactionReceiptResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainTransactionReceiptResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainTransactionReceiptResponse() = default;
};
class DescribeAntChainTransactionReceiptV2Request : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> hash{};

  DescribeAntChainTransactionReceiptV2Request() {}

  explicit DescribeAntChainTransactionReceiptV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (hash) {
      res["Hash"] = boost::any(*hash);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Hash") != m.end() && !m["Hash"].empty()) {
      hash = make_shared<string>(boost::any_cast<string>(m["Hash"]));
    }
  }


  virtual ~DescribeAntChainTransactionReceiptV2Request() = default;
};
class DescribeAntChainTransactionReceiptV2ResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<string> gasUsed{};
  shared_ptr<vector<string>> logs{};
  shared_ptr<long> result{};

  DescribeAntChainTransactionReceiptV2ResponseBodyResult() {}

  explicit DescribeAntChainTransactionReceiptV2ResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (gasUsed) {
      res["GasUsed"] = boost::any(*gasUsed);
    }
    if (logs) {
      res["Logs"] = boost::any(*logs);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("GasUsed") != m.end() && !m["GasUsed"].empty()) {
      gasUsed = make_shared<string>(boost::any_cast<string>(m["GasUsed"]));
    }
    if (m.find("Logs") != m.end() && !m["Logs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Logs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Logs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      logs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<long>(boost::any_cast<long>(m["Result"]));
    }
  }


  virtual ~DescribeAntChainTransactionReceiptV2ResponseBodyResult() = default;
};
class DescribeAntChainTransactionReceiptV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainTransactionReceiptV2ResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainTransactionReceiptV2ResponseBody() {}

  explicit DescribeAntChainTransactionReceiptV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainTransactionReceiptV2ResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainTransactionReceiptV2ResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainTransactionReceiptV2ResponseBody() = default;
};
class DescribeAntChainTransactionReceiptV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainTransactionReceiptV2ResponseBody> body{};

  DescribeAntChainTransactionReceiptV2Response() {}

  explicit DescribeAntChainTransactionReceiptV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainTransactionReceiptV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainTransactionReceiptV2ResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainTransactionReceiptV2Response() = default;
};
class DescribeAntChainTransactionStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<long> end{};
  shared_ptr<long> start{};

  DescribeAntChainTransactionStatisticsRequest() {}

  explicit DescribeAntChainTransactionStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
  }


  virtual ~DescribeAntChainTransactionStatisticsRequest() = default;
};
class DescribeAntChainTransactionStatisticsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<long> creatTime{};
  shared_ptr<string> dt{};
  shared_ptr<long> lastSumBlockHeight{};
  shared_ptr<long> transCount{};

  DescribeAntChainTransactionStatisticsResponseBodyResult() {}

  explicit DescribeAntChainTransactionStatisticsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (creatTime) {
      res["CreatTime"] = boost::any(*creatTime);
    }
    if (dt) {
      res["Dt"] = boost::any(*dt);
    }
    if (lastSumBlockHeight) {
      res["LastSumBlockHeight"] = boost::any(*lastSumBlockHeight);
    }
    if (transCount) {
      res["TransCount"] = boost::any(*transCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("CreatTime") != m.end() && !m["CreatTime"].empty()) {
      creatTime = make_shared<long>(boost::any_cast<long>(m["CreatTime"]));
    }
    if (m.find("Dt") != m.end() && !m["Dt"].empty()) {
      dt = make_shared<string>(boost::any_cast<string>(m["Dt"]));
    }
    if (m.find("LastSumBlockHeight") != m.end() && !m["LastSumBlockHeight"].empty()) {
      lastSumBlockHeight = make_shared<long>(boost::any_cast<long>(m["LastSumBlockHeight"]));
    }
    if (m.find("TransCount") != m.end() && !m["TransCount"].empty()) {
      transCount = make_shared<long>(boost::any_cast<long>(m["TransCount"]));
    }
  }


  virtual ~DescribeAntChainTransactionStatisticsResponseBodyResult() = default;
};
class DescribeAntChainTransactionStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeAntChainTransactionStatisticsResponseBodyResult>> result{};

  DescribeAntChainTransactionStatisticsResponseBody() {}

  explicit DescribeAntChainTransactionStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeAntChainTransactionStatisticsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainTransactionStatisticsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeAntChainTransactionStatisticsResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~DescribeAntChainTransactionStatisticsResponseBody() = default;
};
class DescribeAntChainTransactionStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainTransactionStatisticsResponseBody> body{};

  DescribeAntChainTransactionStatisticsResponse() {}

  explicit DescribeAntChainTransactionStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainTransactionStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainTransactionStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainTransactionStatisticsResponse() = default;
};
class DescribeAntChainTransactionStatisticsV2Request : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> consortiumId{};
  shared_ptr<long> end{};
  shared_ptr<long> start{};

  DescribeAntChainTransactionStatisticsV2Request() {}

  explicit DescribeAntChainTransactionStatisticsV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<long>(boost::any_cast<long>(m["End"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<long>(boost::any_cast<long>(m["Start"]));
    }
  }


  virtual ~DescribeAntChainTransactionStatisticsV2Request() = default;
};
class DescribeAntChainTransactionStatisticsV2ResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<long> creatTime{};
  shared_ptr<long> dt{};
  shared_ptr<long> lastSumBlockHeight{};
  shared_ptr<long> transCount{};

  DescribeAntChainTransactionStatisticsV2ResponseBodyResult() {}

  explicit DescribeAntChainTransactionStatisticsV2ResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (creatTime) {
      res["CreatTime"] = boost::any(*creatTime);
    }
    if (dt) {
      res["Dt"] = boost::any(*dt);
    }
    if (lastSumBlockHeight) {
      res["LastSumBlockHeight"] = boost::any(*lastSumBlockHeight);
    }
    if (transCount) {
      res["TransCount"] = boost::any(*transCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("CreatTime") != m.end() && !m["CreatTime"].empty()) {
      creatTime = make_shared<long>(boost::any_cast<long>(m["CreatTime"]));
    }
    if (m.find("Dt") != m.end() && !m["Dt"].empty()) {
      dt = make_shared<long>(boost::any_cast<long>(m["Dt"]));
    }
    if (m.find("LastSumBlockHeight") != m.end() && !m["LastSumBlockHeight"].empty()) {
      lastSumBlockHeight = make_shared<long>(boost::any_cast<long>(m["LastSumBlockHeight"]));
    }
    if (m.find("TransCount") != m.end() && !m["TransCount"].empty()) {
      transCount = make_shared<long>(boost::any_cast<long>(m["TransCount"]));
    }
  }


  virtual ~DescribeAntChainTransactionStatisticsV2ResponseBodyResult() = default;
};
class DescribeAntChainTransactionStatisticsV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeAntChainTransactionStatisticsV2ResponseBodyResult>> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainTransactionStatisticsV2ResponseBody() {}

  explicit DescribeAntChainTransactionStatisticsV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeAntChainTransactionStatisticsV2ResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainTransactionStatisticsV2ResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeAntChainTransactionStatisticsV2ResponseBodyResult>>(expect1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainTransactionStatisticsV2ResponseBody() = default;
};
class DescribeAntChainTransactionStatisticsV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainTransactionStatisticsV2ResponseBody> body{};

  DescribeAntChainTransactionStatisticsV2Response() {}

  explicit DescribeAntChainTransactionStatisticsV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainTransactionStatisticsV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainTransactionStatisticsV2ResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainTransactionStatisticsV2Response() = default;
};
class DescribeAntChainTransactionV2Request : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> hash{};

  DescribeAntChainTransactionV2Request() {}

  explicit DescribeAntChainTransactionV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (hash) {
      res["Hash"] = boost::any(*hash);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Hash") != m.end() && !m["Hash"].empty()) {
      hash = make_shared<string>(boost::any_cast<string>(m["Hash"]));
    }
  }


  virtual ~DescribeAntChainTransactionV2Request() = default;
};
class DescribeAntChainTransactionV2ResponseBodyResultTransaction : public Darabonba::Model {
public:
  shared_ptr<string> data{};
  shared_ptr<vector<string>> extentions{};
  shared_ptr<string> from{};
  shared_ptr<string> gas{};
  shared_ptr<string> hash{};
  shared_ptr<string> nonce{};
  shared_ptr<long> period{};
  shared_ptr<vector<string>> signatures{};
  shared_ptr<long> timestamp{};
  shared_ptr<string> to{};
  shared_ptr<string> txType{};
  shared_ptr<string> value{};

  DescribeAntChainTransactionV2ResponseBodyResultTransaction() {}

  explicit DescribeAntChainTransactionV2ResponseBodyResultTransaction(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["Data"] = boost::any(*data);
    }
    if (extentions) {
      res["Extentions"] = boost::any(*extentions);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (gas) {
      res["Gas"] = boost::any(*gas);
    }
    if (hash) {
      res["Hash"] = boost::any(*hash);
    }
    if (nonce) {
      res["Nonce"] = boost::any(*nonce);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (signatures) {
      res["Signatures"] = boost::any(*signatures);
    }
    if (timestamp) {
      res["Timestamp"] = boost::any(*timestamp);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    if (txType) {
      res["TxType"] = boost::any(*txType);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Data") != m.end() && !m["Data"].empty()) {
      data = make_shared<string>(boost::any_cast<string>(m["Data"]));
    }
    if (m.find("Extentions") != m.end() && !m["Extentions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Extentions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Extentions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      extentions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("Gas") != m.end() && !m["Gas"].empty()) {
      gas = make_shared<string>(boost::any_cast<string>(m["Gas"]));
    }
    if (m.find("Hash") != m.end() && !m["Hash"].empty()) {
      hash = make_shared<string>(boost::any_cast<string>(m["Hash"]));
    }
    if (m.find("Nonce") != m.end() && !m["Nonce"].empty()) {
      nonce = make_shared<string>(boost::any_cast<string>(m["Nonce"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("Signatures") != m.end() && !m["Signatures"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Signatures"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Signatures"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      signatures = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Timestamp") != m.end() && !m["Timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["Timestamp"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<string>(boost::any_cast<string>(m["To"]));
    }
    if (m.find("TxType") != m.end() && !m["TxType"].empty()) {
      txType = make_shared<string>(boost::any_cast<string>(m["TxType"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeAntChainTransactionV2ResponseBodyResultTransaction() = default;
};
class DescribeAntChainTransactionV2ResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> blockHash{};
  shared_ptr<long> blockHeight{};
  shared_ptr<string> blockVersion{};
  shared_ptr<long> createTime{};
  shared_ptr<string> hash{};
  shared_ptr<DescribeAntChainTransactionV2ResponseBodyResultTransaction> transaction{};

  DescribeAntChainTransactionV2ResponseBodyResult() {}

  explicit DescribeAntChainTransactionV2ResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockHash) {
      res["BlockHash"] = boost::any(*blockHash);
    }
    if (blockHeight) {
      res["BlockHeight"] = boost::any(*blockHeight);
    }
    if (blockVersion) {
      res["BlockVersion"] = boost::any(*blockVersion);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (hash) {
      res["Hash"] = boost::any(*hash);
    }
    if (transaction) {
      res["Transaction"] = transaction ? boost::any(transaction->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockHash") != m.end() && !m["BlockHash"].empty()) {
      blockHash = make_shared<string>(boost::any_cast<string>(m["BlockHash"]));
    }
    if (m.find("BlockHeight") != m.end() && !m["BlockHeight"].empty()) {
      blockHeight = make_shared<long>(boost::any_cast<long>(m["BlockHeight"]));
    }
    if (m.find("BlockVersion") != m.end() && !m["BlockVersion"].empty()) {
      blockVersion = make_shared<string>(boost::any_cast<string>(m["BlockVersion"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Hash") != m.end() && !m["Hash"].empty()) {
      hash = make_shared<string>(boost::any_cast<string>(m["Hash"]));
    }
    if (m.find("Transaction") != m.end() && !m["Transaction"].empty()) {
      if (typeid(map<string, boost::any>) == m["Transaction"].type()) {
        DescribeAntChainTransactionV2ResponseBodyResultTransaction model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Transaction"]));
        transaction = make_shared<DescribeAntChainTransactionV2ResponseBodyResultTransaction>(model1);
      }
    }
  }


  virtual ~DescribeAntChainTransactionV2ResponseBodyResult() = default;
};
class DescribeAntChainTransactionV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainTransactionV2ResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainTransactionV2ResponseBody() {}

  explicit DescribeAntChainTransactionV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainTransactionV2ResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainTransactionV2ResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainTransactionV2ResponseBody() = default;
};
class DescribeAntChainTransactionV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainTransactionV2ResponseBody> body{};

  DescribeAntChainTransactionV2Response() {}

  explicit DescribeAntChainTransactionV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainTransactionV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainTransactionV2ResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainTransactionV2Response() = default;
};
class DescribeAntChainsRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeAntChainsRequest() {}

  explicit DescribeAntChainsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeAntChainsRequest() = default;
};
class DescribeAntChainsResponseBodyResultAntChains : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> antChainName{};
  shared_ptr<string> chainType{};
  shared_ptr<string> cipherSuit{};
  shared_ptr<long> createTime{};
  shared_ptr<long> expireTime{};
  shared_ptr<bool> isAdmin{};
  shared_ptr<string> memberStatus{};
  shared_ptr<string> merkleTreeSuit{};
  shared_ptr<string> network{};
  shared_ptr<long> nodeNum{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceSize{};
  shared_ptr<string> tlsAlgo{};
  shared_ptr<string> version{};

  DescribeAntChainsResponseBodyResultAntChains() {}

  explicit DescribeAntChainsResponseBodyResultAntChains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (antChainName) {
      res["AntChainName"] = boost::any(*antChainName);
    }
    if (chainType) {
      res["ChainType"] = boost::any(*chainType);
    }
    if (cipherSuit) {
      res["CipherSuit"] = boost::any(*cipherSuit);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (isAdmin) {
      res["IsAdmin"] = boost::any(*isAdmin);
    }
    if (memberStatus) {
      res["MemberStatus"] = boost::any(*memberStatus);
    }
    if (merkleTreeSuit) {
      res["MerkleTreeSuit"] = boost::any(*merkleTreeSuit);
    }
    if (network) {
      res["Network"] = boost::any(*network);
    }
    if (nodeNum) {
      res["NodeNum"] = boost::any(*nodeNum);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceSize) {
      res["ResourceSize"] = boost::any(*resourceSize);
    }
    if (tlsAlgo) {
      res["TlsAlgo"] = boost::any(*tlsAlgo);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("AntChainName") != m.end() && !m["AntChainName"].empty()) {
      antChainName = make_shared<string>(boost::any_cast<string>(m["AntChainName"]));
    }
    if (m.find("ChainType") != m.end() && !m["ChainType"].empty()) {
      chainType = make_shared<string>(boost::any_cast<string>(m["ChainType"]));
    }
    if (m.find("CipherSuit") != m.end() && !m["CipherSuit"].empty()) {
      cipherSuit = make_shared<string>(boost::any_cast<string>(m["CipherSuit"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("IsAdmin") != m.end() && !m["IsAdmin"].empty()) {
      isAdmin = make_shared<bool>(boost::any_cast<bool>(m["IsAdmin"]));
    }
    if (m.find("MemberStatus") != m.end() && !m["MemberStatus"].empty()) {
      memberStatus = make_shared<string>(boost::any_cast<string>(m["MemberStatus"]));
    }
    if (m.find("MerkleTreeSuit") != m.end() && !m["MerkleTreeSuit"].empty()) {
      merkleTreeSuit = make_shared<string>(boost::any_cast<string>(m["MerkleTreeSuit"]));
    }
    if (m.find("Network") != m.end() && !m["Network"].empty()) {
      network = make_shared<string>(boost::any_cast<string>(m["Network"]));
    }
    if (m.find("NodeNum") != m.end() && !m["NodeNum"].empty()) {
      nodeNum = make_shared<long>(boost::any_cast<long>(m["NodeNum"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceSize") != m.end() && !m["ResourceSize"].empty()) {
      resourceSize = make_shared<string>(boost::any_cast<string>(m["ResourceSize"]));
    }
    if (m.find("TlsAlgo") != m.end() && !m["TlsAlgo"].empty()) {
      tlsAlgo = make_shared<string>(boost::any_cast<string>(m["TlsAlgo"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeAntChainsResponseBodyResultAntChains() = default;
};
class DescribeAntChainsResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainsResponseBodyResultPagination() {}

  explicit DescribeAntChainsResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainsResponseBodyResultPagination() = default;
};
class DescribeAntChainsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAntChainsResponseBodyResultAntChains>> antChains{};
  shared_ptr<bool> isExist{};
  shared_ptr<DescribeAntChainsResponseBodyResultPagination> pagination{};

  DescribeAntChainsResponseBodyResult() {}

  explicit DescribeAntChainsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChains) {
      vector<boost::any> temp1;
      for(auto item1:*antChains){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AntChains"] = boost::any(temp1);
    }
    if (isExist) {
      res["IsExist"] = boost::any(*isExist);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChains") != m.end() && !m["AntChains"].empty()) {
      if (typeid(vector<boost::any>) == m["AntChains"].type()) {
        vector<DescribeAntChainsResponseBodyResultAntChains> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AntChains"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainsResponseBodyResultAntChains model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        antChains = make_shared<vector<DescribeAntChainsResponseBodyResultAntChains>>(expect1);
      }
    }
    if (m.find("IsExist") != m.end() && !m["IsExist"].empty()) {
      isExist = make_shared<bool>(boost::any_cast<bool>(m["IsExist"]));
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainsResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainsResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeAntChainsResponseBodyResult() = default;
};
class DescribeAntChainsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainsResponseBodyResult> result{};

  DescribeAntChainsResponseBody() {}

  explicit DescribeAntChainsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainsResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAntChainsResponseBody() = default;
};
class DescribeAntChainsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainsResponseBody> body{};

  DescribeAntChainsResponse() {}

  explicit DescribeAntChainsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainsResponse() = default;
};
class DescribeAntChainsV2Request : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeAntChainsV2Request() {}

  explicit DescribeAntChainsV2Request(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeAntChainsV2Request() = default;
};
class DescribeAntChainsV2ResponseBodyResultAntChains : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> antChainName{};
  shared_ptr<string> chainType{};
  shared_ptr<string> cipherSuit{};
  shared_ptr<long> createTime{};
  shared_ptr<long> expireTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> isAdmin{};
  shared_ptr<string> memberStatus{};
  shared_ptr<string> merkleTreeSuit{};
  shared_ptr<bool> monitorStatus{};
  shared_ptr<string> network{};
  shared_ptr<long> nodeNum{};
  shared_ptr<string> regionId{};
  shared_ptr<string> resourceSize{};
  shared_ptr<string> restStatus{};
  shared_ptr<string> tlsAlgo{};
  shared_ptr<string> version{};

  DescribeAntChainsV2ResponseBodyResultAntChains() {}

  explicit DescribeAntChainsV2ResponseBodyResultAntChains(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (antChainName) {
      res["AntChainName"] = boost::any(*antChainName);
    }
    if (chainType) {
      res["ChainType"] = boost::any(*chainType);
    }
    if (cipherSuit) {
      res["CipherSuit"] = boost::any(*cipherSuit);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (isAdmin) {
      res["IsAdmin"] = boost::any(*isAdmin);
    }
    if (memberStatus) {
      res["MemberStatus"] = boost::any(*memberStatus);
    }
    if (merkleTreeSuit) {
      res["MerkleTreeSuit"] = boost::any(*merkleTreeSuit);
    }
    if (monitorStatus) {
      res["MonitorStatus"] = boost::any(*monitorStatus);
    }
    if (network) {
      res["Network"] = boost::any(*network);
    }
    if (nodeNum) {
      res["NodeNum"] = boost::any(*nodeNum);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (resourceSize) {
      res["ResourceSize"] = boost::any(*resourceSize);
    }
    if (restStatus) {
      res["RestStatus"] = boost::any(*restStatus);
    }
    if (tlsAlgo) {
      res["TlsAlgo"] = boost::any(*tlsAlgo);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("AntChainName") != m.end() && !m["AntChainName"].empty()) {
      antChainName = make_shared<string>(boost::any_cast<string>(m["AntChainName"]));
    }
    if (m.find("ChainType") != m.end() && !m["ChainType"].empty()) {
      chainType = make_shared<string>(boost::any_cast<string>(m["ChainType"]));
    }
    if (m.find("CipherSuit") != m.end() && !m["CipherSuit"].empty()) {
      cipherSuit = make_shared<string>(boost::any_cast<string>(m["CipherSuit"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<long>(boost::any_cast<long>(m["ExpireTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("IsAdmin") != m.end() && !m["IsAdmin"].empty()) {
      isAdmin = make_shared<bool>(boost::any_cast<bool>(m["IsAdmin"]));
    }
    if (m.find("MemberStatus") != m.end() && !m["MemberStatus"].empty()) {
      memberStatus = make_shared<string>(boost::any_cast<string>(m["MemberStatus"]));
    }
    if (m.find("MerkleTreeSuit") != m.end() && !m["MerkleTreeSuit"].empty()) {
      merkleTreeSuit = make_shared<string>(boost::any_cast<string>(m["MerkleTreeSuit"]));
    }
    if (m.find("MonitorStatus") != m.end() && !m["MonitorStatus"].empty()) {
      monitorStatus = make_shared<bool>(boost::any_cast<bool>(m["MonitorStatus"]));
    }
    if (m.find("Network") != m.end() && !m["Network"].empty()) {
      network = make_shared<string>(boost::any_cast<string>(m["Network"]));
    }
    if (m.find("NodeNum") != m.end() && !m["NodeNum"].empty()) {
      nodeNum = make_shared<long>(boost::any_cast<long>(m["NodeNum"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("ResourceSize") != m.end() && !m["ResourceSize"].empty()) {
      resourceSize = make_shared<string>(boost::any_cast<string>(m["ResourceSize"]));
    }
    if (m.find("RestStatus") != m.end() && !m["RestStatus"].empty()) {
      restStatus = make_shared<string>(boost::any_cast<string>(m["RestStatus"]));
    }
    if (m.find("TlsAlgo") != m.end() && !m["TlsAlgo"].empty()) {
      tlsAlgo = make_shared<string>(boost::any_cast<string>(m["TlsAlgo"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeAntChainsV2ResponseBodyResultAntChains() = default;
};
class DescribeAntChainsV2ResponseBodyResultPagination : public Darabonba::Model {
public:
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> totalCount{};

  DescribeAntChainsV2ResponseBodyResultPagination() {}

  explicit DescribeAntChainsV2ResponseBodyResultPagination(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~DescribeAntChainsV2ResponseBodyResultPagination() = default;
};
class DescribeAntChainsV2ResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeAntChainsV2ResponseBodyResultAntChains>> antChains{};
  shared_ptr<bool> isExist{};
  shared_ptr<DescribeAntChainsV2ResponseBodyResultPagination> pagination{};

  DescribeAntChainsV2ResponseBodyResult() {}

  explicit DescribeAntChainsV2ResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChains) {
      vector<boost::any> temp1;
      for(auto item1:*antChains){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AntChains"] = boost::any(temp1);
    }
    if (isExist) {
      res["IsExist"] = boost::any(*isExist);
    }
    if (pagination) {
      res["Pagination"] = pagination ? boost::any(pagination->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChains") != m.end() && !m["AntChains"].empty()) {
      if (typeid(vector<boost::any>) == m["AntChains"].type()) {
        vector<DescribeAntChainsV2ResponseBodyResultAntChains> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AntChains"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeAntChainsV2ResponseBodyResultAntChains model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        antChains = make_shared<vector<DescribeAntChainsV2ResponseBodyResultAntChains>>(expect1);
      }
    }
    if (m.find("IsExist") != m.end() && !m["IsExist"].empty()) {
      isExist = make_shared<bool>(boost::any_cast<bool>(m["IsExist"]));
    }
    if (m.find("Pagination") != m.end() && !m["Pagination"].empty()) {
      if (typeid(map<string, boost::any>) == m["Pagination"].type()) {
        DescribeAntChainsV2ResponseBodyResultPagination model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Pagination"]));
        pagination = make_shared<DescribeAntChainsV2ResponseBodyResultPagination>(model1);
      }
    }
  }


  virtual ~DescribeAntChainsV2ResponseBodyResult() = default;
};
class DescribeAntChainsV2ResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> httpStatusCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAntChainsV2ResponseBodyResult> result{};
  shared_ptr<string> resultCode{};
  shared_ptr<string> resultMessage{};
  shared_ptr<bool> success{};

  DescribeAntChainsV2ResponseBody() {}

  explicit DescribeAntChainsV2ResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (httpStatusCode) {
      res["HttpStatusCode"] = boost::any(*httpStatusCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resultCode) {
      res["ResultCode"] = boost::any(*resultCode);
    }
    if (resultMessage) {
      res["ResultMessage"] = boost::any(*resultMessage);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("HttpStatusCode") != m.end() && !m["HttpStatusCode"].empty()) {
      httpStatusCode = make_shared<string>(boost::any_cast<string>(m["HttpStatusCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAntChainsV2ResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAntChainsV2ResponseBodyResult>(model1);
      }
    }
    if (m.find("ResultCode") != m.end() && !m["ResultCode"].empty()) {
      resultCode = make_shared<string>(boost::any_cast<string>(m["ResultCode"]));
    }
    if (m.find("ResultMessage") != m.end() && !m["ResultMessage"].empty()) {
      resultMessage = make_shared<string>(boost::any_cast<string>(m["ResultMessage"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeAntChainsV2ResponseBody() = default;
};
class DescribeAntChainsV2Response : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAntChainsV2ResponseBody> body{};

  DescribeAntChainsV2Response() {}

  explicit DescribeAntChainsV2Response(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAntChainsV2ResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAntChainsV2ResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAntChainsV2Response() = default;
};
class DescribeEthereumDeletableRequest : public Darabonba::Model {
public:
  shared_ptr<string> ethereumId{};

  DescribeEthereumDeletableRequest() {}

  explicit DescribeEthereumDeletableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ethereumId) {
      res["EthereumId"] = boost::any(*ethereumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EthereumId") != m.end() && !m["EthereumId"].empty()) {
      ethereumId = make_shared<string>(boost::any_cast<string>(m["EthereumId"]));
    }
  }


  virtual ~DescribeEthereumDeletableRequest() = default;
};
class DescribeEthereumDeletableResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> deletable{};
  shared_ptr<string> ethereumId{};

  DescribeEthereumDeletableResponseBodyResult() {}

  explicit DescribeEthereumDeletableResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deletable) {
      res["Deletable"] = boost::any(*deletable);
    }
    if (ethereumId) {
      res["EthereumId"] = boost::any(*ethereumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Deletable") != m.end() && !m["Deletable"].empty()) {
      deletable = make_shared<bool>(boost::any_cast<bool>(m["Deletable"]));
    }
    if (m.find("EthereumId") != m.end() && !m["EthereumId"].empty()) {
      ethereumId = make_shared<string>(boost::any_cast<string>(m["EthereumId"]));
    }
  }


  virtual ~DescribeEthereumDeletableResponseBodyResult() = default;
};
class DescribeEthereumDeletableResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeEthereumDeletableResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeEthereumDeletableResponseBody() {}

  explicit DescribeEthereumDeletableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeEthereumDeletableResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeEthereumDeletableResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeEthereumDeletableResponseBody() = default;
};
class DescribeEthereumDeletableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeEthereumDeletableResponseBody> body{};

  DescribeEthereumDeletableResponse() {}

  explicit DescribeEthereumDeletableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeEthereumDeletableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeEthereumDeletableResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeEthereumDeletableResponse() = default;
};
class DescribeFabricCandidateOrganizationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> location{};

  DescribeFabricCandidateOrganizationsRequest() {}

  explicit DescribeFabricCandidateOrganizationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
  }


  virtual ~DescribeFabricCandidateOrganizationsRequest() = default;
};
class DescribeFabricCandidateOrganizationsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> clusterState{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> organizationName{};
  shared_ptr<string> serviceState{};

  DescribeFabricCandidateOrganizationsResponseBodyResult() {}

  explicit DescribeFabricCandidateOrganizationsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterState) {
      res["ClusterState"] = boost::any(*clusterState);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (organizationName) {
      res["OrganizationName"] = boost::any(*organizationName);
    }
    if (serviceState) {
      res["ServiceState"] = boost::any(*serviceState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClusterState") != m.end() && !m["ClusterState"].empty()) {
      clusterState = make_shared<string>(boost::any_cast<string>(m["ClusterState"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("OrganizationName") != m.end() && !m["OrganizationName"].empty()) {
      organizationName = make_shared<string>(boost::any_cast<string>(m["OrganizationName"]));
    }
    if (m.find("ServiceState") != m.end() && !m["ServiceState"].empty()) {
      serviceState = make_shared<string>(boost::any_cast<string>(m["ServiceState"]));
    }
  }


  virtual ~DescribeFabricCandidateOrganizationsResponseBodyResult() = default;
};
class DescribeFabricCandidateOrganizationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeFabricCandidateOrganizationsResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeFabricCandidateOrganizationsResponseBody() {}

  explicit DescribeFabricCandidateOrganizationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeFabricCandidateOrganizationsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFabricCandidateOrganizationsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeFabricCandidateOrganizationsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricCandidateOrganizationsResponseBody() = default;
};
class DescribeFabricCandidateOrganizationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricCandidateOrganizationsResponseBody> body{};

  DescribeFabricCandidateOrganizationsResponse() {}

  explicit DescribeFabricCandidateOrganizationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricCandidateOrganizationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricCandidateOrganizationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricCandidateOrganizationsResponse() = default;
};
class DescribeFabricChaincodeDefinitionTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> organizationId{};

  DescribeFabricChaincodeDefinitionTaskRequest() {}

  explicit DescribeFabricChaincodeDefinitionTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeFabricChaincodeDefinitionTaskRequest() = default;
};
class DescribeFabricChaincodeDefinitionTaskResponseBodyResultContentChaincodeDefinition : public Darabonba::Model {
public:
  shared_ptr<string> chaincodePackageId{};
  shared_ptr<string> collectionConfig{};
  shared_ptr<string> endorsementPolicy{};
  shared_ptr<bool> initRequired{};
  shared_ptr<string> name{};
  shared_ptr<long> sequence{};
  shared_ptr<string> uid{};
  shared_ptr<string> version{};

  DescribeFabricChaincodeDefinitionTaskResponseBodyResultContentChaincodeDefinition() {}

  explicit DescribeFabricChaincodeDefinitionTaskResponseBodyResultContentChaincodeDefinition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodePackageId) {
      res["ChaincodePackageId"] = boost::any(*chaincodePackageId);
    }
    if (collectionConfig) {
      res["CollectionConfig"] = boost::any(*collectionConfig);
    }
    if (endorsementPolicy) {
      res["EndorsementPolicy"] = boost::any(*endorsementPolicy);
    }
    if (initRequired) {
      res["InitRequired"] = boost::any(*initRequired);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (sequence) {
      res["Sequence"] = boost::any(*sequence);
    }
    if (uid) {
      res["Uid"] = boost::any(*uid);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodePackageId") != m.end() && !m["ChaincodePackageId"].empty()) {
      chaincodePackageId = make_shared<string>(boost::any_cast<string>(m["ChaincodePackageId"]));
    }
    if (m.find("CollectionConfig") != m.end() && !m["CollectionConfig"].empty()) {
      collectionConfig = make_shared<string>(boost::any_cast<string>(m["CollectionConfig"]));
    }
    if (m.find("EndorsementPolicy") != m.end() && !m["EndorsementPolicy"].empty()) {
      endorsementPolicy = make_shared<string>(boost::any_cast<string>(m["EndorsementPolicy"]));
    }
    if (m.find("InitRequired") != m.end() && !m["InitRequired"].empty()) {
      initRequired = make_shared<bool>(boost::any_cast<bool>(m["InitRequired"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Sequence") != m.end() && !m["Sequence"].empty()) {
      sequence = make_shared<long>(boost::any_cast<long>(m["Sequence"]));
    }
    if (m.find("Uid") != m.end() && !m["Uid"].empty()) {
      uid = make_shared<string>(boost::any_cast<string>(m["Uid"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~DescribeFabricChaincodeDefinitionTaskResponseBodyResultContentChaincodeDefinition() = default;
};
class DescribeFabricChaincodeDefinitionTaskResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<DescribeFabricChaincodeDefinitionTaskResponseBodyResultContentChaincodeDefinition> chaincodeDefinition{};

  DescribeFabricChaincodeDefinitionTaskResponseBodyResultContent() {}

  explicit DescribeFabricChaincodeDefinitionTaskResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeDefinition) {
      res["ChaincodeDefinition"] = chaincodeDefinition ? boost::any(chaincodeDefinition->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeDefinition") != m.end() && !m["ChaincodeDefinition"].empty()) {
      if (typeid(map<string, boost::any>) == m["ChaincodeDefinition"].type()) {
        DescribeFabricChaincodeDefinitionTaskResponseBodyResultContentChaincodeDefinition model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ChaincodeDefinition"]));
        chaincodeDefinition = make_shared<DescribeFabricChaincodeDefinitionTaskResponseBodyResultContentChaincodeDefinition>(model1);
      }
    }
  }


  virtual ~DescribeFabricChaincodeDefinitionTaskResponseBodyResultContent() = default;
};
class DescribeFabricChaincodeDefinitionTaskResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<string>> approvers{};
  shared_ptr<string> channelName{};
  shared_ptr<DescribeFabricChaincodeDefinitionTaskResponseBodyResultContent> content{};
  shared_ptr<long> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> description{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> type{};

  DescribeFabricChaincodeDefinitionTaskResponseBodyResult() {}

  explicit DescribeFabricChaincodeDefinitionTaskResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (approvers) {
      res["Approvers"] = boost::any(*approvers);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (content) {
      res["Content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Approvers") != m.end() && !m["Approvers"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Approvers"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Approvers"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      approvers = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      if (typeid(map<string, boost::any>) == m["Content"].type()) {
        DescribeFabricChaincodeDefinitionTaskResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Content"]));
        content = make_shared<DescribeFabricChaincodeDefinitionTaskResponseBodyResultContent>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~DescribeFabricChaincodeDefinitionTaskResponseBodyResult() = default;
};
class DescribeFabricChaincodeDefinitionTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeFabricChaincodeDefinitionTaskResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeFabricChaincodeDefinitionTaskResponseBody() {}

  explicit DescribeFabricChaincodeDefinitionTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeFabricChaincodeDefinitionTaskResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeFabricChaincodeDefinitionTaskResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricChaincodeDefinitionTaskResponseBody() = default;
};
class DescribeFabricChaincodeDefinitionTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricChaincodeDefinitionTaskResponseBody> body{};

  DescribeFabricChaincodeDefinitionTaskResponse() {}

  explicit DescribeFabricChaincodeDefinitionTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricChaincodeDefinitionTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricChaincodeDefinitionTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricChaincodeDefinitionTaskResponse() = default;
};
class DescribeFabricChaincodeUploadPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};

  DescribeFabricChaincodeUploadPolicyRequest() {}

  explicit DescribeFabricChaincodeUploadPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeFabricChaincodeUploadPolicyRequest() = default;
};
class DescribeFabricChaincodeUploadPolicyResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> accessId{};
  shared_ptr<string> dir{};
  shared_ptr<long> expire{};
  shared_ptr<string> host{};
  shared_ptr<string> policy{};
  shared_ptr<string> signature{};

  DescribeFabricChaincodeUploadPolicyResponseBodyResult() {}

  explicit DescribeFabricChaincodeUploadPolicyResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessId) {
      res["AccessId"] = boost::any(*accessId);
    }
    if (dir) {
      res["Dir"] = boost::any(*dir);
    }
    if (expire) {
      res["Expire"] = boost::any(*expire);
    }
    if (host) {
      res["Host"] = boost::any(*host);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (signature) {
      res["Signature"] = boost::any(*signature);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessId") != m.end() && !m["AccessId"].empty()) {
      accessId = make_shared<string>(boost::any_cast<string>(m["AccessId"]));
    }
    if (m.find("Dir") != m.end() && !m["Dir"].empty()) {
      dir = make_shared<string>(boost::any_cast<string>(m["Dir"]));
    }
    if (m.find("Expire") != m.end() && !m["Expire"].empty()) {
      expire = make_shared<long>(boost::any_cast<long>(m["Expire"]));
    }
    if (m.find("Host") != m.end() && !m["Host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["Host"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Signature") != m.end() && !m["Signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["Signature"]));
    }
  }


  virtual ~DescribeFabricChaincodeUploadPolicyResponseBodyResult() = default;
};
class DescribeFabricChaincodeUploadPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeFabricChaincodeUploadPolicyResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeFabricChaincodeUploadPolicyResponseBody() {}

  explicit DescribeFabricChaincodeUploadPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeFabricChaincodeUploadPolicyResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeFabricChaincodeUploadPolicyResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricChaincodeUploadPolicyResponseBody() = default;
};
class DescribeFabricChaincodeUploadPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricChaincodeUploadPolicyResponseBody> body{};

  DescribeFabricChaincodeUploadPolicyResponse() {}

  explicit DescribeFabricChaincodeUploadPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricChaincodeUploadPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricChaincodeUploadPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricChaincodeUploadPolicyResponse() = default;
};
class DescribeFabricChannelMembersRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};

  DescribeFabricChannelMembersRequest() {}

  explicit DescribeFabricChannelMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
  }


  virtual ~DescribeFabricChannelMembersRequest() = default;
};
class DescribeFabricChannelMembersResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> acceptTime{};
  shared_ptr<string> channelId{};
  shared_ptr<string> inviteTime{};
  shared_ptr<string> organizationDescription{};
  shared_ptr<string> organizationDomain{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> organizationName{};
  shared_ptr<string> state{};
  shared_ptr<bool> withPeer{};

  DescribeFabricChannelMembersResponseBodyResult() {}

  explicit DescribeFabricChannelMembersResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptTime) {
      res["AcceptTime"] = boost::any(*acceptTime);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (inviteTime) {
      res["InviteTime"] = boost::any(*inviteTime);
    }
    if (organizationDescription) {
      res["OrganizationDescription"] = boost::any(*organizationDescription);
    }
    if (organizationDomain) {
      res["OrganizationDomain"] = boost::any(*organizationDomain);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (organizationName) {
      res["OrganizationName"] = boost::any(*organizationName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (withPeer) {
      res["WithPeer"] = boost::any(*withPeer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptTime") != m.end() && !m["AcceptTime"].empty()) {
      acceptTime = make_shared<string>(boost::any_cast<string>(m["AcceptTime"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("InviteTime") != m.end() && !m["InviteTime"].empty()) {
      inviteTime = make_shared<string>(boost::any_cast<string>(m["InviteTime"]));
    }
    if (m.find("OrganizationDescription") != m.end() && !m["OrganizationDescription"].empty()) {
      organizationDescription = make_shared<string>(boost::any_cast<string>(m["OrganizationDescription"]));
    }
    if (m.find("OrganizationDomain") != m.end() && !m["OrganizationDomain"].empty()) {
      organizationDomain = make_shared<string>(boost::any_cast<string>(m["OrganizationDomain"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("OrganizationName") != m.end() && !m["OrganizationName"].empty()) {
      organizationName = make_shared<string>(boost::any_cast<string>(m["OrganizationName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("WithPeer") != m.end() && !m["WithPeer"].empty()) {
      withPeer = make_shared<bool>(boost::any_cast<bool>(m["WithPeer"]));
    }
  }


  virtual ~DescribeFabricChannelMembersResponseBodyResult() = default;
};
class DescribeFabricChannelMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeFabricChannelMembersResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeFabricChannelMembersResponseBody() {}

  explicit DescribeFabricChannelMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeFabricChannelMembersResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFabricChannelMembersResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeFabricChannelMembersResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricChannelMembersResponseBody() = default;
};
class DescribeFabricChannelMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricChannelMembersResponseBody> body{};

  DescribeFabricChannelMembersResponse() {}

  explicit DescribeFabricChannelMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricChannelMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricChannelMembersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricChannelMembersResponse() = default;
};
class DescribeFabricConsortiumAdminStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> location{};

  DescribeFabricConsortiumAdminStatusRequest() {}

  explicit DescribeFabricConsortiumAdminStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
  }


  virtual ~DescribeFabricConsortiumAdminStatusRequest() = default;
};
class DescribeFabricConsortiumAdminStatusResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> consortiumAdministrator{};
  shared_ptr<string> consortiumId{};

  DescribeFabricConsortiumAdminStatusResponseBodyResult() {}

  explicit DescribeFabricConsortiumAdminStatusResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumAdministrator) {
      res["ConsortiumAdministrator"] = boost::any(*consortiumAdministrator);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumAdministrator") != m.end() && !m["ConsortiumAdministrator"].empty()) {
      consortiumAdministrator = make_shared<bool>(boost::any_cast<bool>(m["ConsortiumAdministrator"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
  }


  virtual ~DescribeFabricConsortiumAdminStatusResponseBodyResult() = default;
};
class DescribeFabricConsortiumAdminStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeFabricConsortiumAdminStatusResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeFabricConsortiumAdminStatusResponseBody() {}

  explicit DescribeFabricConsortiumAdminStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeFabricConsortiumAdminStatusResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFabricConsortiumAdminStatusResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeFabricConsortiumAdminStatusResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricConsortiumAdminStatusResponseBody() = default;
};
class DescribeFabricConsortiumAdminStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricConsortiumAdminStatusResponseBody> body{};

  DescribeFabricConsortiumAdminStatusResponse() {}

  explicit DescribeFabricConsortiumAdminStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricConsortiumAdminStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricConsortiumAdminStatusResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricConsortiumAdminStatusResponse() = default;
};
class DescribeFabricConsortiumChaincodesRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> location{};

  DescribeFabricConsortiumChaincodesRequest() {}

  explicit DescribeFabricConsortiumChaincodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
  }


  virtual ~DescribeFabricConsortiumChaincodesRequest() = default;
};
class DescribeFabricConsortiumChaincodesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> chaincodeName{};
  shared_ptr<string> chaincodeVersion{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deployTime{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<string> input{};
  shared_ptr<bool> install{};
  shared_ptr<string> message{};
  shared_ptr<string> path{};
  shared_ptr<string> providerId{};
  shared_ptr<string> providerName{};
  shared_ptr<string> state{};
  shared_ptr<long> type{};

  DescribeFabricConsortiumChaincodesResponseBodyResult() {}

  explicit DescribeFabricConsortiumChaincodesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (chaincodeName) {
      res["ChaincodeName"] = boost::any(*chaincodeName);
    }
    if (chaincodeVersion) {
      res["ChaincodeVersion"] = boost::any(*chaincodeVersion);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deployTime) {
      res["DeployTime"] = boost::any(*deployTime);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (install) {
      res["Install"] = boost::any(*install);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (providerId) {
      res["ProviderId"] = boost::any(*providerId);
    }
    if (providerName) {
      res["ProviderName"] = boost::any(*providerName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("ChaincodeName") != m.end() && !m["ChaincodeName"].empty()) {
      chaincodeName = make_shared<string>(boost::any_cast<string>(m["ChaincodeName"]));
    }
    if (m.find("ChaincodeVersion") != m.end() && !m["ChaincodeVersion"].empty()) {
      chaincodeVersion = make_shared<string>(boost::any_cast<string>(m["ChaincodeVersion"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeployTime") != m.end() && !m["DeployTime"].empty()) {
      deployTime = make_shared<string>(boost::any_cast<string>(m["DeployTime"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Install") != m.end() && !m["Install"].empty()) {
      install = make_shared<bool>(boost::any_cast<bool>(m["Install"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ProviderId") != m.end() && !m["ProviderId"].empty()) {
      providerId = make_shared<string>(boost::any_cast<string>(m["ProviderId"]));
    }
    if (m.find("ProviderName") != m.end() && !m["ProviderName"].empty()) {
      providerName = make_shared<string>(boost::any_cast<string>(m["ProviderName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~DescribeFabricConsortiumChaincodesResponseBodyResult() = default;
};
class DescribeFabricConsortiumChaincodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeFabricConsortiumChaincodesResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeFabricConsortiumChaincodesResponseBody() {}

  explicit DescribeFabricConsortiumChaincodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeFabricConsortiumChaincodesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFabricConsortiumChaincodesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeFabricConsortiumChaincodesResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricConsortiumChaincodesResponseBody() = default;
};
class DescribeFabricConsortiumChaincodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricConsortiumChaincodesResponseBody> body{};

  DescribeFabricConsortiumChaincodesResponse() {}

  explicit DescribeFabricConsortiumChaincodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricConsortiumChaincodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricConsortiumChaincodesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricConsortiumChaincodesResponse() = default;
};
class DescribeFabricConsortiumChannelsRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> location{};

  DescribeFabricConsortiumChannelsRequest() {}

  explicit DescribeFabricConsortiumChannelsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
  }


  virtual ~DescribeFabricConsortiumChannelsRequest() = default;
};
class DescribeFabricConsortiumChannelsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> batchTimeout{};
  shared_ptr<long> blockCount{};
  shared_ptr<long> chaincodeCount{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelName{};
  shared_ptr<long> consortiumChannelId{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> consortiumName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deleteTime{};
  shared_ptr<bool> deleted{};
  shared_ptr<long> maxMessageCount{};
  shared_ptr<long> memberCount{};
  shared_ptr<string> memberJoinedCount{};
  shared_ptr<bool> needJoined{};
  shared_ptr<string> ownerBid{};
  shared_ptr<string> ownerName{};
  shared_ptr<long> ownerUid{};
  shared_ptr<long> preferredMaxBytes{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};
  shared_ptr<bool> supportChannelConfig{};
  shared_ptr<string> updateTime{};

  DescribeFabricConsortiumChannelsResponseBodyResult() {}

  explicit DescribeFabricConsortiumChannelsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchTimeout) {
      res["BatchTimeout"] = boost::any(*batchTimeout);
    }
    if (blockCount) {
      res["BlockCount"] = boost::any(*blockCount);
    }
    if (chaincodeCount) {
      res["ChaincodeCount"] = boost::any(*chaincodeCount);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (consortiumChannelId) {
      res["ConsortiumChannelId"] = boost::any(*consortiumChannelId);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (consortiumName) {
      res["ConsortiumName"] = boost::any(*consortiumName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deleteTime) {
      res["DeleteTime"] = boost::any(*deleteTime);
    }
    if (deleted) {
      res["Deleted"] = boost::any(*deleted);
    }
    if (maxMessageCount) {
      res["MaxMessageCount"] = boost::any(*maxMessageCount);
    }
    if (memberCount) {
      res["MemberCount"] = boost::any(*memberCount);
    }
    if (memberJoinedCount) {
      res["MemberJoinedCount"] = boost::any(*memberJoinedCount);
    }
    if (needJoined) {
      res["NeedJoined"] = boost::any(*needJoined);
    }
    if (ownerBid) {
      res["OwnerBid"] = boost::any(*ownerBid);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUid) {
      res["OwnerUid"] = boost::any(*ownerUid);
    }
    if (preferredMaxBytes) {
      res["PreferredMaxBytes"] = boost::any(*preferredMaxBytes);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (supportChannelConfig) {
      res["SupportChannelConfig"] = boost::any(*supportChannelConfig);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchTimeout") != m.end() && !m["BatchTimeout"].empty()) {
      batchTimeout = make_shared<long>(boost::any_cast<long>(m["BatchTimeout"]));
    }
    if (m.find("BlockCount") != m.end() && !m["BlockCount"].empty()) {
      blockCount = make_shared<long>(boost::any_cast<long>(m["BlockCount"]));
    }
    if (m.find("ChaincodeCount") != m.end() && !m["ChaincodeCount"].empty()) {
      chaincodeCount = make_shared<long>(boost::any_cast<long>(m["ChaincodeCount"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ConsortiumChannelId") != m.end() && !m["ConsortiumChannelId"].empty()) {
      consortiumChannelId = make_shared<long>(boost::any_cast<long>(m["ConsortiumChannelId"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("ConsortiumName") != m.end() && !m["ConsortiumName"].empty()) {
      consortiumName = make_shared<string>(boost::any_cast<string>(m["ConsortiumName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeleteTime") != m.end() && !m["DeleteTime"].empty()) {
      deleteTime = make_shared<string>(boost::any_cast<string>(m["DeleteTime"]));
    }
    if (m.find("Deleted") != m.end() && !m["Deleted"].empty()) {
      deleted = make_shared<bool>(boost::any_cast<bool>(m["Deleted"]));
    }
    if (m.find("MaxMessageCount") != m.end() && !m["MaxMessageCount"].empty()) {
      maxMessageCount = make_shared<long>(boost::any_cast<long>(m["MaxMessageCount"]));
    }
    if (m.find("MemberCount") != m.end() && !m["MemberCount"].empty()) {
      memberCount = make_shared<long>(boost::any_cast<long>(m["MemberCount"]));
    }
    if (m.find("MemberJoinedCount") != m.end() && !m["MemberJoinedCount"].empty()) {
      memberJoinedCount = make_shared<string>(boost::any_cast<string>(m["MemberJoinedCount"]));
    }
    if (m.find("NeedJoined") != m.end() && !m["NeedJoined"].empty()) {
      needJoined = make_shared<bool>(boost::any_cast<bool>(m["NeedJoined"]));
    }
    if (m.find("OwnerBid") != m.end() && !m["OwnerBid"].empty()) {
      ownerBid = make_shared<string>(boost::any_cast<string>(m["OwnerBid"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUid") != m.end() && !m["OwnerUid"].empty()) {
      ownerUid = make_shared<long>(boost::any_cast<long>(m["OwnerUid"]));
    }
    if (m.find("PreferredMaxBytes") != m.end() && !m["PreferredMaxBytes"].empty()) {
      preferredMaxBytes = make_shared<long>(boost::any_cast<long>(m["PreferredMaxBytes"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("SupportChannelConfig") != m.end() && !m["SupportChannelConfig"].empty()) {
      supportChannelConfig = make_shared<bool>(boost::any_cast<bool>(m["SupportChannelConfig"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeFabricConsortiumChannelsResponseBodyResult() = default;
};
class DescribeFabricConsortiumChannelsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeFabricConsortiumChannelsResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeFabricConsortiumChannelsResponseBody() {}

  explicit DescribeFabricConsortiumChannelsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeFabricConsortiumChannelsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFabricConsortiumChannelsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeFabricConsortiumChannelsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricConsortiumChannelsResponseBody() = default;
};
class DescribeFabricConsortiumChannelsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricConsortiumChannelsResponseBody> body{};

  DescribeFabricConsortiumChannelsResponse() {}

  explicit DescribeFabricConsortiumChannelsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricConsortiumChannelsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricConsortiumChannelsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricConsortiumChannelsResponse() = default;
};
class DescribeFabricConsortiumConfigResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<string>> channelPolicy{};
  shared_ptr<vector<string>> ordererType{};

  DescribeFabricConsortiumConfigResponseBodyResult() {}

  explicit DescribeFabricConsortiumConfigResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelPolicy) {
      res["ChannelPolicy"] = boost::any(*channelPolicy);
    }
    if (ordererType) {
      res["OrdererType"] = boost::any(*ordererType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelPolicy") != m.end() && !m["ChannelPolicy"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ChannelPolicy"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ChannelPolicy"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channelPolicy = make_shared<vector<string>>(toVec1);
    }
    if (m.find("OrdererType") != m.end() && !m["OrdererType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["OrdererType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["OrdererType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ordererType = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeFabricConsortiumConfigResponseBodyResult() = default;
};
class DescribeFabricConsortiumConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeFabricConsortiumConfigResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeFabricConsortiumConfigResponseBody() {}

  explicit DescribeFabricConsortiumConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeFabricConsortiumConfigResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeFabricConsortiumConfigResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricConsortiumConfigResponseBody() = default;
};
class DescribeFabricConsortiumConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricConsortiumConfigResponseBody> body{};

  DescribeFabricConsortiumConfigResponse() {}

  explicit DescribeFabricConsortiumConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricConsortiumConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricConsortiumConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricConsortiumConfigResponse() = default;
};
class DescribeFabricConsortiumDeletableRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> location{};

  DescribeFabricConsortiumDeletableRequest() {}

  explicit DescribeFabricConsortiumDeletableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
  }


  virtual ~DescribeFabricConsortiumDeletableRequest() = default;
};
class DescribeFabricConsortiumDeletableResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> codeName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> consortiumName{};
  shared_ptr<bool> deletable{};
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<string> regionId{};
  shared_ptr<string> state{};
  shared_ptr<string> zoneId{};

  DescribeFabricConsortiumDeletableResponseBodyResult() {}

  explicit DescribeFabricConsortiumDeletableResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codeName) {
      res["CodeName"] = boost::any(*codeName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (consortiumName) {
      res["ConsortiumName"] = boost::any(*consortiumName);
    }
    if (deletable) {
      res["Deletable"] = boost::any(*deletable);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodeName") != m.end() && !m["CodeName"].empty()) {
      codeName = make_shared<string>(boost::any_cast<string>(m["CodeName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("ConsortiumName") != m.end() && !m["ConsortiumName"].empty()) {
      consortiumName = make_shared<string>(boost::any_cast<string>(m["ConsortiumName"]));
    }
    if (m.find("Deletable") != m.end() && !m["Deletable"].empty()) {
      deletable = make_shared<bool>(boost::any_cast<bool>(m["Deletable"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeFabricConsortiumDeletableResponseBodyResult() = default;
};
class DescribeFabricConsortiumDeletableResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeFabricConsortiumDeletableResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeFabricConsortiumDeletableResponseBody() {}

  explicit DescribeFabricConsortiumDeletableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeFabricConsortiumDeletableResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeFabricConsortiumDeletableResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricConsortiumDeletableResponseBody() = default;
};
class DescribeFabricConsortiumDeletableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricConsortiumDeletableResponseBody> body{};

  DescribeFabricConsortiumDeletableResponse() {}

  explicit DescribeFabricConsortiumDeletableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricConsortiumDeletableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricConsortiumDeletableResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricConsortiumDeletableResponse() = default;
};
class DescribeFabricConsortiumMemberApprovalRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> location{};

  DescribeFabricConsortiumMemberApprovalRequest() {}

  explicit DescribeFabricConsortiumMemberApprovalRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
  }


  virtual ~DescribeFabricConsortiumMemberApprovalRequest() = default;
};
class DescribeFabricConsortiumMemberApprovalResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> channelCreatePolicy{};
  shared_ptr<string> confirmTime{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> consortiumName{};
  shared_ptr<string> domainName{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> organizationName{};
  shared_ptr<string> state{};

  DescribeFabricConsortiumMemberApprovalResponseBodyResult() {}

  explicit DescribeFabricConsortiumMemberApprovalResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelCreatePolicy) {
      res["ChannelCreatePolicy"] = boost::any(*channelCreatePolicy);
    }
    if (confirmTime) {
      res["ConfirmTime"] = boost::any(*confirmTime);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (consortiumName) {
      res["ConsortiumName"] = boost::any(*consortiumName);
    }
    if (domainName) {
      res["DomainName"] = boost::any(*domainName);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (organizationName) {
      res["OrganizationName"] = boost::any(*organizationName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelCreatePolicy") != m.end() && !m["ChannelCreatePolicy"].empty()) {
      channelCreatePolicy = make_shared<string>(boost::any_cast<string>(m["ChannelCreatePolicy"]));
    }
    if (m.find("ConfirmTime") != m.end() && !m["ConfirmTime"].empty()) {
      confirmTime = make_shared<string>(boost::any_cast<string>(m["ConfirmTime"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("ConsortiumName") != m.end() && !m["ConsortiumName"].empty()) {
      consortiumName = make_shared<string>(boost::any_cast<string>(m["ConsortiumName"]));
    }
    if (m.find("DomainName") != m.end() && !m["DomainName"].empty()) {
      domainName = make_shared<string>(boost::any_cast<string>(m["DomainName"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("OrganizationName") != m.end() && !m["OrganizationName"].empty()) {
      organizationName = make_shared<string>(boost::any_cast<string>(m["OrganizationName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~DescribeFabricConsortiumMemberApprovalResponseBodyResult() = default;
};
class DescribeFabricConsortiumMemberApprovalResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeFabricConsortiumMemberApprovalResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeFabricConsortiumMemberApprovalResponseBody() {}

  explicit DescribeFabricConsortiumMemberApprovalResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeFabricConsortiumMemberApprovalResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFabricConsortiumMemberApprovalResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeFabricConsortiumMemberApprovalResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricConsortiumMemberApprovalResponseBody() = default;
};
class DescribeFabricConsortiumMemberApprovalResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricConsortiumMemberApprovalResponseBody> body{};

  DescribeFabricConsortiumMemberApprovalResponse() {}

  explicit DescribeFabricConsortiumMemberApprovalResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricConsortiumMemberApprovalResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricConsortiumMemberApprovalResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricConsortiumMemberApprovalResponse() = default;
};
class DescribeFabricConsortiumMembersRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> location{};

  DescribeFabricConsortiumMembersRequest() {}

  explicit DescribeFabricConsortiumMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
  }


  virtual ~DescribeFabricConsortiumMembersRequest() = default;
};
class DescribeFabricConsortiumMembersResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<string> joinedTime{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> organizationName{};

  DescribeFabricConsortiumMembersResponseBodyResult() {}

  explicit DescribeFabricConsortiumMembersResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (joinedTime) {
      res["JoinedTime"] = boost::any(*joinedTime);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (organizationName) {
      res["OrganizationName"] = boost::any(*organizationName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("JoinedTime") != m.end() && !m["JoinedTime"].empty()) {
      joinedTime = make_shared<string>(boost::any_cast<string>(m["JoinedTime"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("OrganizationName") != m.end() && !m["OrganizationName"].empty()) {
      organizationName = make_shared<string>(boost::any_cast<string>(m["OrganizationName"]));
    }
  }


  virtual ~DescribeFabricConsortiumMembersResponseBodyResult() = default;
};
class DescribeFabricConsortiumMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeFabricConsortiumMembersResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeFabricConsortiumMembersResponseBody() {}

  explicit DescribeFabricConsortiumMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeFabricConsortiumMembersResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFabricConsortiumMembersResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeFabricConsortiumMembersResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricConsortiumMembersResponseBody() = default;
};
class DescribeFabricConsortiumMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricConsortiumMembersResponseBody> body{};

  DescribeFabricConsortiumMembersResponse() {}

  explicit DescribeFabricConsortiumMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricConsortiumMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricConsortiumMembersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricConsortiumMembersResponse() = default;
};
class DescribeFabricConsortiumOrderersRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> location{};

  DescribeFabricConsortiumOrderersRequest() {}

  explicit DescribeFabricConsortiumOrderersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
  }


  virtual ~DescribeFabricConsortiumOrderersRequest() = default;
};
class DescribeFabricConsortiumOrderersResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> domain{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> ordererName{};
  shared_ptr<long> port{};
  shared_ptr<string> updateTime{};

  DescribeFabricConsortiumOrderersResponseBodyResult() {}

  explicit DescribeFabricConsortiumOrderersResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (ordererName) {
      res["OrdererName"] = boost::any(*ordererName);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("OrdererName") != m.end() && !m["OrdererName"].empty()) {
      ordererName = make_shared<string>(boost::any_cast<string>(m["OrdererName"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeFabricConsortiumOrderersResponseBodyResult() = default;
};
class DescribeFabricConsortiumOrderersResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeFabricConsortiumOrderersResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeFabricConsortiumOrderersResponseBody() {}

  explicit DescribeFabricConsortiumOrderersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeFabricConsortiumOrderersResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFabricConsortiumOrderersResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeFabricConsortiumOrderersResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricConsortiumOrderersResponseBody() = default;
};
class DescribeFabricConsortiumOrderersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricConsortiumOrderersResponseBody> body{};

  DescribeFabricConsortiumOrderersResponse() {}

  explicit DescribeFabricConsortiumOrderersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricConsortiumOrderersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricConsortiumOrderersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricConsortiumOrderersResponse() = default;
};
class DescribeFabricConsortiumSpecsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};
  shared_ptr<string> specName{};
  shared_ptr<string> specTitle{};

  DescribeFabricConsortiumSpecsResponseBodyResult() {}

  explicit DescribeFabricConsortiumSpecsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (specName) {
      res["SpecName"] = boost::any(*specName);
    }
    if (specTitle) {
      res["SpecTitle"] = boost::any(*specTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("SpecName") != m.end() && !m["SpecName"].empty()) {
      specName = make_shared<string>(boost::any_cast<string>(m["SpecName"]));
    }
    if (m.find("SpecTitle") != m.end() && !m["SpecTitle"].empty()) {
      specTitle = make_shared<string>(boost::any_cast<string>(m["SpecTitle"]));
    }
  }


  virtual ~DescribeFabricConsortiumSpecsResponseBodyResult() = default;
};
class DescribeFabricConsortiumSpecsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeFabricConsortiumSpecsResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeFabricConsortiumSpecsResponseBody() {}

  explicit DescribeFabricConsortiumSpecsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeFabricConsortiumSpecsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFabricConsortiumSpecsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeFabricConsortiumSpecsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricConsortiumSpecsResponseBody() = default;
};
class DescribeFabricConsortiumSpecsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricConsortiumSpecsResponseBody> body{};

  DescribeFabricConsortiumSpecsResponse() {}

  explicit DescribeFabricConsortiumSpecsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricConsortiumSpecsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricConsortiumSpecsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricConsortiumSpecsResponse() = default;
};
class DescribeFabricConsortiumsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeFabricConsortiumsRequestTag() {}

  explicit DescribeFabricConsortiumsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeFabricConsortiumsRequestTag() = default;
};
class DescribeFabricConsortiumsRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> location{};
  shared_ptr<vector<DescribeFabricConsortiumsRequestTag>> tag{};

  DescribeFabricConsortiumsRequest() {}

  explicit DescribeFabricConsortiumsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeFabricConsortiumsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFabricConsortiumsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeFabricConsortiumsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeFabricConsortiumsRequest() = default;
};
class DescribeFabricConsortiumsResponseBodyResultTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeFabricConsortiumsResponseBodyResultTags() {}

  explicit DescribeFabricConsortiumsResponseBodyResultTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeFabricConsortiumsResponseBodyResultTags() = default;
};
class DescribeFabricConsortiumsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> channelCount{};
  shared_ptr<string> channelPolicy{};
  shared_ptr<string> codeName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> consortiumName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> domain{};
  shared_ptr<string> expiredTime{};
  shared_ptr<string> majorVersion{};
  shared_ptr<long> organizationCount{};
  shared_ptr<string> ownerBid{};
  shared_ptr<string> ownerName{};
  shared_ptr<long> ownerUid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> specName{};
  shared_ptr<string> state{};
  shared_ptr<bool> supportChannelConfig{};
  shared_ptr<vector<DescribeFabricConsortiumsResponseBodyResultTags>> tags{};

  DescribeFabricConsortiumsResponseBodyResult() {}

  explicit DescribeFabricConsortiumsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelCount) {
      res["ChannelCount"] = boost::any(*channelCount);
    }
    if (channelPolicy) {
      res["ChannelPolicy"] = boost::any(*channelPolicy);
    }
    if (codeName) {
      res["CodeName"] = boost::any(*codeName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (consortiumName) {
      res["ConsortiumName"] = boost::any(*consortiumName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (expiredTime) {
      res["ExpiredTime"] = boost::any(*expiredTime);
    }
    if (majorVersion) {
      res["MajorVersion"] = boost::any(*majorVersion);
    }
    if (organizationCount) {
      res["OrganizationCount"] = boost::any(*organizationCount);
    }
    if (ownerBid) {
      res["OwnerBid"] = boost::any(*ownerBid);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUid) {
      res["OwnerUid"] = boost::any(*ownerUid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (specName) {
      res["SpecName"] = boost::any(*specName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (supportChannelConfig) {
      res["SupportChannelConfig"] = boost::any(*supportChannelConfig);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelCount") != m.end() && !m["ChannelCount"].empty()) {
      channelCount = make_shared<long>(boost::any_cast<long>(m["ChannelCount"]));
    }
    if (m.find("ChannelPolicy") != m.end() && !m["ChannelPolicy"].empty()) {
      channelPolicy = make_shared<string>(boost::any_cast<string>(m["ChannelPolicy"]));
    }
    if (m.find("CodeName") != m.end() && !m["CodeName"].empty()) {
      codeName = make_shared<string>(boost::any_cast<string>(m["CodeName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("ConsortiumName") != m.end() && !m["ConsortiumName"].empty()) {
      consortiumName = make_shared<string>(boost::any_cast<string>(m["ConsortiumName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("ExpiredTime") != m.end() && !m["ExpiredTime"].empty()) {
      expiredTime = make_shared<string>(boost::any_cast<string>(m["ExpiredTime"]));
    }
    if (m.find("MajorVersion") != m.end() && !m["MajorVersion"].empty()) {
      majorVersion = make_shared<string>(boost::any_cast<string>(m["MajorVersion"]));
    }
    if (m.find("OrganizationCount") != m.end() && !m["OrganizationCount"].empty()) {
      organizationCount = make_shared<long>(boost::any_cast<long>(m["OrganizationCount"]));
    }
    if (m.find("OwnerBid") != m.end() && !m["OwnerBid"].empty()) {
      ownerBid = make_shared<string>(boost::any_cast<string>(m["OwnerBid"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUid") != m.end() && !m["OwnerUid"].empty()) {
      ownerUid = make_shared<long>(boost::any_cast<long>(m["OwnerUid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SpecName") != m.end() && !m["SpecName"].empty()) {
      specName = make_shared<string>(boost::any_cast<string>(m["SpecName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("SupportChannelConfig") != m.end() && !m["SupportChannelConfig"].empty()) {
      supportChannelConfig = make_shared<bool>(boost::any_cast<bool>(m["SupportChannelConfig"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeFabricConsortiumsResponseBodyResultTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFabricConsortiumsResponseBodyResultTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeFabricConsortiumsResponseBodyResultTags>>(expect1);
      }
    }
  }


  virtual ~DescribeFabricConsortiumsResponseBodyResult() = default;
};
class DescribeFabricConsortiumsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeFabricConsortiumsResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeFabricConsortiumsResponseBody() {}

  explicit DescribeFabricConsortiumsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeFabricConsortiumsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFabricConsortiumsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeFabricConsortiumsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricConsortiumsResponseBody() = default;
};
class DescribeFabricConsortiumsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricConsortiumsResponseBody> body{};

  DescribeFabricConsortiumsResponse() {}

  explicit DescribeFabricConsortiumsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricConsortiumsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricConsortiumsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricConsortiumsResponse() = default;
};
class DescribeFabricExplorerRequest : public Darabonba::Model {
public:
  shared_ptr<string> exBody{};
  shared_ptr<string> exMethod{};
  shared_ptr<string> exUrl{};
  shared_ptr<string> organizationId{};

  DescribeFabricExplorerRequest() {}

  explicit DescribeFabricExplorerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (exBody) {
      res["ExBody"] = boost::any(*exBody);
    }
    if (exMethod) {
      res["ExMethod"] = boost::any(*exMethod);
    }
    if (exUrl) {
      res["ExUrl"] = boost::any(*exUrl);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExBody") != m.end() && !m["ExBody"].empty()) {
      exBody = make_shared<string>(boost::any_cast<string>(m["ExBody"]));
    }
    if (m.find("ExMethod") != m.end() && !m["ExMethod"].empty()) {
      exMethod = make_shared<string>(boost::any_cast<string>(m["ExMethod"]));
    }
    if (m.find("ExUrl") != m.end() && !m["ExUrl"].empty()) {
      exUrl = make_shared<string>(boost::any_cast<string>(m["ExUrl"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeFabricExplorerRequest() = default;
};
class DescribeFabricExplorerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  DescribeFabricExplorerResponseBody() {}

  explicit DescribeFabricExplorerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricExplorerResponseBody() = default;
};
class DescribeFabricExplorerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricExplorerResponseBody> body{};

  DescribeFabricExplorerResponse() {}

  explicit DescribeFabricExplorerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricExplorerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricExplorerResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricExplorerResponse() = default;
};
class DescribeFabricInvitationCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};

  DescribeFabricInvitationCodeRequest() {}

  explicit DescribeFabricInvitationCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
  }


  virtual ~DescribeFabricInvitationCodeRequest() = default;
};
class DescribeFabricInvitationCodeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> accepted{};
  shared_ptr<string> code{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> email{};
  shared_ptr<string> expireTime{};
  shared_ptr<long> invitationId{};
  shared_ptr<string> sendTime{};
  shared_ptr<string> senderBid{};
  shared_ptr<long> senderId{};
  shared_ptr<string> senderName{};
  shared_ptr<string> url{};

  DescribeFabricInvitationCodeResponseBodyResult() {}

  explicit DescribeFabricInvitationCodeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accepted) {
      res["Accepted"] = boost::any(*accepted);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (invitationId) {
      res["InvitationId"] = boost::any(*invitationId);
    }
    if (sendTime) {
      res["SendTime"] = boost::any(*sendTime);
    }
    if (senderBid) {
      res["SenderBid"] = boost::any(*senderBid);
    }
    if (senderId) {
      res["SenderId"] = boost::any(*senderId);
    }
    if (senderName) {
      res["SenderName"] = boost::any(*senderName);
    }
    if (url) {
      res["Url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Accepted") != m.end() && !m["Accepted"].empty()) {
      accepted = make_shared<bool>(boost::any_cast<bool>(m["Accepted"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("InvitationId") != m.end() && !m["InvitationId"].empty()) {
      invitationId = make_shared<long>(boost::any_cast<long>(m["InvitationId"]));
    }
    if (m.find("SendTime") != m.end() && !m["SendTime"].empty()) {
      sendTime = make_shared<string>(boost::any_cast<string>(m["SendTime"]));
    }
    if (m.find("SenderBid") != m.end() && !m["SenderBid"].empty()) {
      senderBid = make_shared<string>(boost::any_cast<string>(m["SenderBid"]));
    }
    if (m.find("SenderId") != m.end() && !m["SenderId"].empty()) {
      senderId = make_shared<long>(boost::any_cast<long>(m["SenderId"]));
    }
    if (m.find("SenderName") != m.end() && !m["SenderName"].empty()) {
      senderName = make_shared<string>(boost::any_cast<string>(m["SenderName"]));
    }
    if (m.find("Url") != m.end() && !m["Url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["Url"]));
    }
  }


  virtual ~DescribeFabricInvitationCodeResponseBodyResult() = default;
};
class DescribeFabricInvitationCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeFabricInvitationCodeResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeFabricInvitationCodeResponseBody() {}

  explicit DescribeFabricInvitationCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeFabricInvitationCodeResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeFabricInvitationCodeResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricInvitationCodeResponseBody() = default;
};
class DescribeFabricInvitationCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricInvitationCodeResponseBody> body{};

  DescribeFabricInvitationCodeResponse() {}

  explicit DescribeFabricInvitationCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricInvitationCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricInvitationCodeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricInvitationCodeResponse() = default;
};
class DescribeFabricInviterRequest : public Darabonba::Model {
public:
  shared_ptr<string> code{};

  DescribeFabricInviterRequest() {}

  explicit DescribeFabricInviterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
  }


  virtual ~DescribeFabricInviterRequest() = default;
};
class DescribeFabricInviterResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> consortiumName{};
  shared_ptr<string> expireTime{};
  shared_ptr<long> inviterId{};
  shared_ptr<string> inviterName{};

  DescribeFabricInviterResponseBodyResult() {}

  explicit DescribeFabricInviterResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (consortiumName) {
      res["ConsortiumName"] = boost::any(*consortiumName);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (inviterId) {
      res["InviterId"] = boost::any(*inviterId);
    }
    if (inviterName) {
      res["InviterName"] = boost::any(*inviterName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("ConsortiumName") != m.end() && !m["ConsortiumName"].empty()) {
      consortiumName = make_shared<string>(boost::any_cast<string>(m["ConsortiumName"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("InviterId") != m.end() && !m["InviterId"].empty()) {
      inviterId = make_shared<long>(boost::any_cast<long>(m["InviterId"]));
    }
    if (m.find("InviterName") != m.end() && !m["InviterName"].empty()) {
      inviterName = make_shared<string>(boost::any_cast<string>(m["InviterName"]));
    }
  }


  virtual ~DescribeFabricInviterResponseBodyResult() = default;
};
class DescribeFabricInviterResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeFabricInviterResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeFabricInviterResponseBody() {}

  explicit DescribeFabricInviterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeFabricInviterResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeFabricInviterResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricInviterResponseBody() = default;
};
class DescribeFabricInviterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricInviterResponseBody> body{};

  DescribeFabricInviterResponse() {}

  explicit DescribeFabricInviterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricInviterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricInviterResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricInviterResponse() = default;
};
class DescribeFabricOrdererLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> lines{};
  shared_ptr<string> ordererName{};

  DescribeFabricOrdererLogsRequest() {}

  explicit DescribeFabricOrdererLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (lines) {
      res["Lines"] = boost::any(*lines);
    }
    if (ordererName) {
      res["OrdererName"] = boost::any(*ordererName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("Lines") != m.end() && !m["Lines"].empty()) {
      lines = make_shared<string>(boost::any_cast<string>(m["Lines"]));
    }
    if (m.find("OrdererName") != m.end() && !m["OrdererName"].empty()) {
      ordererName = make_shared<string>(boost::any_cast<string>(m["OrdererName"]));
    }
  }


  virtual ~DescribeFabricOrdererLogsRequest() = default;
};
class DescribeFabricOrdererLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  DescribeFabricOrdererLogsResponseBody() {}

  explicit DescribeFabricOrdererLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricOrdererLogsResponseBody() = default;
};
class DescribeFabricOrdererLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricOrdererLogsResponseBody> body{};

  DescribeFabricOrdererLogsResponse() {}

  explicit DescribeFabricOrdererLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricOrdererLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricOrdererLogsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricOrdererLogsResponse() = default;
};
class DescribeFabricOrganizationRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeFabricOrganizationRequestTag() {}

  explicit DescribeFabricOrganizationRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeFabricOrganizationRequestTag() = default;
};
class DescribeFabricOrganizationRequest : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};
  shared_ptr<vector<DescribeFabricOrganizationRequestTag>> tag{};

  DescribeFabricOrganizationRequest() {}

  explicit DescribeFabricOrganizationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeFabricOrganizationRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFabricOrganizationRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeFabricOrganizationRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeFabricOrganizationRequest() = default;
};
class DescribeFabricOrganizationResponseBodyResultTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeFabricOrganizationResponseBodyResultTags() {}

  explicit DescribeFabricOrganizationResponseBodyResultTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeFabricOrganizationResponseBodyResultTags() = default;
};
class DescribeFabricOrganizationResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> CANAME{};
  shared_ptr<string> CAUrl{};
  shared_ptr<string> codeName{};
  shared_ptr<long> consortiumCount{};
  shared_ptr<string> createTime{};
  shared_ptr<string> domain{};
  shared_ptr<string> MSP{};
  shared_ptr<string> organizationDescription{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> organizationName{};
  shared_ptr<string> ownerBid{};
  shared_ptr<string> ownerName{};
  shared_ptr<long> ownerUid{};
  shared_ptr<long> peerCount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> specName{};
  shared_ptr<string> state{};
  shared_ptr<vector<DescribeFabricOrganizationResponseBodyResultTags>> tags{};
  shared_ptr<long> userCount{};
  shared_ptr<string> zoneId{};

  DescribeFabricOrganizationResponseBodyResult() {}

  explicit DescribeFabricOrganizationResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (CANAME) {
      res["CANAME"] = boost::any(*CANAME);
    }
    if (CAUrl) {
      res["CAUrl"] = boost::any(*CAUrl);
    }
    if (codeName) {
      res["CodeName"] = boost::any(*codeName);
    }
    if (consortiumCount) {
      res["ConsortiumCount"] = boost::any(*consortiumCount);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (MSP) {
      res["MSP"] = boost::any(*MSP);
    }
    if (organizationDescription) {
      res["OrganizationDescription"] = boost::any(*organizationDescription);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (organizationName) {
      res["OrganizationName"] = boost::any(*organizationName);
    }
    if (ownerBid) {
      res["OwnerBid"] = boost::any(*ownerBid);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUid) {
      res["OwnerUid"] = boost::any(*ownerUid);
    }
    if (peerCount) {
      res["PeerCount"] = boost::any(*peerCount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (specName) {
      res["SpecName"] = boost::any(*specName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (userCount) {
      res["UserCount"] = boost::any(*userCount);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CANAME") != m.end() && !m["CANAME"].empty()) {
      CANAME = make_shared<string>(boost::any_cast<string>(m["CANAME"]));
    }
    if (m.find("CAUrl") != m.end() && !m["CAUrl"].empty()) {
      CAUrl = make_shared<string>(boost::any_cast<string>(m["CAUrl"]));
    }
    if (m.find("CodeName") != m.end() && !m["CodeName"].empty()) {
      codeName = make_shared<string>(boost::any_cast<string>(m["CodeName"]));
    }
    if (m.find("ConsortiumCount") != m.end() && !m["ConsortiumCount"].empty()) {
      consortiumCount = make_shared<long>(boost::any_cast<long>(m["ConsortiumCount"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("MSP") != m.end() && !m["MSP"].empty()) {
      MSP = make_shared<string>(boost::any_cast<string>(m["MSP"]));
    }
    if (m.find("OrganizationDescription") != m.end() && !m["OrganizationDescription"].empty()) {
      organizationDescription = make_shared<string>(boost::any_cast<string>(m["OrganizationDescription"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("OrganizationName") != m.end() && !m["OrganizationName"].empty()) {
      organizationName = make_shared<string>(boost::any_cast<string>(m["OrganizationName"]));
    }
    if (m.find("OwnerBid") != m.end() && !m["OwnerBid"].empty()) {
      ownerBid = make_shared<string>(boost::any_cast<string>(m["OwnerBid"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUid") != m.end() && !m["OwnerUid"].empty()) {
      ownerUid = make_shared<long>(boost::any_cast<long>(m["OwnerUid"]));
    }
    if (m.find("PeerCount") != m.end() && !m["PeerCount"].empty()) {
      peerCount = make_shared<long>(boost::any_cast<long>(m["PeerCount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SpecName") != m.end() && !m["SpecName"].empty()) {
      specName = make_shared<string>(boost::any_cast<string>(m["SpecName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeFabricOrganizationResponseBodyResultTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFabricOrganizationResponseBodyResultTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeFabricOrganizationResponseBodyResultTags>>(expect1);
      }
    }
    if (m.find("UserCount") != m.end() && !m["UserCount"].empty()) {
      userCount = make_shared<long>(boost::any_cast<long>(m["UserCount"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeFabricOrganizationResponseBodyResult() = default;
};
class DescribeFabricOrganizationResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeFabricOrganizationResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeFabricOrganizationResponseBody() {}

  explicit DescribeFabricOrganizationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeFabricOrganizationResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeFabricOrganizationResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricOrganizationResponseBody() = default;
};
class DescribeFabricOrganizationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricOrganizationResponseBody> body{};

  DescribeFabricOrganizationResponse() {}

  explicit DescribeFabricOrganizationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricOrganizationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricOrganizationResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricOrganizationResponse() = default;
};
class DescribeFabricOrganizationChaincodePackageRequest : public Darabonba::Model {
public:
  shared_ptr<string> organizationId{};

  DescribeFabricOrganizationChaincodePackageRequest() {}

  explicit DescribeFabricOrganizationChaincodePackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeFabricOrganizationChaincodePackageRequest() = default;
};
class DescribeFabricOrganizationChaincodePackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ChaincodePackage>> result{};
  shared_ptr<bool> success{};

  DescribeFabricOrganizationChaincodePackageResponseBody() {}

  explicit DescribeFabricOrganizationChaincodePackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ChaincodePackage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ChaincodePackage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ChaincodePackage>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricOrganizationChaincodePackageResponseBody() = default;
};
class DescribeFabricOrganizationChaincodePackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricOrganizationChaincodePackageResponseBody> body{};

  DescribeFabricOrganizationChaincodePackageResponse() {}

  explicit DescribeFabricOrganizationChaincodePackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricOrganizationChaincodePackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricOrganizationChaincodePackageResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricOrganizationChaincodePackageResponse() = default;
};
class DescribeFabricOrganizationChaincodesRequest : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};

  DescribeFabricOrganizationChaincodesRequest() {}

  explicit DescribeFabricOrganizationChaincodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeFabricOrganizationChaincodesRequest() = default;
};
class DescribeFabricOrganizationChaincodesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> chaincodeName{};
  shared_ptr<string> chaincodeVersion{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> creator{};
  shared_ptr<string> deployTime{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<string> installed{};
  shared_ptr<string> message{};
  shared_ptr<string> state{};

  DescribeFabricOrganizationChaincodesResponseBodyResult() {}

  explicit DescribeFabricOrganizationChaincodesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (chaincodeName) {
      res["ChaincodeName"] = boost::any(*chaincodeName);
    }
    if (chaincodeVersion) {
      res["ChaincodeVersion"] = boost::any(*chaincodeVersion);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (creator) {
      res["Creator"] = boost::any(*creator);
    }
    if (deployTime) {
      res["DeployTime"] = boost::any(*deployTime);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (installed) {
      res["Installed"] = boost::any(*installed);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("ChaincodeName") != m.end() && !m["ChaincodeName"].empty()) {
      chaincodeName = make_shared<string>(boost::any_cast<string>(m["ChaincodeName"]));
    }
    if (m.find("ChaincodeVersion") != m.end() && !m["ChaincodeVersion"].empty()) {
      chaincodeVersion = make_shared<string>(boost::any_cast<string>(m["ChaincodeVersion"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Creator") != m.end() && !m["Creator"].empty()) {
      creator = make_shared<string>(boost::any_cast<string>(m["Creator"]));
    }
    if (m.find("DeployTime") != m.end() && !m["DeployTime"].empty()) {
      deployTime = make_shared<string>(boost::any_cast<string>(m["DeployTime"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("Installed") != m.end() && !m["Installed"].empty()) {
      installed = make_shared<string>(boost::any_cast<string>(m["Installed"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~DescribeFabricOrganizationChaincodesResponseBodyResult() = default;
};
class DescribeFabricOrganizationChaincodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeFabricOrganizationChaincodesResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeFabricOrganizationChaincodesResponseBody() {}

  explicit DescribeFabricOrganizationChaincodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeFabricOrganizationChaincodesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFabricOrganizationChaincodesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeFabricOrganizationChaincodesResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricOrganizationChaincodesResponseBody() = default;
};
class DescribeFabricOrganizationChaincodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricOrganizationChaincodesResponseBody> body{};

  DescribeFabricOrganizationChaincodesResponse() {}

  explicit DescribeFabricOrganizationChaincodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricOrganizationChaincodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricOrganizationChaincodesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricOrganizationChaincodesResponse() = default;
};
class DescribeFabricOrganizationChannelsRequest : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};

  DescribeFabricOrganizationChannelsRequest() {}

  explicit DescribeFabricOrganizationChannelsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeFabricOrganizationChannelsRequest() = default;
};
class DescribeFabricOrganizationChannelsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> batchTimeout{};
  shared_ptr<long> blockCount{};
  shared_ptr<long> chaincodeCount{};
  shared_ptr<string> channelId{};
  shared_ptr<string> channelName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> consortiumName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deleteTime{};
  shared_ptr<bool> deleted{};
  shared_ptr<long> maxMessageCount{};
  shared_ptr<long> memberCount{};
  shared_ptr<string> ownerBid{};
  shared_ptr<string> ownerName{};
  shared_ptr<long> ownerUid{};
  shared_ptr<long> preferredMaxBytes{};
  shared_ptr<string> requestId{};
  shared_ptr<string> state{};
  shared_ptr<bool> supportChannelConfig{};
  shared_ptr<string> updateTime{};

  DescribeFabricOrganizationChannelsResponseBodyResult() {}

  explicit DescribeFabricOrganizationChannelsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchTimeout) {
      res["BatchTimeout"] = boost::any(*batchTimeout);
    }
    if (blockCount) {
      res["BlockCount"] = boost::any(*blockCount);
    }
    if (chaincodeCount) {
      res["ChaincodeCount"] = boost::any(*chaincodeCount);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (consortiumName) {
      res["ConsortiumName"] = boost::any(*consortiumName);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deleteTime) {
      res["DeleteTime"] = boost::any(*deleteTime);
    }
    if (deleted) {
      res["Deleted"] = boost::any(*deleted);
    }
    if (maxMessageCount) {
      res["MaxMessageCount"] = boost::any(*maxMessageCount);
    }
    if (memberCount) {
      res["MemberCount"] = boost::any(*memberCount);
    }
    if (ownerBid) {
      res["OwnerBid"] = boost::any(*ownerBid);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUid) {
      res["OwnerUid"] = boost::any(*ownerUid);
    }
    if (preferredMaxBytes) {
      res["PreferredMaxBytes"] = boost::any(*preferredMaxBytes);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (supportChannelConfig) {
      res["SupportChannelConfig"] = boost::any(*supportChannelConfig);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BatchTimeout") != m.end() && !m["BatchTimeout"].empty()) {
      batchTimeout = make_shared<long>(boost::any_cast<long>(m["BatchTimeout"]));
    }
    if (m.find("BlockCount") != m.end() && !m["BlockCount"].empty()) {
      blockCount = make_shared<long>(boost::any_cast<long>(m["BlockCount"]));
    }
    if (m.find("ChaincodeCount") != m.end() && !m["ChaincodeCount"].empty()) {
      chaincodeCount = make_shared<long>(boost::any_cast<long>(m["ChaincodeCount"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("ConsortiumName") != m.end() && !m["ConsortiumName"].empty()) {
      consortiumName = make_shared<string>(boost::any_cast<string>(m["ConsortiumName"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeleteTime") != m.end() && !m["DeleteTime"].empty()) {
      deleteTime = make_shared<string>(boost::any_cast<string>(m["DeleteTime"]));
    }
    if (m.find("Deleted") != m.end() && !m["Deleted"].empty()) {
      deleted = make_shared<bool>(boost::any_cast<bool>(m["Deleted"]));
    }
    if (m.find("MaxMessageCount") != m.end() && !m["MaxMessageCount"].empty()) {
      maxMessageCount = make_shared<long>(boost::any_cast<long>(m["MaxMessageCount"]));
    }
    if (m.find("MemberCount") != m.end() && !m["MemberCount"].empty()) {
      memberCount = make_shared<long>(boost::any_cast<long>(m["MemberCount"]));
    }
    if (m.find("OwnerBid") != m.end() && !m["OwnerBid"].empty()) {
      ownerBid = make_shared<string>(boost::any_cast<string>(m["OwnerBid"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUid") != m.end() && !m["OwnerUid"].empty()) {
      ownerUid = make_shared<long>(boost::any_cast<long>(m["OwnerUid"]));
    }
    if (m.find("PreferredMaxBytes") != m.end() && !m["PreferredMaxBytes"].empty()) {
      preferredMaxBytes = make_shared<long>(boost::any_cast<long>(m["PreferredMaxBytes"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("SupportChannelConfig") != m.end() && !m["SupportChannelConfig"].empty()) {
      supportChannelConfig = make_shared<bool>(boost::any_cast<bool>(m["SupportChannelConfig"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeFabricOrganizationChannelsResponseBodyResult() = default;
};
class DescribeFabricOrganizationChannelsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeFabricOrganizationChannelsResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeFabricOrganizationChannelsResponseBody() {}

  explicit DescribeFabricOrganizationChannelsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeFabricOrganizationChannelsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFabricOrganizationChannelsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeFabricOrganizationChannelsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricOrganizationChannelsResponseBody() = default;
};
class DescribeFabricOrganizationChannelsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricOrganizationChannelsResponseBody> body{};

  DescribeFabricOrganizationChannelsResponse() {}

  explicit DescribeFabricOrganizationChannelsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricOrganizationChannelsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricOrganizationChannelsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricOrganizationChannelsResponse() = default;
};
class DescribeFabricOrganizationDeletableRequest : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};

  DescribeFabricOrganizationDeletableRequest() {}

  explicit DescribeFabricOrganizationDeletableRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeFabricOrganizationDeletableRequest() = default;
};
class DescribeFabricOrganizationDeletableResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> codeName{};
  shared_ptr<bool> deletable{};
  shared_ptr<string> domain{};
  shared_ptr<string> organizationDescription{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> organizationName{};
  shared_ptr<string> regionId{};
  shared_ptr<string> state{};
  shared_ptr<string> zoneId{};

  DescribeFabricOrganizationDeletableResponseBodyResult() {}

  explicit DescribeFabricOrganizationDeletableResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codeName) {
      res["CodeName"] = boost::any(*codeName);
    }
    if (deletable) {
      res["Deletable"] = boost::any(*deletable);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (organizationDescription) {
      res["OrganizationDescription"] = boost::any(*organizationDescription);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (organizationName) {
      res["OrganizationName"] = boost::any(*organizationName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodeName") != m.end() && !m["CodeName"].empty()) {
      codeName = make_shared<string>(boost::any_cast<string>(m["CodeName"]));
    }
    if (m.find("Deletable") != m.end() && !m["Deletable"].empty()) {
      deletable = make_shared<bool>(boost::any_cast<bool>(m["Deletable"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("OrganizationDescription") != m.end() && !m["OrganizationDescription"].empty()) {
      organizationDescription = make_shared<string>(boost::any_cast<string>(m["OrganizationDescription"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("OrganizationName") != m.end() && !m["OrganizationName"].empty()) {
      organizationName = make_shared<string>(boost::any_cast<string>(m["OrganizationName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeFabricOrganizationDeletableResponseBodyResult() = default;
};
class DescribeFabricOrganizationDeletableResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeFabricOrganizationDeletableResponseBodyResult> result{};
  shared_ptr<bool> success{};

  DescribeFabricOrganizationDeletableResponseBody() {}

  explicit DescribeFabricOrganizationDeletableResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeFabricOrganizationDeletableResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeFabricOrganizationDeletableResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricOrganizationDeletableResponseBody() = default;
};
class DescribeFabricOrganizationDeletableResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricOrganizationDeletableResponseBody> body{};

  DescribeFabricOrganizationDeletableResponse() {}

  explicit DescribeFabricOrganizationDeletableResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricOrganizationDeletableResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricOrganizationDeletableResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricOrganizationDeletableResponse() = default;
};
class DescribeFabricOrganizationMembersRequest : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};

  DescribeFabricOrganizationMembersRequest() {}

  explicit DescribeFabricOrganizationMembersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeFabricOrganizationMembersRequest() = default;
};
class DescribeFabricOrganizationMembersResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> consortiumName{};
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<string> joinedTime{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> organizationName{};
  shared_ptr<string> state{};

  DescribeFabricOrganizationMembersResponseBodyResult() {}

  explicit DescribeFabricOrganizationMembersResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (consortiumName) {
      res["ConsortiumName"] = boost::any(*consortiumName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (joinedTime) {
      res["JoinedTime"] = boost::any(*joinedTime);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (organizationName) {
      res["OrganizationName"] = boost::any(*organizationName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("ConsortiumName") != m.end() && !m["ConsortiumName"].empty()) {
      consortiumName = make_shared<string>(boost::any_cast<string>(m["ConsortiumName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("JoinedTime") != m.end() && !m["JoinedTime"].empty()) {
      joinedTime = make_shared<string>(boost::any_cast<string>(m["JoinedTime"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("OrganizationName") != m.end() && !m["OrganizationName"].empty()) {
      organizationName = make_shared<string>(boost::any_cast<string>(m["OrganizationName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
  }


  virtual ~DescribeFabricOrganizationMembersResponseBodyResult() = default;
};
class DescribeFabricOrganizationMembersResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeFabricOrganizationMembersResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeFabricOrganizationMembersResponseBody() {}

  explicit DescribeFabricOrganizationMembersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeFabricOrganizationMembersResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFabricOrganizationMembersResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeFabricOrganizationMembersResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricOrganizationMembersResponseBody() = default;
};
class DescribeFabricOrganizationMembersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricOrganizationMembersResponseBody> body{};

  DescribeFabricOrganizationMembersResponse() {}

  explicit DescribeFabricOrganizationMembersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricOrganizationMembersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricOrganizationMembersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricOrganizationMembersResponse() = default;
};
class DescribeFabricOrganizationPeersRequest : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};

  DescribeFabricOrganizationPeersRequest() {}

  explicit DescribeFabricOrganizationPeersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeFabricOrganizationPeersRequest() = default;
};
class DescribeFabricOrganizationPeersResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> domain{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> internetIp{};
  shared_ptr<string> intranetIp{};
  shared_ptr<bool> isAnchor{};
  shared_ptr<string> organizationPeerName{};
  shared_ptr<long> port{};
  shared_ptr<string> updateTime{};

  DescribeFabricOrganizationPeersResponseBodyResult() {}

  explicit DescribeFabricOrganizationPeersResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (internetIp) {
      res["InternetIp"] = boost::any(*internetIp);
    }
    if (intranetIp) {
      res["IntranetIp"] = boost::any(*intranetIp);
    }
    if (isAnchor) {
      res["IsAnchor"] = boost::any(*isAnchor);
    }
    if (organizationPeerName) {
      res["OrganizationPeerName"] = boost::any(*organizationPeerName);
    }
    if (port) {
      res["Port"] = boost::any(*port);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("InternetIp") != m.end() && !m["InternetIp"].empty()) {
      internetIp = make_shared<string>(boost::any_cast<string>(m["InternetIp"]));
    }
    if (m.find("IntranetIp") != m.end() && !m["IntranetIp"].empty()) {
      intranetIp = make_shared<string>(boost::any_cast<string>(m["IntranetIp"]));
    }
    if (m.find("IsAnchor") != m.end() && !m["IsAnchor"].empty()) {
      isAnchor = make_shared<bool>(boost::any_cast<bool>(m["IsAnchor"]));
    }
    if (m.find("OrganizationPeerName") != m.end() && !m["OrganizationPeerName"].empty()) {
      organizationPeerName = make_shared<string>(boost::any_cast<string>(m["OrganizationPeerName"]));
    }
    if (m.find("Port") != m.end() && !m["Port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["Port"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DescribeFabricOrganizationPeersResponseBodyResult() = default;
};
class DescribeFabricOrganizationPeersResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeFabricOrganizationPeersResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeFabricOrganizationPeersResponseBody() {}

  explicit DescribeFabricOrganizationPeersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeFabricOrganizationPeersResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFabricOrganizationPeersResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeFabricOrganizationPeersResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricOrganizationPeersResponseBody() = default;
};
class DescribeFabricOrganizationPeersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricOrganizationPeersResponseBody> body{};

  DescribeFabricOrganizationPeersResponse() {}

  explicit DescribeFabricOrganizationPeersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricOrganizationPeersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricOrganizationPeersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricOrganizationPeersResponse() = default;
};
class DescribeFabricOrganizationSpecsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};
  shared_ptr<string> organizationSpecsName{};
  shared_ptr<string> title{};

  DescribeFabricOrganizationSpecsResponseBodyResult() {}

  explicit DescribeFabricOrganizationSpecsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (organizationSpecsName) {
      res["OrganizationSpecsName"] = boost::any(*organizationSpecsName);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("OrganizationSpecsName") != m.end() && !m["OrganizationSpecsName"].empty()) {
      organizationSpecsName = make_shared<string>(boost::any_cast<string>(m["OrganizationSpecsName"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~DescribeFabricOrganizationSpecsResponseBodyResult() = default;
};
class DescribeFabricOrganizationSpecsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeFabricOrganizationSpecsResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeFabricOrganizationSpecsResponseBody() {}

  explicit DescribeFabricOrganizationSpecsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeFabricOrganizationSpecsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFabricOrganizationSpecsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeFabricOrganizationSpecsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricOrganizationSpecsResponseBody() = default;
};
class DescribeFabricOrganizationSpecsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricOrganizationSpecsResponseBody> body{};

  DescribeFabricOrganizationSpecsResponse() {}

  explicit DescribeFabricOrganizationSpecsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricOrganizationSpecsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricOrganizationSpecsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricOrganizationSpecsResponse() = default;
};
class DescribeFabricOrganizationUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};

  DescribeFabricOrganizationUsersRequest() {}

  explicit DescribeFabricOrganizationUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~DescribeFabricOrganizationUsersRequest() = default;
};
class DescribeFabricOrganizationUsersResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> attrs{};
  shared_ptr<string> callerBid{};
  shared_ptr<long> callerUid{};
  shared_ptr<string> createTime{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> fullName{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> username{};

  DescribeFabricOrganizationUsersResponseBodyResult() {}

  explicit DescribeFabricOrganizationUsersResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (attrs) {
      res["Attrs"] = boost::any(*attrs);
    }
    if (callerBid) {
      res["CallerBid"] = boost::any(*callerBid);
    }
    if (callerUid) {
      res["CallerUid"] = boost::any(*callerUid);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (fullName) {
      res["FullName"] = boost::any(*fullName);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Attrs") != m.end() && !m["Attrs"].empty()) {
      attrs = make_shared<string>(boost::any_cast<string>(m["Attrs"]));
    }
    if (m.find("CallerBid") != m.end() && !m["CallerBid"].empty()) {
      callerBid = make_shared<string>(boost::any_cast<string>(m["CallerBid"]));
    }
    if (m.find("CallerUid") != m.end() && !m["CallerUid"].empty()) {
      callerUid = make_shared<long>(boost::any_cast<long>(m["CallerUid"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("FullName") != m.end() && !m["FullName"].empty()) {
      fullName = make_shared<string>(boost::any_cast<string>(m["FullName"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~DescribeFabricOrganizationUsersResponseBodyResult() = default;
};
class DescribeFabricOrganizationUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeFabricOrganizationUsersResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeFabricOrganizationUsersResponseBody() {}

  explicit DescribeFabricOrganizationUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeFabricOrganizationUsersResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFabricOrganizationUsersResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeFabricOrganizationUsersResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricOrganizationUsersResponseBody() = default;
};
class DescribeFabricOrganizationUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricOrganizationUsersResponseBody> body{};

  DescribeFabricOrganizationUsersResponse() {}

  explicit DescribeFabricOrganizationUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricOrganizationUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricOrganizationUsersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricOrganizationUsersResponse() = default;
};
class DescribeFabricOrganizationsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeFabricOrganizationsRequestTag() {}

  explicit DescribeFabricOrganizationsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeFabricOrganizationsRequestTag() = default;
};
class DescribeFabricOrganizationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<vector<DescribeFabricOrganizationsRequestTag>> tag{};

  DescribeFabricOrganizationsRequest() {}

  explicit DescribeFabricOrganizationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeFabricOrganizationsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFabricOrganizationsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeFabricOrganizationsRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeFabricOrganizationsRequest() = default;
};
class DescribeFabricOrganizationsResponseBodyResultTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeFabricOrganizationsResponseBodyResultTags() {}

  explicit DescribeFabricOrganizationsResponseBodyResultTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeFabricOrganizationsResponseBodyResultTags() = default;
};
class DescribeFabricOrganizationsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> codeName{};
  shared_ptr<long> consortiumCount{};
  shared_ptr<string> createTime{};
  shared_ptr<string> domain{};
  shared_ptr<string> majorVersion{};
  shared_ptr<string> organizationDescription{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> organizationName{};
  shared_ptr<string> ownerBid{};
  shared_ptr<string> ownerName{};
  shared_ptr<long> ownerUid{};
  shared_ptr<long> peerCount{};
  shared_ptr<string> regionId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> specName{};
  shared_ptr<string> state{};
  shared_ptr<vector<DescribeFabricOrganizationsResponseBodyResultTags>> tags{};
  shared_ptr<long> userCount{};
  shared_ptr<string> zoneId{};

  DescribeFabricOrganizationsResponseBodyResult() {}

  explicit DescribeFabricOrganizationsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codeName) {
      res["CodeName"] = boost::any(*codeName);
    }
    if (consortiumCount) {
      res["ConsortiumCount"] = boost::any(*consortiumCount);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (domain) {
      res["Domain"] = boost::any(*domain);
    }
    if (majorVersion) {
      res["MajorVersion"] = boost::any(*majorVersion);
    }
    if (organizationDescription) {
      res["OrganizationDescription"] = boost::any(*organizationDescription);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (organizationName) {
      res["OrganizationName"] = boost::any(*organizationName);
    }
    if (ownerBid) {
      res["OwnerBid"] = boost::any(*ownerBid);
    }
    if (ownerName) {
      res["OwnerName"] = boost::any(*ownerName);
    }
    if (ownerUid) {
      res["OwnerUid"] = boost::any(*ownerUid);
    }
    if (peerCount) {
      res["PeerCount"] = boost::any(*peerCount);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (specName) {
      res["SpecName"] = boost::any(*specName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (userCount) {
      res["UserCount"] = boost::any(*userCount);
    }
    if (zoneId) {
      res["ZoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CodeName") != m.end() && !m["CodeName"].empty()) {
      codeName = make_shared<string>(boost::any_cast<string>(m["CodeName"]));
    }
    if (m.find("ConsortiumCount") != m.end() && !m["ConsortiumCount"].empty()) {
      consortiumCount = make_shared<long>(boost::any_cast<long>(m["ConsortiumCount"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Domain") != m.end() && !m["Domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["Domain"]));
    }
    if (m.find("MajorVersion") != m.end() && !m["MajorVersion"].empty()) {
      majorVersion = make_shared<string>(boost::any_cast<string>(m["MajorVersion"]));
    }
    if (m.find("OrganizationDescription") != m.end() && !m["OrganizationDescription"].empty()) {
      organizationDescription = make_shared<string>(boost::any_cast<string>(m["OrganizationDescription"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("OrganizationName") != m.end() && !m["OrganizationName"].empty()) {
      organizationName = make_shared<string>(boost::any_cast<string>(m["OrganizationName"]));
    }
    if (m.find("OwnerBid") != m.end() && !m["OwnerBid"].empty()) {
      ownerBid = make_shared<string>(boost::any_cast<string>(m["OwnerBid"]));
    }
    if (m.find("OwnerName") != m.end() && !m["OwnerName"].empty()) {
      ownerName = make_shared<string>(boost::any_cast<string>(m["OwnerName"]));
    }
    if (m.find("OwnerUid") != m.end() && !m["OwnerUid"].empty()) {
      ownerUid = make_shared<long>(boost::any_cast<long>(m["OwnerUid"]));
    }
    if (m.find("PeerCount") != m.end() && !m["PeerCount"].empty()) {
      peerCount = make_shared<long>(boost::any_cast<long>(m["PeerCount"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SpecName") != m.end() && !m["SpecName"].empty()) {
      specName = make_shared<string>(boost::any_cast<string>(m["SpecName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeFabricOrganizationsResponseBodyResultTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFabricOrganizationsResponseBodyResultTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeFabricOrganizationsResponseBodyResultTags>>(expect1);
      }
    }
    if (m.find("UserCount") != m.end() && !m["UserCount"].empty()) {
      userCount = make_shared<long>(boost::any_cast<long>(m["UserCount"]));
    }
    if (m.find("ZoneId") != m.end() && !m["ZoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["ZoneId"]));
    }
  }


  virtual ~DescribeFabricOrganizationsResponseBodyResult() = default;
};
class DescribeFabricOrganizationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeFabricOrganizationsResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeFabricOrganizationsResponseBody() {}

  explicit DescribeFabricOrganizationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeFabricOrganizationsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFabricOrganizationsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeFabricOrganizationsResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricOrganizationsResponseBody() = default;
};
class DescribeFabricOrganizationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricOrganizationsResponseBody> body{};

  DescribeFabricOrganizationsResponse() {}

  explicit DescribeFabricOrganizationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricOrganizationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricOrganizationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricOrganizationsResponse() = default;
};
class DescribeFabricPeerLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> lines{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> peerName{};

  DescribeFabricPeerLogsRequest() {}

  explicit DescribeFabricPeerLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lines) {
      res["Lines"] = boost::any(*lines);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (peerName) {
      res["PeerName"] = boost::any(*peerName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lines") != m.end() && !m["Lines"].empty()) {
      lines = make_shared<string>(boost::any_cast<string>(m["Lines"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("PeerName") != m.end() && !m["PeerName"].empty()) {
      peerName = make_shared<string>(boost::any_cast<string>(m["PeerName"]));
    }
  }


  virtual ~DescribeFabricPeerLogsRequest() = default;
};
class DescribeFabricPeerLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  DescribeFabricPeerLogsResponseBody() {}

  explicit DescribeFabricPeerLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeFabricPeerLogsResponseBody() = default;
};
class DescribeFabricPeerLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeFabricPeerLogsResponseBody> body{};

  DescribeFabricPeerLogsResponse() {}

  explicit DescribeFabricPeerLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFabricPeerLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFabricPeerLogsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFabricPeerLogsResponse() = default;
};
class DescribeRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};
  shared_ptr<string> regionId{};

  DescribeRegionsRequest() {}

  explicit DescribeRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeRegionsRequest() = default;
};
class DescribeRegionsResponseBodyRegions : public Darabonba::Model {
public:
  shared_ptr<string> localName{};
  shared_ptr<string> regionEndpoint{};
  shared_ptr<string> regionId{};

  DescribeRegionsResponseBodyRegions() {}

  explicit DescribeRegionsResponseBodyRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (regionEndpoint) {
      res["RegionEndpoint"] = boost::any(*regionEndpoint);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("RegionEndpoint") != m.end() && !m["RegionEndpoint"].empty()) {
      regionEndpoint = make_shared<string>(boost::any_cast<string>(m["RegionEndpoint"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeRegionsResponseBodyRegions() = default;
};
class DescribeRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<vector<DescribeRegionsResponseBodyRegions>> regions{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  DescribeRegionsResponseBody() {}

  explicit DescribeRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (regions) {
      vector<boost::any> temp1;
      for(auto item1:*regions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Regions"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(vector<boost::any>) == m["Regions"].type()) {
        vector<DescribeRegionsResponseBodyRegions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Regions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRegionsResponseBodyRegions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regions = make_shared<vector<DescribeRegionsResponseBodyRegions>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeRegionsResponseBody() = default;
};
class DescribeRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRegionsResponseBody> body{};

  DescribeRegionsResponse() {}

  explicit DescribeRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRegionsResponse() = default;
};
class DescribeRootDomainResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};
  shared_ptr<bool> success{};

  DescribeRootDomainResponseBody() {}

  explicit DescribeRootDomainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeRootDomainResponseBody() = default;
};
class DescribeRootDomainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRootDomainResponseBody> body{};

  DescribeRootDomainResponse() {}

  explicit DescribeRootDomainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRootDomainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRootDomainResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRootDomainResponse() = default;
};
class DescribeTasksResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<bool> handled{};
  shared_ptr<string> operationType{};
  shared_ptr<long> requestTime{};
  shared_ptr<string> responseTime{};
  shared_ptr<string> result{};
  shared_ptr<string> sender{};
  shared_ptr<string> target{};
  shared_ptr<long> taskId{};

  DescribeTasksResponseBodyResult() {}

  explicit DescribeTasksResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    if (handled) {
      res["Handled"] = boost::any(*handled);
    }
    if (operationType) {
      res["OperationType"] = boost::any(*operationType);
    }
    if (requestTime) {
      res["RequestTime"] = boost::any(*requestTime);
    }
    if (responseTime) {
      res["ResponseTime"] = boost::any(*responseTime);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (sender) {
      res["Sender"] = boost::any(*sender);
    }
    if (target) {
      res["Target"] = boost::any(*target);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
    if (m.find("Handled") != m.end() && !m["Handled"].empty()) {
      handled = make_shared<bool>(boost::any_cast<bool>(m["Handled"]));
    }
    if (m.find("OperationType") != m.end() && !m["OperationType"].empty()) {
      operationType = make_shared<string>(boost::any_cast<string>(m["OperationType"]));
    }
    if (m.find("RequestTime") != m.end() && !m["RequestTime"].empty()) {
      requestTime = make_shared<long>(boost::any_cast<long>(m["RequestTime"]));
    }
    if (m.find("ResponseTime") != m.end() && !m["ResponseTime"].empty()) {
      responseTime = make_shared<string>(boost::any_cast<string>(m["ResponseTime"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
    if (m.find("Sender") != m.end() && !m["Sender"].empty()) {
      sender = make_shared<string>(boost::any_cast<string>(m["Sender"]));
    }
    if (m.find("Target") != m.end() && !m["Target"].empty()) {
      target = make_shared<string>(boost::any_cast<string>(m["Target"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<long>(boost::any_cast<long>(m["TaskId"]));
    }
  }


  virtual ~DescribeTasksResponseBodyResult() = default;
};
class DescribeTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> dynamicCode{};
  shared_ptr<string> dynamicMessage{};
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeTasksResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DescribeTasksResponseBody() {}

  explicit DescribeTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dynamicCode) {
      res["DynamicCode"] = boost::any(*dynamicCode);
    }
    if (dynamicMessage) {
      res["DynamicMessage"] = boost::any(*dynamicMessage);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DynamicCode") != m.end() && !m["DynamicCode"].empty()) {
      dynamicCode = make_shared<string>(boost::any_cast<string>(m["DynamicCode"]));
    }
    if (m.find("DynamicMessage") != m.end() && !m["DynamicMessage"].empty()) {
      dynamicMessage = make_shared<string>(boost::any_cast<string>(m["DynamicMessage"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeTasksResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTasksResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeTasksResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeTasksResponseBody() = default;
};
class DescribeTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTasksResponseBody> body{};

  DescribeTasksResponse() {}

  explicit DescribeTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTasksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTasksResponse() = default;
};
class DownloadFabricOrganizationSDKRequest : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> username{};

  DownloadFabricOrganizationSDKRequest() {}

  explicit DownloadFabricOrganizationSDKRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~DownloadFabricOrganizationSDKRequest() = default;
};
class DownloadFabricOrganizationSDKResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> path{};

  DownloadFabricOrganizationSDKResponseBodyResult() {}

  explicit DownloadFabricOrganizationSDKResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
  }


  virtual ~DownloadFabricOrganizationSDKResponseBodyResult() = default;
};
class DownloadFabricOrganizationSDKResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DownloadFabricOrganizationSDKResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  DownloadFabricOrganizationSDKResponseBody() {}

  explicit DownloadFabricOrganizationSDKResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DownloadFabricOrganizationSDKResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DownloadFabricOrganizationSDKResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DownloadFabricOrganizationSDKResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DownloadFabricOrganizationSDKResponseBody() = default;
};
class DownloadFabricOrganizationSDKResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DownloadFabricOrganizationSDKResponseBody> body{};

  DownloadFabricOrganizationSDKResponse() {}

  explicit DownloadFabricOrganizationSDKResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DownloadFabricOrganizationSDKResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DownloadFabricOrganizationSDKResponseBody>(model1);
      }
    }
  }


  virtual ~DownloadFabricOrganizationSDKResponse() = default;
};
class FreezeAntChainAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> antChainId{};

  FreezeAntChainAccountRequest() {}

  explicit FreezeAntChainAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
  }


  virtual ~FreezeAntChainAccountRequest() = default;
};
class FreezeAntChainAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  FreezeAntChainAccountResponseBody() {}

  explicit FreezeAntChainAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~FreezeAntChainAccountResponseBody() = default;
};
class FreezeAntChainAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FreezeAntChainAccountResponseBody> body{};

  FreezeAntChainAccountResponse() {}

  explicit FreezeAntChainAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FreezeAntChainAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FreezeAntChainAccountResponseBody>(model1);
      }
    }
  }


  virtual ~FreezeAntChainAccountResponse() = default;
};
class InstallFabricChaincodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};

  InstallFabricChaincodeRequest() {}

  explicit InstallFabricChaincodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~InstallFabricChaincodeRequest() = default;
};
class InstallFabricChaincodeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> chaincodeName{};
  shared_ptr<string> chaincodeVersion{};
  shared_ptr<string> channelName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deployTime{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<string> input{};
  shared_ptr<bool> install{};
  shared_ptr<string> message{};
  shared_ptr<string> path{};
  shared_ptr<string> providerId{};
  shared_ptr<string> providerName{};
  shared_ptr<string> state{};
  shared_ptr<long> type{};

  InstallFabricChaincodeResponseBodyResult() {}

  explicit InstallFabricChaincodeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (chaincodeName) {
      res["ChaincodeName"] = boost::any(*chaincodeName);
    }
    if (chaincodeVersion) {
      res["ChaincodeVersion"] = boost::any(*chaincodeVersion);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deployTime) {
      res["DeployTime"] = boost::any(*deployTime);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (install) {
      res["Install"] = boost::any(*install);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (providerId) {
      res["ProviderId"] = boost::any(*providerId);
    }
    if (providerName) {
      res["ProviderName"] = boost::any(*providerName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("ChaincodeName") != m.end() && !m["ChaincodeName"].empty()) {
      chaincodeName = make_shared<string>(boost::any_cast<string>(m["ChaincodeName"]));
    }
    if (m.find("ChaincodeVersion") != m.end() && !m["ChaincodeVersion"].empty()) {
      chaincodeVersion = make_shared<string>(boost::any_cast<string>(m["ChaincodeVersion"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeployTime") != m.end() && !m["DeployTime"].empty()) {
      deployTime = make_shared<string>(boost::any_cast<string>(m["DeployTime"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Install") != m.end() && !m["Install"].empty()) {
      install = make_shared<bool>(boost::any_cast<bool>(m["Install"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ProviderId") != m.end() && !m["ProviderId"].empty()) {
      providerId = make_shared<string>(boost::any_cast<string>(m["ProviderId"]));
    }
    if (m.find("ProviderName") != m.end() && !m["ProviderName"].empty()) {
      providerName = make_shared<string>(boost::any_cast<string>(m["ProviderName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~InstallFabricChaincodeResponseBodyResult() = default;
};
class InstallFabricChaincodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<InstallFabricChaincodeResponseBodyResult> result{};
  shared_ptr<bool> success{};

  InstallFabricChaincodeResponseBody() {}

  explicit InstallFabricChaincodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        InstallFabricChaincodeResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<InstallFabricChaincodeResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~InstallFabricChaincodeResponseBody() = default;
};
class InstallFabricChaincodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InstallFabricChaincodeResponseBody> body{};

  InstallFabricChaincodeResponse() {}

  explicit InstallFabricChaincodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstallFabricChaincodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstallFabricChaincodeResponseBody>(model1);
      }
    }
  }


  virtual ~InstallFabricChaincodeResponse() = default;
};
class InstallFabricChaincodePackageRequest : public Darabonba::Model {
public:
  shared_ptr<string> chaincodePackageId{};
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};

  InstallFabricChaincodePackageRequest() {}

  explicit InstallFabricChaincodePackageRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodePackageId) {
      res["ChaincodePackageId"] = boost::any(*chaincodePackageId);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodePackageId") != m.end() && !m["ChaincodePackageId"].empty()) {
      chaincodePackageId = make_shared<string>(boost::any_cast<string>(m["ChaincodePackageId"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~InstallFabricChaincodePackageRequest() = default;
};
class InstallFabricChaincodePackageResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ChaincodePackage> result{};
  shared_ptr<bool> success{};

  InstallFabricChaincodePackageResponseBody() {}

  explicit InstallFabricChaincodePackageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ChaincodePackage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ChaincodePackage>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~InstallFabricChaincodePackageResponseBody() = default;
};
class InstallFabricChaincodePackageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InstallFabricChaincodePackageResponseBody> body{};

  InstallFabricChaincodePackageResponse() {}

  explicit InstallFabricChaincodePackageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstallFabricChaincodePackageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstallFabricChaincodePackageResponseBody>(model1);
      }
    }
  }


  virtual ~InstallFabricChaincodePackageResponse() = default;
};
class InstantiateFabricChaincodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> collectionConfig{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};

  InstantiateFabricChaincodeRequest() {}

  explicit InstantiateFabricChaincodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (collectionConfig) {
      res["CollectionConfig"] = boost::any(*collectionConfig);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("CollectionConfig") != m.end() && !m["CollectionConfig"].empty()) {
      collectionConfig = make_shared<string>(boost::any_cast<string>(m["CollectionConfig"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~InstantiateFabricChaincodeRequest() = default;
};
class InstantiateFabricChaincodeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> chaincodeName{};
  shared_ptr<string> chaincodeVersion{};
  shared_ptr<string> channelName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deployTime{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<string> input{};
  shared_ptr<bool> install{};
  shared_ptr<string> message{};
  shared_ptr<string> path{};
  shared_ptr<string> providerId{};
  shared_ptr<string> providerName{};
  shared_ptr<string> state{};
  shared_ptr<long> type{};

  InstantiateFabricChaincodeResponseBodyResult() {}

  explicit InstantiateFabricChaincodeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (chaincodeName) {
      res["ChaincodeName"] = boost::any(*chaincodeName);
    }
    if (chaincodeVersion) {
      res["ChaincodeVersion"] = boost::any(*chaincodeVersion);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deployTime) {
      res["DeployTime"] = boost::any(*deployTime);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (install) {
      res["Install"] = boost::any(*install);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (providerId) {
      res["ProviderId"] = boost::any(*providerId);
    }
    if (providerName) {
      res["ProviderName"] = boost::any(*providerName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("ChaincodeName") != m.end() && !m["ChaincodeName"].empty()) {
      chaincodeName = make_shared<string>(boost::any_cast<string>(m["ChaincodeName"]));
    }
    if (m.find("ChaincodeVersion") != m.end() && !m["ChaincodeVersion"].empty()) {
      chaincodeVersion = make_shared<string>(boost::any_cast<string>(m["ChaincodeVersion"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeployTime") != m.end() && !m["DeployTime"].empty()) {
      deployTime = make_shared<string>(boost::any_cast<string>(m["DeployTime"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Install") != m.end() && !m["Install"].empty()) {
      install = make_shared<bool>(boost::any_cast<bool>(m["Install"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ProviderId") != m.end() && !m["ProviderId"].empty()) {
      providerId = make_shared<string>(boost::any_cast<string>(m["ProviderId"]));
    }
    if (m.find("ProviderName") != m.end() && !m["ProviderName"].empty()) {
      providerName = make_shared<string>(boost::any_cast<string>(m["ProviderName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~InstantiateFabricChaincodeResponseBodyResult() = default;
};
class InstantiateFabricChaincodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<InstantiateFabricChaincodeResponseBodyResult> result{};
  shared_ptr<bool> success{};

  InstantiateFabricChaincodeResponseBody() {}

  explicit InstantiateFabricChaincodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        InstantiateFabricChaincodeResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<InstantiateFabricChaincodeResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~InstantiateFabricChaincodeResponseBody() = default;
};
class InstantiateFabricChaincodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InstantiateFabricChaincodeResponseBody> body{};

  InstantiateFabricChaincodeResponse() {}

  explicit InstantiateFabricChaincodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstantiateFabricChaincodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstantiateFabricChaincodeResponseBody>(model1);
      }
    }
  }


  virtual ~InstantiateFabricChaincodeResponse() = default;
};
class JoinFabricChannelRequest : public Darabonba::Model {
public:
  shared_ptr<string> channelId{};
  shared_ptr<string> do_{};
  shared_ptr<string> location{};

  JoinFabricChannelRequest() {}

  explicit JoinFabricChannelRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (do_) {
      res["Do"] = boost::any(*do_);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("Do") != m.end() && !m["Do"].empty()) {
      do_ = make_shared<string>(boost::any_cast<string>(m["Do"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
  }


  virtual ~JoinFabricChannelRequest() = default;
};
class JoinFabricChannelResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> acceptTime{};
  shared_ptr<string> approveTime{};
  shared_ptr<string> channelId{};
  shared_ptr<string> confirmTime{};
  shared_ptr<string> destroyTime{};
  shared_ptr<string> inviteTime{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> state{};
  shared_ptr<bool> withPeer{};

  JoinFabricChannelResponseBodyResult() {}

  explicit JoinFabricChannelResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptTime) {
      res["AcceptTime"] = boost::any(*acceptTime);
    }
    if (approveTime) {
      res["ApproveTime"] = boost::any(*approveTime);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (confirmTime) {
      res["ConfirmTime"] = boost::any(*confirmTime);
    }
    if (destroyTime) {
      res["DestroyTime"] = boost::any(*destroyTime);
    }
    if (inviteTime) {
      res["InviteTime"] = boost::any(*inviteTime);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (withPeer) {
      res["WithPeer"] = boost::any(*withPeer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptTime") != m.end() && !m["AcceptTime"].empty()) {
      acceptTime = make_shared<string>(boost::any_cast<string>(m["AcceptTime"]));
    }
    if (m.find("ApproveTime") != m.end() && !m["ApproveTime"].empty()) {
      approveTime = make_shared<string>(boost::any_cast<string>(m["ApproveTime"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("ConfirmTime") != m.end() && !m["ConfirmTime"].empty()) {
      confirmTime = make_shared<string>(boost::any_cast<string>(m["ConfirmTime"]));
    }
    if (m.find("DestroyTime") != m.end() && !m["DestroyTime"].empty()) {
      destroyTime = make_shared<string>(boost::any_cast<string>(m["DestroyTime"]));
    }
    if (m.find("InviteTime") != m.end() && !m["InviteTime"].empty()) {
      inviteTime = make_shared<string>(boost::any_cast<string>(m["InviteTime"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("WithPeer") != m.end() && !m["WithPeer"].empty()) {
      withPeer = make_shared<bool>(boost::any_cast<bool>(m["WithPeer"]));
    }
  }


  virtual ~JoinFabricChannelResponseBodyResult() = default;
};
class JoinFabricChannelResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<JoinFabricChannelResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  JoinFabricChannelResponseBody() {}

  explicit JoinFabricChannelResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<JoinFabricChannelResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            JoinFabricChannelResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<JoinFabricChannelResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~JoinFabricChannelResponseBody() = default;
};
class JoinFabricChannelResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<JoinFabricChannelResponseBody> body{};

  JoinFabricChannelResponse() {}

  explicit JoinFabricChannelResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        JoinFabricChannelResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<JoinFabricChannelResponseBody>(model1);
      }
    }
  }


  virtual ~JoinFabricChannelResponse() = default;
};
class ListTagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListTagResourcesRequestTag() {}

  explicit ListTagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListTagResourcesRequestTag() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<ListTagResourcesRequestTag>> tag{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListTagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListTagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListTagResourcesResponseBodyTagResources() {}

  explicit ListTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResources() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListTagResourcesResponseBodyTagResources>> tagResources{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      vector<boost::any> temp1;
      for(auto item1:*tagResources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResources"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResources"].type()) {
        vector<ListTagResourcesResponseBodyTagResources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyTagResources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResources = make_shared<vector<ListTagResourcesResponseBodyTagResources>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class ResetAntChainCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};

  ResetAntChainCertificateRequest() {}

  explicit ResetAntChainCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
  }


  virtual ~ResetAntChainCertificateRequest() = default;
};
class ResetAntChainCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  ResetAntChainCertificateResponseBody() {}

  explicit ResetAntChainCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~ResetAntChainCertificateResponseBody() = default;
};
class ResetAntChainCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetAntChainCertificateResponseBody> body{};

  ResetAntChainCertificateResponse() {}

  explicit ResetAntChainCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetAntChainCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetAntChainCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~ResetAntChainCertificateResponse() = default;
};
class ResetAntChainUserCertificateRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> username{};

  ResetAntChainUserCertificateRequest() {}

  explicit ResetAntChainUserCertificateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~ResetAntChainUserCertificateRequest() = default;
};
class ResetAntChainUserCertificateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  ResetAntChainUserCertificateResponseBody() {}

  explicit ResetAntChainUserCertificateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~ResetAntChainUserCertificateResponseBody() = default;
};
class ResetAntChainUserCertificateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetAntChainUserCertificateResponseBody> body{};

  ResetAntChainUserCertificateResponse() {}

  explicit ResetAntChainUserCertificateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetAntChainUserCertificateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetAntChainUserCertificateResponseBody>(model1);
      }
    }
  }


  virtual ~ResetAntChainUserCertificateResponse() = default;
};
class ResetFabricOrganizationUserPasswordRequest : public Darabonba::Model {
public:
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> password{};
  shared_ptr<string> username{};

  ResetFabricOrganizationUserPasswordRequest() {}

  explicit ResetFabricOrganizationUserPasswordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~ResetFabricOrganizationUserPasswordRequest() = default;
};
class ResetFabricOrganizationUserPasswordResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> expireTime{};
  shared_ptr<string> fullname{};
  shared_ptr<string> organizationId{};
  shared_ptr<string> password{};
  shared_ptr<string> username{};

  ResetFabricOrganizationUserPasswordResponseBodyResult() {}

  explicit ResetFabricOrganizationUserPasswordResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (expireTime) {
      res["ExpireTime"] = boost::any(*expireTime);
    }
    if (fullname) {
      res["Fullname"] = boost::any(*fullname);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("ExpireTime") != m.end() && !m["ExpireTime"].empty()) {
      expireTime = make_shared<string>(boost::any_cast<string>(m["ExpireTime"]));
    }
    if (m.find("Fullname") != m.end() && !m["Fullname"].empty()) {
      fullname = make_shared<string>(boost::any_cast<string>(m["Fullname"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~ResetFabricOrganizationUserPasswordResponseBodyResult() = default;
};
class ResetFabricOrganizationUserPasswordResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<ResetFabricOrganizationUserPasswordResponseBodyResult> result{};
  shared_ptr<bool> success{};

  ResetFabricOrganizationUserPasswordResponseBody() {}

  explicit ResetFabricOrganizationUserPasswordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ResetFabricOrganizationUserPasswordResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ResetFabricOrganizationUserPasswordResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ResetFabricOrganizationUserPasswordResponseBody() = default;
};
class ResetFabricOrganizationUserPasswordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResetFabricOrganizationUserPasswordResponseBody> body{};

  ResetFabricOrganizationUserPasswordResponse() {}

  explicit ResetFabricOrganizationUserPasswordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetFabricOrganizationUserPasswordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetFabricOrganizationUserPasswordResponseBody>(model1);
      }
    }
  }


  virtual ~ResetFabricOrganizationUserPasswordResponse() = default;
};
class SubmitFabricChaincodeDefinitionRequest : public Darabonba::Model {
public:
  shared_ptr<string> chaincodePackageId{};
  shared_ptr<string> chaincodeVersion{};
  shared_ptr<string> channelId{};
  shared_ptr<string> collectionConfig{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<bool> initRequired{};
  shared_ptr<string> location{};
  shared_ptr<string> name{};
  shared_ptr<string> organizationId{};

  SubmitFabricChaincodeDefinitionRequest() {}

  explicit SubmitFabricChaincodeDefinitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodePackageId) {
      res["ChaincodePackageId"] = boost::any(*chaincodePackageId);
    }
    if (chaincodeVersion) {
      res["ChaincodeVersion"] = boost::any(*chaincodeVersion);
    }
    if (channelId) {
      res["ChannelId"] = boost::any(*channelId);
    }
    if (collectionConfig) {
      res["CollectionConfig"] = boost::any(*collectionConfig);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (initRequired) {
      res["InitRequired"] = boost::any(*initRequired);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodePackageId") != m.end() && !m["ChaincodePackageId"].empty()) {
      chaincodePackageId = make_shared<string>(boost::any_cast<string>(m["ChaincodePackageId"]));
    }
    if (m.find("ChaincodeVersion") != m.end() && !m["ChaincodeVersion"].empty()) {
      chaincodeVersion = make_shared<string>(boost::any_cast<string>(m["ChaincodeVersion"]));
    }
    if (m.find("ChannelId") != m.end() && !m["ChannelId"].empty()) {
      channelId = make_shared<string>(boost::any_cast<string>(m["ChannelId"]));
    }
    if (m.find("CollectionConfig") != m.end() && !m["CollectionConfig"].empty()) {
      collectionConfig = make_shared<string>(boost::any_cast<string>(m["CollectionConfig"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("InitRequired") != m.end() && !m["InitRequired"].empty()) {
      initRequired = make_shared<bool>(boost::any_cast<bool>(m["InitRequired"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~SubmitFabricChaincodeDefinitionRequest() = default;
};
class SubmitFabricChaincodeDefinitionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ChaincodeVO> result{};
  shared_ptr<bool> success{};

  SubmitFabricChaincodeDefinitionResponseBody() {}

  explicit SubmitFabricChaincodeDefinitionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ChaincodeVO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ChaincodeVO>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SubmitFabricChaincodeDefinitionResponseBody() = default;
};
class SubmitFabricChaincodeDefinitionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SubmitFabricChaincodeDefinitionResponseBody> body{};

  SubmitFabricChaincodeDefinitionResponse() {}

  explicit SubmitFabricChaincodeDefinitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SubmitFabricChaincodeDefinitionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SubmitFabricChaincodeDefinitionResponseBody>(model1);
      }
    }
  }


  virtual ~SubmitFabricChaincodeDefinitionResponse() = default;
};
class SynchronizeFabricChaincodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> organizationId{};

  SynchronizeFabricChaincodeRequest() {}

  explicit SynchronizeFabricChaincodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~SynchronizeFabricChaincodeRequest() = default;
};
class SynchronizeFabricChaincodeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> chaincodeName{};
  shared_ptr<string> chaincodeVersion{};
  shared_ptr<string> channelName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deployTime{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<string> input{};
  shared_ptr<bool> install{};
  shared_ptr<string> message{};
  shared_ptr<string> path{};
  shared_ptr<string> providerId{};
  shared_ptr<string> providerName{};
  shared_ptr<string> state{};
  shared_ptr<long> type{};

  SynchronizeFabricChaincodeResponseBodyResult() {}

  explicit SynchronizeFabricChaincodeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (chaincodeName) {
      res["ChaincodeName"] = boost::any(*chaincodeName);
    }
    if (chaincodeVersion) {
      res["ChaincodeVersion"] = boost::any(*chaincodeVersion);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deployTime) {
      res["DeployTime"] = boost::any(*deployTime);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (install) {
      res["Install"] = boost::any(*install);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (providerId) {
      res["ProviderId"] = boost::any(*providerId);
    }
    if (providerName) {
      res["ProviderName"] = boost::any(*providerName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("ChaincodeName") != m.end() && !m["ChaincodeName"].empty()) {
      chaincodeName = make_shared<string>(boost::any_cast<string>(m["ChaincodeName"]));
    }
    if (m.find("ChaincodeVersion") != m.end() && !m["ChaincodeVersion"].empty()) {
      chaincodeVersion = make_shared<string>(boost::any_cast<string>(m["ChaincodeVersion"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeployTime") != m.end() && !m["DeployTime"].empty()) {
      deployTime = make_shared<string>(boost::any_cast<string>(m["DeployTime"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Install") != m.end() && !m["Install"].empty()) {
      install = make_shared<bool>(boost::any_cast<bool>(m["Install"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ProviderId") != m.end() && !m["ProviderId"].empty()) {
      providerId = make_shared<string>(boost::any_cast<string>(m["ProviderId"]));
    }
    if (m.find("ProviderName") != m.end() && !m["ProviderName"].empty()) {
      providerName = make_shared<string>(boost::any_cast<string>(m["ProviderName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~SynchronizeFabricChaincodeResponseBodyResult() = default;
};
class SynchronizeFabricChaincodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<SynchronizeFabricChaincodeResponseBodyResult> result{};
  shared_ptr<bool> success{};

  SynchronizeFabricChaincodeResponseBody() {}

  explicit SynchronizeFabricChaincodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        SynchronizeFabricChaincodeResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<SynchronizeFabricChaincodeResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~SynchronizeFabricChaincodeResponseBody() = default;
};
class SynchronizeFabricChaincodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SynchronizeFabricChaincodeResponseBody> body{};

  SynchronizeFabricChaincodeResponse() {}

  explicit SynchronizeFabricChaincodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SynchronizeFabricChaincodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SynchronizeFabricChaincodeResponseBody>(model1);
      }
    }
  }


  virtual ~SynchronizeFabricChaincodeResponse() = default;
};
class TagResourcesRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagResourcesRequestTag() {}

  explicit TagResourcesRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~TagResourcesRequestTag() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<TagResourcesRequestTag>> tag{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<TagResourcesRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<TagResourcesRequestTag>>(expect1);
      }
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};
  shared_ptr<bool> success{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class UnfreezeAntChainAccountRequest : public Darabonba::Model {
public:
  shared_ptr<string> account{};
  shared_ptr<string> antChainId{};

  UnfreezeAntChainAccountRequest() {}

  explicit UnfreezeAntChainAccountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (account) {
      res["Account"] = boost::any(*account);
    }
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Account") != m.end() && !m["Account"].empty()) {
      account = make_shared<string>(boost::any_cast<string>(m["Account"]));
    }
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
  }


  virtual ~UnfreezeAntChainAccountRequest() = default;
};
class UnfreezeAntChainAccountResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  UnfreezeAntChainAccountResponseBody() {}

  explicit UnfreezeAntChainAccountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~UnfreezeAntChainAccountResponseBody() = default;
};
class UnfreezeAntChainAccountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnfreezeAntChainAccountResponseBody> body{};

  UnfreezeAntChainAccountResponse() {}

  explicit UnfreezeAntChainAccountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnfreezeAntChainAccountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnfreezeAntChainAccountResponseBody>(model1);
      }
    }
  }


  virtual ~UnfreezeAntChainAccountResponse() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<vector<string>> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<string>> tagKey{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceId = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TagKey"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TagKey"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      tagKey = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};
  shared_ptr<bool> success{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class UpdateAntChainRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> antChainName{};

  UpdateAntChainRequest() {}

  explicit UpdateAntChainRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (antChainName) {
      res["AntChainName"] = boost::any(*antChainName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("AntChainName") != m.end() && !m["AntChainName"].empty()) {
      antChainName = make_shared<string>(boost::any_cast<string>(m["AntChainName"]));
    }
  }


  virtual ~UpdateAntChainRequest() = default;
};
class UpdateAntChainResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  UpdateAntChainResponseBody() {}

  explicit UpdateAntChainResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~UpdateAntChainResponseBody() = default;
};
class UpdateAntChainResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAntChainResponseBody> body{};

  UpdateAntChainResponse() {}

  explicit UpdateAntChainResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAntChainResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAntChainResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAntChainResponse() = default;
};
class UpdateAntChainConsortiumRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumDescription{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> consortiumName{};

  UpdateAntChainConsortiumRequest() {}

  explicit UpdateAntChainConsortiumRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumDescription) {
      res["ConsortiumDescription"] = boost::any(*consortiumDescription);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (consortiumName) {
      res["ConsortiumName"] = boost::any(*consortiumName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumDescription") != m.end() && !m["ConsortiumDescription"].empty()) {
      consortiumDescription = make_shared<string>(boost::any_cast<string>(m["ConsortiumDescription"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("ConsortiumName") != m.end() && !m["ConsortiumName"].empty()) {
      consortiumName = make_shared<string>(boost::any_cast<string>(m["ConsortiumName"]));
    }
  }


  virtual ~UpdateAntChainConsortiumRequest() = default;
};
class UpdateAntChainConsortiumResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  UpdateAntChainConsortiumResponseBody() {}

  explicit UpdateAntChainConsortiumResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~UpdateAntChainConsortiumResponseBody() = default;
};
class UpdateAntChainConsortiumResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAntChainConsortiumResponseBody> body{};

  UpdateAntChainConsortiumResponse() {}

  explicit UpdateAntChainConsortiumResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAntChainConsortiumResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAntChainConsortiumResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAntChainConsortiumResponse() = default;
};
class UpdateAntChainContractContentRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> contentId{};
  shared_ptr<string> contentName{};
  shared_ptr<string> parentContentId{};

  UpdateAntChainContractContentRequest() {}

  explicit UpdateAntChainContractContentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (contentId) {
      res["ContentId"] = boost::any(*contentId);
    }
    if (contentName) {
      res["ContentName"] = boost::any(*contentName);
    }
    if (parentContentId) {
      res["ParentContentId"] = boost::any(*parentContentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ContentId") != m.end() && !m["ContentId"].empty()) {
      contentId = make_shared<string>(boost::any_cast<string>(m["ContentId"]));
    }
    if (m.find("ContentName") != m.end() && !m["ContentName"].empty()) {
      contentName = make_shared<string>(boost::any_cast<string>(m["ContentName"]));
    }
    if (m.find("ParentContentId") != m.end() && !m["ParentContentId"].empty()) {
      parentContentId = make_shared<string>(boost::any_cast<string>(m["ParentContentId"]));
    }
  }


  virtual ~UpdateAntChainContractContentRequest() = default;
};
class UpdateAntChainContractContentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  UpdateAntChainContractContentResponseBody() {}

  explicit UpdateAntChainContractContentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~UpdateAntChainContractContentResponseBody() = default;
};
class UpdateAntChainContractContentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAntChainContractContentResponseBody> body{};

  UpdateAntChainContractContentResponse() {}

  explicit UpdateAntChainContractContentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAntChainContractContentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAntChainContractContentResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAntChainContractContentResponse() = default;
};
class UpdateAntChainContractProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectDescription{};
  shared_ptr<string> projectId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> projectVersion{};

  UpdateAntChainContractProjectRequest() {}

  explicit UpdateAntChainContractProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectDescription) {
      res["ProjectDescription"] = boost::any(*projectDescription);
    }
    if (projectId) {
      res["ProjectId"] = boost::any(*projectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (projectVersion) {
      res["ProjectVersion"] = boost::any(*projectVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectDescription") != m.end() && !m["ProjectDescription"].empty()) {
      projectDescription = make_shared<string>(boost::any_cast<string>(m["ProjectDescription"]));
    }
    if (m.find("ProjectId") != m.end() && !m["ProjectId"].empty()) {
      projectId = make_shared<string>(boost::any_cast<string>(m["ProjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProjectVersion") != m.end() && !m["ProjectVersion"].empty()) {
      projectVersion = make_shared<string>(boost::any_cast<string>(m["ProjectVersion"]));
    }
  }


  virtual ~UpdateAntChainContractProjectRequest() = default;
};
class UpdateAntChainContractProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  UpdateAntChainContractProjectResponseBody() {}

  explicit UpdateAntChainContractProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~UpdateAntChainContractProjectResponseBody() = default;
};
class UpdateAntChainContractProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAntChainContractProjectResponseBody> body{};

  UpdateAntChainContractProjectResponse() {}

  explicit UpdateAntChainContractProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAntChainContractProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAntChainContractProjectResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAntChainContractProjectResponse() = default;
};
class UpdateAntChainMemberRequest : public Darabonba::Model {
public:
  shared_ptr<string> consortiumId{};
  shared_ptr<string> memberId{};
  shared_ptr<string> memberName{};

  UpdateAntChainMemberRequest() {}

  explicit UpdateAntChainMemberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (memberId) {
      res["MemberId"] = boost::any(*memberId);
    }
    if (memberName) {
      res["MemberName"] = boost::any(*memberName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("MemberId") != m.end() && !m["MemberId"].empty()) {
      memberId = make_shared<string>(boost::any_cast<string>(m["MemberId"]));
    }
    if (m.find("MemberName") != m.end() && !m["MemberName"].empty()) {
      memberName = make_shared<string>(boost::any_cast<string>(m["MemberName"]));
    }
  }


  virtual ~UpdateAntChainMemberRequest() = default;
};
class UpdateAntChainMemberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  UpdateAntChainMemberResponseBody() {}

  explicit UpdateAntChainMemberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~UpdateAntChainMemberResponseBody() = default;
};
class UpdateAntChainMemberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAntChainMemberResponseBody> body{};

  UpdateAntChainMemberResponse() {}

  explicit UpdateAntChainMemberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAntChainMemberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAntChainMemberResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAntChainMemberResponse() = default;
};
class UpdateAntChainQRCodeAuthorizationRequest : public Darabonba::Model {
public:
  shared_ptr<string> antChainId{};
  shared_ptr<string> authorizationType{};
  shared_ptr<string> QRCodeType{};

  UpdateAntChainQRCodeAuthorizationRequest() {}

  explicit UpdateAntChainQRCodeAuthorizationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (antChainId) {
      res["AntChainId"] = boost::any(*antChainId);
    }
    if (authorizationType) {
      res["AuthorizationType"] = boost::any(*authorizationType);
    }
    if (QRCodeType) {
      res["QRCodeType"] = boost::any(*QRCodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AntChainId") != m.end() && !m["AntChainId"].empty()) {
      antChainId = make_shared<string>(boost::any_cast<string>(m["AntChainId"]));
    }
    if (m.find("AuthorizationType") != m.end() && !m["AuthorizationType"].empty()) {
      authorizationType = make_shared<string>(boost::any_cast<string>(m["AuthorizationType"]));
    }
    if (m.find("QRCodeType") != m.end() && !m["QRCodeType"].empty()) {
      QRCodeType = make_shared<string>(boost::any_cast<string>(m["QRCodeType"]));
    }
  }


  virtual ~UpdateAntChainQRCodeAuthorizationRequest() = default;
};
class UpdateAntChainQRCodeAuthorizationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  UpdateAntChainQRCodeAuthorizationResponseBody() {}

  explicit UpdateAntChainQRCodeAuthorizationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~UpdateAntChainQRCodeAuthorizationResponseBody() = default;
};
class UpdateAntChainQRCodeAuthorizationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAntChainQRCodeAuthorizationResponseBody> body{};

  UpdateAntChainQRCodeAuthorizationResponse() {}

  explicit UpdateAntChainQRCodeAuthorizationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAntChainQRCodeAuthorizationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAntChainQRCodeAuthorizationResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAntChainQRCodeAuthorizationResponse() = default;
};
class UpgradeFabricChaincodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> collectionConfig{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};

  UpgradeFabricChaincodeRequest() {}

  explicit UpgradeFabricChaincodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (collectionConfig) {
      res["CollectionConfig"] = boost::any(*collectionConfig);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("CollectionConfig") != m.end() && !m["CollectionConfig"].empty()) {
      collectionConfig = make_shared<string>(boost::any_cast<string>(m["CollectionConfig"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~UpgradeFabricChaincodeRequest() = default;
};
class UpgradeFabricChaincodeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> chaincodeName{};
  shared_ptr<string> chaincodeVersion{};
  shared_ptr<string> channelName{};
  shared_ptr<string> consortiumId{};
  shared_ptr<string> createTime{};
  shared_ptr<string> deployTime{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<string> input{};
  shared_ptr<bool> install{};
  shared_ptr<string> message{};
  shared_ptr<string> path{};
  shared_ptr<string> providerId{};
  shared_ptr<string> providerName{};
  shared_ptr<string> state{};
  shared_ptr<long> type{};

  UpgradeFabricChaincodeResponseBodyResult() {}

  explicit UpgradeFabricChaincodeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (chaincodeName) {
      res["ChaincodeName"] = boost::any(*chaincodeName);
    }
    if (chaincodeVersion) {
      res["ChaincodeVersion"] = boost::any(*chaincodeVersion);
    }
    if (channelName) {
      res["ChannelName"] = boost::any(*channelName);
    }
    if (consortiumId) {
      res["ConsortiumId"] = boost::any(*consortiumId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (deployTime) {
      res["DeployTime"] = boost::any(*deployTime);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (input) {
      res["Input"] = boost::any(*input);
    }
    if (install) {
      res["Install"] = boost::any(*install);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (path) {
      res["Path"] = boost::any(*path);
    }
    if (providerId) {
      res["ProviderId"] = boost::any(*providerId);
    }
    if (providerName) {
      res["ProviderName"] = boost::any(*providerName);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("ChaincodeName") != m.end() && !m["ChaincodeName"].empty()) {
      chaincodeName = make_shared<string>(boost::any_cast<string>(m["ChaincodeName"]));
    }
    if (m.find("ChaincodeVersion") != m.end() && !m["ChaincodeVersion"].empty()) {
      chaincodeVersion = make_shared<string>(boost::any_cast<string>(m["ChaincodeVersion"]));
    }
    if (m.find("ChannelName") != m.end() && !m["ChannelName"].empty()) {
      channelName = make_shared<string>(boost::any_cast<string>(m["ChannelName"]));
    }
    if (m.find("ConsortiumId") != m.end() && !m["ConsortiumId"].empty()) {
      consortiumId = make_shared<string>(boost::any_cast<string>(m["ConsortiumId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DeployTime") != m.end() && !m["DeployTime"].empty()) {
      deployTime = make_shared<string>(boost::any_cast<string>(m["DeployTime"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      input = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Install") != m.end() && !m["Install"].empty()) {
      install = make_shared<bool>(boost::any_cast<bool>(m["Install"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Path") != m.end() && !m["Path"].empty()) {
      path = make_shared<string>(boost::any_cast<string>(m["Path"]));
    }
    if (m.find("ProviderId") != m.end() && !m["ProviderId"].empty()) {
      providerId = make_shared<string>(boost::any_cast<string>(m["ProviderId"]));
    }
    if (m.find("ProviderName") != m.end() && !m["ProviderName"].empty()) {
      providerName = make_shared<string>(boost::any_cast<string>(m["ProviderName"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
  }


  virtual ~UpgradeFabricChaincodeResponseBodyResult() = default;
};
class UpgradeFabricChaincodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> requestId{};
  shared_ptr<UpgradeFabricChaincodeResponseBodyResult> result{};
  shared_ptr<bool> success{};

  UpgradeFabricChaincodeResponseBody() {}

  explicit UpgradeFabricChaincodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        UpgradeFabricChaincodeResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<UpgradeFabricChaincodeResponseBodyResult>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpgradeFabricChaincodeResponseBody() = default;
};
class UpgradeFabricChaincodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpgradeFabricChaincodeResponseBody> body{};

  UpgradeFabricChaincodeResponse() {}

  explicit UpgradeFabricChaincodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpgradeFabricChaincodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpgradeFabricChaincodeResponseBody>(model1);
      }
    }
  }


  virtual ~UpgradeFabricChaincodeResponse() = default;
};
class UpgradeFabricChaincodeDefinitionRequest : public Darabonba::Model {
public:
  shared_ptr<string> chaincodeId{};
  shared_ptr<string> chaincodePackageId{};
  shared_ptr<string> chaincodeVersion{};
  shared_ptr<string> collectionConfig{};
  shared_ptr<string> endorsePolicy{};
  shared_ptr<bool> initRequired{};
  shared_ptr<string> location{};
  shared_ptr<string> organizationId{};

  UpgradeFabricChaincodeDefinitionRequest() {}

  explicit UpgradeFabricChaincodeDefinitionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chaincodeId) {
      res["ChaincodeId"] = boost::any(*chaincodeId);
    }
    if (chaincodePackageId) {
      res["ChaincodePackageId"] = boost::any(*chaincodePackageId);
    }
    if (chaincodeVersion) {
      res["ChaincodeVersion"] = boost::any(*chaincodeVersion);
    }
    if (collectionConfig) {
      res["CollectionConfig"] = boost::any(*collectionConfig);
    }
    if (endorsePolicy) {
      res["EndorsePolicy"] = boost::any(*endorsePolicy);
    }
    if (initRequired) {
      res["InitRequired"] = boost::any(*initRequired);
    }
    if (location) {
      res["Location"] = boost::any(*location);
    }
    if (organizationId) {
      res["OrganizationId"] = boost::any(*organizationId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ChaincodeId") != m.end() && !m["ChaincodeId"].empty()) {
      chaincodeId = make_shared<string>(boost::any_cast<string>(m["ChaincodeId"]));
    }
    if (m.find("ChaincodePackageId") != m.end() && !m["ChaincodePackageId"].empty()) {
      chaincodePackageId = make_shared<string>(boost::any_cast<string>(m["ChaincodePackageId"]));
    }
    if (m.find("ChaincodeVersion") != m.end() && !m["ChaincodeVersion"].empty()) {
      chaincodeVersion = make_shared<string>(boost::any_cast<string>(m["ChaincodeVersion"]));
    }
    if (m.find("CollectionConfig") != m.end() && !m["CollectionConfig"].empty()) {
      collectionConfig = make_shared<string>(boost::any_cast<string>(m["CollectionConfig"]));
    }
    if (m.find("EndorsePolicy") != m.end() && !m["EndorsePolicy"].empty()) {
      endorsePolicy = make_shared<string>(boost::any_cast<string>(m["EndorsePolicy"]));
    }
    if (m.find("InitRequired") != m.end() && !m["InitRequired"].empty()) {
      initRequired = make_shared<bool>(boost::any_cast<bool>(m["InitRequired"]));
    }
    if (m.find("Location") != m.end() && !m["Location"].empty()) {
      location = make_shared<string>(boost::any_cast<string>(m["Location"]));
    }
    if (m.find("OrganizationId") != m.end() && !m["OrganizationId"].empty()) {
      organizationId = make_shared<string>(boost::any_cast<string>(m["OrganizationId"]));
    }
  }


  virtual ~UpgradeFabricChaincodeDefinitionRequest() = default;
};
class UpgradeFabricChaincodeDefinitionResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> errorCode{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<ChaincodeVO> result{};
  shared_ptr<bool> success{};

  UpgradeFabricChaincodeDefinitionResponseBody() {}

  explicit UpgradeFabricChaincodeDefinitionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<long>(boost::any_cast<long>(m["ErrorCode"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ChaincodeVO model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ChaincodeVO>(model1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~UpgradeFabricChaincodeDefinitionResponseBody() = default;
};
class UpgradeFabricChaincodeDefinitionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpgradeFabricChaincodeDefinitionResponseBody> body{};

  UpgradeFabricChaincodeDefinitionResponse() {}

  explicit UpgradeFabricChaincodeDefinitionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpgradeFabricChaincodeDefinitionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpgradeFabricChaincodeDefinitionResponseBody>(model1);
      }
    }
  }


  virtual ~UpgradeFabricChaincodeDefinitionResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AcceptFabricInvitationResponse acceptFabricInvitationWithOptions(shared_ptr<AcceptFabricInvitationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AcceptFabricInvitationResponse acceptFabricInvitation(shared_ptr<AcceptFabricInvitationRequest> request);
  ApplyAntChainCertificateResponse applyAntChainCertificateWithOptions(shared_ptr<ApplyAntChainCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyAntChainCertificateResponse applyAntChainCertificate(shared_ptr<ApplyAntChainCertificateRequest> request);
  ApplyAntChainCertificateWithKeyAutoCreationResponse applyAntChainCertificateWithKeyAutoCreationWithOptions(shared_ptr<ApplyAntChainCertificateWithKeyAutoCreationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApplyAntChainCertificateWithKeyAutoCreationResponse applyAntChainCertificateWithKeyAutoCreation(shared_ptr<ApplyAntChainCertificateWithKeyAutoCreationRequest> request);
  ApproveFabricChaincodeDefinitionResponse approveFabricChaincodeDefinitionWithOptions(shared_ptr<ApproveFabricChaincodeDefinitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ApproveFabricChaincodeDefinitionResponse approveFabricChaincodeDefinition(shared_ptr<ApproveFabricChaincodeDefinitionRequest> request);
  BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponse batchAddAntChainMiniAppQRCodeAuthorizedUsersWithOptions(shared_ptr<BatchAddAntChainMiniAppQRCodeAuthorizedUsersRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchAddAntChainMiniAppQRCodeAuthorizedUsersResponse batchAddAntChainMiniAppQRCodeAuthorizedUsers(shared_ptr<BatchAddAntChainMiniAppQRCodeAuthorizedUsersRequest> request);
  CheckFabricConsortiumDomainResponse checkFabricConsortiumDomainWithOptions(shared_ptr<CheckFabricConsortiumDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckFabricConsortiumDomainResponse checkFabricConsortiumDomain(shared_ptr<CheckFabricConsortiumDomainRequest> request);
  CheckFabricOrganizationDomainResponse checkFabricOrganizationDomainWithOptions(shared_ptr<CheckFabricOrganizationDomainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckFabricOrganizationDomainResponse checkFabricOrganizationDomain(shared_ptr<CheckFabricOrganizationDomainRequest> request);
  ConfirmFabricConsortiumMemberResponse confirmFabricConsortiumMemberWithOptions(shared_ptr<ConfirmFabricConsortiumMemberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfirmFabricConsortiumMemberResponse confirmFabricConsortiumMember(shared_ptr<ConfirmFabricConsortiumMemberRequest> request);
  CopyAntChainContractProjectResponse copyAntChainContractProjectWithOptions(shared_ptr<CopyAntChainContractProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CopyAntChainContractProjectResponse copyAntChainContractProject(shared_ptr<CopyAntChainContractProjectRequest> request);
  CreateAntChainAccountResponse createAntChainAccountWithOptions(shared_ptr<CreateAntChainAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAntChainAccountResponse createAntChainAccount(shared_ptr<CreateAntChainAccountRequest> request);
  CreateAntChainAccountWithKeyPairAutoCreationResponse createAntChainAccountWithKeyPairAutoCreationWithOptions(shared_ptr<CreateAntChainAccountWithKeyPairAutoCreationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAntChainAccountWithKeyPairAutoCreationResponse createAntChainAccountWithKeyPairAutoCreation(shared_ptr<CreateAntChainAccountWithKeyPairAutoCreationRequest> request);
  CreateAntChainConsortiumResponse createAntChainConsortiumWithOptions(shared_ptr<CreateAntChainConsortiumRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAntChainConsortiumResponse createAntChainConsortium(shared_ptr<CreateAntChainConsortiumRequest> request);
  CreateAntChainContractContentResponse createAntChainContractContentWithOptions(shared_ptr<CreateAntChainContractContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAntChainContractContentResponse createAntChainContractContent(shared_ptr<CreateAntChainContractContentRequest> request);
  CreateAntChainContractProjectResponse createAntChainContractProjectWithOptions(shared_ptr<CreateAntChainContractProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAntChainContractProjectResponse createAntChainContractProject(shared_ptr<CreateAntChainContractProjectRequest> request);
  CreateAntChainKmsAccountNewResponse createAntChainKmsAccountNewWithOptions(shared_ptr<CreateAntChainKmsAccountNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateAntChainKmsAccountNewResponse createAntChainKmsAccountNew(shared_ptr<CreateAntChainKmsAccountNewRequest> request);
  CreateFabricChaincodeResponse createFabricChaincodeWithOptions(shared_ptr<CreateFabricChaincodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFabricChaincodeResponse createFabricChaincode(shared_ptr<CreateFabricChaincodeRequest> request);
  CreateFabricChaincodePackageResponse createFabricChaincodePackageWithOptions(shared_ptr<CreateFabricChaincodePackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFabricChaincodePackageResponse createFabricChaincodePackage(shared_ptr<CreateFabricChaincodePackageRequest> request);
  CreateFabricChannelResponse createFabricChannelWithOptions(shared_ptr<CreateFabricChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFabricChannelResponse createFabricChannel(shared_ptr<CreateFabricChannelRequest> request);
  CreateFabricChannelMemberResponse createFabricChannelMemberWithOptions(shared_ptr<CreateFabricChannelMemberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFabricChannelMemberResponse createFabricChannelMember(shared_ptr<CreateFabricChannelMemberRequest> request);
  CreateFabricConsortiumResponse createFabricConsortiumWithOptions(shared_ptr<CreateFabricConsortiumRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFabricConsortiumResponse createFabricConsortium(shared_ptr<CreateFabricConsortiumRequest> request);
  CreateFabricConsortiumMemberResponse createFabricConsortiumMemberWithOptions(shared_ptr<CreateFabricConsortiumMemberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFabricConsortiumMemberResponse createFabricConsortiumMember(shared_ptr<CreateFabricConsortiumMemberRequest> request);
  CreateFabricOrganizationResponse createFabricOrganizationWithOptions(shared_ptr<CreateFabricOrganizationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFabricOrganizationResponse createFabricOrganization(shared_ptr<CreateFabricOrganizationRequest> request);
  CreateFabricOrganizationUserResponse createFabricOrganizationUserWithOptions(shared_ptr<CreateFabricOrganizationUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFabricOrganizationUserResponse createFabricOrganizationUser(shared_ptr<CreateFabricOrganizationUserRequest> request);
  DeleteAntChainConsortiumResponse deleteAntChainConsortiumWithOptions(shared_ptr<DeleteAntChainConsortiumRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAntChainConsortiumResponse deleteAntChainConsortium(shared_ptr<DeleteAntChainConsortiumRequest> request);
  DeleteAntChainContractContentResponse deleteAntChainContractContentWithOptions(shared_ptr<DeleteAntChainContractContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAntChainContractContentResponse deleteAntChainContractContent(shared_ptr<DeleteAntChainContractContentRequest> request);
  DeleteAntChainContractProjectResponse deleteAntChainContractProjectWithOptions(shared_ptr<DeleteAntChainContractProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAntChainContractProjectResponse deleteAntChainContractProject(shared_ptr<DeleteAntChainContractProjectRequest> request);
  DeleteAntChainMiniAppQRCodeAuthorizedUserResponse deleteAntChainMiniAppQRCodeAuthorizedUserWithOptions(shared_ptr<DeleteAntChainMiniAppQRCodeAuthorizedUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteAntChainMiniAppQRCodeAuthorizedUserResponse deleteAntChainMiniAppQRCodeAuthorizedUser(shared_ptr<DeleteAntChainMiniAppQRCodeAuthorizedUserRequest> request);
  DeleteFabricChaincodeResponse deleteFabricChaincodeWithOptions(shared_ptr<DeleteFabricChaincodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFabricChaincodeResponse deleteFabricChaincode(shared_ptr<DeleteFabricChaincodeRequest> request);
  DescribeAntChainAccountsResponse describeAntChainAccountsWithOptions(shared_ptr<DescribeAntChainAccountsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainAccountsResponse describeAntChainAccounts(shared_ptr<DescribeAntChainAccountsRequest> request);
  DescribeAntChainAccountsV2Response describeAntChainAccountsV2WithOptions(shared_ptr<DescribeAntChainAccountsV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainAccountsV2Response describeAntChainAccountsV2(shared_ptr<DescribeAntChainAccountsV2Request> request);
  DescribeAntChainBlockResponse describeAntChainBlockWithOptions(shared_ptr<DescribeAntChainBlockRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainBlockResponse describeAntChainBlock(shared_ptr<DescribeAntChainBlockRequest> request);
  DescribeAntChainBlockV2Response describeAntChainBlockV2WithOptions(shared_ptr<DescribeAntChainBlockV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainBlockV2Response describeAntChainBlockV2(shared_ptr<DescribeAntChainBlockV2Request> request);
  DescribeAntChainCertificateApplicationsResponse describeAntChainCertificateApplicationsWithOptions(shared_ptr<DescribeAntChainCertificateApplicationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainCertificateApplicationsResponse describeAntChainCertificateApplications(shared_ptr<DescribeAntChainCertificateApplicationsRequest> request);
  DescribeAntChainCertificateApplicationsV2Response describeAntChainCertificateApplicationsV2WithOptions(shared_ptr<DescribeAntChainCertificateApplicationsV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainCertificateApplicationsV2Response describeAntChainCertificateApplicationsV2(shared_ptr<DescribeAntChainCertificateApplicationsV2Request> request);
  DescribeAntChainConsortiumsResponse describeAntChainConsortiumsWithOptions(shared_ptr<DescribeAntChainConsortiumsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainConsortiumsResponse describeAntChainConsortiums(shared_ptr<DescribeAntChainConsortiumsRequest> request);
  DescribeAntChainConsortiumsV2Response describeAntChainConsortiumsV2WithOptions(shared_ptr<DescribeAntChainConsortiumsV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainConsortiumsV2Response describeAntChainConsortiumsV2(shared_ptr<DescribeAntChainConsortiumsV2Request> request);
  DescribeAntChainContractProjectContentTreeResponse describeAntChainContractProjectContentTreeWithOptions(shared_ptr<DescribeAntChainContractProjectContentTreeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainContractProjectContentTreeResponse describeAntChainContractProjectContentTree(shared_ptr<DescribeAntChainContractProjectContentTreeRequest> request);
  DescribeAntChainContractProjectContentTreeV2Response describeAntChainContractProjectContentTreeV2WithOptions(shared_ptr<DescribeAntChainContractProjectContentTreeV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainContractProjectContentTreeV2Response describeAntChainContractProjectContentTreeV2(shared_ptr<DescribeAntChainContractProjectContentTreeV2Request> request);
  DescribeAntChainContractProjectsResponse describeAntChainContractProjectsWithOptions(shared_ptr<DescribeAntChainContractProjectsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainContractProjectsResponse describeAntChainContractProjects(shared_ptr<DescribeAntChainContractProjectsRequest> request);
  DescribeAntChainContractProjectsV2Response describeAntChainContractProjectsV2WithOptions(shared_ptr<DescribeAntChainContractProjectsV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainContractProjectsV2Response describeAntChainContractProjectsV2(shared_ptr<DescribeAntChainContractProjectsV2Request> request);
  DescribeAntChainDownloadPathsResponse describeAntChainDownloadPathsWithOptions(shared_ptr<DescribeAntChainDownloadPathsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainDownloadPathsResponse describeAntChainDownloadPaths(shared_ptr<DescribeAntChainDownloadPathsRequest> request);
  DescribeAntChainDownloadPathsV2Response describeAntChainDownloadPathsV2WithOptions(shared_ptr<DescribeAntChainDownloadPathsV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainDownloadPathsV2Response describeAntChainDownloadPathsV2(shared_ptr<DescribeAntChainDownloadPathsV2Request> request);
  DescribeAntChainInformationResponse describeAntChainInformationWithOptions(shared_ptr<DescribeAntChainInformationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainInformationResponse describeAntChainInformation(shared_ptr<DescribeAntChainInformationRequest> request);
  DescribeAntChainInformationV2Response describeAntChainInformationV2WithOptions(shared_ptr<DescribeAntChainInformationV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainInformationV2Response describeAntChainInformationV2(shared_ptr<DescribeAntChainInformationV2Request> request);
  DescribeAntChainLatestBlocksResponse describeAntChainLatestBlocksWithOptions(shared_ptr<DescribeAntChainLatestBlocksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainLatestBlocksResponse describeAntChainLatestBlocks(shared_ptr<DescribeAntChainLatestBlocksRequest> request);
  DescribeAntChainLatestBlocksV2Response describeAntChainLatestBlocksV2WithOptions(shared_ptr<DescribeAntChainLatestBlocksV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainLatestBlocksV2Response describeAntChainLatestBlocksV2(shared_ptr<DescribeAntChainLatestBlocksV2Request> request);
  DescribeAntChainLatestTransactionDigestsResponse describeAntChainLatestTransactionDigestsWithOptions(shared_ptr<DescribeAntChainLatestTransactionDigestsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainLatestTransactionDigestsResponse describeAntChainLatestTransactionDigests(shared_ptr<DescribeAntChainLatestTransactionDigestsRequest> request);
  DescribeAntChainLatestTransactionDigestsV2Response describeAntChainLatestTransactionDigestsV2WithOptions(shared_ptr<DescribeAntChainLatestTransactionDigestsV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainLatestTransactionDigestsV2Response describeAntChainLatestTransactionDigestsV2(shared_ptr<DescribeAntChainLatestTransactionDigestsV2Request> request);
  DescribeAntChainMembersResponse describeAntChainMembersWithOptions(shared_ptr<DescribeAntChainMembersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainMembersResponse describeAntChainMembers(shared_ptr<DescribeAntChainMembersRequest> request);
  DescribeAntChainMembersV2Response describeAntChainMembersV2WithOptions(shared_ptr<DescribeAntChainMembersV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainMembersV2Response describeAntChainMembersV2(shared_ptr<DescribeAntChainMembersV2Request> request);
  DescribeAntChainMiniAppBrowserQRCodeAccessLogResponse describeAntChainMiniAppBrowserQRCodeAccessLogWithOptions(shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAccessLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainMiniAppBrowserQRCodeAccessLogResponse describeAntChainMiniAppBrowserQRCodeAccessLog(shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAccessLogRequest> request);
  DescribeAntChainMiniAppBrowserQRCodeAccessLogV2Response describeAntChainMiniAppBrowserQRCodeAccessLogV2WithOptions(shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAccessLogV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainMiniAppBrowserQRCodeAccessLogV2Response describeAntChainMiniAppBrowserQRCodeAccessLogV2(shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAccessLogV2Request> request);
  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponse describeAntChainMiniAppBrowserQRCodeAuthorizedUsersWithOptions(shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersResponse describeAntChainMiniAppBrowserQRCodeAuthorizedUsers(shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersRequest> request);
  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2Response describeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2WithOptions(shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2Response describeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2(shared_ptr<DescribeAntChainMiniAppBrowserQRCodeAuthorizedUsersV2Request> request);
  DescribeAntChainMiniAppBrowserTransactionQRCodeResponse describeAntChainMiniAppBrowserTransactionQRCodeWithOptions(shared_ptr<DescribeAntChainMiniAppBrowserTransactionQRCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainMiniAppBrowserTransactionQRCodeResponse describeAntChainMiniAppBrowserTransactionQRCode(shared_ptr<DescribeAntChainMiniAppBrowserTransactionQRCodeRequest> request);
  DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponse describeAntChainMiniAppBrowserTransactionQRCodeNewWithOptions(shared_ptr<DescribeAntChainMiniAppBrowserTransactionQRCodeNewRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainMiniAppBrowserTransactionQRCodeNewResponse describeAntChainMiniAppBrowserTransactionQRCodeNew(shared_ptr<DescribeAntChainMiniAppBrowserTransactionQRCodeNewRequest> request);
  DescribeAntChainNodesResponse describeAntChainNodesWithOptions(shared_ptr<DescribeAntChainNodesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainNodesResponse describeAntChainNodes(shared_ptr<DescribeAntChainNodesRequest> request);
  DescribeAntChainNodesV2Response describeAntChainNodesV2WithOptions(shared_ptr<DescribeAntChainNodesV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainNodesV2Response describeAntChainNodesV2(shared_ptr<DescribeAntChainNodesV2Request> request);
  DescribeAntChainQRCodeAuthorizationResponse describeAntChainQRCodeAuthorizationWithOptions(shared_ptr<DescribeAntChainQRCodeAuthorizationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainQRCodeAuthorizationResponse describeAntChainQRCodeAuthorization(shared_ptr<DescribeAntChainQRCodeAuthorizationRequest> request);
  DescribeAntChainQRCodeAuthorizationV2Response describeAntChainQRCodeAuthorizationV2WithOptions(shared_ptr<DescribeAntChainQRCodeAuthorizationV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainQRCodeAuthorizationV2Response describeAntChainQRCodeAuthorizationV2(shared_ptr<DescribeAntChainQRCodeAuthorizationV2Request> request);
  DescribeAntChainTransactionResponse describeAntChainTransactionWithOptions(shared_ptr<DescribeAntChainTransactionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainTransactionResponse describeAntChainTransaction(shared_ptr<DescribeAntChainTransactionRequest> request);
  DescribeAntChainTransactionReceiptResponse describeAntChainTransactionReceiptWithOptions(shared_ptr<DescribeAntChainTransactionReceiptRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainTransactionReceiptResponse describeAntChainTransactionReceipt(shared_ptr<DescribeAntChainTransactionReceiptRequest> request);
  DescribeAntChainTransactionReceiptV2Response describeAntChainTransactionReceiptV2WithOptions(shared_ptr<DescribeAntChainTransactionReceiptV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainTransactionReceiptV2Response describeAntChainTransactionReceiptV2(shared_ptr<DescribeAntChainTransactionReceiptV2Request> request);
  DescribeAntChainTransactionStatisticsResponse describeAntChainTransactionStatisticsWithOptions(shared_ptr<DescribeAntChainTransactionStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainTransactionStatisticsResponse describeAntChainTransactionStatistics(shared_ptr<DescribeAntChainTransactionStatisticsRequest> request);
  DescribeAntChainTransactionStatisticsV2Response describeAntChainTransactionStatisticsV2WithOptions(shared_ptr<DescribeAntChainTransactionStatisticsV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainTransactionStatisticsV2Response describeAntChainTransactionStatisticsV2(shared_ptr<DescribeAntChainTransactionStatisticsV2Request> request);
  DescribeAntChainTransactionV2Response describeAntChainTransactionV2WithOptions(shared_ptr<DescribeAntChainTransactionV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainTransactionV2Response describeAntChainTransactionV2(shared_ptr<DescribeAntChainTransactionV2Request> request);
  DescribeAntChainsResponse describeAntChainsWithOptions(shared_ptr<DescribeAntChainsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainsResponse describeAntChains(shared_ptr<DescribeAntChainsRequest> request);
  DescribeAntChainsV2Response describeAntChainsV2WithOptions(shared_ptr<DescribeAntChainsV2Request> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAntChainsV2Response describeAntChainsV2(shared_ptr<DescribeAntChainsV2Request> request);
  DescribeEthereumDeletableResponse describeEthereumDeletableWithOptions(shared_ptr<DescribeEthereumDeletableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeEthereumDeletableResponse describeEthereumDeletable(shared_ptr<DescribeEthereumDeletableRequest> request);
  DescribeFabricCandidateOrganizationsResponse describeFabricCandidateOrganizationsWithOptions(shared_ptr<DescribeFabricCandidateOrganizationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricCandidateOrganizationsResponse describeFabricCandidateOrganizations(shared_ptr<DescribeFabricCandidateOrganizationsRequest> request);
  DescribeFabricChaincodeDefinitionTaskResponse describeFabricChaincodeDefinitionTaskWithOptions(shared_ptr<DescribeFabricChaincodeDefinitionTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricChaincodeDefinitionTaskResponse describeFabricChaincodeDefinitionTask(shared_ptr<DescribeFabricChaincodeDefinitionTaskRequest> request);
  DescribeFabricChaincodeUploadPolicyResponse describeFabricChaincodeUploadPolicyWithOptions(shared_ptr<DescribeFabricChaincodeUploadPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricChaincodeUploadPolicyResponse describeFabricChaincodeUploadPolicy(shared_ptr<DescribeFabricChaincodeUploadPolicyRequest> request);
  DescribeFabricChannelMembersResponse describeFabricChannelMembersWithOptions(shared_ptr<DescribeFabricChannelMembersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricChannelMembersResponse describeFabricChannelMembers(shared_ptr<DescribeFabricChannelMembersRequest> request);
  DescribeFabricConsortiumAdminStatusResponse describeFabricConsortiumAdminStatusWithOptions(shared_ptr<DescribeFabricConsortiumAdminStatusRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricConsortiumAdminStatusResponse describeFabricConsortiumAdminStatus(shared_ptr<DescribeFabricConsortiumAdminStatusRequest> request);
  DescribeFabricConsortiumChaincodesResponse describeFabricConsortiumChaincodesWithOptions(shared_ptr<DescribeFabricConsortiumChaincodesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricConsortiumChaincodesResponse describeFabricConsortiumChaincodes(shared_ptr<DescribeFabricConsortiumChaincodesRequest> request);
  DescribeFabricConsortiumChannelsResponse describeFabricConsortiumChannelsWithOptions(shared_ptr<DescribeFabricConsortiumChannelsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricConsortiumChannelsResponse describeFabricConsortiumChannels(shared_ptr<DescribeFabricConsortiumChannelsRequest> request);
  DescribeFabricConsortiumConfigResponse describeFabricConsortiumConfigWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricConsortiumConfigResponse describeFabricConsortiumConfig();
  DescribeFabricConsortiumDeletableResponse describeFabricConsortiumDeletableWithOptions(shared_ptr<DescribeFabricConsortiumDeletableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricConsortiumDeletableResponse describeFabricConsortiumDeletable(shared_ptr<DescribeFabricConsortiumDeletableRequest> request);
  DescribeFabricConsortiumMemberApprovalResponse describeFabricConsortiumMemberApprovalWithOptions(shared_ptr<DescribeFabricConsortiumMemberApprovalRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricConsortiumMemberApprovalResponse describeFabricConsortiumMemberApproval(shared_ptr<DescribeFabricConsortiumMemberApprovalRequest> request);
  DescribeFabricConsortiumMembersResponse describeFabricConsortiumMembersWithOptions(shared_ptr<DescribeFabricConsortiumMembersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricConsortiumMembersResponse describeFabricConsortiumMembers(shared_ptr<DescribeFabricConsortiumMembersRequest> request);
  DescribeFabricConsortiumOrderersResponse describeFabricConsortiumOrderersWithOptions(shared_ptr<DescribeFabricConsortiumOrderersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricConsortiumOrderersResponse describeFabricConsortiumOrderers(shared_ptr<DescribeFabricConsortiumOrderersRequest> request);
  DescribeFabricConsortiumSpecsResponse describeFabricConsortiumSpecsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricConsortiumSpecsResponse describeFabricConsortiumSpecs();
  DescribeFabricConsortiumsResponse describeFabricConsortiumsWithOptions(shared_ptr<DescribeFabricConsortiumsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricConsortiumsResponse describeFabricConsortiums(shared_ptr<DescribeFabricConsortiumsRequest> request);
  DescribeFabricExplorerResponse describeFabricExplorerWithOptions(shared_ptr<DescribeFabricExplorerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricExplorerResponse describeFabricExplorer(shared_ptr<DescribeFabricExplorerRequest> request);
  DescribeFabricInvitationCodeResponse describeFabricInvitationCodeWithOptions(shared_ptr<DescribeFabricInvitationCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricInvitationCodeResponse describeFabricInvitationCode(shared_ptr<DescribeFabricInvitationCodeRequest> request);
  DescribeFabricInviterResponse describeFabricInviterWithOptions(shared_ptr<DescribeFabricInviterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricInviterResponse describeFabricInviter(shared_ptr<DescribeFabricInviterRequest> request);
  DescribeFabricOrdererLogsResponse describeFabricOrdererLogsWithOptions(shared_ptr<DescribeFabricOrdererLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricOrdererLogsResponse describeFabricOrdererLogs(shared_ptr<DescribeFabricOrdererLogsRequest> request);
  DescribeFabricOrganizationResponse describeFabricOrganizationWithOptions(shared_ptr<DescribeFabricOrganizationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricOrganizationResponse describeFabricOrganization(shared_ptr<DescribeFabricOrganizationRequest> request);
  DescribeFabricOrganizationChaincodePackageResponse describeFabricOrganizationChaincodePackageWithOptions(shared_ptr<DescribeFabricOrganizationChaincodePackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricOrganizationChaincodePackageResponse describeFabricOrganizationChaincodePackage(shared_ptr<DescribeFabricOrganizationChaincodePackageRequest> request);
  DescribeFabricOrganizationChaincodesResponse describeFabricOrganizationChaincodesWithOptions(shared_ptr<DescribeFabricOrganizationChaincodesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricOrganizationChaincodesResponse describeFabricOrganizationChaincodes(shared_ptr<DescribeFabricOrganizationChaincodesRequest> request);
  DescribeFabricOrganizationChannelsResponse describeFabricOrganizationChannelsWithOptions(shared_ptr<DescribeFabricOrganizationChannelsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricOrganizationChannelsResponse describeFabricOrganizationChannels(shared_ptr<DescribeFabricOrganizationChannelsRequest> request);
  DescribeFabricOrganizationDeletableResponse describeFabricOrganizationDeletableWithOptions(shared_ptr<DescribeFabricOrganizationDeletableRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricOrganizationDeletableResponse describeFabricOrganizationDeletable(shared_ptr<DescribeFabricOrganizationDeletableRequest> request);
  DescribeFabricOrganizationMembersResponse describeFabricOrganizationMembersWithOptions(shared_ptr<DescribeFabricOrganizationMembersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricOrganizationMembersResponse describeFabricOrganizationMembers(shared_ptr<DescribeFabricOrganizationMembersRequest> request);
  DescribeFabricOrganizationPeersResponse describeFabricOrganizationPeersWithOptions(shared_ptr<DescribeFabricOrganizationPeersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricOrganizationPeersResponse describeFabricOrganizationPeers(shared_ptr<DescribeFabricOrganizationPeersRequest> request);
  DescribeFabricOrganizationSpecsResponse describeFabricOrganizationSpecsWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricOrganizationSpecsResponse describeFabricOrganizationSpecs();
  DescribeFabricOrganizationUsersResponse describeFabricOrganizationUsersWithOptions(shared_ptr<DescribeFabricOrganizationUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricOrganizationUsersResponse describeFabricOrganizationUsers(shared_ptr<DescribeFabricOrganizationUsersRequest> request);
  DescribeFabricOrganizationsResponse describeFabricOrganizationsWithOptions(shared_ptr<DescribeFabricOrganizationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricOrganizationsResponse describeFabricOrganizations(shared_ptr<DescribeFabricOrganizationsRequest> request);
  DescribeFabricPeerLogsResponse describeFabricPeerLogsWithOptions(shared_ptr<DescribeFabricPeerLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFabricPeerLogsResponse describeFabricPeerLogs(shared_ptr<DescribeFabricPeerLogsRequest> request);
  DescribeRegionsResponse describeRegionsWithOptions(shared_ptr<DescribeRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRegionsResponse describeRegions(shared_ptr<DescribeRegionsRequest> request);
  DescribeRootDomainResponse describeRootDomainWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRootDomainResponse describeRootDomain();
  DescribeTasksResponse describeTasksWithOptions(shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTasksResponse describeTasks();
  DownloadFabricOrganizationSDKResponse downloadFabricOrganizationSDKWithOptions(shared_ptr<DownloadFabricOrganizationSDKRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DownloadFabricOrganizationSDKResponse downloadFabricOrganizationSDK(shared_ptr<DownloadFabricOrganizationSDKRequest> request);
  FreezeAntChainAccountResponse freezeAntChainAccountWithOptions(shared_ptr<FreezeAntChainAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FreezeAntChainAccountResponse freezeAntChainAccount(shared_ptr<FreezeAntChainAccountRequest> request);
  InstallFabricChaincodeResponse installFabricChaincodeWithOptions(shared_ptr<InstallFabricChaincodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstallFabricChaincodeResponse installFabricChaincode(shared_ptr<InstallFabricChaincodeRequest> request);
  InstallFabricChaincodePackageResponse installFabricChaincodePackageWithOptions(shared_ptr<InstallFabricChaincodePackageRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstallFabricChaincodePackageResponse installFabricChaincodePackage(shared_ptr<InstallFabricChaincodePackageRequest> request);
  InstantiateFabricChaincodeResponse instantiateFabricChaincodeWithOptions(shared_ptr<InstantiateFabricChaincodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstantiateFabricChaincodeResponse instantiateFabricChaincode(shared_ptr<InstantiateFabricChaincodeRequest> request);
  JoinFabricChannelResponse joinFabricChannelWithOptions(shared_ptr<JoinFabricChannelRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  JoinFabricChannelResponse joinFabricChannel(shared_ptr<JoinFabricChannelRequest> request);
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  ResetAntChainCertificateResponse resetAntChainCertificateWithOptions(shared_ptr<ResetAntChainCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetAntChainCertificateResponse resetAntChainCertificate(shared_ptr<ResetAntChainCertificateRequest> request);
  ResetAntChainUserCertificateResponse resetAntChainUserCertificateWithOptions(shared_ptr<ResetAntChainUserCertificateRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetAntChainUserCertificateResponse resetAntChainUserCertificate(shared_ptr<ResetAntChainUserCertificateRequest> request);
  ResetFabricOrganizationUserPasswordResponse resetFabricOrganizationUserPasswordWithOptions(shared_ptr<ResetFabricOrganizationUserPasswordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetFabricOrganizationUserPasswordResponse resetFabricOrganizationUserPassword(shared_ptr<ResetFabricOrganizationUserPasswordRequest> request);
  SubmitFabricChaincodeDefinitionResponse submitFabricChaincodeDefinitionWithOptions(shared_ptr<SubmitFabricChaincodeDefinitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SubmitFabricChaincodeDefinitionResponse submitFabricChaincodeDefinition(shared_ptr<SubmitFabricChaincodeDefinitionRequest> request);
  SynchronizeFabricChaincodeResponse synchronizeFabricChaincodeWithOptions(shared_ptr<SynchronizeFabricChaincodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SynchronizeFabricChaincodeResponse synchronizeFabricChaincode(shared_ptr<SynchronizeFabricChaincodeRequest> request);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  UnfreezeAntChainAccountResponse unfreezeAntChainAccountWithOptions(shared_ptr<UnfreezeAntChainAccountRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnfreezeAntChainAccountResponse unfreezeAntChainAccount(shared_ptr<UnfreezeAntChainAccountRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);
  UpdateAntChainResponse updateAntChainWithOptions(shared_ptr<UpdateAntChainRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAntChainResponse updateAntChain(shared_ptr<UpdateAntChainRequest> request);
  UpdateAntChainConsortiumResponse updateAntChainConsortiumWithOptions(shared_ptr<UpdateAntChainConsortiumRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAntChainConsortiumResponse updateAntChainConsortium(shared_ptr<UpdateAntChainConsortiumRequest> request);
  UpdateAntChainContractContentResponse updateAntChainContractContentWithOptions(shared_ptr<UpdateAntChainContractContentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAntChainContractContentResponse updateAntChainContractContent(shared_ptr<UpdateAntChainContractContentRequest> request);
  UpdateAntChainContractProjectResponse updateAntChainContractProjectWithOptions(shared_ptr<UpdateAntChainContractProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAntChainContractProjectResponse updateAntChainContractProject(shared_ptr<UpdateAntChainContractProjectRequest> request);
  UpdateAntChainMemberResponse updateAntChainMemberWithOptions(shared_ptr<UpdateAntChainMemberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAntChainMemberResponse updateAntChainMember(shared_ptr<UpdateAntChainMemberRequest> request);
  UpdateAntChainQRCodeAuthorizationResponse updateAntChainQRCodeAuthorizationWithOptions(shared_ptr<UpdateAntChainQRCodeAuthorizationRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAntChainQRCodeAuthorizationResponse updateAntChainQRCodeAuthorization(shared_ptr<UpdateAntChainQRCodeAuthorizationRequest> request);
  UpgradeFabricChaincodeResponse upgradeFabricChaincodeWithOptions(shared_ptr<UpgradeFabricChaincodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpgradeFabricChaincodeResponse upgradeFabricChaincode(shared_ptr<UpgradeFabricChaincodeRequest> request);
  UpgradeFabricChaincodeDefinitionResponse upgradeFabricChaincodeDefinitionWithOptions(shared_ptr<UpgradeFabricChaincodeDefinitionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpgradeFabricChaincodeDefinitionResponse upgradeFabricChaincodeDefinition(shared_ptr<UpgradeFabricChaincodeDefinitionRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Baas20181221

#endif
