// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_GEMP20210413_H_
#define ALIBABACLOUD_GEMP20210413_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_GEMP20210413 {
class ProblemLevelGroupValue : public Darabonba::Model {
public:
  shared_ptr<long> childRuleRelation{};
  shared_ptr<long> matchCount{};
  shared_ptr<long> timeWindow{};
  shared_ptr<string> timeWindowUnit{};
  shared_ptr<bool> enableUpgrade{};
  shared_ptr<long> upgradeTimeWindow{};
  shared_ptr<string> upgradeTimeWindowUnit{};

  ProblemLevelGroupValue() {}

  explicit ProblemLevelGroupValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (childRuleRelation) {
      res["childRuleRelation"] = boost::any(*childRuleRelation);
    }
    if (matchCount) {
      res["matchCount"] = boost::any(*matchCount);
    }
    if (timeWindow) {
      res["timeWindow"] = boost::any(*timeWindow);
    }
    if (timeWindowUnit) {
      res["timeWindowUnit"] = boost::any(*timeWindowUnit);
    }
    if (enableUpgrade) {
      res["enableUpgrade"] = boost::any(*enableUpgrade);
    }
    if (upgradeTimeWindow) {
      res["upgradeTimeWindow"] = boost::any(*upgradeTimeWindow);
    }
    if (upgradeTimeWindowUnit) {
      res["upgradeTimeWindowUnit"] = boost::any(*upgradeTimeWindowUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("childRuleRelation") != m.end() && !m["childRuleRelation"].empty()) {
      childRuleRelation = make_shared<long>(boost::any_cast<long>(m["childRuleRelation"]));
    }
    if (m.find("matchCount") != m.end() && !m["matchCount"].empty()) {
      matchCount = make_shared<long>(boost::any_cast<long>(m["matchCount"]));
    }
    if (m.find("timeWindow") != m.end() && !m["timeWindow"].empty()) {
      timeWindow = make_shared<long>(boost::any_cast<long>(m["timeWindow"]));
    }
    if (m.find("timeWindowUnit") != m.end() && !m["timeWindowUnit"].empty()) {
      timeWindowUnit = make_shared<string>(boost::any_cast<string>(m["timeWindowUnit"]));
    }
    if (m.find("enableUpgrade") != m.end() && !m["enableUpgrade"].empty()) {
      enableUpgrade = make_shared<bool>(boost::any_cast<bool>(m["enableUpgrade"]));
    }
    if (m.find("upgradeTimeWindow") != m.end() && !m["upgradeTimeWindow"].empty()) {
      upgradeTimeWindow = make_shared<long>(boost::any_cast<long>(m["upgradeTimeWindow"]));
    }
    if (m.find("upgradeTimeWindowUnit") != m.end() && !m["upgradeTimeWindowUnit"].empty()) {
      upgradeTimeWindowUnit = make_shared<string>(boost::any_cast<string>(m["upgradeTimeWindowUnit"]));
    }
  }


  virtual ~ProblemLevelGroupValue() = default;
};
class DataProblemLevelGroupValue : public Darabonba::Model {
public:
  shared_ptr<long> childRuleRelation{};
  shared_ptr<long> matchCount{};
  shared_ptr<long> timeWindow{};
  shared_ptr<string> timeWindowUnit{};
  shared_ptr<bool> enableUpgrade{};
  shared_ptr<long> upgradeTimeWindow{};
  shared_ptr<string> upgradeTimeWindowUnit{};

  DataProblemLevelGroupValue() {}

  explicit DataProblemLevelGroupValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (childRuleRelation) {
      res["childRuleRelation"] = boost::any(*childRuleRelation);
    }
    if (matchCount) {
      res["matchCount"] = boost::any(*matchCount);
    }
    if (timeWindow) {
      res["timeWindow"] = boost::any(*timeWindow);
    }
    if (timeWindowUnit) {
      res["timeWindowUnit"] = boost::any(*timeWindowUnit);
    }
    if (enableUpgrade) {
      res["enableUpgrade"] = boost::any(*enableUpgrade);
    }
    if (upgradeTimeWindow) {
      res["upgradeTimeWindow"] = boost::any(*upgradeTimeWindow);
    }
    if (upgradeTimeWindowUnit) {
      res["upgradeTimeWindowUnit"] = boost::any(*upgradeTimeWindowUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("childRuleRelation") != m.end() && !m["childRuleRelation"].empty()) {
      childRuleRelation = make_shared<long>(boost::any_cast<long>(m["childRuleRelation"]));
    }
    if (m.find("matchCount") != m.end() && !m["matchCount"].empty()) {
      matchCount = make_shared<long>(boost::any_cast<long>(m["matchCount"]));
    }
    if (m.find("timeWindow") != m.end() && !m["timeWindow"].empty()) {
      timeWindow = make_shared<long>(boost::any_cast<long>(m["timeWindow"]));
    }
    if (m.find("timeWindowUnit") != m.end() && !m["timeWindowUnit"].empty()) {
      timeWindowUnit = make_shared<string>(boost::any_cast<string>(m["timeWindowUnit"]));
    }
    if (m.find("enableUpgrade") != m.end() && !m["enableUpgrade"].empty()) {
      enableUpgrade = make_shared<bool>(boost::any_cast<bool>(m["enableUpgrade"]));
    }
    if (m.find("upgradeTimeWindow") != m.end() && !m["upgradeTimeWindow"].empty()) {
      upgradeTimeWindow = make_shared<long>(boost::any_cast<long>(m["upgradeTimeWindow"]));
    }
    if (m.find("upgradeTimeWindowUnit") != m.end() && !m["upgradeTimeWindowUnit"].empty()) {
      upgradeTimeWindowUnit = make_shared<string>(boost::any_cast<string>(m["upgradeTimeWindowUnit"]));
    }
  }


  virtual ~DataProblemLevelGroupValue() = default;
};
class DataValue : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> description{};
  shared_ptr<string> configDescription{};
  shared_ptr<string> configCode{};
  shared_ptr<string> parentCode{};
  shared_ptr<string> configKey{};
  shared_ptr<string> configValue{};
  shared_ptr<bool> requirement{};

  DataValue() {}

  explicit DataValue(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (configDescription) {
      res["configDescription"] = boost::any(*configDescription);
    }
    if (configCode) {
      res["configCode"] = boost::any(*configCode);
    }
    if (parentCode) {
      res["parentCode"] = boost::any(*parentCode);
    }
    if (configKey) {
      res["configKey"] = boost::any(*configKey);
    }
    if (configValue) {
      res["configValue"] = boost::any(*configValue);
    }
    if (requirement) {
      res["requirement"] = boost::any(*requirement);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("configDescription") != m.end() && !m["configDescription"].empty()) {
      configDescription = make_shared<string>(boost::any_cast<string>(m["configDescription"]));
    }
    if (m.find("configCode") != m.end() && !m["configCode"].empty()) {
      configCode = make_shared<string>(boost::any_cast<string>(m["configCode"]));
    }
    if (m.find("parentCode") != m.end() && !m["parentCode"].empty()) {
      parentCode = make_shared<string>(boost::any_cast<string>(m["parentCode"]));
    }
    if (m.find("configKey") != m.end() && !m["configKey"].empty()) {
      configKey = make_shared<string>(boost::any_cast<string>(m["configKey"]));
    }
    if (m.find("configValue") != m.end() && !m["configValue"].empty()) {
      configValue = make_shared<string>(boost::any_cast<string>(m["configValue"]));
    }
    if (m.find("requirement") != m.end() && !m["requirement"].empty()) {
      requirement = make_shared<bool>(boost::any_cast<bool>(m["requirement"]));
    }
  }


  virtual ~DataValue() = default;
};
class AddProblemServiceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> problemId{};
  shared_ptr<vector<long>> serviceGroupIds{};

  AddProblemServiceGroupRequest() {}

  explicit AddProblemServiceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    if (serviceGroupIds) {
      res["serviceGroupIds"] = boost::any(*serviceGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
    if (m.find("serviceGroupIds") != m.end() && !m["serviceGroupIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["serviceGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["serviceGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      serviceGroupIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~AddProblemServiceGroupRequest() = default;
};
class AddProblemServiceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddProblemServiceGroupResponseBody() {}

  explicit AddProblemServiceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~AddProblemServiceGroupResponseBody() = default;
};
class AddProblemServiceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddProblemServiceGroupResponseBody> body{};

  AddProblemServiceGroupResponse() {}

  explicit AddProblemServiceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddProblemServiceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddProblemServiceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~AddProblemServiceGroupResponse() = default;
};
class BillingStatisticsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> appUserCount{};
  shared_ptr<long> appUserCountFree{};
  shared_ptr<long> emailSend{};
  shared_ptr<long> emailSendFree{};
  shared_ptr<long> escalationPlanCount{};
  shared_ptr<long> escalationPlanCountFree{};
  shared_ptr<long> eventReportApi{};
  shared_ptr<long> eventReportApiFree{};
  shared_ptr<long> hasScheduleServiceGroupCount{};
  shared_ptr<long> hasScheduleServiceGroupCountFree{};
  shared_ptr<long> imMsgSend{};
  shared_ptr<long> imMsgSendFree{};
  shared_ptr<long> ruleCount{};
  shared_ptr<long> ruleCountFree{};
  shared_ptr<long> smsSend{};
  shared_ptr<long> smsSendFree{};
  shared_ptr<long> subscriptionNotifyCount{};
  shared_ptr<long> subscriptionNotifyCountFree{};
  shared_ptr<bool> type{};
  shared_ptr<long> voiceSend{};
  shared_ptr<long> voiceSendFree{};

  BillingStatisticsResponseBodyData() {}

  explicit BillingStatisticsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appUserCount) {
      res["appUserCount"] = boost::any(*appUserCount);
    }
    if (appUserCountFree) {
      res["appUserCountFree"] = boost::any(*appUserCountFree);
    }
    if (emailSend) {
      res["emailSend"] = boost::any(*emailSend);
    }
    if (emailSendFree) {
      res["emailSendFree"] = boost::any(*emailSendFree);
    }
    if (escalationPlanCount) {
      res["escalationPlanCount"] = boost::any(*escalationPlanCount);
    }
    if (escalationPlanCountFree) {
      res["escalationPlanCountFree"] = boost::any(*escalationPlanCountFree);
    }
    if (eventReportApi) {
      res["eventReportApi"] = boost::any(*eventReportApi);
    }
    if (eventReportApiFree) {
      res["eventReportApiFree"] = boost::any(*eventReportApiFree);
    }
    if (hasScheduleServiceGroupCount) {
      res["hasScheduleServiceGroupCount"] = boost::any(*hasScheduleServiceGroupCount);
    }
    if (hasScheduleServiceGroupCountFree) {
      res["hasScheduleServiceGroupCountFree"] = boost::any(*hasScheduleServiceGroupCountFree);
    }
    if (imMsgSend) {
      res["imMsgSend"] = boost::any(*imMsgSend);
    }
    if (imMsgSendFree) {
      res["imMsgSendFree"] = boost::any(*imMsgSendFree);
    }
    if (ruleCount) {
      res["ruleCount"] = boost::any(*ruleCount);
    }
    if (ruleCountFree) {
      res["ruleCountFree"] = boost::any(*ruleCountFree);
    }
    if (smsSend) {
      res["smsSend"] = boost::any(*smsSend);
    }
    if (smsSendFree) {
      res["smsSendFree"] = boost::any(*smsSendFree);
    }
    if (subscriptionNotifyCount) {
      res["subscriptionNotifyCount"] = boost::any(*subscriptionNotifyCount);
    }
    if (subscriptionNotifyCountFree) {
      res["subscriptionNotifyCountFree"] = boost::any(*subscriptionNotifyCountFree);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (voiceSend) {
      res["voiceSend"] = boost::any(*voiceSend);
    }
    if (voiceSendFree) {
      res["voiceSendFree"] = boost::any(*voiceSendFree);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("appUserCount") != m.end() && !m["appUserCount"].empty()) {
      appUserCount = make_shared<long>(boost::any_cast<long>(m["appUserCount"]));
    }
    if (m.find("appUserCountFree") != m.end() && !m["appUserCountFree"].empty()) {
      appUserCountFree = make_shared<long>(boost::any_cast<long>(m["appUserCountFree"]));
    }
    if (m.find("emailSend") != m.end() && !m["emailSend"].empty()) {
      emailSend = make_shared<long>(boost::any_cast<long>(m["emailSend"]));
    }
    if (m.find("emailSendFree") != m.end() && !m["emailSendFree"].empty()) {
      emailSendFree = make_shared<long>(boost::any_cast<long>(m["emailSendFree"]));
    }
    if (m.find("escalationPlanCount") != m.end() && !m["escalationPlanCount"].empty()) {
      escalationPlanCount = make_shared<long>(boost::any_cast<long>(m["escalationPlanCount"]));
    }
    if (m.find("escalationPlanCountFree") != m.end() && !m["escalationPlanCountFree"].empty()) {
      escalationPlanCountFree = make_shared<long>(boost::any_cast<long>(m["escalationPlanCountFree"]));
    }
    if (m.find("eventReportApi") != m.end() && !m["eventReportApi"].empty()) {
      eventReportApi = make_shared<long>(boost::any_cast<long>(m["eventReportApi"]));
    }
    if (m.find("eventReportApiFree") != m.end() && !m["eventReportApiFree"].empty()) {
      eventReportApiFree = make_shared<long>(boost::any_cast<long>(m["eventReportApiFree"]));
    }
    if (m.find("hasScheduleServiceGroupCount") != m.end() && !m["hasScheduleServiceGroupCount"].empty()) {
      hasScheduleServiceGroupCount = make_shared<long>(boost::any_cast<long>(m["hasScheduleServiceGroupCount"]));
    }
    if (m.find("hasScheduleServiceGroupCountFree") != m.end() && !m["hasScheduleServiceGroupCountFree"].empty()) {
      hasScheduleServiceGroupCountFree = make_shared<long>(boost::any_cast<long>(m["hasScheduleServiceGroupCountFree"]));
    }
    if (m.find("imMsgSend") != m.end() && !m["imMsgSend"].empty()) {
      imMsgSend = make_shared<long>(boost::any_cast<long>(m["imMsgSend"]));
    }
    if (m.find("imMsgSendFree") != m.end() && !m["imMsgSendFree"].empty()) {
      imMsgSendFree = make_shared<long>(boost::any_cast<long>(m["imMsgSendFree"]));
    }
    if (m.find("ruleCount") != m.end() && !m["ruleCount"].empty()) {
      ruleCount = make_shared<long>(boost::any_cast<long>(m["ruleCount"]));
    }
    if (m.find("ruleCountFree") != m.end() && !m["ruleCountFree"].empty()) {
      ruleCountFree = make_shared<long>(boost::any_cast<long>(m["ruleCountFree"]));
    }
    if (m.find("smsSend") != m.end() && !m["smsSend"].empty()) {
      smsSend = make_shared<long>(boost::any_cast<long>(m["smsSend"]));
    }
    if (m.find("smsSendFree") != m.end() && !m["smsSendFree"].empty()) {
      smsSendFree = make_shared<long>(boost::any_cast<long>(m["smsSendFree"]));
    }
    if (m.find("subscriptionNotifyCount") != m.end() && !m["subscriptionNotifyCount"].empty()) {
      subscriptionNotifyCount = make_shared<long>(boost::any_cast<long>(m["subscriptionNotifyCount"]));
    }
    if (m.find("subscriptionNotifyCountFree") != m.end() && !m["subscriptionNotifyCountFree"].empty()) {
      subscriptionNotifyCountFree = make_shared<long>(boost::any_cast<long>(m["subscriptionNotifyCountFree"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<bool>(boost::any_cast<bool>(m["type"]));
    }
    if (m.find("voiceSend") != m.end() && !m["voiceSend"].empty()) {
      voiceSend = make_shared<long>(boost::any_cast<long>(m["voiceSend"]));
    }
    if (m.find("voiceSendFree") != m.end() && !m["voiceSendFree"].empty()) {
      voiceSendFree = make_shared<long>(boost::any_cast<long>(m["voiceSendFree"]));
    }
  }


  virtual ~BillingStatisticsResponseBodyData() = default;
};
class BillingStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<BillingStatisticsResponseBodyData> data{};

  BillingStatisticsResponseBody() {}

  explicit BillingStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        BillingStatisticsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<BillingStatisticsResponseBodyData>(model1);
      }
    }
  }


  virtual ~BillingStatisticsResponseBody() = default;
};
class BillingStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BillingStatisticsResponseBody> body{};

  BillingStatisticsResponse() {}

  explicit BillingStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BillingStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BillingStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~BillingStatisticsResponse() = default;
};
class CancelProblemRequest : public Darabonba::Model {
public:
  shared_ptr<long> cancelReason{};
  shared_ptr<string> cancelReasonDescription{};
  shared_ptr<string> clientToken{};
  shared_ptr<long> problemId{};
  shared_ptr<long> problemNotifyType{};

  CancelProblemRequest() {}

  explicit CancelProblemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cancelReason) {
      res["cancelReason"] = boost::any(*cancelReason);
    }
    if (cancelReasonDescription) {
      res["cancelReasonDescription"] = boost::any(*cancelReasonDescription);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    if (problemNotifyType) {
      res["problemNotifyType"] = boost::any(*problemNotifyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cancelReason") != m.end() && !m["cancelReason"].empty()) {
      cancelReason = make_shared<long>(boost::any_cast<long>(m["cancelReason"]));
    }
    if (m.find("cancelReasonDescription") != m.end() && !m["cancelReasonDescription"].empty()) {
      cancelReasonDescription = make_shared<string>(boost::any_cast<string>(m["cancelReasonDescription"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
    if (m.find("problemNotifyType") != m.end() && !m["problemNotifyType"].empty()) {
      problemNotifyType = make_shared<long>(boost::any_cast<long>(m["problemNotifyType"]));
    }
  }


  virtual ~CancelProblemRequest() = default;
};
class CancelProblemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CancelProblemResponseBody() {}

  explicit CancelProblemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CancelProblemResponseBody() = default;
};
class CancelProblemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelProblemResponseBody> body{};

  CancelProblemResponse() {}

  explicit CancelProblemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelProblemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelProblemResponseBody>(model1);
      }
    }
  }


  virtual ~CancelProblemResponse() = default;
};
class CheckWebhookRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> webhook{};
  shared_ptr<string> webhookType{};

  CheckWebhookRequest() {}

  explicit CheckWebhookRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (webhook) {
      res["webhook"] = boost::any(*webhook);
    }
    if (webhookType) {
      res["webhookType"] = boost::any(*webhookType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("webhook") != m.end() && !m["webhook"].empty()) {
      webhook = make_shared<string>(boost::any_cast<string>(m["webhook"]));
    }
    if (m.find("webhookType") != m.end() && !m["webhookType"].empty()) {
      webhookType = make_shared<string>(boost::any_cast<string>(m["webhookType"]));
    }
  }


  virtual ~CheckWebhookRequest() = default;
};
class CheckWebhookResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CheckWebhookResponseBody() {}

  explicit CheckWebhookResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CheckWebhookResponseBody() = default;
};
class CheckWebhookResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CheckWebhookResponseBody> body{};

  CheckWebhookResponse() {}

  explicit CheckWebhookResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CheckWebhookResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CheckWebhookResponseBody>(model1);
      }
    }
  }


  virtual ~CheckWebhookResponse() = default;
};
class ConfirmIntegrationConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> integrationConfigId{};

  ConfirmIntegrationConfigRequest() {}

  explicit ConfirmIntegrationConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (integrationConfigId) {
      res["integrationConfigId"] = boost::any(*integrationConfigId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("integrationConfigId") != m.end() && !m["integrationConfigId"].empty()) {
      integrationConfigId = make_shared<long>(boost::any_cast<long>(m["integrationConfigId"]));
    }
  }


  virtual ~ConfirmIntegrationConfigRequest() = default;
};
class ConfirmIntegrationConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ConfirmIntegrationConfigResponseBody() {}

  explicit ConfirmIntegrationConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ConfirmIntegrationConfigResponseBody() = default;
};
class ConfirmIntegrationConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ConfirmIntegrationConfigResponseBody> body{};

  ConfirmIntegrationConfigResponse() {}

  explicit ConfirmIntegrationConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ConfirmIntegrationConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ConfirmIntegrationConfigResponseBody>(model1);
      }
    }
  }


  virtual ~ConfirmIntegrationConfigResponse() = default;
};
class CreateEscalationPlanRequestEscalationPlanRulesEscalationPlanConditions : public Darabonba::Model {
public:
  shared_ptr<string> effection{};
  shared_ptr<string> level{};

  CreateEscalationPlanRequestEscalationPlanRulesEscalationPlanConditions() {}

  explicit CreateEscalationPlanRequestEscalationPlanRulesEscalationPlanConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effection) {
      res["effection"] = boost::any(*effection);
    }
    if (level) {
      res["level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("effection") != m.end() && !m["effection"].empty()) {
      effection = make_shared<string>(boost::any_cast<string>(m["effection"]));
    }
    if (m.find("level") != m.end() && !m["level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["level"]));
    }
  }


  virtual ~CreateEscalationPlanRequestEscalationPlanRulesEscalationPlanConditions() = default;
};
class CreateEscalationPlanRequestEscalationPlanRulesEscalationPlanStrategies : public Darabonba::Model {
public:
  shared_ptr<bool> enableWebhook{};
  shared_ptr<string> escalationPlanType{};
  shared_ptr<vector<string>> noticeChannels{};
  shared_ptr<vector<long>> noticeObjects{};
  shared_ptr<string> noticeTime{};
  shared_ptr<vector<long>> serviceGroupIds{};

  CreateEscalationPlanRequestEscalationPlanRulesEscalationPlanStrategies() {}

  explicit CreateEscalationPlanRequestEscalationPlanRulesEscalationPlanStrategies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableWebhook) {
      res["enableWebhook"] = boost::any(*enableWebhook);
    }
    if (escalationPlanType) {
      res["escalationPlanType"] = boost::any(*escalationPlanType);
    }
    if (noticeChannels) {
      res["noticeChannels"] = boost::any(*noticeChannels);
    }
    if (noticeObjects) {
      res["noticeObjects"] = boost::any(*noticeObjects);
    }
    if (noticeTime) {
      res["noticeTime"] = boost::any(*noticeTime);
    }
    if (serviceGroupIds) {
      res["serviceGroupIds"] = boost::any(*serviceGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enableWebhook") != m.end() && !m["enableWebhook"].empty()) {
      enableWebhook = make_shared<bool>(boost::any_cast<bool>(m["enableWebhook"]));
    }
    if (m.find("escalationPlanType") != m.end() && !m["escalationPlanType"].empty()) {
      escalationPlanType = make_shared<string>(boost::any_cast<string>(m["escalationPlanType"]));
    }
    if (m.find("noticeChannels") != m.end() && !m["noticeChannels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["noticeChannels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["noticeChannels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      noticeChannels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("noticeObjects") != m.end() && !m["noticeObjects"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["noticeObjects"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["noticeObjects"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      noticeObjects = make_shared<vector<long>>(toVec1);
    }
    if (m.find("noticeTime") != m.end() && !m["noticeTime"].empty()) {
      noticeTime = make_shared<string>(boost::any_cast<string>(m["noticeTime"]));
    }
    if (m.find("serviceGroupIds") != m.end() && !m["serviceGroupIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["serviceGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["serviceGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      serviceGroupIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~CreateEscalationPlanRequestEscalationPlanRulesEscalationPlanStrategies() = default;
};
class CreateEscalationPlanRequestEscalationPlanRules : public Darabonba::Model {
public:
  shared_ptr<vector<CreateEscalationPlanRequestEscalationPlanRulesEscalationPlanConditions>> escalationPlanConditions{};
  shared_ptr<vector<CreateEscalationPlanRequestEscalationPlanRulesEscalationPlanStrategies>> escalationPlanStrategies{};
  shared_ptr<string> escalationPlanType{};

  CreateEscalationPlanRequestEscalationPlanRules() {}

  explicit CreateEscalationPlanRequestEscalationPlanRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalationPlanConditions) {
      vector<boost::any> temp1;
      for(auto item1:*escalationPlanConditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["escalationPlanConditions"] = boost::any(temp1);
    }
    if (escalationPlanStrategies) {
      vector<boost::any> temp1;
      for(auto item1:*escalationPlanStrategies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["escalationPlanStrategies"] = boost::any(temp1);
    }
    if (escalationPlanType) {
      res["escalationPlanType"] = boost::any(*escalationPlanType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("escalationPlanConditions") != m.end() && !m["escalationPlanConditions"].empty()) {
      if (typeid(vector<boost::any>) == m["escalationPlanConditions"].type()) {
        vector<CreateEscalationPlanRequestEscalationPlanRulesEscalationPlanConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["escalationPlanConditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEscalationPlanRequestEscalationPlanRulesEscalationPlanConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        escalationPlanConditions = make_shared<vector<CreateEscalationPlanRequestEscalationPlanRulesEscalationPlanConditions>>(expect1);
      }
    }
    if (m.find("escalationPlanStrategies") != m.end() && !m["escalationPlanStrategies"].empty()) {
      if (typeid(vector<boost::any>) == m["escalationPlanStrategies"].type()) {
        vector<CreateEscalationPlanRequestEscalationPlanRulesEscalationPlanStrategies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["escalationPlanStrategies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEscalationPlanRequestEscalationPlanRulesEscalationPlanStrategies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        escalationPlanStrategies = make_shared<vector<CreateEscalationPlanRequestEscalationPlanRulesEscalationPlanStrategies>>(expect1);
      }
    }
    if (m.find("escalationPlanType") != m.end() && !m["escalationPlanType"].empty()) {
      escalationPlanType = make_shared<string>(boost::any_cast<string>(m["escalationPlanType"]));
    }
  }


  virtual ~CreateEscalationPlanRequestEscalationPlanRules() = default;
};
class CreateEscalationPlanRequestEscalationPlanScopeObjects : public Darabonba::Model {
public:
  shared_ptr<string> scope{};
  shared_ptr<long> scopeObjectId{};

  CreateEscalationPlanRequestEscalationPlanScopeObjects() {}

  explicit CreateEscalationPlanRequestEscalationPlanScopeObjects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (scopeObjectId) {
      res["scopeObjectId"] = boost::any(*scopeObjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
    if (m.find("scopeObjectId") != m.end() && !m["scopeObjectId"].empty()) {
      scopeObjectId = make_shared<long>(boost::any_cast<long>(m["scopeObjectId"]));
    }
  }


  virtual ~CreateEscalationPlanRequestEscalationPlanScopeObjects() = default;
};
class CreateEscalationPlanRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> escalationPlanDescription{};
  shared_ptr<string> escalationPlanName{};
  shared_ptr<vector<CreateEscalationPlanRequestEscalationPlanRules>> escalationPlanRules{};
  shared_ptr<vector<CreateEscalationPlanRequestEscalationPlanScopeObjects>> escalationPlanScopeObjects{};

  CreateEscalationPlanRequest() {}

  explicit CreateEscalationPlanRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (escalationPlanDescription) {
      res["escalationPlanDescription"] = boost::any(*escalationPlanDescription);
    }
    if (escalationPlanName) {
      res["escalationPlanName"] = boost::any(*escalationPlanName);
    }
    if (escalationPlanRules) {
      vector<boost::any> temp1;
      for(auto item1:*escalationPlanRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["escalationPlanRules"] = boost::any(temp1);
    }
    if (escalationPlanScopeObjects) {
      vector<boost::any> temp1;
      for(auto item1:*escalationPlanScopeObjects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["escalationPlanScopeObjects"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("escalationPlanDescription") != m.end() && !m["escalationPlanDescription"].empty()) {
      escalationPlanDescription = make_shared<string>(boost::any_cast<string>(m["escalationPlanDescription"]));
    }
    if (m.find("escalationPlanName") != m.end() && !m["escalationPlanName"].empty()) {
      escalationPlanName = make_shared<string>(boost::any_cast<string>(m["escalationPlanName"]));
    }
    if (m.find("escalationPlanRules") != m.end() && !m["escalationPlanRules"].empty()) {
      if (typeid(vector<boost::any>) == m["escalationPlanRules"].type()) {
        vector<CreateEscalationPlanRequestEscalationPlanRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["escalationPlanRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEscalationPlanRequestEscalationPlanRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        escalationPlanRules = make_shared<vector<CreateEscalationPlanRequestEscalationPlanRules>>(expect1);
      }
    }
    if (m.find("escalationPlanScopeObjects") != m.end() && !m["escalationPlanScopeObjects"].empty()) {
      if (typeid(vector<boost::any>) == m["escalationPlanScopeObjects"].type()) {
        vector<CreateEscalationPlanRequestEscalationPlanScopeObjects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["escalationPlanScopeObjects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateEscalationPlanRequestEscalationPlanScopeObjects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        escalationPlanScopeObjects = make_shared<vector<CreateEscalationPlanRequestEscalationPlanScopeObjects>>(expect1);
      }
    }
  }


  virtual ~CreateEscalationPlanRequest() = default;
};
class CreateEscalationPlanResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> escalationPlanId{};

  CreateEscalationPlanResponseBodyData() {}

  explicit CreateEscalationPlanResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalationPlanId) {
      res["escalationPlanId"] = boost::any(*escalationPlanId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("escalationPlanId") != m.end() && !m["escalationPlanId"].empty()) {
      escalationPlanId = make_shared<long>(boost::any_cast<long>(m["escalationPlanId"]));
    }
  }


  virtual ~CreateEscalationPlanResponseBodyData() = default;
};
class CreateEscalationPlanResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateEscalationPlanResponseBodyData> data{};
  shared_ptr<string> requestId{};

  CreateEscalationPlanResponseBody() {}

  explicit CreateEscalationPlanResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        CreateEscalationPlanResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<CreateEscalationPlanResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CreateEscalationPlanResponseBody() = default;
};
class CreateEscalationPlanResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateEscalationPlanResponseBody> body{};

  CreateEscalationPlanResponse() {}

  explicit CreateEscalationPlanResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEscalationPlanResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEscalationPlanResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEscalationPlanResponse() = default;
};
class CreateIncidentRequest : public Darabonba::Model {
public:
  shared_ptr<long> assignUserId{};
  shared_ptr<vector<string>> channels{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> effect{};
  shared_ptr<string> incidentDescription{};
  shared_ptr<string> incidentLevel{};
  shared_ptr<string> incidentTitle{};
  shared_ptr<long> relatedServiceId{};
  shared_ptr<long> serviceGroupId{};

  CreateIncidentRequest() {}

  explicit CreateIncidentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignUserId) {
      res["assignUserId"] = boost::any(*assignUserId);
    }
    if (channels) {
      res["channels"] = boost::any(*channels);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (effect) {
      res["effect"] = boost::any(*effect);
    }
    if (incidentDescription) {
      res["incidentDescription"] = boost::any(*incidentDescription);
    }
    if (incidentLevel) {
      res["incidentLevel"] = boost::any(*incidentLevel);
    }
    if (incidentTitle) {
      res["incidentTitle"] = boost::any(*incidentTitle);
    }
    if (relatedServiceId) {
      res["relatedServiceId"] = boost::any(*relatedServiceId);
    }
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignUserId") != m.end() && !m["assignUserId"].empty()) {
      assignUserId = make_shared<long>(boost::any_cast<long>(m["assignUserId"]));
    }
    if (m.find("channels") != m.end() && !m["channels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["channels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["channels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      channels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("effect") != m.end() && !m["effect"].empty()) {
      effect = make_shared<string>(boost::any_cast<string>(m["effect"]));
    }
    if (m.find("incidentDescription") != m.end() && !m["incidentDescription"].empty()) {
      incidentDescription = make_shared<string>(boost::any_cast<string>(m["incidentDescription"]));
    }
    if (m.find("incidentLevel") != m.end() && !m["incidentLevel"].empty()) {
      incidentLevel = make_shared<string>(boost::any_cast<string>(m["incidentLevel"]));
    }
    if (m.find("incidentTitle") != m.end() && !m["incidentTitle"].empty()) {
      incidentTitle = make_shared<string>(boost::any_cast<string>(m["incidentTitle"]));
    }
    if (m.find("relatedServiceId") != m.end() && !m["relatedServiceId"].empty()) {
      relatedServiceId = make_shared<long>(boost::any_cast<long>(m["relatedServiceId"]));
    }
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
  }


  virtual ~CreateIncidentRequest() = default;
};
class CreateIncidentResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> incidentId{};

  CreateIncidentResponseBodyData() {}

  explicit CreateIncidentResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (incidentId) {
      res["incidentId"] = boost::any(*incidentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("incidentId") != m.end() && !m["incidentId"].empty()) {
      incidentId = make_shared<long>(boost::any_cast<long>(m["incidentId"]));
    }
  }


  virtual ~CreateIncidentResponseBodyData() = default;
};
class CreateIncidentResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateIncidentResponseBodyData> data{};
  shared_ptr<string> requestId{};

  CreateIncidentResponseBody() {}

  explicit CreateIncidentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        CreateIncidentResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<CreateIncidentResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CreateIncidentResponseBody() = default;
};
class CreateIncidentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateIncidentResponseBody> body{};

  CreateIncidentResponse() {}

  explicit CreateIncidentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateIncidentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateIncidentResponseBody>(model1);
      }
    }
  }


  virtual ~CreateIncidentResponse() = default;
};
class CreateIncidentSubtotalRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<long> incidentId{};

  CreateIncidentSubtotalRequest() {}

  explicit CreateIncidentSubtotalRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (incidentId) {
      res["incidentId"] = boost::any(*incidentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("incidentId") != m.end() && !m["incidentId"].empty()) {
      incidentId = make_shared<long>(boost::any_cast<long>(m["incidentId"]));
    }
  }


  virtual ~CreateIncidentSubtotalRequest() = default;
};
class CreateIncidentSubtotalResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> subtotalId{};

  CreateIncidentSubtotalResponseBodyData() {}

  explicit CreateIncidentSubtotalResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtotalId) {
      res["subtotalId"] = boost::any(*subtotalId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("subtotalId") != m.end() && !m["subtotalId"].empty()) {
      subtotalId = make_shared<long>(boost::any_cast<long>(m["subtotalId"]));
    }
  }


  virtual ~CreateIncidentSubtotalResponseBodyData() = default;
};
class CreateIncidentSubtotalResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateIncidentSubtotalResponseBodyData> data{};
  shared_ptr<string> requestId{};

  CreateIncidentSubtotalResponseBody() {}

  explicit CreateIncidentSubtotalResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        CreateIncidentSubtotalResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<CreateIncidentSubtotalResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CreateIncidentSubtotalResponseBody() = default;
};
class CreateIncidentSubtotalResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateIncidentSubtotalResponseBody> body{};

  CreateIncidentSubtotalResponse() {}

  explicit CreateIncidentSubtotalResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateIncidentSubtotalResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateIncidentSubtotalResponseBody>(model1);
      }
    }
  }


  virtual ~CreateIncidentSubtotalResponse() = default;
};
class CreateIntegrationConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> monitorSourceId{};

  CreateIntegrationConfigRequest() {}

  explicit CreateIntegrationConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (monitorSourceId) {
      res["monitorSourceId"] = boost::any(*monitorSourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("monitorSourceId") != m.end() && !m["monitorSourceId"].empty()) {
      monitorSourceId = make_shared<long>(boost::any_cast<long>(m["monitorSourceId"]));
    }
  }


  virtual ~CreateIntegrationConfigRequest() = default;
};
class CreateIntegrationConfigResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> integrationConfigId{};

  CreateIntegrationConfigResponseBodyData() {}

  explicit CreateIntegrationConfigResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integrationConfigId) {
      res["integrationConfigId"] = boost::any(*integrationConfigId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("integrationConfigId") != m.end() && !m["integrationConfigId"].empty()) {
      integrationConfigId = make_shared<long>(boost::any_cast<long>(m["integrationConfigId"]));
    }
  }


  virtual ~CreateIntegrationConfigResponseBodyData() = default;
};
class CreateIntegrationConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateIntegrationConfigResponseBodyData> data{};
  shared_ptr<string> requestId{};

  CreateIntegrationConfigResponseBody() {}

  explicit CreateIntegrationConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        CreateIntegrationConfigResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<CreateIntegrationConfigResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CreateIntegrationConfigResponseBody() = default;
};
class CreateIntegrationConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateIntegrationConfigResponseBody> body{};

  CreateIntegrationConfigResponse() {}

  explicit CreateIntegrationConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateIntegrationConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateIntegrationConfigResponseBody>(model1);
      }
    }
  }


  virtual ~CreateIntegrationConfigResponse() = default;
};
class CreateProblemRequest : public Darabonba::Model {
public:
  shared_ptr<vector<long>> affectServiceIds{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> discoverTime{};
  shared_ptr<long> incidentId{};
  shared_ptr<long> mainHandlerId{};
  shared_ptr<string> preliminaryReason{};
  shared_ptr<string> problemLevel{};
  shared_ptr<string> problemName{};
  shared_ptr<string> problemNotifyType{};
  shared_ptr<string> problemStatus{};
  shared_ptr<string> progressSummary{};
  shared_ptr<long> progressSummaryRichTextId{};
  shared_ptr<string> recoveryTime{};
  shared_ptr<long> relatedServiceId{};
  shared_ptr<vector<long>> serviceGroupIds{};

  CreateProblemRequest() {}

  explicit CreateProblemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (affectServiceIds) {
      res["affectServiceIds"] = boost::any(*affectServiceIds);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (discoverTime) {
      res["discoverTime"] = boost::any(*discoverTime);
    }
    if (incidentId) {
      res["incidentId"] = boost::any(*incidentId);
    }
    if (mainHandlerId) {
      res["mainHandlerId"] = boost::any(*mainHandlerId);
    }
    if (preliminaryReason) {
      res["preliminaryReason"] = boost::any(*preliminaryReason);
    }
    if (problemLevel) {
      res["problemLevel"] = boost::any(*problemLevel);
    }
    if (problemName) {
      res["problemName"] = boost::any(*problemName);
    }
    if (problemNotifyType) {
      res["problemNotifyType"] = boost::any(*problemNotifyType);
    }
    if (problemStatus) {
      res["problemStatus"] = boost::any(*problemStatus);
    }
    if (progressSummary) {
      res["progressSummary"] = boost::any(*progressSummary);
    }
    if (progressSummaryRichTextId) {
      res["progressSummaryRichTextId"] = boost::any(*progressSummaryRichTextId);
    }
    if (recoveryTime) {
      res["recoveryTime"] = boost::any(*recoveryTime);
    }
    if (relatedServiceId) {
      res["relatedServiceId"] = boost::any(*relatedServiceId);
    }
    if (serviceGroupIds) {
      res["serviceGroupIds"] = boost::any(*serviceGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("affectServiceIds") != m.end() && !m["affectServiceIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["affectServiceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["affectServiceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      affectServiceIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("discoverTime") != m.end() && !m["discoverTime"].empty()) {
      discoverTime = make_shared<string>(boost::any_cast<string>(m["discoverTime"]));
    }
    if (m.find("incidentId") != m.end() && !m["incidentId"].empty()) {
      incidentId = make_shared<long>(boost::any_cast<long>(m["incidentId"]));
    }
    if (m.find("mainHandlerId") != m.end() && !m["mainHandlerId"].empty()) {
      mainHandlerId = make_shared<long>(boost::any_cast<long>(m["mainHandlerId"]));
    }
    if (m.find("preliminaryReason") != m.end() && !m["preliminaryReason"].empty()) {
      preliminaryReason = make_shared<string>(boost::any_cast<string>(m["preliminaryReason"]));
    }
    if (m.find("problemLevel") != m.end() && !m["problemLevel"].empty()) {
      problemLevel = make_shared<string>(boost::any_cast<string>(m["problemLevel"]));
    }
    if (m.find("problemName") != m.end() && !m["problemName"].empty()) {
      problemName = make_shared<string>(boost::any_cast<string>(m["problemName"]));
    }
    if (m.find("problemNotifyType") != m.end() && !m["problemNotifyType"].empty()) {
      problemNotifyType = make_shared<string>(boost::any_cast<string>(m["problemNotifyType"]));
    }
    if (m.find("problemStatus") != m.end() && !m["problemStatus"].empty()) {
      problemStatus = make_shared<string>(boost::any_cast<string>(m["problemStatus"]));
    }
    if (m.find("progressSummary") != m.end() && !m["progressSummary"].empty()) {
      progressSummary = make_shared<string>(boost::any_cast<string>(m["progressSummary"]));
    }
    if (m.find("progressSummaryRichTextId") != m.end() && !m["progressSummaryRichTextId"].empty()) {
      progressSummaryRichTextId = make_shared<long>(boost::any_cast<long>(m["progressSummaryRichTextId"]));
    }
    if (m.find("recoveryTime") != m.end() && !m["recoveryTime"].empty()) {
      recoveryTime = make_shared<string>(boost::any_cast<string>(m["recoveryTime"]));
    }
    if (m.find("relatedServiceId") != m.end() && !m["relatedServiceId"].empty()) {
      relatedServiceId = make_shared<long>(boost::any_cast<long>(m["relatedServiceId"]));
    }
    if (m.find("serviceGroupIds") != m.end() && !m["serviceGroupIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["serviceGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["serviceGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      serviceGroupIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~CreateProblemRequest() = default;
};
class CreateProblemResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> problemId{};

  CreateProblemResponseBodyData() {}

  explicit CreateProblemResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
  }


  virtual ~CreateProblemResponseBodyData() = default;
};
class CreateProblemResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateProblemResponseBodyData> data{};
  shared_ptr<string> requestId{};

  CreateProblemResponseBody() {}

  explicit CreateProblemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        CreateProblemResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<CreateProblemResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CreateProblemResponseBody() = default;
};
class CreateProblemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateProblemResponseBody> body{};

  CreateProblemResponse() {}

  explicit CreateProblemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProblemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProblemResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProblemResponse() = default;
};
class CreateProblemEffectionServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<string> level{};
  shared_ptr<vector<string>> pictureUrl{};
  shared_ptr<long> problemId{};
  shared_ptr<long> serviceId{};
  shared_ptr<string> status{};

  CreateProblemEffectionServiceRequest() {}

  explicit CreateProblemEffectionServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (level) {
      res["level"] = boost::any(*level);
    }
    if (pictureUrl) {
      res["pictureUrl"] = boost::any(*pictureUrl);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    if (serviceId) {
      res["serviceId"] = boost::any(*serviceId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("level") != m.end() && !m["level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["level"]));
    }
    if (m.find("pictureUrl") != m.end() && !m["pictureUrl"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["pictureUrl"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["pictureUrl"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      pictureUrl = make_shared<vector<string>>(toVec1);
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
    if (m.find("serviceId") != m.end() && !m["serviceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["serviceId"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~CreateProblemEffectionServiceRequest() = default;
};
class CreateProblemEffectionServiceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> effectionServiceId{};

  CreateProblemEffectionServiceResponseBodyData() {}

  explicit CreateProblemEffectionServiceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effectionServiceId) {
      res["effectionServiceId"] = boost::any(*effectionServiceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("effectionServiceId") != m.end() && !m["effectionServiceId"].empty()) {
      effectionServiceId = make_shared<long>(boost::any_cast<long>(m["effectionServiceId"]));
    }
  }


  virtual ~CreateProblemEffectionServiceResponseBodyData() = default;
};
class CreateProblemEffectionServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateProblemEffectionServiceResponseBodyData> data{};
  shared_ptr<string> requestId{};

  CreateProblemEffectionServiceResponseBody() {}

  explicit CreateProblemEffectionServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        CreateProblemEffectionServiceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<CreateProblemEffectionServiceResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CreateProblemEffectionServiceResponseBody() = default;
};
class CreateProblemEffectionServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateProblemEffectionServiceResponseBody> body{};

  CreateProblemEffectionServiceResponse() {}

  explicit CreateProblemEffectionServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProblemEffectionServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProblemEffectionServiceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProblemEffectionServiceResponse() = default;
};
class CreateProblemMeasureRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkStandard{};
  shared_ptr<long> checkUserId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> content{};
  shared_ptr<long> directorId{};
  shared_ptr<string> planFinishTime{};
  shared_ptr<long> problemId{};
  shared_ptr<long> stalkerId{};
  shared_ptr<string> status{};
  shared_ptr<long> type{};

  CreateProblemMeasureRequest() {}

  explicit CreateProblemMeasureRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkStandard) {
      res["checkStandard"] = boost::any(*checkStandard);
    }
    if (checkUserId) {
      res["checkUserId"] = boost::any(*checkUserId);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (directorId) {
      res["directorId"] = boost::any(*directorId);
    }
    if (planFinishTime) {
      res["planFinishTime"] = boost::any(*planFinishTime);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    if (stalkerId) {
      res["stalkerId"] = boost::any(*stalkerId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("checkStandard") != m.end() && !m["checkStandard"].empty()) {
      checkStandard = make_shared<string>(boost::any_cast<string>(m["checkStandard"]));
    }
    if (m.find("checkUserId") != m.end() && !m["checkUserId"].empty()) {
      checkUserId = make_shared<long>(boost::any_cast<long>(m["checkUserId"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("directorId") != m.end() && !m["directorId"].empty()) {
      directorId = make_shared<long>(boost::any_cast<long>(m["directorId"]));
    }
    if (m.find("planFinishTime") != m.end() && !m["planFinishTime"].empty()) {
      planFinishTime = make_shared<string>(boost::any_cast<string>(m["planFinishTime"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
    if (m.find("stalkerId") != m.end() && !m["stalkerId"].empty()) {
      stalkerId = make_shared<long>(boost::any_cast<long>(m["stalkerId"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~CreateProblemMeasureRequest() = default;
};
class CreateProblemMeasureResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> measureId{};

  CreateProblemMeasureResponseBodyData() {}

  explicit CreateProblemMeasureResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (measureId) {
      res["measureId"] = boost::any(*measureId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("measureId") != m.end() && !m["measureId"].empty()) {
      measureId = make_shared<long>(boost::any_cast<long>(m["measureId"]));
    }
  }


  virtual ~CreateProblemMeasureResponseBodyData() = default;
};
class CreateProblemMeasureResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateProblemMeasureResponseBodyData> data{};
  shared_ptr<string> requestId{};

  CreateProblemMeasureResponseBody() {}

  explicit CreateProblemMeasureResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        CreateProblemMeasureResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<CreateProblemMeasureResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CreateProblemMeasureResponseBody() = default;
};
class CreateProblemMeasureResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateProblemMeasureResponseBody> body{};

  CreateProblemMeasureResponse() {}

  explicit CreateProblemMeasureResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProblemMeasureResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProblemMeasureResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProblemMeasureResponse() = default;
};
class CreateProblemSubtotalRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<long> problemId{};

  CreateProblemSubtotalRequest() {}

  explicit CreateProblemSubtotalRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
  }


  virtual ~CreateProblemSubtotalRequest() = default;
};
class CreateProblemSubtotalResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> subtotalId{};

  CreateProblemSubtotalResponseBodyData() {}

  explicit CreateProblemSubtotalResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subtotalId) {
      res["subtotalId"] = boost::any(*subtotalId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("subtotalId") != m.end() && !m["subtotalId"].empty()) {
      subtotalId = make_shared<long>(boost::any_cast<long>(m["subtotalId"]));
    }
  }


  virtual ~CreateProblemSubtotalResponseBodyData() = default;
};
class CreateProblemSubtotalResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateProblemSubtotalResponseBodyData> data{};
  shared_ptr<string> requestId{};

  CreateProblemSubtotalResponseBody() {}

  explicit CreateProblemSubtotalResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        CreateProblemSubtotalResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<CreateProblemSubtotalResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CreateProblemSubtotalResponseBody() = default;
};
class CreateProblemSubtotalResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateProblemSubtotalResponseBody> body{};

  CreateProblemSubtotalResponse() {}

  explicit CreateProblemSubtotalResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProblemSubtotalResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProblemSubtotalResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProblemSubtotalResponse() = default;
};
class CreateProblemTimelineRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> content{};
  shared_ptr<string> keyNode{};
  shared_ptr<long> problemId{};
  shared_ptr<string> time{};

  CreateProblemTimelineRequest() {}

  explicit CreateProblemTimelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (keyNode) {
      res["keyNode"] = boost::any(*keyNode);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    if (time) {
      res["time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("keyNode") != m.end() && !m["keyNode"].empty()) {
      keyNode = make_shared<string>(boost::any_cast<string>(m["keyNode"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
    if (m.find("time") != m.end() && !m["time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["time"]));
    }
  }


  virtual ~CreateProblemTimelineRequest() = default;
};
class CreateProblemTimelineResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> problemTimelineId{};

  CreateProblemTimelineResponseBodyData() {}

  explicit CreateProblemTimelineResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (problemTimelineId) {
      res["problemTimelineId"] = boost::any(*problemTimelineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("problemTimelineId") != m.end() && !m["problemTimelineId"].empty()) {
      problemTimelineId = make_shared<long>(boost::any_cast<long>(m["problemTimelineId"]));
    }
  }


  virtual ~CreateProblemTimelineResponseBodyData() = default;
};
class CreateProblemTimelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateProblemTimelineResponseBodyData> data{};
  shared_ptr<string> requestId{};

  CreateProblemTimelineResponseBody() {}

  explicit CreateProblemTimelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        CreateProblemTimelineResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<CreateProblemTimelineResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CreateProblemTimelineResponseBody() = default;
};
class CreateProblemTimelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateProblemTimelineResponseBody> body{};

  CreateProblemTimelineResponse() {}

  explicit CreateProblemTimelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProblemTimelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProblemTimelineResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProblemTimelineResponse() = default;
};
class CreateProblemTimelinesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> problemId{};
  shared_ptr<string> timelineNodes{};

  CreateProblemTimelinesRequest() {}

  explicit CreateProblemTimelinesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    if (timelineNodes) {
      res["timelineNodes"] = boost::any(*timelineNodes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
    if (m.find("timelineNodes") != m.end() && !m["timelineNodes"].empty()) {
      timelineNodes = make_shared<string>(boost::any_cast<string>(m["timelineNodes"]));
    }
  }


  virtual ~CreateProblemTimelinesRequest() = default;
};
class CreateProblemTimelinesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<long>> problemTimelineIds{};

  CreateProblemTimelinesResponseBodyData() {}

  explicit CreateProblemTimelinesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (problemTimelineIds) {
      res["problemTimelineIds"] = boost::any(*problemTimelineIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("problemTimelineIds") != m.end() && !m["problemTimelineIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["problemTimelineIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["problemTimelineIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      problemTimelineIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~CreateProblemTimelinesResponseBodyData() = default;
};
class CreateProblemTimelinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateProblemTimelinesResponseBodyData> data{};
  shared_ptr<string> requestId{};

  CreateProblemTimelinesResponseBody() {}

  explicit CreateProblemTimelinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        CreateProblemTimelinesResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<CreateProblemTimelinesResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CreateProblemTimelinesResponseBody() = default;
};
class CreateProblemTimelinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateProblemTimelinesResponseBody> body{};

  CreateProblemTimelinesResponse() {}

  explicit CreateProblemTimelinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProblemTimelinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProblemTimelinesResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProblemTimelinesResponse() = default;
};
class CreateRichTextRequest : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> richText{};

  CreateRichTextRequest() {}

  explicit CreateRichTextRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["instanceType"] = boost::any(*instanceType);
    }
    if (richText) {
      res["richText"] = boost::any(*richText);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["instanceId"]));
    }
    if (m.find("instanceType") != m.end() && !m["instanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["instanceType"]));
    }
    if (m.find("richText") != m.end() && !m["richText"].empty()) {
      richText = make_shared<string>(boost::any_cast<string>(m["richText"]));
    }
  }


  virtual ~CreateRichTextRequest() = default;
};
class CreateRichTextResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<long> instanceType{};
  shared_ptr<string> richText{};

  CreateRichTextResponseBodyData() {}

  explicit CreateRichTextResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["instanceType"] = boost::any(*instanceType);
    }
    if (richText) {
      res["richText"] = boost::any(*richText);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["instanceId"]));
    }
    if (m.find("instanceType") != m.end() && !m["instanceType"].empty()) {
      instanceType = make_shared<long>(boost::any_cast<long>(m["instanceType"]));
    }
    if (m.find("richText") != m.end() && !m["richText"].empty()) {
      richText = make_shared<string>(boost::any_cast<string>(m["richText"]));
    }
  }


  virtual ~CreateRichTextResponseBodyData() = default;
};
class CreateRichTextResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateRichTextResponseBodyData> data{};
  shared_ptr<string> requestId{};

  CreateRichTextResponseBody() {}

  explicit CreateRichTextResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        CreateRichTextResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<CreateRichTextResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CreateRichTextResponseBody() = default;
};
class CreateRichTextResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRichTextResponseBody> body{};

  CreateRichTextResponse() {}

  explicit CreateRichTextResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRichTextResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRichTextResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRichTextResponse() = default;
};
class CreateRouteRuleRequestRouteChildRulesConditions : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> operationSymbol{};
  shared_ptr<string> value{};

  CreateRouteRuleRequestRouteChildRulesConditions() {}

  explicit CreateRouteRuleRequestRouteChildRulesConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (operationSymbol) {
      res["operationSymbol"] = boost::any(*operationSymbol);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("operationSymbol") != m.end() && !m["operationSymbol"].empty()) {
      operationSymbol = make_shared<string>(boost::any_cast<string>(m["operationSymbol"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~CreateRouteRuleRequestRouteChildRulesConditions() = default;
};
class CreateRouteRuleRequestRouteChildRules : public Darabonba::Model {
public:
  shared_ptr<long> childConditionRelation{};
  shared_ptr<vector<CreateRouteRuleRequestRouteChildRulesConditions>> conditions{};
  shared_ptr<long> monitorSourceId{};
  shared_ptr<string> problemLevel{};

  CreateRouteRuleRequestRouteChildRules() {}

  explicit CreateRouteRuleRequestRouteChildRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (childConditionRelation) {
      res["childConditionRelation"] = boost::any(*childConditionRelation);
    }
    if (conditions) {
      vector<boost::any> temp1;
      for(auto item1:*conditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["conditions"] = boost::any(temp1);
    }
    if (monitorSourceId) {
      res["monitorSourceId"] = boost::any(*monitorSourceId);
    }
    if (problemLevel) {
      res["problemLevel"] = boost::any(*problemLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("childConditionRelation") != m.end() && !m["childConditionRelation"].empty()) {
      childConditionRelation = make_shared<long>(boost::any_cast<long>(m["childConditionRelation"]));
    }
    if (m.find("conditions") != m.end() && !m["conditions"].empty()) {
      if (typeid(vector<boost::any>) == m["conditions"].type()) {
        vector<CreateRouteRuleRequestRouteChildRulesConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["conditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateRouteRuleRequestRouteChildRulesConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditions = make_shared<vector<CreateRouteRuleRequestRouteChildRulesConditions>>(expect1);
      }
    }
    if (m.find("monitorSourceId") != m.end() && !m["monitorSourceId"].empty()) {
      monitorSourceId = make_shared<long>(boost::any_cast<long>(m["monitorSourceId"]));
    }
    if (m.find("problemLevel") != m.end() && !m["problemLevel"].empty()) {
      problemLevel = make_shared<string>(boost::any_cast<string>(m["problemLevel"]));
    }
  }


  virtual ~CreateRouteRuleRequestRouteChildRules() = default;
};
class CreateRouteRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> assignObjectId{};
  shared_ptr<string> assignObjectType{};
  shared_ptr<string> childRuleRelation{};
  shared_ptr<string> clientToken{};
  shared_ptr<vector<string>> convergenceFields{};
  shared_ptr<long> convergenceType{};
  shared_ptr<vector<string>> coverageProblemLevels{};
  shared_ptr<string> effection{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> incidentLevel{};
  shared_ptr<long> matchCount{};
  shared_ptr<vector<string>> notifyChannels{};
  shared_ptr<vector<long>> problemEffectionServices{};
  shared_ptr<map<string, ProblemLevelGroupValue>> problemLevelGroup{};
  shared_ptr<long> relatedServiceId{};
  shared_ptr<vector<CreateRouteRuleRequestRouteChildRules>> routeChildRules{};
  shared_ptr<string> routeType{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> timeWindow{};
  shared_ptr<string> timeWindowUnit{};

  CreateRouteRuleRequest() {}

  explicit CreateRouteRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignObjectId) {
      res["assignObjectId"] = boost::any(*assignObjectId);
    }
    if (assignObjectType) {
      res["assignObjectType"] = boost::any(*assignObjectType);
    }
    if (childRuleRelation) {
      res["childRuleRelation"] = boost::any(*childRuleRelation);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (convergenceFields) {
      res["convergenceFields"] = boost::any(*convergenceFields);
    }
    if (convergenceType) {
      res["convergenceType"] = boost::any(*convergenceType);
    }
    if (coverageProblemLevels) {
      res["coverageProblemLevels"] = boost::any(*coverageProblemLevels);
    }
    if (effection) {
      res["effection"] = boost::any(*effection);
    }
    if (enableStatus) {
      res["enableStatus"] = boost::any(*enableStatus);
    }
    if (incidentLevel) {
      res["incidentLevel"] = boost::any(*incidentLevel);
    }
    if (matchCount) {
      res["matchCount"] = boost::any(*matchCount);
    }
    if (notifyChannels) {
      res["notifyChannels"] = boost::any(*notifyChannels);
    }
    if (problemEffectionServices) {
      res["problemEffectionServices"] = boost::any(*problemEffectionServices);
    }
    if (problemLevelGroup) {
      map<string, boost::any> temp1;
      for(auto item1:*problemLevelGroup){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["problemLevelGroup"] = boost::any(temp1);
    }
    if (relatedServiceId) {
      res["relatedServiceId"] = boost::any(*relatedServiceId);
    }
    if (routeChildRules) {
      vector<boost::any> temp1;
      for(auto item1:*routeChildRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["routeChildRules"] = boost::any(temp1);
    }
    if (routeType) {
      res["routeType"] = boost::any(*routeType);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    if (timeWindow) {
      res["timeWindow"] = boost::any(*timeWindow);
    }
    if (timeWindowUnit) {
      res["timeWindowUnit"] = boost::any(*timeWindowUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignObjectId") != m.end() && !m["assignObjectId"].empty()) {
      assignObjectId = make_shared<long>(boost::any_cast<long>(m["assignObjectId"]));
    }
    if (m.find("assignObjectType") != m.end() && !m["assignObjectType"].empty()) {
      assignObjectType = make_shared<string>(boost::any_cast<string>(m["assignObjectType"]));
    }
    if (m.find("childRuleRelation") != m.end() && !m["childRuleRelation"].empty()) {
      childRuleRelation = make_shared<string>(boost::any_cast<string>(m["childRuleRelation"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("convergenceFields") != m.end() && !m["convergenceFields"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["convergenceFields"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["convergenceFields"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      convergenceFields = make_shared<vector<string>>(toVec1);
    }
    if (m.find("convergenceType") != m.end() && !m["convergenceType"].empty()) {
      convergenceType = make_shared<long>(boost::any_cast<long>(m["convergenceType"]));
    }
    if (m.find("coverageProblemLevels") != m.end() && !m["coverageProblemLevels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["coverageProblemLevels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["coverageProblemLevels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      coverageProblemLevels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("effection") != m.end() && !m["effection"].empty()) {
      effection = make_shared<string>(boost::any_cast<string>(m["effection"]));
    }
    if (m.find("enableStatus") != m.end() && !m["enableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["enableStatus"]));
    }
    if (m.find("incidentLevel") != m.end() && !m["incidentLevel"].empty()) {
      incidentLevel = make_shared<string>(boost::any_cast<string>(m["incidentLevel"]));
    }
    if (m.find("matchCount") != m.end() && !m["matchCount"].empty()) {
      matchCount = make_shared<long>(boost::any_cast<long>(m["matchCount"]));
    }
    if (m.find("notifyChannels") != m.end() && !m["notifyChannels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["notifyChannels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["notifyChannels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      notifyChannels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("problemEffectionServices") != m.end() && !m["problemEffectionServices"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["problemEffectionServices"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["problemEffectionServices"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      problemEffectionServices = make_shared<vector<long>>(toVec1);
    }
    if (m.find("problemLevelGroup") != m.end() && !m["problemLevelGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["problemLevelGroup"].type()) {
        map<string, ProblemLevelGroupValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["problemLevelGroup"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            ProblemLevelGroupValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        problemLevelGroup = make_shared<map<string, ProblemLevelGroupValue>>(expect1);
      }
    }
    if (m.find("relatedServiceId") != m.end() && !m["relatedServiceId"].empty()) {
      relatedServiceId = make_shared<long>(boost::any_cast<long>(m["relatedServiceId"]));
    }
    if (m.find("routeChildRules") != m.end() && !m["routeChildRules"].empty()) {
      if (typeid(vector<boost::any>) == m["routeChildRules"].type()) {
        vector<CreateRouteRuleRequestRouteChildRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["routeChildRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateRouteRuleRequestRouteChildRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routeChildRules = make_shared<vector<CreateRouteRuleRequestRouteChildRules>>(expect1);
      }
    }
    if (m.find("routeType") != m.end() && !m["routeType"].empty()) {
      routeType = make_shared<string>(boost::any_cast<string>(m["routeType"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
    if (m.find("timeWindow") != m.end() && !m["timeWindow"].empty()) {
      timeWindow = make_shared<long>(boost::any_cast<long>(m["timeWindow"]));
    }
    if (m.find("timeWindowUnit") != m.end() && !m["timeWindowUnit"].empty()) {
      timeWindowUnit = make_shared<string>(boost::any_cast<string>(m["timeWindowUnit"]));
    }
  }


  virtual ~CreateRouteRuleRequest() = default;
};
class CreateRouteRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> routeRuleId{};

  CreateRouteRuleResponseBodyData() {}

  explicit CreateRouteRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routeRuleId) {
      res["routeRuleId"] = boost::any(*routeRuleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("routeRuleId") != m.end() && !m["routeRuleId"].empty()) {
      routeRuleId = make_shared<long>(boost::any_cast<long>(m["routeRuleId"]));
    }
  }


  virtual ~CreateRouteRuleResponseBodyData() = default;
};
class CreateRouteRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateRouteRuleResponseBodyData> data{};
  shared_ptr<string> requestId{};

  CreateRouteRuleResponseBody() {}

  explicit CreateRouteRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        CreateRouteRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<CreateRouteRuleResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CreateRouteRuleResponseBody() = default;
};
class CreateRouteRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateRouteRuleResponseBody> body{};

  CreateRouteRuleResponse() {}

  explicit CreateRouteRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateRouteRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateRouteRuleResponseBody>(model1);
      }
    }
  }


  virtual ~CreateRouteRuleResponse() = default;
};
class CreateServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> serviceDescription{};
  shared_ptr<string> serviceName{};

  CreateServiceRequest() {}

  explicit CreateServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (serviceDescription) {
      res["serviceDescription"] = boost::any(*serviceDescription);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("serviceDescription") != m.end() && !m["serviceDescription"].empty()) {
      serviceDescription = make_shared<string>(boost::any_cast<string>(m["serviceDescription"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
  }


  virtual ~CreateServiceRequest() = default;
};
class CreateServiceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> serviceId{};

  CreateServiceResponseBodyData() {}

  explicit CreateServiceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceId) {
      res["serviceId"] = boost::any(*serviceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("serviceId") != m.end() && !m["serviceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["serviceId"]));
    }
  }


  virtual ~CreateServiceResponseBodyData() = default;
};
class CreateServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateServiceResponseBodyData> data{};
  shared_ptr<string> requestId{};

  CreateServiceResponseBody() {}

  explicit CreateServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        CreateServiceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<CreateServiceResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CreateServiceResponseBody() = default;
};
class CreateServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateServiceResponseBody> body{};

  CreateServiceResponse() {}

  explicit CreateServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateServiceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateServiceResponse() = default;
};
class CreateServiceGroupRequestMonitorSourceTemplates : public Darabonba::Model {
public:
  shared_ptr<long> monitorSourceId{};
  shared_ptr<string> monitorSourceName{};
  shared_ptr<string> templateContent{};
  shared_ptr<long> templateId{};

  CreateServiceGroupRequestMonitorSourceTemplates() {}

  explicit CreateServiceGroupRequestMonitorSourceTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorSourceId) {
      res["monitorSourceId"] = boost::any(*monitorSourceId);
    }
    if (monitorSourceName) {
      res["monitorSourceName"] = boost::any(*monitorSourceName);
    }
    if (templateContent) {
      res["templateContent"] = boost::any(*templateContent);
    }
    if (templateId) {
      res["templateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("monitorSourceId") != m.end() && !m["monitorSourceId"].empty()) {
      monitorSourceId = make_shared<long>(boost::any_cast<long>(m["monitorSourceId"]));
    }
    if (m.find("monitorSourceName") != m.end() && !m["monitorSourceName"].empty()) {
      monitorSourceName = make_shared<string>(boost::any_cast<string>(m["monitorSourceName"]));
    }
    if (m.find("templateContent") != m.end() && !m["templateContent"].empty()) {
      templateContent = make_shared<string>(boost::any_cast<string>(m["templateContent"]));
    }
    if (m.find("templateId") != m.end() && !m["templateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["templateId"]));
    }
  }


  virtual ~CreateServiceGroupRequestMonitorSourceTemplates() = default;
};
class CreateServiceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> enableWebhook{};
  shared_ptr<vector<CreateServiceGroupRequestMonitorSourceTemplates>> monitorSourceTemplates{};
  shared_ptr<string> serviceGroupDescription{};
  shared_ptr<string> serviceGroupName{};
  shared_ptr<vector<long>> userIds{};
  shared_ptr<string> webhookLink{};
  shared_ptr<string> webhookType{};

  CreateServiceGroupRequest() {}

  explicit CreateServiceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (enableWebhook) {
      res["enableWebhook"] = boost::any(*enableWebhook);
    }
    if (monitorSourceTemplates) {
      vector<boost::any> temp1;
      for(auto item1:*monitorSourceTemplates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["monitorSourceTemplates"] = boost::any(temp1);
    }
    if (serviceGroupDescription) {
      res["serviceGroupDescription"] = boost::any(*serviceGroupDescription);
    }
    if (serviceGroupName) {
      res["serviceGroupName"] = boost::any(*serviceGroupName);
    }
    if (userIds) {
      res["userIds"] = boost::any(*userIds);
    }
    if (webhookLink) {
      res["webhookLink"] = boost::any(*webhookLink);
    }
    if (webhookType) {
      res["webhookType"] = boost::any(*webhookType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("enableWebhook") != m.end() && !m["enableWebhook"].empty()) {
      enableWebhook = make_shared<string>(boost::any_cast<string>(m["enableWebhook"]));
    }
    if (m.find("monitorSourceTemplates") != m.end() && !m["monitorSourceTemplates"].empty()) {
      if (typeid(vector<boost::any>) == m["monitorSourceTemplates"].type()) {
        vector<CreateServiceGroupRequestMonitorSourceTemplates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["monitorSourceTemplates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateServiceGroupRequestMonitorSourceTemplates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorSourceTemplates = make_shared<vector<CreateServiceGroupRequestMonitorSourceTemplates>>(expect1);
      }
    }
    if (m.find("serviceGroupDescription") != m.end() && !m["serviceGroupDescription"].empty()) {
      serviceGroupDescription = make_shared<string>(boost::any_cast<string>(m["serviceGroupDescription"]));
    }
    if (m.find("serviceGroupName") != m.end() && !m["serviceGroupName"].empty()) {
      serviceGroupName = make_shared<string>(boost::any_cast<string>(m["serviceGroupName"]));
    }
    if (m.find("userIds") != m.end() && !m["userIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["userIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["userIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      userIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("webhookLink") != m.end() && !m["webhookLink"].empty()) {
      webhookLink = make_shared<string>(boost::any_cast<string>(m["webhookLink"]));
    }
    if (m.find("webhookType") != m.end() && !m["webhookType"].empty()) {
      webhookType = make_shared<string>(boost::any_cast<string>(m["webhookType"]));
    }
  }


  virtual ~CreateServiceGroupRequest() = default;
};
class CreateServiceGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> serviceGroupId{};

  CreateServiceGroupResponseBodyData() {}

  explicit CreateServiceGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
  }


  virtual ~CreateServiceGroupResponseBodyData() = default;
};
class CreateServiceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateServiceGroupResponseBodyData> data{};
  shared_ptr<string> requestId{};

  CreateServiceGroupResponseBody() {}

  explicit CreateServiceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        CreateServiceGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<CreateServiceGroupResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CreateServiceGroupResponseBody() = default;
};
class CreateServiceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateServiceGroupResponseBody> body{};

  CreateServiceGroupResponse() {}

  explicit CreateServiceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateServiceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateServiceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~CreateServiceGroupResponse() = default;
};
class CreateServiceGroupSchedulingRequestFastSchedulingSchedulingUsers : public Darabonba::Model {
public:
  shared_ptr<string> schedulingObjectType{};
  shared_ptr<long> schedulingOrder{};
  shared_ptr<long> schedulingUserId{};
  shared_ptr<vector<long>> schedulingUserIdList{};

  CreateServiceGroupSchedulingRequestFastSchedulingSchedulingUsers() {}

  explicit CreateServiceGroupSchedulingRequestFastSchedulingSchedulingUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (schedulingObjectType) {
      res["schedulingObjectType"] = boost::any(*schedulingObjectType);
    }
    if (schedulingOrder) {
      res["schedulingOrder"] = boost::any(*schedulingOrder);
    }
    if (schedulingUserId) {
      res["schedulingUserId"] = boost::any(*schedulingUserId);
    }
    if (schedulingUserIdList) {
      res["schedulingUserIdList"] = boost::any(*schedulingUserIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("schedulingObjectType") != m.end() && !m["schedulingObjectType"].empty()) {
      schedulingObjectType = make_shared<string>(boost::any_cast<string>(m["schedulingObjectType"]));
    }
    if (m.find("schedulingOrder") != m.end() && !m["schedulingOrder"].empty()) {
      schedulingOrder = make_shared<long>(boost::any_cast<long>(m["schedulingOrder"]));
    }
    if (m.find("schedulingUserId") != m.end() && !m["schedulingUserId"].empty()) {
      schedulingUserId = make_shared<long>(boost::any_cast<long>(m["schedulingUserId"]));
    }
    if (m.find("schedulingUserIdList") != m.end() && !m["schedulingUserIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["schedulingUserIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["schedulingUserIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      schedulingUserIdList = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~CreateServiceGroupSchedulingRequestFastSchedulingSchedulingUsers() = default;
};
class CreateServiceGroupSchedulingRequestFastScheduling : public Darabonba::Model {
public:
  shared_ptr<string> dutyPlan{};
  shared_ptr<vector<CreateServiceGroupSchedulingRequestFastSchedulingSchedulingUsers>> schedulingUsers{};
  shared_ptr<long> singleDuration{};
  shared_ptr<string> singleDurationUnit{};

  CreateServiceGroupSchedulingRequestFastScheduling() {}

  explicit CreateServiceGroupSchedulingRequestFastScheduling(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dutyPlan) {
      res["dutyPlan"] = boost::any(*dutyPlan);
    }
    if (schedulingUsers) {
      vector<boost::any> temp1;
      for(auto item1:*schedulingUsers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["schedulingUsers"] = boost::any(temp1);
    }
    if (singleDuration) {
      res["singleDuration"] = boost::any(*singleDuration);
    }
    if (singleDurationUnit) {
      res["singleDurationUnit"] = boost::any(*singleDurationUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dutyPlan") != m.end() && !m["dutyPlan"].empty()) {
      dutyPlan = make_shared<string>(boost::any_cast<string>(m["dutyPlan"]));
    }
    if (m.find("schedulingUsers") != m.end() && !m["schedulingUsers"].empty()) {
      if (typeid(vector<boost::any>) == m["schedulingUsers"].type()) {
        vector<CreateServiceGroupSchedulingRequestFastSchedulingSchedulingUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["schedulingUsers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateServiceGroupSchedulingRequestFastSchedulingSchedulingUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        schedulingUsers = make_shared<vector<CreateServiceGroupSchedulingRequestFastSchedulingSchedulingUsers>>(expect1);
      }
    }
    if (m.find("singleDuration") != m.end() && !m["singleDuration"].empty()) {
      singleDuration = make_shared<long>(boost::any_cast<long>(m["singleDuration"]));
    }
    if (m.find("singleDurationUnit") != m.end() && !m["singleDurationUnit"].empty()) {
      singleDurationUnit = make_shared<string>(boost::any_cast<string>(m["singleDurationUnit"]));
    }
  }


  virtual ~CreateServiceGroupSchedulingRequestFastScheduling() = default;
};
class CreateServiceGroupSchedulingRequestFineSchedulingSchedulingFineShifts : public Darabonba::Model {
public:
  shared_ptr<long> cycleOrder{};
  shared_ptr<string> schedulingEndTime{};
  shared_ptr<string> schedulingObjectType{};
  shared_ptr<long> schedulingOrder{};
  shared_ptr<string> schedulingStartTime{};
  shared_ptr<long> schedulingUserId{};
  shared_ptr<vector<long>> schedulingUserIdList{};
  shared_ptr<string> shiftName{};
  shared_ptr<bool> skipOneDay{};

  CreateServiceGroupSchedulingRequestFineSchedulingSchedulingFineShifts() {}

  explicit CreateServiceGroupSchedulingRequestFineSchedulingSchedulingFineShifts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleOrder) {
      res["cycleOrder"] = boost::any(*cycleOrder);
    }
    if (schedulingEndTime) {
      res["schedulingEndTime"] = boost::any(*schedulingEndTime);
    }
    if (schedulingObjectType) {
      res["schedulingObjectType"] = boost::any(*schedulingObjectType);
    }
    if (schedulingOrder) {
      res["schedulingOrder"] = boost::any(*schedulingOrder);
    }
    if (schedulingStartTime) {
      res["schedulingStartTime"] = boost::any(*schedulingStartTime);
    }
    if (schedulingUserId) {
      res["schedulingUserId"] = boost::any(*schedulingUserId);
    }
    if (schedulingUserIdList) {
      res["schedulingUserIdList"] = boost::any(*schedulingUserIdList);
    }
    if (shiftName) {
      res["shiftName"] = boost::any(*shiftName);
    }
    if (skipOneDay) {
      res["skipOneDay"] = boost::any(*skipOneDay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cycleOrder") != m.end() && !m["cycleOrder"].empty()) {
      cycleOrder = make_shared<long>(boost::any_cast<long>(m["cycleOrder"]));
    }
    if (m.find("schedulingEndTime") != m.end() && !m["schedulingEndTime"].empty()) {
      schedulingEndTime = make_shared<string>(boost::any_cast<string>(m["schedulingEndTime"]));
    }
    if (m.find("schedulingObjectType") != m.end() && !m["schedulingObjectType"].empty()) {
      schedulingObjectType = make_shared<string>(boost::any_cast<string>(m["schedulingObjectType"]));
    }
    if (m.find("schedulingOrder") != m.end() && !m["schedulingOrder"].empty()) {
      schedulingOrder = make_shared<long>(boost::any_cast<long>(m["schedulingOrder"]));
    }
    if (m.find("schedulingStartTime") != m.end() && !m["schedulingStartTime"].empty()) {
      schedulingStartTime = make_shared<string>(boost::any_cast<string>(m["schedulingStartTime"]));
    }
    if (m.find("schedulingUserId") != m.end() && !m["schedulingUserId"].empty()) {
      schedulingUserId = make_shared<long>(boost::any_cast<long>(m["schedulingUserId"]));
    }
    if (m.find("schedulingUserIdList") != m.end() && !m["schedulingUserIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["schedulingUserIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["schedulingUserIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      schedulingUserIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("shiftName") != m.end() && !m["shiftName"].empty()) {
      shiftName = make_shared<string>(boost::any_cast<string>(m["shiftName"]));
    }
    if (m.find("skipOneDay") != m.end() && !m["skipOneDay"].empty()) {
      skipOneDay = make_shared<bool>(boost::any_cast<bool>(m["skipOneDay"]));
    }
  }


  virtual ~CreateServiceGroupSchedulingRequestFineSchedulingSchedulingFineShifts() = default;
};
class CreateServiceGroupSchedulingRequestFineSchedulingSchedulingTemplateFineShifts : public Darabonba::Model {
public:
  shared_ptr<string> schedulingEndTime{};
  shared_ptr<string> schedulingObjectType{};
  shared_ptr<long> schedulingOrder{};
  shared_ptr<string> schedulingStartTime{};
  shared_ptr<long> schedulingUserId{};
  shared_ptr<vector<long>> schedulingUserIdList{};
  shared_ptr<string> schedulingUserName{};
  shared_ptr<bool> skipOneDay{};

  CreateServiceGroupSchedulingRequestFineSchedulingSchedulingTemplateFineShifts() {}

  explicit CreateServiceGroupSchedulingRequestFineSchedulingSchedulingTemplateFineShifts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (schedulingEndTime) {
      res["schedulingEndTime"] = boost::any(*schedulingEndTime);
    }
    if (schedulingObjectType) {
      res["schedulingObjectType"] = boost::any(*schedulingObjectType);
    }
    if (schedulingOrder) {
      res["schedulingOrder"] = boost::any(*schedulingOrder);
    }
    if (schedulingStartTime) {
      res["schedulingStartTime"] = boost::any(*schedulingStartTime);
    }
    if (schedulingUserId) {
      res["schedulingUserId"] = boost::any(*schedulingUserId);
    }
    if (schedulingUserIdList) {
      res["schedulingUserIdList"] = boost::any(*schedulingUserIdList);
    }
    if (schedulingUserName) {
      res["schedulingUserName"] = boost::any(*schedulingUserName);
    }
    if (skipOneDay) {
      res["skipOneDay"] = boost::any(*skipOneDay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("schedulingEndTime") != m.end() && !m["schedulingEndTime"].empty()) {
      schedulingEndTime = make_shared<string>(boost::any_cast<string>(m["schedulingEndTime"]));
    }
    if (m.find("schedulingObjectType") != m.end() && !m["schedulingObjectType"].empty()) {
      schedulingObjectType = make_shared<string>(boost::any_cast<string>(m["schedulingObjectType"]));
    }
    if (m.find("schedulingOrder") != m.end() && !m["schedulingOrder"].empty()) {
      schedulingOrder = make_shared<long>(boost::any_cast<long>(m["schedulingOrder"]));
    }
    if (m.find("schedulingStartTime") != m.end() && !m["schedulingStartTime"].empty()) {
      schedulingStartTime = make_shared<string>(boost::any_cast<string>(m["schedulingStartTime"]));
    }
    if (m.find("schedulingUserId") != m.end() && !m["schedulingUserId"].empty()) {
      schedulingUserId = make_shared<long>(boost::any_cast<long>(m["schedulingUserId"]));
    }
    if (m.find("schedulingUserIdList") != m.end() && !m["schedulingUserIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["schedulingUserIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["schedulingUserIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      schedulingUserIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("schedulingUserName") != m.end() && !m["schedulingUserName"].empty()) {
      schedulingUserName = make_shared<string>(boost::any_cast<string>(m["schedulingUserName"]));
    }
    if (m.find("skipOneDay") != m.end() && !m["skipOneDay"].empty()) {
      skipOneDay = make_shared<bool>(boost::any_cast<bool>(m["skipOneDay"]));
    }
  }


  virtual ~CreateServiceGroupSchedulingRequestFineSchedulingSchedulingTemplateFineShifts() = default;
};
class CreateServiceGroupSchedulingRequestFineScheduling : public Darabonba::Model {
public:
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<vector<CreateServiceGroupSchedulingRequestFineSchedulingSchedulingFineShifts>> schedulingFineShifts{};
  shared_ptr<vector<CreateServiceGroupSchedulingRequestFineSchedulingSchedulingTemplateFineShifts>> schedulingTemplateFineShifts{};
  shared_ptr<string> shiftType{};

  CreateServiceGroupSchedulingRequestFineScheduling() {}

  explicit CreateServiceGroupSchedulingRequestFineScheduling(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (period) {
      res["period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["periodUnit"] = boost::any(*periodUnit);
    }
    if (schedulingFineShifts) {
      vector<boost::any> temp1;
      for(auto item1:*schedulingFineShifts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["schedulingFineShifts"] = boost::any(temp1);
    }
    if (schedulingTemplateFineShifts) {
      vector<boost::any> temp1;
      for(auto item1:*schedulingTemplateFineShifts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["schedulingTemplateFineShifts"] = boost::any(temp1);
    }
    if (shiftType) {
      res["shiftType"] = boost::any(*shiftType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("period") != m.end() && !m["period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["period"]));
    }
    if (m.find("periodUnit") != m.end() && !m["periodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["periodUnit"]));
    }
    if (m.find("schedulingFineShifts") != m.end() && !m["schedulingFineShifts"].empty()) {
      if (typeid(vector<boost::any>) == m["schedulingFineShifts"].type()) {
        vector<CreateServiceGroupSchedulingRequestFineSchedulingSchedulingFineShifts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["schedulingFineShifts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateServiceGroupSchedulingRequestFineSchedulingSchedulingFineShifts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        schedulingFineShifts = make_shared<vector<CreateServiceGroupSchedulingRequestFineSchedulingSchedulingFineShifts>>(expect1);
      }
    }
    if (m.find("schedulingTemplateFineShifts") != m.end() && !m["schedulingTemplateFineShifts"].empty()) {
      if (typeid(vector<boost::any>) == m["schedulingTemplateFineShifts"].type()) {
        vector<CreateServiceGroupSchedulingRequestFineSchedulingSchedulingTemplateFineShifts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["schedulingTemplateFineShifts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateServiceGroupSchedulingRequestFineSchedulingSchedulingTemplateFineShifts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        schedulingTemplateFineShifts = make_shared<vector<CreateServiceGroupSchedulingRequestFineSchedulingSchedulingTemplateFineShifts>>(expect1);
      }
    }
    if (m.find("shiftType") != m.end() && !m["shiftType"].empty()) {
      shiftType = make_shared<string>(boost::any_cast<string>(m["shiftType"]));
    }
  }


  virtual ~CreateServiceGroupSchedulingRequestFineScheduling() = default;
};
class CreateServiceGroupSchedulingRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<CreateServiceGroupSchedulingRequestFastScheduling> fastScheduling{};
  shared_ptr<CreateServiceGroupSchedulingRequestFineScheduling> fineScheduling{};
  shared_ptr<string> schedulingWay{};
  shared_ptr<long> serviceGroupId{};

  CreateServiceGroupSchedulingRequest() {}

  explicit CreateServiceGroupSchedulingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (fastScheduling) {
      res["fastScheduling"] = fastScheduling ? boost::any(fastScheduling->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fineScheduling) {
      res["fineScheduling"] = fineScheduling ? boost::any(fineScheduling->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (schedulingWay) {
      res["schedulingWay"] = boost::any(*schedulingWay);
    }
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("fastScheduling") != m.end() && !m["fastScheduling"].empty()) {
      if (typeid(map<string, boost::any>) == m["fastScheduling"].type()) {
        CreateServiceGroupSchedulingRequestFastScheduling model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["fastScheduling"]));
        fastScheduling = make_shared<CreateServiceGroupSchedulingRequestFastScheduling>(model1);
      }
    }
    if (m.find("fineScheduling") != m.end() && !m["fineScheduling"].empty()) {
      if (typeid(map<string, boost::any>) == m["fineScheduling"].type()) {
        CreateServiceGroupSchedulingRequestFineScheduling model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["fineScheduling"]));
        fineScheduling = make_shared<CreateServiceGroupSchedulingRequestFineScheduling>(model1);
      }
    }
    if (m.find("schedulingWay") != m.end() && !m["schedulingWay"].empty()) {
      schedulingWay = make_shared<string>(boost::any_cast<string>(m["schedulingWay"]));
    }
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
  }


  virtual ~CreateServiceGroupSchedulingRequest() = default;
};
class CreateServiceGroupSchedulingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateServiceGroupSchedulingResponseBody() {}

  explicit CreateServiceGroupSchedulingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CreateServiceGroupSchedulingResponseBody() = default;
};
class CreateServiceGroupSchedulingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateServiceGroupSchedulingResponseBody> body{};

  CreateServiceGroupSchedulingResponse() {}

  explicit CreateServiceGroupSchedulingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateServiceGroupSchedulingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateServiceGroupSchedulingResponseBody>(model1);
      }
    }
  }


  virtual ~CreateServiceGroupSchedulingResponse() = default;
};
class CreateSubscriptionRequestNotifyObjectList : public Darabonba::Model {
public:
  shared_ptr<long> notifyObjectId{};

  CreateSubscriptionRequestNotifyObjectList() {}

  explicit CreateSubscriptionRequestNotifyObjectList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notifyObjectId) {
      res["notifyObjectId"] = boost::any(*notifyObjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("notifyObjectId") != m.end() && !m["notifyObjectId"].empty()) {
      notifyObjectId = make_shared<long>(boost::any_cast<long>(m["notifyObjectId"]));
    }
  }


  virtual ~CreateSubscriptionRequestNotifyObjectList() = default;
};
class CreateSubscriptionRequestNotifyStrategyListPeriodChannel : public Darabonba::Model {
public:
  shared_ptr<string> nonWorkday{};
  shared_ptr<string> workday{};

  CreateSubscriptionRequestNotifyStrategyListPeriodChannel() {}

  explicit CreateSubscriptionRequestNotifyStrategyListPeriodChannel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonWorkday) {
      res["nonWorkday"] = boost::any(*nonWorkday);
    }
    if (workday) {
      res["workday"] = boost::any(*workday);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("nonWorkday") != m.end() && !m["nonWorkday"].empty()) {
      nonWorkday = make_shared<string>(boost::any_cast<string>(m["nonWorkday"]));
    }
    if (m.find("workday") != m.end() && !m["workday"].empty()) {
      workday = make_shared<string>(boost::any_cast<string>(m["workday"]));
    }
  }


  virtual ~CreateSubscriptionRequestNotifyStrategyListPeriodChannel() = default;
};
class CreateSubscriptionRequestNotifyStrategyListStrategiesConditions : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> effection{};
  shared_ptr<string> level{};
  shared_ptr<string> problemNotifyType{};

  CreateSubscriptionRequestNotifyStrategyListStrategiesConditions() {}

  explicit CreateSubscriptionRequestNotifyStrategyListStrategiesConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["action"] = boost::any(*action);
    }
    if (effection) {
      res["effection"] = boost::any(*effection);
    }
    if (level) {
      res["level"] = boost::any(*level);
    }
    if (problemNotifyType) {
      res["problemNotifyType"] = boost::any(*problemNotifyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("action") != m.end() && !m["action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["action"]));
    }
    if (m.find("effection") != m.end() && !m["effection"].empty()) {
      effection = make_shared<string>(boost::any_cast<string>(m["effection"]));
    }
    if (m.find("level") != m.end() && !m["level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["level"]));
    }
    if (m.find("problemNotifyType") != m.end() && !m["problemNotifyType"].empty()) {
      problemNotifyType = make_shared<string>(boost::any_cast<string>(m["problemNotifyType"]));
    }
  }


  virtual ~CreateSubscriptionRequestNotifyStrategyListStrategiesConditions() = default;
};
class CreateSubscriptionRequestNotifyStrategyListStrategies : public Darabonba::Model {
public:
  shared_ptr<vector<CreateSubscriptionRequestNotifyStrategyListStrategiesConditions>> conditions{};

  CreateSubscriptionRequestNotifyStrategyListStrategies() {}

  explicit CreateSubscriptionRequestNotifyStrategyListStrategies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (conditions) {
      vector<boost::any> temp1;
      for(auto item1:*conditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["conditions"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("conditions") != m.end() && !m["conditions"].empty()) {
      if (typeid(vector<boost::any>) == m["conditions"].type()) {
        vector<CreateSubscriptionRequestNotifyStrategyListStrategiesConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["conditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSubscriptionRequestNotifyStrategyListStrategiesConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditions = make_shared<vector<CreateSubscriptionRequestNotifyStrategyListStrategiesConditions>>(expect1);
      }
    }
  }


  virtual ~CreateSubscriptionRequestNotifyStrategyListStrategies() = default;
};
class CreateSubscriptionRequestNotifyStrategyList : public Darabonba::Model {
public:
  shared_ptr<string> channels{};
  shared_ptr<long> instanceType{};
  shared_ptr<CreateSubscriptionRequestNotifyStrategyListPeriodChannel> periodChannel{};
  shared_ptr<vector<CreateSubscriptionRequestNotifyStrategyListStrategies>> strategies{};

  CreateSubscriptionRequestNotifyStrategyList() {}

  explicit CreateSubscriptionRequestNotifyStrategyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["channels"] = boost::any(*channels);
    }
    if (instanceType) {
      res["instanceType"] = boost::any(*instanceType);
    }
    if (periodChannel) {
      res["periodChannel"] = periodChannel ? boost::any(periodChannel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (strategies) {
      vector<boost::any> temp1;
      for(auto item1:*strategies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["strategies"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("channels") != m.end() && !m["channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["channels"]));
    }
    if (m.find("instanceType") != m.end() && !m["instanceType"].empty()) {
      instanceType = make_shared<long>(boost::any_cast<long>(m["instanceType"]));
    }
    if (m.find("periodChannel") != m.end() && !m["periodChannel"].empty()) {
      if (typeid(map<string, boost::any>) == m["periodChannel"].type()) {
        CreateSubscriptionRequestNotifyStrategyListPeriodChannel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["periodChannel"]));
        periodChannel = make_shared<CreateSubscriptionRequestNotifyStrategyListPeriodChannel>(model1);
      }
    }
    if (m.find("strategies") != m.end() && !m["strategies"].empty()) {
      if (typeid(vector<boost::any>) == m["strategies"].type()) {
        vector<CreateSubscriptionRequestNotifyStrategyListStrategies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["strategies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSubscriptionRequestNotifyStrategyListStrategies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        strategies = make_shared<vector<CreateSubscriptionRequestNotifyStrategyListStrategies>>(expect1);
      }
    }
  }


  virtual ~CreateSubscriptionRequestNotifyStrategyList() = default;
};
class CreateSubscriptionRequestScopeObjectList : public Darabonba::Model {
public:
  shared_ptr<long> scopeObjectId{};

  CreateSubscriptionRequestScopeObjectList() {}

  explicit CreateSubscriptionRequestScopeObjectList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scopeObjectId) {
      res["scopeObjectId"] = boost::any(*scopeObjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("scopeObjectId") != m.end() && !m["scopeObjectId"].empty()) {
      scopeObjectId = make_shared<long>(boost::any_cast<long>(m["scopeObjectId"]));
    }
  }


  virtual ~CreateSubscriptionRequestScopeObjectList() = default;
};
class CreateSubscriptionRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> endTime{};
  shared_ptr<long> expiredType{};
  shared_ptr<vector<CreateSubscriptionRequestNotifyObjectList>> notifyObjectList{};
  shared_ptr<long> notifyObjectType{};
  shared_ptr<vector<CreateSubscriptionRequestNotifyStrategyList>> notifyStrategyList{};
  shared_ptr<string> period{};
  shared_ptr<long> scope{};
  shared_ptr<vector<CreateSubscriptionRequestScopeObjectList>> scopeObjectList{};
  shared_ptr<string> startTime{};
  shared_ptr<string> subscriptionTitle{};

  CreateSubscriptionRequest() {}

  explicit CreateSubscriptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (expiredType) {
      res["expiredType"] = boost::any(*expiredType);
    }
    if (notifyObjectList) {
      vector<boost::any> temp1;
      for(auto item1:*notifyObjectList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["notifyObjectList"] = boost::any(temp1);
    }
    if (notifyObjectType) {
      res["notifyObjectType"] = boost::any(*notifyObjectType);
    }
    if (notifyStrategyList) {
      vector<boost::any> temp1;
      for(auto item1:*notifyStrategyList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["notifyStrategyList"] = boost::any(temp1);
    }
    if (period) {
      res["period"] = boost::any(*period);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (scopeObjectList) {
      vector<boost::any> temp1;
      for(auto item1:*scopeObjectList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["scopeObjectList"] = boost::any(temp1);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (subscriptionTitle) {
      res["subscriptionTitle"] = boost::any(*subscriptionTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("expiredType") != m.end() && !m["expiredType"].empty()) {
      expiredType = make_shared<long>(boost::any_cast<long>(m["expiredType"]));
    }
    if (m.find("notifyObjectList") != m.end() && !m["notifyObjectList"].empty()) {
      if (typeid(vector<boost::any>) == m["notifyObjectList"].type()) {
        vector<CreateSubscriptionRequestNotifyObjectList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["notifyObjectList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSubscriptionRequestNotifyObjectList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifyObjectList = make_shared<vector<CreateSubscriptionRequestNotifyObjectList>>(expect1);
      }
    }
    if (m.find("notifyObjectType") != m.end() && !m["notifyObjectType"].empty()) {
      notifyObjectType = make_shared<long>(boost::any_cast<long>(m["notifyObjectType"]));
    }
    if (m.find("notifyStrategyList") != m.end() && !m["notifyStrategyList"].empty()) {
      if (typeid(vector<boost::any>) == m["notifyStrategyList"].type()) {
        vector<CreateSubscriptionRequestNotifyStrategyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["notifyStrategyList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSubscriptionRequestNotifyStrategyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifyStrategyList = make_shared<vector<CreateSubscriptionRequestNotifyStrategyList>>(expect1);
      }
    }
    if (m.find("period") != m.end() && !m["period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["period"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<long>(boost::any_cast<long>(m["scope"]));
    }
    if (m.find("scopeObjectList") != m.end() && !m["scopeObjectList"].empty()) {
      if (typeid(vector<boost::any>) == m["scopeObjectList"].type()) {
        vector<CreateSubscriptionRequestScopeObjectList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["scopeObjectList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateSubscriptionRequestScopeObjectList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scopeObjectList = make_shared<vector<CreateSubscriptionRequestScopeObjectList>>(expect1);
      }
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
    if (m.find("subscriptionTitle") != m.end() && !m["subscriptionTitle"].empty()) {
      subscriptionTitle = make_shared<string>(boost::any_cast<string>(m["subscriptionTitle"]));
    }
  }


  virtual ~CreateSubscriptionRequest() = default;
};
class CreateSubscriptionResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> subscriptionId{};

  CreateSubscriptionResponseBodyData() {}

  explicit CreateSubscriptionResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subscriptionId) {
      res["subscriptionId"] = boost::any(*subscriptionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("subscriptionId") != m.end() && !m["subscriptionId"].empty()) {
      subscriptionId = make_shared<long>(boost::any_cast<long>(m["subscriptionId"]));
    }
  }


  virtual ~CreateSubscriptionResponseBodyData() = default;
};
class CreateSubscriptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateSubscriptionResponseBodyData> data{};
  shared_ptr<string> requestId{};

  CreateSubscriptionResponseBody() {}

  explicit CreateSubscriptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        CreateSubscriptionResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<CreateSubscriptionResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CreateSubscriptionResponseBody() = default;
};
class CreateSubscriptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSubscriptionResponseBody> body{};

  CreateSubscriptionResponse() {}

  explicit CreateSubscriptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSubscriptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSubscriptionResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSubscriptionResponse() = default;
};
class CreateTenantApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> channel{};
  shared_ptr<string> clientToken{};

  CreateTenantApplicationRequest() {}

  explicit CreateTenantApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channel) {
      res["channel"] = boost::any(*channel);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("channel") != m.end() && !m["channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["channel"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~CreateTenantApplicationRequest() = default;
};
class CreateTenantApplicationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> openUrl{};
  shared_ptr<string> progress{};

  CreateTenantApplicationResponseBodyData() {}

  explicit CreateTenantApplicationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (openUrl) {
      res["openUrl"] = boost::any(*openUrl);
    }
    if (progress) {
      res["progress"] = boost::any(*progress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("openUrl") != m.end() && !m["openUrl"].empty()) {
      openUrl = make_shared<string>(boost::any_cast<string>(m["openUrl"]));
    }
    if (m.find("progress") != m.end() && !m["progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["progress"]));
    }
  }


  virtual ~CreateTenantApplicationResponseBodyData() = default;
};
class CreateTenantApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateTenantApplicationResponseBodyData> data{};
  shared_ptr<string> requestId{};

  CreateTenantApplicationResponseBody() {}

  explicit CreateTenantApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        CreateTenantApplicationResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<CreateTenantApplicationResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CreateTenantApplicationResponseBody() = default;
};
class CreateTenantApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTenantApplicationResponseBody> body{};

  CreateTenantApplicationResponse() {}

  explicit CreateTenantApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTenantApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTenantApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTenantApplicationResponse() = default;
};
class CreateUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> email{};
  shared_ptr<string> phone{};
  shared_ptr<long> ramId{};
  shared_ptr<string> username{};

  CreateUserRequest() {}

  explicit CreateUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (ramId) {
      res["ramId"] = boost::any(*ramId);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("ramId") != m.end() && !m["ramId"].empty()) {
      ramId = make_shared<long>(boost::any_cast<long>(m["ramId"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~CreateUserRequest() = default;
};
class CreateUserResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> userId{};

  CreateUserResponseBodyData() {}

  explicit CreateUserResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
  }


  virtual ~CreateUserResponseBodyData() = default;
};
class CreateUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<CreateUserResponseBodyData> data{};
  shared_ptr<string> requestId{};

  CreateUserResponseBody() {}

  explicit CreateUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        CreateUserResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<CreateUserResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~CreateUserResponseBody() = default;
};
class CreateUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateUserResponseBody> body{};

  CreateUserResponse() {}

  explicit CreateUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateUserResponseBody>(model1);
      }
    }
  }


  virtual ~CreateUserResponse() = default;
};
class DeleteEscalationPlanRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> escalationPlanId{};

  DeleteEscalationPlanRequest() {}

  explicit DeleteEscalationPlanRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (escalationPlanId) {
      res["escalationPlanId"] = boost::any(*escalationPlanId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("escalationPlanId") != m.end() && !m["escalationPlanId"].empty()) {
      escalationPlanId = make_shared<long>(boost::any_cast<long>(m["escalationPlanId"]));
    }
  }


  virtual ~DeleteEscalationPlanRequest() = default;
};
class DeleteEscalationPlanResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteEscalationPlanResponseBody() {}

  explicit DeleteEscalationPlanResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DeleteEscalationPlanResponseBody() = default;
};
class DeleteEscalationPlanResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteEscalationPlanResponseBody> body{};

  DeleteEscalationPlanResponse() {}

  explicit DeleteEscalationPlanResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEscalationPlanResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEscalationPlanResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEscalationPlanResponse() = default;
};
class DeleteIncidentRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> incidentId{};

  DeleteIncidentRequest() {}

  explicit DeleteIncidentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (incidentId) {
      res["incidentId"] = boost::any(*incidentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("incidentId") != m.end() && !m["incidentId"].empty()) {
      incidentId = make_shared<long>(boost::any_cast<long>(m["incidentId"]));
    }
  }


  virtual ~DeleteIncidentRequest() = default;
};
class DeleteIncidentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteIncidentResponseBody() {}

  explicit DeleteIncidentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DeleteIncidentResponseBody() = default;
};
class DeleteIncidentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteIncidentResponseBody> body{};

  DeleteIncidentResponse() {}

  explicit DeleteIncidentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteIncidentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteIncidentResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteIncidentResponse() = default;
};
class DeleteIntegrationConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> integrationConfigId{};

  DeleteIntegrationConfigRequest() {}

  explicit DeleteIntegrationConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (integrationConfigId) {
      res["integrationConfigId"] = boost::any(*integrationConfigId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("integrationConfigId") != m.end() && !m["integrationConfigId"].empty()) {
      integrationConfigId = make_shared<long>(boost::any_cast<long>(m["integrationConfigId"]));
    }
  }


  virtual ~DeleteIntegrationConfigRequest() = default;
};
class DeleteIntegrationConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteIntegrationConfigResponseBody() {}

  explicit DeleteIntegrationConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DeleteIntegrationConfigResponseBody() = default;
};
class DeleteIntegrationConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteIntegrationConfigResponseBody> body{};

  DeleteIntegrationConfigResponse() {}

  explicit DeleteIntegrationConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteIntegrationConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteIntegrationConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteIntegrationConfigResponse() = default;
};
class DeleteProblemRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> problemId{};

  DeleteProblemRequest() {}

  explicit DeleteProblemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
  }


  virtual ~DeleteProblemRequest() = default;
};
class DeleteProblemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteProblemResponseBody() {}

  explicit DeleteProblemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DeleteProblemResponseBody() = default;
};
class DeleteProblemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteProblemResponseBody> body{};

  DeleteProblemResponse() {}

  explicit DeleteProblemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteProblemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteProblemResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteProblemResponse() = default;
};
class DeleteProblemEffectionServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> effectionServiceId{};
  shared_ptr<long> problemId{};

  DeleteProblemEffectionServiceRequest() {}

  explicit DeleteProblemEffectionServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (effectionServiceId) {
      res["effectionServiceId"] = boost::any(*effectionServiceId);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("effectionServiceId") != m.end() && !m["effectionServiceId"].empty()) {
      effectionServiceId = make_shared<long>(boost::any_cast<long>(m["effectionServiceId"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
  }


  virtual ~DeleteProblemEffectionServiceRequest() = default;
};
class DeleteProblemEffectionServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteProblemEffectionServiceResponseBody() {}

  explicit DeleteProblemEffectionServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DeleteProblemEffectionServiceResponseBody() = default;
};
class DeleteProblemEffectionServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteProblemEffectionServiceResponseBody> body{};

  DeleteProblemEffectionServiceResponse() {}

  explicit DeleteProblemEffectionServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteProblemEffectionServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteProblemEffectionServiceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteProblemEffectionServiceResponse() = default;
};
class DeleteProblemMeasureRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> measureId{};
  shared_ptr<string> problemId{};

  DeleteProblemMeasureRequest() {}

  explicit DeleteProblemMeasureRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (measureId) {
      res["measureId"] = boost::any(*measureId);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("measureId") != m.end() && !m["measureId"].empty()) {
      measureId = make_shared<long>(boost::any_cast<long>(m["measureId"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<string>(boost::any_cast<string>(m["problemId"]));
    }
  }


  virtual ~DeleteProblemMeasureRequest() = default;
};
class DeleteProblemMeasureResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteProblemMeasureResponseBody() {}

  explicit DeleteProblemMeasureResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DeleteProblemMeasureResponseBody() = default;
};
class DeleteProblemMeasureResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteProblemMeasureResponseBody> body{};

  DeleteProblemMeasureResponse() {}

  explicit DeleteProblemMeasureResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteProblemMeasureResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteProblemMeasureResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteProblemMeasureResponse() = default;
};
class DeleteProblemTimelineRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> problemId{};
  shared_ptr<long> problemTimelineId{};

  DeleteProblemTimelineRequest() {}

  explicit DeleteProblemTimelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    if (problemTimelineId) {
      res["problemTimelineId"] = boost::any(*problemTimelineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
    if (m.find("problemTimelineId") != m.end() && !m["problemTimelineId"].empty()) {
      problemTimelineId = make_shared<long>(boost::any_cast<long>(m["problemTimelineId"]));
    }
  }


  virtual ~DeleteProblemTimelineRequest() = default;
};
class DeleteProblemTimelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteProblemTimelineResponseBody() {}

  explicit DeleteProblemTimelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DeleteProblemTimelineResponseBody() = default;
};
class DeleteProblemTimelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteProblemTimelineResponseBody> body{};

  DeleteProblemTimelineResponse() {}

  explicit DeleteProblemTimelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteProblemTimelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteProblemTimelineResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteProblemTimelineResponse() = default;
};
class DeleteRouteRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> routeRuleId{};

  DeleteRouteRuleRequest() {}

  explicit DeleteRouteRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (routeRuleId) {
      res["routeRuleId"] = boost::any(*routeRuleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("routeRuleId") != m.end() && !m["routeRuleId"].empty()) {
      routeRuleId = make_shared<long>(boost::any_cast<long>(m["routeRuleId"]));
    }
  }


  virtual ~DeleteRouteRuleRequest() = default;
};
class DeleteRouteRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> requestId{};

  DeleteRouteRuleResponseBody() {}

  explicit DeleteRouteRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<long>(boost::any_cast<long>(m["requestId"]));
    }
  }


  virtual ~DeleteRouteRuleResponseBody() = default;
};
class DeleteRouteRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteRouteRuleResponseBody> body{};

  DeleteRouteRuleResponse() {}

  explicit DeleteRouteRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRouteRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRouteRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRouteRuleResponse() = default;
};
class DeleteServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> serviceId{};

  DeleteServiceRequest() {}

  explicit DeleteServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (serviceId) {
      res["serviceId"] = boost::any(*serviceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("serviceId") != m.end() && !m["serviceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["serviceId"]));
    }
  }


  virtual ~DeleteServiceRequest() = default;
};
class DeleteServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteServiceResponseBody() {}

  explicit DeleteServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DeleteServiceResponseBody() = default;
};
class DeleteServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteServiceResponseBody> body{};

  DeleteServiceResponse() {}

  explicit DeleteServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteServiceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteServiceResponse() = default;
};
class DeleteServiceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> serviceGroupId{};

  DeleteServiceGroupRequest() {}

  explicit DeleteServiceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
  }


  virtual ~DeleteServiceGroupRequest() = default;
};
class DeleteServiceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteServiceGroupResponseBody() {}

  explicit DeleteServiceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DeleteServiceGroupResponseBody() = default;
};
class DeleteServiceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteServiceGroupResponseBody> body{};

  DeleteServiceGroupResponse() {}

  explicit DeleteServiceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteServiceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteServiceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteServiceGroupResponse() = default;
};
class DeleteServiceGroupSchedulingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteServiceGroupSchedulingResponseBody() {}

  explicit DeleteServiceGroupSchedulingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DeleteServiceGroupSchedulingResponseBody() = default;
};
class DeleteServiceGroupSchedulingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteServiceGroupSchedulingResponseBody> body{};

  DeleteServiceGroupSchedulingResponse() {}

  explicit DeleteServiceGroupSchedulingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteServiceGroupSchedulingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteServiceGroupSchedulingResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteServiceGroupSchedulingResponse() = default;
};
class DeleteServiceGroupUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> newUserId{};
  shared_ptr<long> oldUserId{};
  shared_ptr<bool> removeUser{};
  shared_ptr<long> serviceGroupId{};

  DeleteServiceGroupUserRequest() {}

  explicit DeleteServiceGroupUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (newUserId) {
      res["newUserId"] = boost::any(*newUserId);
    }
    if (oldUserId) {
      res["oldUserId"] = boost::any(*oldUserId);
    }
    if (removeUser) {
      res["removeUser"] = boost::any(*removeUser);
    }
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("newUserId") != m.end() && !m["newUserId"].empty()) {
      newUserId = make_shared<long>(boost::any_cast<long>(m["newUserId"]));
    }
    if (m.find("oldUserId") != m.end() && !m["oldUserId"].empty()) {
      oldUserId = make_shared<long>(boost::any_cast<long>(m["oldUserId"]));
    }
    if (m.find("removeUser") != m.end() && !m["removeUser"].empty()) {
      removeUser = make_shared<bool>(boost::any_cast<bool>(m["removeUser"]));
    }
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
  }


  virtual ~DeleteServiceGroupUserRequest() = default;
};
class DeleteServiceGroupUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteServiceGroupUserResponseBody() {}

  explicit DeleteServiceGroupUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DeleteServiceGroupUserResponseBody() = default;
};
class DeleteServiceGroupUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteServiceGroupUserResponseBody> body{};

  DeleteServiceGroupUserResponse() {}

  explicit DeleteServiceGroupUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteServiceGroupUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteServiceGroupUserResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteServiceGroupUserResponse() = default;
};
class DeleteSubscriptionRequest : public Darabonba::Model {
public:
  shared_ptr<long> subscriptionId{};

  DeleteSubscriptionRequest() {}

  explicit DeleteSubscriptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subscriptionId) {
      res["subscriptionId"] = boost::any(*subscriptionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("subscriptionId") != m.end() && !m["subscriptionId"].empty()) {
      subscriptionId = make_shared<long>(boost::any_cast<long>(m["subscriptionId"]));
    }
  }


  virtual ~DeleteSubscriptionRequest() = default;
};
class DeleteSubscriptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSubscriptionResponseBody() {}

  explicit DeleteSubscriptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DeleteSubscriptionResponseBody() = default;
};
class DeleteSubscriptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSubscriptionResponseBody> body{};

  DeleteSubscriptionResponse() {}

  explicit DeleteSubscriptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSubscriptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSubscriptionResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSubscriptionResponse() = default;
};
class DeleteUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> userId{};

  DeleteUserRequest() {}

  explicit DeleteUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
  }


  virtual ~DeleteUserRequest() = default;
};
class DeleteUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteUserResponseBody() {}

  explicit DeleteUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DeleteUserResponseBody() = default;
};
class DeleteUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteUserResponseBody> body{};

  DeleteUserResponse() {}

  explicit DeleteUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteUserResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteUserResponse() = default;
};
class DeliverIncidentRequest : public Darabonba::Model {
public:
  shared_ptr<long> assignUserId{};
  shared_ptr<string> clientToken{};
  shared_ptr<long> incidentId{};

  DeliverIncidentRequest() {}

  explicit DeliverIncidentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignUserId) {
      res["assignUserId"] = boost::any(*assignUserId);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (incidentId) {
      res["incidentId"] = boost::any(*incidentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignUserId") != m.end() && !m["assignUserId"].empty()) {
      assignUserId = make_shared<long>(boost::any_cast<long>(m["assignUserId"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("incidentId") != m.end() && !m["incidentId"].empty()) {
      incidentId = make_shared<long>(boost::any_cast<long>(m["incidentId"]));
    }
  }


  virtual ~DeliverIncidentRequest() = default;
};
class DeliverIncidentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeliverIncidentResponseBody() {}

  explicit DeliverIncidentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DeliverIncidentResponseBody() = default;
};
class DeliverIncidentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeliverIncidentResponseBody> body{};

  DeliverIncidentResponse() {}

  explicit DeliverIncidentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeliverIncidentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeliverIncidentResponseBody>(model1);
      }
    }
  }


  virtual ~DeliverIncidentResponse() = default;
};
class DisableEscalationPlanRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> escalationPlanId{};

  DisableEscalationPlanRequest() {}

  explicit DisableEscalationPlanRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (escalationPlanId) {
      res["escalationPlanId"] = boost::any(*escalationPlanId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("escalationPlanId") != m.end() && !m["escalationPlanId"].empty()) {
      escalationPlanId = make_shared<long>(boost::any_cast<long>(m["escalationPlanId"]));
    }
  }


  virtual ~DisableEscalationPlanRequest() = default;
};
class DisableEscalationPlanResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableEscalationPlanResponseBody() {}

  explicit DisableEscalationPlanResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DisableEscalationPlanResponseBody() = default;
};
class DisableEscalationPlanResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableEscalationPlanResponseBody> body{};

  DisableEscalationPlanResponse() {}

  explicit DisableEscalationPlanResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableEscalationPlanResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableEscalationPlanResponseBody>(model1);
      }
    }
  }


  virtual ~DisableEscalationPlanResponse() = default;
};
class DisableIntegrationConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> integrationConfigId{};

  DisableIntegrationConfigRequest() {}

  explicit DisableIntegrationConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (integrationConfigId) {
      res["integrationConfigId"] = boost::any(*integrationConfigId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("integrationConfigId") != m.end() && !m["integrationConfigId"].empty()) {
      integrationConfigId = make_shared<long>(boost::any_cast<long>(m["integrationConfigId"]));
    }
  }


  virtual ~DisableIntegrationConfigRequest() = default;
};
class DisableIntegrationConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableIntegrationConfigResponseBody() {}

  explicit DisableIntegrationConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DisableIntegrationConfigResponseBody() = default;
};
class DisableIntegrationConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableIntegrationConfigResponseBody> body{};

  DisableIntegrationConfigResponse() {}

  explicit DisableIntegrationConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableIntegrationConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableIntegrationConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DisableIntegrationConfigResponse() = default;
};
class DisableRouteRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> routeRuleId{};

  DisableRouteRuleRequest() {}

  explicit DisableRouteRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (routeRuleId) {
      res["routeRuleId"] = boost::any(*routeRuleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("routeRuleId") != m.end() && !m["routeRuleId"].empty()) {
      routeRuleId = make_shared<long>(boost::any_cast<long>(m["routeRuleId"]));
    }
  }


  virtual ~DisableRouteRuleRequest() = default;
};
class DisableRouteRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> data{};
  shared_ptr<string> requestId{};

  DisableRouteRuleResponseBody() {}

  explicit DisableRouteRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["data"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DisableRouteRuleResponseBody() = default;
};
class DisableRouteRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableRouteRuleResponseBody> body{};

  DisableRouteRuleResponse() {}

  explicit DisableRouteRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableRouteRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableRouteRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DisableRouteRuleResponse() = default;
};
class DisableServiceGroupWebhookRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> serviceGroupId{};

  DisableServiceGroupWebhookRequest() {}

  explicit DisableServiceGroupWebhookRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
  }


  virtual ~DisableServiceGroupWebhookRequest() = default;
};
class DisableServiceGroupWebhookResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableServiceGroupWebhookResponseBody() {}

  explicit DisableServiceGroupWebhookResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DisableServiceGroupWebhookResponseBody() = default;
};
class DisableServiceGroupWebhookResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableServiceGroupWebhookResponseBody> body{};

  DisableServiceGroupWebhookResponse() {}

  explicit DisableServiceGroupWebhookResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableServiceGroupWebhookResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableServiceGroupWebhookResponseBody>(model1);
      }
    }
  }


  virtual ~DisableServiceGroupWebhookResponse() = default;
};
class DisableSubscriptionRequest : public Darabonba::Model {
public:
  shared_ptr<long> subscriptionId{};

  DisableSubscriptionRequest() {}

  explicit DisableSubscriptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subscriptionId) {
      res["subscriptionId"] = boost::any(*subscriptionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("subscriptionId") != m.end() && !m["subscriptionId"].empty()) {
      subscriptionId = make_shared<long>(boost::any_cast<long>(m["subscriptionId"]));
    }
  }


  virtual ~DisableSubscriptionRequest() = default;
};
class DisableSubscriptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableSubscriptionResponseBody() {}

  explicit DisableSubscriptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~DisableSubscriptionResponseBody() = default;
};
class DisableSubscriptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DisableSubscriptionResponseBody> body{};

  DisableSubscriptionResponse() {}

  explicit DisableSubscriptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableSubscriptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableSubscriptionResponseBody>(model1);
      }
    }
  }


  virtual ~DisableSubscriptionResponse() = default;
};
class EnableEscalationPlanRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> escalationPlanId{};

  EnableEscalationPlanRequest() {}

  explicit EnableEscalationPlanRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (escalationPlanId) {
      res["escalationPlanId"] = boost::any(*escalationPlanId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("escalationPlanId") != m.end() && !m["escalationPlanId"].empty()) {
      escalationPlanId = make_shared<long>(boost::any_cast<long>(m["escalationPlanId"]));
    }
  }


  virtual ~EnableEscalationPlanRequest() = default;
};
class EnableEscalationPlanResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableEscalationPlanResponseBody() {}

  explicit EnableEscalationPlanResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~EnableEscalationPlanResponseBody() = default;
};
class EnableEscalationPlanResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableEscalationPlanResponseBody> body{};

  EnableEscalationPlanResponse() {}

  explicit EnableEscalationPlanResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableEscalationPlanResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableEscalationPlanResponseBody>(model1);
      }
    }
  }


  virtual ~EnableEscalationPlanResponse() = default;
};
class EnableIntegrationConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> integrationConfigId{};

  EnableIntegrationConfigRequest() {}

  explicit EnableIntegrationConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (integrationConfigId) {
      res["integrationConfigId"] = boost::any(*integrationConfigId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("integrationConfigId") != m.end() && !m["integrationConfigId"].empty()) {
      integrationConfigId = make_shared<long>(boost::any_cast<long>(m["integrationConfigId"]));
    }
  }


  virtual ~EnableIntegrationConfigRequest() = default;
};
class EnableIntegrationConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableIntegrationConfigResponseBody() {}

  explicit EnableIntegrationConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~EnableIntegrationConfigResponseBody() = default;
};
class EnableIntegrationConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableIntegrationConfigResponseBody> body{};

  EnableIntegrationConfigResponse() {}

  explicit EnableIntegrationConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableIntegrationConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableIntegrationConfigResponseBody>(model1);
      }
    }
  }


  virtual ~EnableIntegrationConfigResponse() = default;
};
class EnableRouteRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> routeRuleId{};

  EnableRouteRuleRequest() {}

  explicit EnableRouteRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (routeRuleId) {
      res["routeRuleId"] = boost::any(*routeRuleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("routeRuleId") != m.end() && !m["routeRuleId"].empty()) {
      routeRuleId = make_shared<long>(boost::any_cast<long>(m["routeRuleId"]));
    }
  }


  virtual ~EnableRouteRuleRequest() = default;
};
class EnableRouteRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> data{};
  shared_ptr<string> requestId{};

  EnableRouteRuleResponseBody() {}

  explicit EnableRouteRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["data"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~EnableRouteRuleResponseBody() = default;
};
class EnableRouteRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableRouteRuleResponseBody> body{};

  EnableRouteRuleResponse() {}

  explicit EnableRouteRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableRouteRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableRouteRuleResponseBody>(model1);
      }
    }
  }


  virtual ~EnableRouteRuleResponse() = default;
};
class EnableServiceGroupWebhookRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> serviceGroupId{};

  EnableServiceGroupWebhookRequest() {}

  explicit EnableServiceGroupWebhookRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
  }


  virtual ~EnableServiceGroupWebhookRequest() = default;
};
class EnableServiceGroupWebhookResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableServiceGroupWebhookResponseBody() {}

  explicit EnableServiceGroupWebhookResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~EnableServiceGroupWebhookResponseBody() = default;
};
class EnableServiceGroupWebhookResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableServiceGroupWebhookResponseBody> body{};

  EnableServiceGroupWebhookResponse() {}

  explicit EnableServiceGroupWebhookResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableServiceGroupWebhookResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableServiceGroupWebhookResponseBody>(model1);
      }
    }
  }


  virtual ~EnableServiceGroupWebhookResponse() = default;
};
class EnableSubscriptionRequest : public Darabonba::Model {
public:
  shared_ptr<long> subscriptionId{};

  EnableSubscriptionRequest() {}

  explicit EnableSubscriptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subscriptionId) {
      res["subscriptionId"] = boost::any(*subscriptionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("subscriptionId") != m.end() && !m["subscriptionId"].empty()) {
      subscriptionId = make_shared<long>(boost::any_cast<long>(m["subscriptionId"]));
    }
  }


  virtual ~EnableSubscriptionRequest() = default;
};
class EnableSubscriptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableSubscriptionResponseBody() {}

  explicit EnableSubscriptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~EnableSubscriptionResponseBody() = default;
};
class EnableSubscriptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EnableSubscriptionResponseBody> body{};

  EnableSubscriptionResponse() {}

  explicit EnableSubscriptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableSubscriptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableSubscriptionResponseBody>(model1);
      }
    }
  }


  virtual ~EnableSubscriptionResponse() = default;
};
class FinishIncidentRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> incidentFinishReason{};
  shared_ptr<string> incidentFinishReasonDescription{};
  shared_ptr<long> incidentFinishSolution{};
  shared_ptr<string> incidentFinishSolutionDescription{};
  shared_ptr<vector<long>> incidentIds{};

  FinishIncidentRequest() {}

  explicit FinishIncidentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (incidentFinishReason) {
      res["incidentFinishReason"] = boost::any(*incidentFinishReason);
    }
    if (incidentFinishReasonDescription) {
      res["incidentFinishReasonDescription"] = boost::any(*incidentFinishReasonDescription);
    }
    if (incidentFinishSolution) {
      res["incidentFinishSolution"] = boost::any(*incidentFinishSolution);
    }
    if (incidentFinishSolutionDescription) {
      res["incidentFinishSolutionDescription"] = boost::any(*incidentFinishSolutionDescription);
    }
    if (incidentIds) {
      res["incidentIds"] = boost::any(*incidentIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("incidentFinishReason") != m.end() && !m["incidentFinishReason"].empty()) {
      incidentFinishReason = make_shared<long>(boost::any_cast<long>(m["incidentFinishReason"]));
    }
    if (m.find("incidentFinishReasonDescription") != m.end() && !m["incidentFinishReasonDescription"].empty()) {
      incidentFinishReasonDescription = make_shared<string>(boost::any_cast<string>(m["incidentFinishReasonDescription"]));
    }
    if (m.find("incidentFinishSolution") != m.end() && !m["incidentFinishSolution"].empty()) {
      incidentFinishSolution = make_shared<long>(boost::any_cast<long>(m["incidentFinishSolution"]));
    }
    if (m.find("incidentFinishSolutionDescription") != m.end() && !m["incidentFinishSolutionDescription"].empty()) {
      incidentFinishSolutionDescription = make_shared<string>(boost::any_cast<string>(m["incidentFinishSolutionDescription"]));
    }
    if (m.find("incidentIds") != m.end() && !m["incidentIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["incidentIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["incidentIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      incidentIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~FinishIncidentRequest() = default;
};
class FinishIncidentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  FinishIncidentResponseBody() {}

  explicit FinishIncidentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~FinishIncidentResponseBody() = default;
};
class FinishIncidentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FinishIncidentResponseBody> body{};

  FinishIncidentResponse() {}

  explicit FinishIncidentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FinishIncidentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FinishIncidentResponseBody>(model1);
      }
    }
  }


  virtual ~FinishIncidentResponse() = default;
};
class FinishProblemRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> problemId{};

  FinishProblemRequest() {}

  explicit FinishProblemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
  }


  virtual ~FinishProblemRequest() = default;
};
class FinishProblemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  FinishProblemResponseBody() {}

  explicit FinishProblemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~FinishProblemResponseBody() = default;
};
class FinishProblemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FinishProblemResponseBody> body{};

  FinishProblemResponse() {}

  explicit FinishProblemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FinishProblemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FinishProblemResponseBody>(model1);
      }
    }
  }


  virtual ~FinishProblemResponse() = default;
};
class GeneratePictureLinkRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> keys{};
  shared_ptr<long> problemId{};

  GeneratePictureLinkRequest() {}

  explicit GeneratePictureLinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keys) {
      res["keys"] = boost::any(*keys);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("keys") != m.end() && !m["keys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["keys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["keys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      keys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
  }


  virtual ~GeneratePictureLinkRequest() = default;
};
class GeneratePictureLinkResponseBodyDataLinks : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> link{};

  GeneratePictureLinkResponseBodyDataLinks() {}

  explicit GeneratePictureLinkResponseBodyDataLinks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (link) {
      res["link"] = boost::any(*link);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("link") != m.end() && !m["link"].empty()) {
      link = make_shared<string>(boost::any_cast<string>(m["link"]));
    }
  }


  virtual ~GeneratePictureLinkResponseBodyDataLinks() = default;
};
class GeneratePictureLinkResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GeneratePictureLinkResponseBodyDataLinks>> links{};

  GeneratePictureLinkResponseBodyData() {}

  explicit GeneratePictureLinkResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (links) {
      vector<boost::any> temp1;
      for(auto item1:*links){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["links"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("links") != m.end() && !m["links"].empty()) {
      if (typeid(vector<boost::any>) == m["links"].type()) {
        vector<GeneratePictureLinkResponseBodyDataLinks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["links"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GeneratePictureLinkResponseBodyDataLinks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        links = make_shared<vector<GeneratePictureLinkResponseBodyDataLinks>>(expect1);
      }
    }
  }


  virtual ~GeneratePictureLinkResponseBodyData() = default;
};
class GeneratePictureLinkResponseBody : public Darabonba::Model {
public:
  shared_ptr<GeneratePictureLinkResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GeneratePictureLinkResponseBody() {}

  explicit GeneratePictureLinkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GeneratePictureLinkResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GeneratePictureLinkResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GeneratePictureLinkResponseBody() = default;
};
class GeneratePictureLinkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GeneratePictureLinkResponseBody> body{};

  GeneratePictureLinkResponse() {}

  explicit GeneratePictureLinkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GeneratePictureLinkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GeneratePictureLinkResponseBody>(model1);
      }
    }
  }


  virtual ~GeneratePictureLinkResponse() = default;
};
class GeneratePictureUploadSignRequestFiles : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<long> fileSize{};
  shared_ptr<string> fileType{};

  GeneratePictureUploadSignRequestFiles() {}

  explicit GeneratePictureUploadSignRequestFiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["fileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["fileSize"] = boost::any(*fileSize);
    }
    if (fileType) {
      res["fileType"] = boost::any(*fileType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fileName") != m.end() && !m["fileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["fileName"]));
    }
    if (m.find("fileSize") != m.end() && !m["fileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["fileSize"]));
    }
    if (m.find("fileType") != m.end() && !m["fileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["fileType"]));
    }
  }


  virtual ~GeneratePictureUploadSignRequestFiles() = default;
};
class GeneratePictureUploadSignRequest : public Darabonba::Model {
public:
  shared_ptr<vector<GeneratePictureUploadSignRequestFiles>> files{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> instanceType{};

  GeneratePictureUploadSignRequest() {}

  explicit GeneratePictureUploadSignRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (files) {
      vector<boost::any> temp1;
      for(auto item1:*files){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["files"] = boost::any(temp1);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["instanceType"] = boost::any(*instanceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("files") != m.end() && !m["files"].empty()) {
      if (typeid(vector<boost::any>) == m["files"].type()) {
        vector<GeneratePictureUploadSignRequestFiles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["files"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GeneratePictureUploadSignRequestFiles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        files = make_shared<vector<GeneratePictureUploadSignRequestFiles>>(expect1);
      }
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["instanceId"]));
    }
    if (m.find("instanceType") != m.end() && !m["instanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["instanceType"]));
    }
  }


  virtual ~GeneratePictureUploadSignRequest() = default;
};
class GeneratePictureUploadSignResponseBodyDataFiles : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<long> fileSize{};
  shared_ptr<string> fileType{};
  shared_ptr<string> key{};

  GeneratePictureUploadSignResponseBodyDataFiles() {}

  explicit GeneratePictureUploadSignResponseBodyDataFiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["fileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["fileSize"] = boost::any(*fileSize);
    }
    if (fileType) {
      res["fileType"] = boost::any(*fileType);
    }
    if (key) {
      res["key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fileName") != m.end() && !m["fileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["fileName"]));
    }
    if (m.find("fileSize") != m.end() && !m["fileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["fileSize"]));
    }
    if (m.find("fileType") != m.end() && !m["fileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["fileType"]));
    }
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
  }


  virtual ~GeneratePictureUploadSignResponseBodyDataFiles() = default;
};
class GeneratePictureUploadSignResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> accessKeyId{};
  shared_ptr<string> bucketName{};
  shared_ptr<vector<GeneratePictureUploadSignResponseBodyDataFiles>> files{};
  shared_ptr<string> policy{};
  shared_ptr<string> signature{};
  shared_ptr<string> url{};

  GeneratePictureUploadSignResponseBodyData() {}

  explicit GeneratePictureUploadSignResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKeyId) {
      res["accessKeyId"] = boost::any(*accessKeyId);
    }
    if (bucketName) {
      res["bucketName"] = boost::any(*bucketName);
    }
    if (files) {
      vector<boost::any> temp1;
      for(auto item1:*files){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["files"] = boost::any(temp1);
    }
    if (policy) {
      res["policy"] = boost::any(*policy);
    }
    if (signature) {
      res["signature"] = boost::any(*signature);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessKeyId") != m.end() && !m["accessKeyId"].empty()) {
      accessKeyId = make_shared<string>(boost::any_cast<string>(m["accessKeyId"]));
    }
    if (m.find("bucketName") != m.end() && !m["bucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["bucketName"]));
    }
    if (m.find("files") != m.end() && !m["files"].empty()) {
      if (typeid(vector<boost::any>) == m["files"].type()) {
        vector<GeneratePictureUploadSignResponseBodyDataFiles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["files"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GeneratePictureUploadSignResponseBodyDataFiles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        files = make_shared<vector<GeneratePictureUploadSignResponseBodyDataFiles>>(expect1);
      }
    }
    if (m.find("policy") != m.end() && !m["policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["policy"]));
    }
    if (m.find("signature") != m.end() && !m["signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["signature"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~GeneratePictureUploadSignResponseBodyData() = default;
};
class GeneratePictureUploadSignResponseBody : public Darabonba::Model {
public:
  shared_ptr<GeneratePictureUploadSignResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GeneratePictureUploadSignResponseBody() {}

  explicit GeneratePictureUploadSignResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GeneratePictureUploadSignResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GeneratePictureUploadSignResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GeneratePictureUploadSignResponseBody() = default;
};
class GeneratePictureUploadSignResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GeneratePictureUploadSignResponseBody> body{};

  GeneratePictureUploadSignResponse() {}

  explicit GeneratePictureUploadSignResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GeneratePictureUploadSignResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GeneratePictureUploadSignResponseBody>(model1);
      }
    }
  }


  virtual ~GeneratePictureUploadSignResponse() = default;
};
class GenerateProblemPictureLinkRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> keys{};
  shared_ptr<string> problemId{};

  GenerateProblemPictureLinkRequest() {}

  explicit GenerateProblemPictureLinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keys) {
      res["keys"] = boost::any(*keys);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("keys") != m.end() && !m["keys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["keys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["keys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      keys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<string>(boost::any_cast<string>(m["problemId"]));
    }
  }


  virtual ~GenerateProblemPictureLinkRequest() = default;
};
class GenerateProblemPictureLinkResponseBodyDataLinks : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> link{};

  GenerateProblemPictureLinkResponseBodyDataLinks() {}

  explicit GenerateProblemPictureLinkResponseBodyDataLinks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (link) {
      res["link"] = boost::any(*link);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("link") != m.end() && !m["link"].empty()) {
      link = make_shared<string>(boost::any_cast<string>(m["link"]));
    }
  }


  virtual ~GenerateProblemPictureLinkResponseBodyDataLinks() = default;
};
class GenerateProblemPictureLinkResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GenerateProblemPictureLinkResponseBodyDataLinks>> links{};

  GenerateProblemPictureLinkResponseBodyData() {}

  explicit GenerateProblemPictureLinkResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (links) {
      vector<boost::any> temp1;
      for(auto item1:*links){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["links"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("links") != m.end() && !m["links"].empty()) {
      if (typeid(vector<boost::any>) == m["links"].type()) {
        vector<GenerateProblemPictureLinkResponseBodyDataLinks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["links"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GenerateProblemPictureLinkResponseBodyDataLinks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        links = make_shared<vector<GenerateProblemPictureLinkResponseBodyDataLinks>>(expect1);
      }
    }
  }


  virtual ~GenerateProblemPictureLinkResponseBodyData() = default;
};
class GenerateProblemPictureLinkResponseBody : public Darabonba::Model {
public:
  shared_ptr<GenerateProblemPictureLinkResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GenerateProblemPictureLinkResponseBody() {}

  explicit GenerateProblemPictureLinkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GenerateProblemPictureLinkResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GenerateProblemPictureLinkResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GenerateProblemPictureLinkResponseBody() = default;
};
class GenerateProblemPictureLinkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GenerateProblemPictureLinkResponseBody> body{};

  GenerateProblemPictureLinkResponse() {}

  explicit GenerateProblemPictureLinkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateProblemPictureLinkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateProblemPictureLinkResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateProblemPictureLinkResponse() = default;
};
class GenerateProblemPictureUploadSignRequest : public Darabonba::Model {
public:
  shared_ptr<string> fileName{};
  shared_ptr<long> fileSize{};
  shared_ptr<string> fileType{};
  shared_ptr<long> problemId{};

  GenerateProblemPictureUploadSignRequest() {}

  explicit GenerateProblemPictureUploadSignRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileName) {
      res["fileName"] = boost::any(*fileName);
    }
    if (fileSize) {
      res["fileSize"] = boost::any(*fileSize);
    }
    if (fileType) {
      res["fileType"] = boost::any(*fileType);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fileName") != m.end() && !m["fileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["fileName"]));
    }
    if (m.find("fileSize") != m.end() && !m["fileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["fileSize"]));
    }
    if (m.find("fileType") != m.end() && !m["fileType"].empty()) {
      fileType = make_shared<string>(boost::any_cast<string>(m["fileType"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
  }


  virtual ~GenerateProblemPictureUploadSignRequest() = default;
};
class GenerateProblemPictureUploadSignResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> accessKeyId{};
  shared_ptr<string> bucketName{};
  shared_ptr<string> key{};
  shared_ptr<string> policy{};
  shared_ptr<string> signature{};
  shared_ptr<string> url{};

  GenerateProblemPictureUploadSignResponseBodyData() {}

  explicit GenerateProblemPictureUploadSignResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKeyId) {
      res["accessKeyId"] = boost::any(*accessKeyId);
    }
    if (bucketName) {
      res["bucketName"] = boost::any(*bucketName);
    }
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (policy) {
      res["policy"] = boost::any(*policy);
    }
    if (signature) {
      res["signature"] = boost::any(*signature);
    }
    if (url) {
      res["url"] = boost::any(*url);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessKeyId") != m.end() && !m["accessKeyId"].empty()) {
      accessKeyId = make_shared<string>(boost::any_cast<string>(m["accessKeyId"]));
    }
    if (m.find("bucketName") != m.end() && !m["bucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["bucketName"]));
    }
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("policy") != m.end() && !m["policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["policy"]));
    }
    if (m.find("signature") != m.end() && !m["signature"].empty()) {
      signature = make_shared<string>(boost::any_cast<string>(m["signature"]));
    }
    if (m.find("url") != m.end() && !m["url"].empty()) {
      url = make_shared<string>(boost::any_cast<string>(m["url"]));
    }
  }


  virtual ~GenerateProblemPictureUploadSignResponseBodyData() = default;
};
class GenerateProblemPictureUploadSignResponseBody : public Darabonba::Model {
public:
  shared_ptr<GenerateProblemPictureUploadSignResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GenerateProblemPictureUploadSignResponseBody() {}

  explicit GenerateProblemPictureUploadSignResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GenerateProblemPictureUploadSignResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GenerateProblemPictureUploadSignResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GenerateProblemPictureUploadSignResponseBody() = default;
};
class GenerateProblemPictureUploadSignResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GenerateProblemPictureUploadSignResponseBody> body{};

  GenerateProblemPictureUploadSignResponse() {}

  explicit GenerateProblemPictureUploadSignResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateProblemPictureUploadSignResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateProblemPictureUploadSignResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateProblemPictureUploadSignResponse() = default;
};
class GetEscalationPlanRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> escalationPlanId{};

  GetEscalationPlanRequest() {}

  explicit GetEscalationPlanRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (escalationPlanId) {
      res["escalationPlanId"] = boost::any(*escalationPlanId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("escalationPlanId") != m.end() && !m["escalationPlanId"].empty()) {
      escalationPlanId = make_shared<long>(boost::any_cast<long>(m["escalationPlanId"]));
    }
  }


  virtual ~GetEscalationPlanRequest() = default;
};
class GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanConditions : public Darabonba::Model {
public:
  shared_ptr<string> effection{};
  shared_ptr<string> level{};

  GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanConditions() {}

  explicit GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effection) {
      res["effection"] = boost::any(*effection);
    }
    if (level) {
      res["level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("effection") != m.end() && !m["effection"].empty()) {
      effection = make_shared<string>(boost::any_cast<string>(m["effection"]));
    }
    if (m.find("level") != m.end() && !m["level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["level"]));
    }
  }


  virtual ~GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanConditions() = default;
};
class GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanStrategiesNoticeObjectList : public Darabonba::Model {
public:
  shared_ptr<long> noticeObjectId{};
  shared_ptr<string> noticeObjectName{};

  GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanStrategiesNoticeObjectList() {}

  explicit GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanStrategiesNoticeObjectList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (noticeObjectId) {
      res["noticeObjectId"] = boost::any(*noticeObjectId);
    }
    if (noticeObjectName) {
      res["noticeObjectName"] = boost::any(*noticeObjectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("noticeObjectId") != m.end() && !m["noticeObjectId"].empty()) {
      noticeObjectId = make_shared<long>(boost::any_cast<long>(m["noticeObjectId"]));
    }
    if (m.find("noticeObjectName") != m.end() && !m["noticeObjectName"].empty()) {
      noticeObjectName = make_shared<string>(boost::any_cast<string>(m["noticeObjectName"]));
    }
  }


  virtual ~GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanStrategiesNoticeObjectList() = default;
};
class GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanStrategiesServiceGroups : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> serviceGroupName{};

  GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanStrategiesServiceGroups() {}

  explicit GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanStrategiesServiceGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (serviceGroupName) {
      res["serviceGroupName"] = boost::any(*serviceGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("serviceGroupName") != m.end() && !m["serviceGroupName"].empty()) {
      serviceGroupName = make_shared<string>(boost::any_cast<string>(m["serviceGroupName"]));
    }
  }


  virtual ~GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanStrategiesServiceGroups() = default;
};
class GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanStrategies : public Darabonba::Model {
public:
  shared_ptr<bool> enableWebhook{};
  shared_ptr<string> escalationPlanType{};
  shared_ptr<string> noticeChannels{};
  shared_ptr<vector<GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanStrategiesNoticeObjectList>> noticeObjectList{};
  shared_ptr<long> noticeTime{};
  shared_ptr<vector<GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanStrategiesServiceGroups>> serviceGroups{};

  GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanStrategies() {}

  explicit GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanStrategies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableWebhook) {
      res["enableWebhook"] = boost::any(*enableWebhook);
    }
    if (escalationPlanType) {
      res["escalationPlanType"] = boost::any(*escalationPlanType);
    }
    if (noticeChannels) {
      res["noticeChannels"] = boost::any(*noticeChannels);
    }
    if (noticeObjectList) {
      vector<boost::any> temp1;
      for(auto item1:*noticeObjectList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["noticeObjectList"] = boost::any(temp1);
    }
    if (noticeTime) {
      res["noticeTime"] = boost::any(*noticeTime);
    }
    if (serviceGroups) {
      vector<boost::any> temp1;
      for(auto item1:*serviceGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["serviceGroups"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enableWebhook") != m.end() && !m["enableWebhook"].empty()) {
      enableWebhook = make_shared<bool>(boost::any_cast<bool>(m["enableWebhook"]));
    }
    if (m.find("escalationPlanType") != m.end() && !m["escalationPlanType"].empty()) {
      escalationPlanType = make_shared<string>(boost::any_cast<string>(m["escalationPlanType"]));
    }
    if (m.find("noticeChannels") != m.end() && !m["noticeChannels"].empty()) {
      noticeChannels = make_shared<string>(boost::any_cast<string>(m["noticeChannels"]));
    }
    if (m.find("noticeObjectList") != m.end() && !m["noticeObjectList"].empty()) {
      if (typeid(vector<boost::any>) == m["noticeObjectList"].type()) {
        vector<GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanStrategiesNoticeObjectList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["noticeObjectList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanStrategiesNoticeObjectList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        noticeObjectList = make_shared<vector<GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanStrategiesNoticeObjectList>>(expect1);
      }
    }
    if (m.find("noticeTime") != m.end() && !m["noticeTime"].empty()) {
      noticeTime = make_shared<long>(boost::any_cast<long>(m["noticeTime"]));
    }
    if (m.find("serviceGroups") != m.end() && !m["serviceGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["serviceGroups"].type()) {
        vector<GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanStrategiesServiceGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["serviceGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanStrategiesServiceGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceGroups = make_shared<vector<GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanStrategiesServiceGroups>>(expect1);
      }
    }
  }


  virtual ~GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanStrategies() = default;
};
class GetEscalationPlanResponseBodyDataEscalationPlanRules : public Darabonba::Model {
public:
  shared_ptr<vector<GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanConditions>> escalationPlanConditions{};
  shared_ptr<long> escalationPlanRuleId{};
  shared_ptr<vector<GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanStrategies>> escalationPlanStrategies{};

  GetEscalationPlanResponseBodyDataEscalationPlanRules() {}

  explicit GetEscalationPlanResponseBodyDataEscalationPlanRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalationPlanConditions) {
      vector<boost::any> temp1;
      for(auto item1:*escalationPlanConditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["escalationPlanConditions"] = boost::any(temp1);
    }
    if (escalationPlanRuleId) {
      res["escalationPlanRuleId"] = boost::any(*escalationPlanRuleId);
    }
    if (escalationPlanStrategies) {
      vector<boost::any> temp1;
      for(auto item1:*escalationPlanStrategies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["escalationPlanStrategies"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("escalationPlanConditions") != m.end() && !m["escalationPlanConditions"].empty()) {
      if (typeid(vector<boost::any>) == m["escalationPlanConditions"].type()) {
        vector<GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["escalationPlanConditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        escalationPlanConditions = make_shared<vector<GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanConditions>>(expect1);
      }
    }
    if (m.find("escalationPlanRuleId") != m.end() && !m["escalationPlanRuleId"].empty()) {
      escalationPlanRuleId = make_shared<long>(boost::any_cast<long>(m["escalationPlanRuleId"]));
    }
    if (m.find("escalationPlanStrategies") != m.end() && !m["escalationPlanStrategies"].empty()) {
      if (typeid(vector<boost::any>) == m["escalationPlanStrategies"].type()) {
        vector<GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanStrategies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["escalationPlanStrategies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanStrategies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        escalationPlanStrategies = make_shared<vector<GetEscalationPlanResponseBodyDataEscalationPlanRulesEscalationPlanStrategies>>(expect1);
      }
    }
  }


  virtual ~GetEscalationPlanResponseBodyDataEscalationPlanRules() = default;
};
class GetEscalationPlanResponseBodyDataEscalationPlanScopeObjects : public Darabonba::Model {
public:
  shared_ptr<long> escalationPlanScopeObjects{};
  shared_ptr<string> scope{};
  shared_ptr<long> scopeObjectDeletedType{};
  shared_ptr<long> scopeObjectId{};
  shared_ptr<string> scopeObjectName{};

  GetEscalationPlanResponseBodyDataEscalationPlanScopeObjects() {}

  explicit GetEscalationPlanResponseBodyDataEscalationPlanScopeObjects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalationPlanScopeObjects) {
      res["escalationPlanScopeObjects"] = boost::any(*escalationPlanScopeObjects);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (scopeObjectDeletedType) {
      res["scopeObjectDeletedType"] = boost::any(*scopeObjectDeletedType);
    }
    if (scopeObjectId) {
      res["scopeObjectId"] = boost::any(*scopeObjectId);
    }
    if (scopeObjectName) {
      res["scopeObjectName"] = boost::any(*scopeObjectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("escalationPlanScopeObjects") != m.end() && !m["escalationPlanScopeObjects"].empty()) {
      escalationPlanScopeObjects = make_shared<long>(boost::any_cast<long>(m["escalationPlanScopeObjects"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
    if (m.find("scopeObjectDeletedType") != m.end() && !m["scopeObjectDeletedType"].empty()) {
      scopeObjectDeletedType = make_shared<long>(boost::any_cast<long>(m["scopeObjectDeletedType"]));
    }
    if (m.find("scopeObjectId") != m.end() && !m["scopeObjectId"].empty()) {
      scopeObjectId = make_shared<long>(boost::any_cast<long>(m["scopeObjectId"]));
    }
    if (m.find("scopeObjectName") != m.end() && !m["scopeObjectName"].empty()) {
      scopeObjectName = make_shared<string>(boost::any_cast<string>(m["scopeObjectName"]));
    }
  }


  virtual ~GetEscalationPlanResponseBodyDataEscalationPlanScopeObjects() = default;
};
class GetEscalationPlanResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> escalationPlanDescription{};
  shared_ptr<long> escalationPlanId{};
  shared_ptr<string> escalationPlanName{};
  shared_ptr<vector<GetEscalationPlanResponseBodyDataEscalationPlanRules>> escalationPlanRules{};
  shared_ptr<vector<GetEscalationPlanResponseBodyDataEscalationPlanScopeObjects>> escalationPlanScopeObjects{};

  GetEscalationPlanResponseBodyData() {}

  explicit GetEscalationPlanResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (escalationPlanDescription) {
      res["escalationPlanDescription"] = boost::any(*escalationPlanDescription);
    }
    if (escalationPlanId) {
      res["escalationPlanId"] = boost::any(*escalationPlanId);
    }
    if (escalationPlanName) {
      res["escalationPlanName"] = boost::any(*escalationPlanName);
    }
    if (escalationPlanRules) {
      vector<boost::any> temp1;
      for(auto item1:*escalationPlanRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["escalationPlanRules"] = boost::any(temp1);
    }
    if (escalationPlanScopeObjects) {
      vector<boost::any> temp1;
      for(auto item1:*escalationPlanScopeObjects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["escalationPlanScopeObjects"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("escalationPlanDescription") != m.end() && !m["escalationPlanDescription"].empty()) {
      escalationPlanDescription = make_shared<string>(boost::any_cast<string>(m["escalationPlanDescription"]));
    }
    if (m.find("escalationPlanId") != m.end() && !m["escalationPlanId"].empty()) {
      escalationPlanId = make_shared<long>(boost::any_cast<long>(m["escalationPlanId"]));
    }
    if (m.find("escalationPlanName") != m.end() && !m["escalationPlanName"].empty()) {
      escalationPlanName = make_shared<string>(boost::any_cast<string>(m["escalationPlanName"]));
    }
    if (m.find("escalationPlanRules") != m.end() && !m["escalationPlanRules"].empty()) {
      if (typeid(vector<boost::any>) == m["escalationPlanRules"].type()) {
        vector<GetEscalationPlanResponseBodyDataEscalationPlanRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["escalationPlanRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEscalationPlanResponseBodyDataEscalationPlanRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        escalationPlanRules = make_shared<vector<GetEscalationPlanResponseBodyDataEscalationPlanRules>>(expect1);
      }
    }
    if (m.find("escalationPlanScopeObjects") != m.end() && !m["escalationPlanScopeObjects"].empty()) {
      if (typeid(vector<boost::any>) == m["escalationPlanScopeObjects"].type()) {
        vector<GetEscalationPlanResponseBodyDataEscalationPlanScopeObjects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["escalationPlanScopeObjects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEscalationPlanResponseBodyDataEscalationPlanScopeObjects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        escalationPlanScopeObjects = make_shared<vector<GetEscalationPlanResponseBodyDataEscalationPlanScopeObjects>>(expect1);
      }
    }
  }


  virtual ~GetEscalationPlanResponseBodyData() = default;
};
class GetEscalationPlanResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetEscalationPlanResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetEscalationPlanResponseBody() {}

  explicit GetEscalationPlanResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GetEscalationPlanResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GetEscalationPlanResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetEscalationPlanResponseBody() = default;
};
class GetEscalationPlanResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEscalationPlanResponseBody> body{};

  GetEscalationPlanResponse() {}

  explicit GetEscalationPlanResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEscalationPlanResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEscalationPlanResponseBody>(model1);
      }
    }
  }


  virtual ~GetEscalationPlanResponse() = default;
};
class GetEventRequest : public Darabonba::Model {
public:
  shared_ptr<long> monitorSourceId{};

  GetEventRequest() {}

  explicit GetEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorSourceId) {
      res["monitorSourceId"] = boost::any(*monitorSourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("monitorSourceId") != m.end() && !m["monitorSourceId"].empty()) {
      monitorSourceId = make_shared<long>(boost::any_cast<long>(m["monitorSourceId"]));
    }
  }


  virtual ~GetEventRequest() = default;
};
class GetEventResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> eventJson{};
  shared_ptr<string> eventTime{};
  shared_ptr<long> monitorSourceId{};
  shared_ptr<string> monitorSourceName{};

  GetEventResponseBodyData() {}

  explicit GetEventResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventJson) {
      res["eventJson"] = boost::any(*eventJson);
    }
    if (eventTime) {
      res["eventTime"] = boost::any(*eventTime);
    }
    if (monitorSourceId) {
      res["monitorSourceId"] = boost::any(*monitorSourceId);
    }
    if (monitorSourceName) {
      res["monitorSourceName"] = boost::any(*monitorSourceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("eventJson") != m.end() && !m["eventJson"].empty()) {
      eventJson = make_shared<string>(boost::any_cast<string>(m["eventJson"]));
    }
    if (m.find("eventTime") != m.end() && !m["eventTime"].empty()) {
      eventTime = make_shared<string>(boost::any_cast<string>(m["eventTime"]));
    }
    if (m.find("monitorSourceId") != m.end() && !m["monitorSourceId"].empty()) {
      monitorSourceId = make_shared<long>(boost::any_cast<long>(m["monitorSourceId"]));
    }
    if (m.find("monitorSourceName") != m.end() && !m["monitorSourceName"].empty()) {
      monitorSourceName = make_shared<string>(boost::any_cast<string>(m["monitorSourceName"]));
    }
  }


  virtual ~GetEventResponseBodyData() = default;
};
class GetEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetEventResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetEventResponseBody() {}

  explicit GetEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GetEventResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GetEventResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetEventResponseBody() = default;
};
class GetEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEventResponseBody> body{};

  GetEventResponse() {}

  explicit GetEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEventResponseBody>(model1);
      }
    }
  }


  virtual ~GetEventResponse() = default;
};
class GetHomePageGuidanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};

  GetHomePageGuidanceRequest() {}

  explicit GetHomePageGuidanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~GetHomePageGuidanceRequest() = default;
};
class GetHomePageGuidanceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> notifySubscriptionStatus{};
  shared_ptr<bool> serviceGroupStatus{};
  shared_ptr<bool> serviceStatus{};
  shared_ptr<bool> usersStatus{};

  GetHomePageGuidanceResponseBodyData() {}

  explicit GetHomePageGuidanceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notifySubscriptionStatus) {
      res["notifySubscriptionStatus"] = boost::any(*notifySubscriptionStatus);
    }
    if (serviceGroupStatus) {
      res["serviceGroupStatus"] = boost::any(*serviceGroupStatus);
    }
    if (serviceStatus) {
      res["serviceStatus"] = boost::any(*serviceStatus);
    }
    if (usersStatus) {
      res["usersStatus"] = boost::any(*usersStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("notifySubscriptionStatus") != m.end() && !m["notifySubscriptionStatus"].empty()) {
      notifySubscriptionStatus = make_shared<bool>(boost::any_cast<bool>(m["notifySubscriptionStatus"]));
    }
    if (m.find("serviceGroupStatus") != m.end() && !m["serviceGroupStatus"].empty()) {
      serviceGroupStatus = make_shared<bool>(boost::any_cast<bool>(m["serviceGroupStatus"]));
    }
    if (m.find("serviceStatus") != m.end() && !m["serviceStatus"].empty()) {
      serviceStatus = make_shared<bool>(boost::any_cast<bool>(m["serviceStatus"]));
    }
    if (m.find("usersStatus") != m.end() && !m["usersStatus"].empty()) {
      usersStatus = make_shared<bool>(boost::any_cast<bool>(m["usersStatus"]));
    }
  }


  virtual ~GetHomePageGuidanceResponseBodyData() = default;
};
class GetHomePageGuidanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetHomePageGuidanceResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetHomePageGuidanceResponseBody() {}

  explicit GetHomePageGuidanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GetHomePageGuidanceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GetHomePageGuidanceResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetHomePageGuidanceResponseBody() = default;
};
class GetHomePageGuidanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetHomePageGuidanceResponseBody> body{};

  GetHomePageGuidanceResponse() {}

  explicit GetHomePageGuidanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetHomePageGuidanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetHomePageGuidanceResponseBody>(model1);
      }
    }
  }


  virtual ~GetHomePageGuidanceResponse() = default;
};
class GetIncidentRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> incidentId{};

  GetIncidentRequest() {}

  explicit GetIncidentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (incidentId) {
      res["incidentId"] = boost::any(*incidentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("incidentId") != m.end() && !m["incidentId"].empty()) {
      incidentId = make_shared<long>(boost::any_cast<long>(m["incidentId"]));
    }
  }


  virtual ~GetIncidentRequest() = default;
};
class GetIncidentResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> assignToWhoIsValid{};
  shared_ptr<long> assignUserId{};
  shared_ptr<string> assignUserName{};
  shared_ptr<string> assignUserPhone{};
  shared_ptr<string> createTime{};
  shared_ptr<long> defaultAssignToWho{};
  shared_ptr<long> defaultAssignToWhoIsValid{};
  shared_ptr<string> defaultAssignToWhoName{};
  shared_ptr<long> durationTime{};
  shared_ptr<string> effect{};
  shared_ptr<string> incidentDescription{};
  shared_ptr<long> incidentId{};
  shared_ptr<string> incidentLevel{};
  shared_ptr<string> incidentNumber{};
  shared_ptr<string> incidentStatus{};
  shared_ptr<string> incidentTitle{};
  shared_ptr<bool> isManual{};
  shared_ptr<bool> isUpgrade{};
  shared_ptr<vector<string>> notifyChannels{};
  shared_ptr<long> problemId{};
  shared_ptr<string> problemNumber{};
  shared_ptr<long> relRouteRuleDeleteType{};
  shared_ptr<long> relServiceDeleteType{};
  shared_ptr<long> relServiceGroupIsValid{};
  shared_ptr<string> relatedServiceDescription{};
  shared_ptr<long> relatedServiceGroupId{};
  shared_ptr<string> relatedServiceGroupName{};
  shared_ptr<long> relatedServiceId{};
  shared_ptr<string> relatedServiceName{};
  shared_ptr<long> routeRuleId{};
  shared_ptr<string> routeRuleName{};

  GetIncidentResponseBodyData() {}

  explicit GetIncidentResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignToWhoIsValid) {
      res["assignToWhoIsValid"] = boost::any(*assignToWhoIsValid);
    }
    if (assignUserId) {
      res["assignUserId"] = boost::any(*assignUserId);
    }
    if (assignUserName) {
      res["assignUserName"] = boost::any(*assignUserName);
    }
    if (assignUserPhone) {
      res["assignUserPhone"] = boost::any(*assignUserPhone);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (defaultAssignToWho) {
      res["defaultAssignToWho"] = boost::any(*defaultAssignToWho);
    }
    if (defaultAssignToWhoIsValid) {
      res["defaultAssignToWhoIsValid"] = boost::any(*defaultAssignToWhoIsValid);
    }
    if (defaultAssignToWhoName) {
      res["defaultAssignToWhoName"] = boost::any(*defaultAssignToWhoName);
    }
    if (durationTime) {
      res["durationTime"] = boost::any(*durationTime);
    }
    if (effect) {
      res["effect"] = boost::any(*effect);
    }
    if (incidentDescription) {
      res["incidentDescription"] = boost::any(*incidentDescription);
    }
    if (incidentId) {
      res["incidentId"] = boost::any(*incidentId);
    }
    if (incidentLevel) {
      res["incidentLevel"] = boost::any(*incidentLevel);
    }
    if (incidentNumber) {
      res["incidentNumber"] = boost::any(*incidentNumber);
    }
    if (incidentStatus) {
      res["incidentStatus"] = boost::any(*incidentStatus);
    }
    if (incidentTitle) {
      res["incidentTitle"] = boost::any(*incidentTitle);
    }
    if (isManual) {
      res["isManual"] = boost::any(*isManual);
    }
    if (isUpgrade) {
      res["isUpgrade"] = boost::any(*isUpgrade);
    }
    if (notifyChannels) {
      res["notifyChannels"] = boost::any(*notifyChannels);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    if (problemNumber) {
      res["problemNumber"] = boost::any(*problemNumber);
    }
    if (relRouteRuleDeleteType) {
      res["relRouteRuleDeleteType"] = boost::any(*relRouteRuleDeleteType);
    }
    if (relServiceDeleteType) {
      res["relServiceDeleteType"] = boost::any(*relServiceDeleteType);
    }
    if (relServiceGroupIsValid) {
      res["relServiceGroupIsValid"] = boost::any(*relServiceGroupIsValid);
    }
    if (relatedServiceDescription) {
      res["relatedServiceDescription"] = boost::any(*relatedServiceDescription);
    }
    if (relatedServiceGroupId) {
      res["relatedServiceGroupId"] = boost::any(*relatedServiceGroupId);
    }
    if (relatedServiceGroupName) {
      res["relatedServiceGroupName"] = boost::any(*relatedServiceGroupName);
    }
    if (relatedServiceId) {
      res["relatedServiceId"] = boost::any(*relatedServiceId);
    }
    if (relatedServiceName) {
      res["relatedServiceName"] = boost::any(*relatedServiceName);
    }
    if (routeRuleId) {
      res["routeRuleId"] = boost::any(*routeRuleId);
    }
    if (routeRuleName) {
      res["routeRuleName"] = boost::any(*routeRuleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignToWhoIsValid") != m.end() && !m["assignToWhoIsValid"].empty()) {
      assignToWhoIsValid = make_shared<long>(boost::any_cast<long>(m["assignToWhoIsValid"]));
    }
    if (m.find("assignUserId") != m.end() && !m["assignUserId"].empty()) {
      assignUserId = make_shared<long>(boost::any_cast<long>(m["assignUserId"]));
    }
    if (m.find("assignUserName") != m.end() && !m["assignUserName"].empty()) {
      assignUserName = make_shared<string>(boost::any_cast<string>(m["assignUserName"]));
    }
    if (m.find("assignUserPhone") != m.end() && !m["assignUserPhone"].empty()) {
      assignUserPhone = make_shared<string>(boost::any_cast<string>(m["assignUserPhone"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("defaultAssignToWho") != m.end() && !m["defaultAssignToWho"].empty()) {
      defaultAssignToWho = make_shared<long>(boost::any_cast<long>(m["defaultAssignToWho"]));
    }
    if (m.find("defaultAssignToWhoIsValid") != m.end() && !m["defaultAssignToWhoIsValid"].empty()) {
      defaultAssignToWhoIsValid = make_shared<long>(boost::any_cast<long>(m["defaultAssignToWhoIsValid"]));
    }
    if (m.find("defaultAssignToWhoName") != m.end() && !m["defaultAssignToWhoName"].empty()) {
      defaultAssignToWhoName = make_shared<string>(boost::any_cast<string>(m["defaultAssignToWhoName"]));
    }
    if (m.find("durationTime") != m.end() && !m["durationTime"].empty()) {
      durationTime = make_shared<long>(boost::any_cast<long>(m["durationTime"]));
    }
    if (m.find("effect") != m.end() && !m["effect"].empty()) {
      effect = make_shared<string>(boost::any_cast<string>(m["effect"]));
    }
    if (m.find("incidentDescription") != m.end() && !m["incidentDescription"].empty()) {
      incidentDescription = make_shared<string>(boost::any_cast<string>(m["incidentDescription"]));
    }
    if (m.find("incidentId") != m.end() && !m["incidentId"].empty()) {
      incidentId = make_shared<long>(boost::any_cast<long>(m["incidentId"]));
    }
    if (m.find("incidentLevel") != m.end() && !m["incidentLevel"].empty()) {
      incidentLevel = make_shared<string>(boost::any_cast<string>(m["incidentLevel"]));
    }
    if (m.find("incidentNumber") != m.end() && !m["incidentNumber"].empty()) {
      incidentNumber = make_shared<string>(boost::any_cast<string>(m["incidentNumber"]));
    }
    if (m.find("incidentStatus") != m.end() && !m["incidentStatus"].empty()) {
      incidentStatus = make_shared<string>(boost::any_cast<string>(m["incidentStatus"]));
    }
    if (m.find("incidentTitle") != m.end() && !m["incidentTitle"].empty()) {
      incidentTitle = make_shared<string>(boost::any_cast<string>(m["incidentTitle"]));
    }
    if (m.find("isManual") != m.end() && !m["isManual"].empty()) {
      isManual = make_shared<bool>(boost::any_cast<bool>(m["isManual"]));
    }
    if (m.find("isUpgrade") != m.end() && !m["isUpgrade"].empty()) {
      isUpgrade = make_shared<bool>(boost::any_cast<bool>(m["isUpgrade"]));
    }
    if (m.find("notifyChannels") != m.end() && !m["notifyChannels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["notifyChannels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["notifyChannels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      notifyChannels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
    if (m.find("problemNumber") != m.end() && !m["problemNumber"].empty()) {
      problemNumber = make_shared<string>(boost::any_cast<string>(m["problemNumber"]));
    }
    if (m.find("relRouteRuleDeleteType") != m.end() && !m["relRouteRuleDeleteType"].empty()) {
      relRouteRuleDeleteType = make_shared<long>(boost::any_cast<long>(m["relRouteRuleDeleteType"]));
    }
    if (m.find("relServiceDeleteType") != m.end() && !m["relServiceDeleteType"].empty()) {
      relServiceDeleteType = make_shared<long>(boost::any_cast<long>(m["relServiceDeleteType"]));
    }
    if (m.find("relServiceGroupIsValid") != m.end() && !m["relServiceGroupIsValid"].empty()) {
      relServiceGroupIsValid = make_shared<long>(boost::any_cast<long>(m["relServiceGroupIsValid"]));
    }
    if (m.find("relatedServiceDescription") != m.end() && !m["relatedServiceDescription"].empty()) {
      relatedServiceDescription = make_shared<string>(boost::any_cast<string>(m["relatedServiceDescription"]));
    }
    if (m.find("relatedServiceGroupId") != m.end() && !m["relatedServiceGroupId"].empty()) {
      relatedServiceGroupId = make_shared<long>(boost::any_cast<long>(m["relatedServiceGroupId"]));
    }
    if (m.find("relatedServiceGroupName") != m.end() && !m["relatedServiceGroupName"].empty()) {
      relatedServiceGroupName = make_shared<string>(boost::any_cast<string>(m["relatedServiceGroupName"]));
    }
    if (m.find("relatedServiceId") != m.end() && !m["relatedServiceId"].empty()) {
      relatedServiceId = make_shared<long>(boost::any_cast<long>(m["relatedServiceId"]));
    }
    if (m.find("relatedServiceName") != m.end() && !m["relatedServiceName"].empty()) {
      relatedServiceName = make_shared<string>(boost::any_cast<string>(m["relatedServiceName"]));
    }
    if (m.find("routeRuleId") != m.end() && !m["routeRuleId"].empty()) {
      routeRuleId = make_shared<long>(boost::any_cast<long>(m["routeRuleId"]));
    }
    if (m.find("routeRuleName") != m.end() && !m["routeRuleName"].empty()) {
      routeRuleName = make_shared<string>(boost::any_cast<string>(m["routeRuleName"]));
    }
  }


  virtual ~GetIncidentResponseBodyData() = default;
};
class GetIncidentResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetIncidentResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetIncidentResponseBody() {}

  explicit GetIncidentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GetIncidentResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GetIncidentResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetIncidentResponseBody() = default;
};
class GetIncidentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetIncidentResponseBody> body{};

  GetIncidentResponse() {}

  explicit GetIncidentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetIncidentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetIncidentResponseBody>(model1);
      }
    }
  }


  virtual ~GetIncidentResponse() = default;
};
class GetIncidentListByIdListRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<vector<long>> incidentIdList{};

  GetIncidentListByIdListRequest() {}

  explicit GetIncidentListByIdListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (incidentIdList) {
      res["incidentIdList"] = boost::any(*incidentIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("incidentIdList") != m.end() && !m["incidentIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["incidentIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["incidentIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      incidentIdList = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~GetIncidentListByIdListRequest() = default;
};
class GetIncidentListByIdListResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> assignToWhoIsValid{};
  shared_ptr<long> assignUserId{};
  shared_ptr<string> assignUserName{};
  shared_ptr<string> assignUserPhone{};
  shared_ptr<string> createTime{};
  shared_ptr<long> defaultAssignToWho{};
  shared_ptr<long> defaultAssignToWhoIsValid{};
  shared_ptr<string> defaultAssignToWhoName{};
  shared_ptr<string> durationTime{};
  shared_ptr<string> effect{};
  shared_ptr<string> incidentDescription{};
  shared_ptr<long> incidentId{};
  shared_ptr<string> incidentLevel{};
  shared_ptr<string> incidentNumber{};
  shared_ptr<string> incidentStatus{};
  shared_ptr<string> incidentTitle{};
  shared_ptr<bool> isManual{};
  shared_ptr<bool> isUpgrade{};
  shared_ptr<vector<string>> notifyChannels{};
  shared_ptr<long> problemId{};
  shared_ptr<string> problemNumber{};
  shared_ptr<long> relRouteRuleDeleteType{};
  shared_ptr<long> relServiceDeleteType{};
  shared_ptr<long> relServiceGroupIsValid{};
  shared_ptr<string> relatedServiceDescription{};
  shared_ptr<long> relatedServiceGroupId{};
  shared_ptr<string> relatedServiceGroupName{};
  shared_ptr<long> relatedServiceId{};
  shared_ptr<string> relatedServiceName{};
  shared_ptr<long> routeRuleId{};
  shared_ptr<string> routeRuleName{};

  GetIncidentListByIdListResponseBodyData() {}

  explicit GetIncidentListByIdListResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignToWhoIsValid) {
      res["assignToWhoIsValid"] = boost::any(*assignToWhoIsValid);
    }
    if (assignUserId) {
      res["assignUserId"] = boost::any(*assignUserId);
    }
    if (assignUserName) {
      res["assignUserName"] = boost::any(*assignUserName);
    }
    if (assignUserPhone) {
      res["assignUserPhone"] = boost::any(*assignUserPhone);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (defaultAssignToWho) {
      res["defaultAssignToWho"] = boost::any(*defaultAssignToWho);
    }
    if (defaultAssignToWhoIsValid) {
      res["defaultAssignToWhoIsValid"] = boost::any(*defaultAssignToWhoIsValid);
    }
    if (defaultAssignToWhoName) {
      res["defaultAssignToWhoName"] = boost::any(*defaultAssignToWhoName);
    }
    if (durationTime) {
      res["durationTime"] = boost::any(*durationTime);
    }
    if (effect) {
      res["effect"] = boost::any(*effect);
    }
    if (incidentDescription) {
      res["incidentDescription"] = boost::any(*incidentDescription);
    }
    if (incidentId) {
      res["incidentId"] = boost::any(*incidentId);
    }
    if (incidentLevel) {
      res["incidentLevel"] = boost::any(*incidentLevel);
    }
    if (incidentNumber) {
      res["incidentNumber"] = boost::any(*incidentNumber);
    }
    if (incidentStatus) {
      res["incidentStatus"] = boost::any(*incidentStatus);
    }
    if (incidentTitle) {
      res["incidentTitle"] = boost::any(*incidentTitle);
    }
    if (isManual) {
      res["isManual"] = boost::any(*isManual);
    }
    if (isUpgrade) {
      res["isUpgrade"] = boost::any(*isUpgrade);
    }
    if (notifyChannels) {
      res["notifyChannels"] = boost::any(*notifyChannels);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    if (problemNumber) {
      res["problemNumber"] = boost::any(*problemNumber);
    }
    if (relRouteRuleDeleteType) {
      res["relRouteRuleDeleteType"] = boost::any(*relRouteRuleDeleteType);
    }
    if (relServiceDeleteType) {
      res["relServiceDeleteType"] = boost::any(*relServiceDeleteType);
    }
    if (relServiceGroupIsValid) {
      res["relServiceGroupIsValid"] = boost::any(*relServiceGroupIsValid);
    }
    if (relatedServiceDescription) {
      res["relatedServiceDescription"] = boost::any(*relatedServiceDescription);
    }
    if (relatedServiceGroupId) {
      res["relatedServiceGroupId"] = boost::any(*relatedServiceGroupId);
    }
    if (relatedServiceGroupName) {
      res["relatedServiceGroupName"] = boost::any(*relatedServiceGroupName);
    }
    if (relatedServiceId) {
      res["relatedServiceId"] = boost::any(*relatedServiceId);
    }
    if (relatedServiceName) {
      res["relatedServiceName"] = boost::any(*relatedServiceName);
    }
    if (routeRuleId) {
      res["routeRuleId"] = boost::any(*routeRuleId);
    }
    if (routeRuleName) {
      res["routeRuleName"] = boost::any(*routeRuleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignToWhoIsValid") != m.end() && !m["assignToWhoIsValid"].empty()) {
      assignToWhoIsValid = make_shared<long>(boost::any_cast<long>(m["assignToWhoIsValid"]));
    }
    if (m.find("assignUserId") != m.end() && !m["assignUserId"].empty()) {
      assignUserId = make_shared<long>(boost::any_cast<long>(m["assignUserId"]));
    }
    if (m.find("assignUserName") != m.end() && !m["assignUserName"].empty()) {
      assignUserName = make_shared<string>(boost::any_cast<string>(m["assignUserName"]));
    }
    if (m.find("assignUserPhone") != m.end() && !m["assignUserPhone"].empty()) {
      assignUserPhone = make_shared<string>(boost::any_cast<string>(m["assignUserPhone"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("defaultAssignToWho") != m.end() && !m["defaultAssignToWho"].empty()) {
      defaultAssignToWho = make_shared<long>(boost::any_cast<long>(m["defaultAssignToWho"]));
    }
    if (m.find("defaultAssignToWhoIsValid") != m.end() && !m["defaultAssignToWhoIsValid"].empty()) {
      defaultAssignToWhoIsValid = make_shared<long>(boost::any_cast<long>(m["defaultAssignToWhoIsValid"]));
    }
    if (m.find("defaultAssignToWhoName") != m.end() && !m["defaultAssignToWhoName"].empty()) {
      defaultAssignToWhoName = make_shared<string>(boost::any_cast<string>(m["defaultAssignToWhoName"]));
    }
    if (m.find("durationTime") != m.end() && !m["durationTime"].empty()) {
      durationTime = make_shared<string>(boost::any_cast<string>(m["durationTime"]));
    }
    if (m.find("effect") != m.end() && !m["effect"].empty()) {
      effect = make_shared<string>(boost::any_cast<string>(m["effect"]));
    }
    if (m.find("incidentDescription") != m.end() && !m["incidentDescription"].empty()) {
      incidentDescription = make_shared<string>(boost::any_cast<string>(m["incidentDescription"]));
    }
    if (m.find("incidentId") != m.end() && !m["incidentId"].empty()) {
      incidentId = make_shared<long>(boost::any_cast<long>(m["incidentId"]));
    }
    if (m.find("incidentLevel") != m.end() && !m["incidentLevel"].empty()) {
      incidentLevel = make_shared<string>(boost::any_cast<string>(m["incidentLevel"]));
    }
    if (m.find("incidentNumber") != m.end() && !m["incidentNumber"].empty()) {
      incidentNumber = make_shared<string>(boost::any_cast<string>(m["incidentNumber"]));
    }
    if (m.find("incidentStatus") != m.end() && !m["incidentStatus"].empty()) {
      incidentStatus = make_shared<string>(boost::any_cast<string>(m["incidentStatus"]));
    }
    if (m.find("incidentTitle") != m.end() && !m["incidentTitle"].empty()) {
      incidentTitle = make_shared<string>(boost::any_cast<string>(m["incidentTitle"]));
    }
    if (m.find("isManual") != m.end() && !m["isManual"].empty()) {
      isManual = make_shared<bool>(boost::any_cast<bool>(m["isManual"]));
    }
    if (m.find("isUpgrade") != m.end() && !m["isUpgrade"].empty()) {
      isUpgrade = make_shared<bool>(boost::any_cast<bool>(m["isUpgrade"]));
    }
    if (m.find("notifyChannels") != m.end() && !m["notifyChannels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["notifyChannels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["notifyChannels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      notifyChannels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
    if (m.find("problemNumber") != m.end() && !m["problemNumber"].empty()) {
      problemNumber = make_shared<string>(boost::any_cast<string>(m["problemNumber"]));
    }
    if (m.find("relRouteRuleDeleteType") != m.end() && !m["relRouteRuleDeleteType"].empty()) {
      relRouteRuleDeleteType = make_shared<long>(boost::any_cast<long>(m["relRouteRuleDeleteType"]));
    }
    if (m.find("relServiceDeleteType") != m.end() && !m["relServiceDeleteType"].empty()) {
      relServiceDeleteType = make_shared<long>(boost::any_cast<long>(m["relServiceDeleteType"]));
    }
    if (m.find("relServiceGroupIsValid") != m.end() && !m["relServiceGroupIsValid"].empty()) {
      relServiceGroupIsValid = make_shared<long>(boost::any_cast<long>(m["relServiceGroupIsValid"]));
    }
    if (m.find("relatedServiceDescription") != m.end() && !m["relatedServiceDescription"].empty()) {
      relatedServiceDescription = make_shared<string>(boost::any_cast<string>(m["relatedServiceDescription"]));
    }
    if (m.find("relatedServiceGroupId") != m.end() && !m["relatedServiceGroupId"].empty()) {
      relatedServiceGroupId = make_shared<long>(boost::any_cast<long>(m["relatedServiceGroupId"]));
    }
    if (m.find("relatedServiceGroupName") != m.end() && !m["relatedServiceGroupName"].empty()) {
      relatedServiceGroupName = make_shared<string>(boost::any_cast<string>(m["relatedServiceGroupName"]));
    }
    if (m.find("relatedServiceId") != m.end() && !m["relatedServiceId"].empty()) {
      relatedServiceId = make_shared<long>(boost::any_cast<long>(m["relatedServiceId"]));
    }
    if (m.find("relatedServiceName") != m.end() && !m["relatedServiceName"].empty()) {
      relatedServiceName = make_shared<string>(boost::any_cast<string>(m["relatedServiceName"]));
    }
    if (m.find("routeRuleId") != m.end() && !m["routeRuleId"].empty()) {
      routeRuleId = make_shared<long>(boost::any_cast<long>(m["routeRuleId"]));
    }
    if (m.find("routeRuleName") != m.end() && !m["routeRuleName"].empty()) {
      routeRuleName = make_shared<string>(boost::any_cast<string>(m["routeRuleName"]));
    }
  }


  virtual ~GetIncidentListByIdListResponseBodyData() = default;
};
class GetIncidentListByIdListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetIncidentListByIdListResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  GetIncidentListByIdListResponseBody() {}

  explicit GetIncidentListByIdListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<GetIncidentListByIdListResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetIncidentListByIdListResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetIncidentListByIdListResponseBodyData>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetIncidentListByIdListResponseBody() = default;
};
class GetIncidentListByIdListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetIncidentListByIdListResponseBody> body{};

  GetIncidentListByIdListResponse() {}

  explicit GetIncidentListByIdListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetIncidentListByIdListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetIncidentListByIdListResponseBody>(model1);
      }
    }
  }


  virtual ~GetIncidentListByIdListResponse() = default;
};
class GetIncidentStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};

  GetIncidentStatisticsRequest() {}

  explicit GetIncidentStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~GetIncidentStatisticsRequest() = default;
};
class GetIncidentStatisticsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> allFinish{};
  shared_ptr<long> allResponse{};
  shared_ptr<long> myFinish{};
  shared_ptr<long> myResponse{};

  GetIncidentStatisticsResponseBodyData() {}

  explicit GetIncidentStatisticsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (allFinish) {
      res["allFinish"] = boost::any(*allFinish);
    }
    if (allResponse) {
      res["allResponse"] = boost::any(*allResponse);
    }
    if (myFinish) {
      res["myFinish"] = boost::any(*myFinish);
    }
    if (myResponse) {
      res["myResponse"] = boost::any(*myResponse);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("allFinish") != m.end() && !m["allFinish"].empty()) {
      allFinish = make_shared<long>(boost::any_cast<long>(m["allFinish"]));
    }
    if (m.find("allResponse") != m.end() && !m["allResponse"].empty()) {
      allResponse = make_shared<long>(boost::any_cast<long>(m["allResponse"]));
    }
    if (m.find("myFinish") != m.end() && !m["myFinish"].empty()) {
      myFinish = make_shared<long>(boost::any_cast<long>(m["myFinish"]));
    }
    if (m.find("myResponse") != m.end() && !m["myResponse"].empty()) {
      myResponse = make_shared<long>(boost::any_cast<long>(m["myResponse"]));
    }
  }


  virtual ~GetIncidentStatisticsResponseBodyData() = default;
};
class GetIncidentStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetIncidentStatisticsResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetIncidentStatisticsResponseBody() {}

  explicit GetIncidentStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GetIncidentStatisticsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GetIncidentStatisticsResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetIncidentStatisticsResponseBody() = default;
};
class GetIncidentStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetIncidentStatisticsResponseBody> body{};

  GetIncidentStatisticsResponse() {}

  explicit GetIncidentStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetIncidentStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetIncidentStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~GetIncidentStatisticsResponse() = default;
};
class GetIncidentSubtotalCountRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<vector<long>> incidentIds{};

  GetIncidentSubtotalCountRequest() {}

  explicit GetIncidentSubtotalCountRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (incidentIds) {
      res["incidentIds"] = boost::any(*incidentIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("incidentIds") != m.end() && !m["incidentIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["incidentIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["incidentIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      incidentIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~GetIncidentSubtotalCountRequest() = default;
};
class GetIncidentSubtotalCountResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<map<string, boost::any>> subtotalCount{};

  GetIncidentSubtotalCountResponseBodyData() {}

  explicit GetIncidentSubtotalCountResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (subtotalCount) {
      res["subtotalCount"] = boost::any(*subtotalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("subtotalCount") != m.end() && !m["subtotalCount"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["subtotalCount"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      subtotalCount = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~GetIncidentSubtotalCountResponseBodyData() = default;
};
class GetIncidentSubtotalCountResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetIncidentSubtotalCountResponseBodyData> data{};

  GetIncidentSubtotalCountResponseBody() {}

  explicit GetIncidentSubtotalCountResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GetIncidentSubtotalCountResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GetIncidentSubtotalCountResponseBodyData>(model1);
      }
    }
  }


  virtual ~GetIncidentSubtotalCountResponseBody() = default;
};
class GetIncidentSubtotalCountResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetIncidentSubtotalCountResponseBody> body{};

  GetIncidentSubtotalCountResponse() {}

  explicit GetIncidentSubtotalCountResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetIncidentSubtotalCountResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetIncidentSubtotalCountResponseBody>(model1);
      }
    }
  }


  virtual ~GetIncidentSubtotalCountResponse() = default;
};
class GetIntegrationConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> integrationConfigId{};

  GetIntegrationConfigRequest() {}

  explicit GetIntegrationConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (integrationConfigId) {
      res["integrationConfigId"] = boost::any(*integrationConfigId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("integrationConfigId") != m.end() && !m["integrationConfigId"].empty()) {
      integrationConfigId = make_shared<long>(boost::any_cast<long>(m["integrationConfigId"]));
    }
  }


  virtual ~GetIntegrationConfigRequest() = default;
};
class GetIntegrationConfigResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> accessKey{};
  shared_ptr<long> integrationConfigId{};
  shared_ptr<bool> isReceivedEvent{};
  shared_ptr<long> monitorSourceId{};
  shared_ptr<string> monitorSourceName{};
  shared_ptr<string> monitorSourceShortName{};
  shared_ptr<string> status{};

  GetIntegrationConfigResponseBodyData() {}

  explicit GetIntegrationConfigResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKey) {
      res["accessKey"] = boost::any(*accessKey);
    }
    if (integrationConfigId) {
      res["integrationConfigId"] = boost::any(*integrationConfigId);
    }
    if (isReceivedEvent) {
      res["isReceivedEvent"] = boost::any(*isReceivedEvent);
    }
    if (monitorSourceId) {
      res["monitorSourceId"] = boost::any(*monitorSourceId);
    }
    if (monitorSourceName) {
      res["monitorSourceName"] = boost::any(*monitorSourceName);
    }
    if (monitorSourceShortName) {
      res["monitorSourceShortName"] = boost::any(*monitorSourceShortName);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessKey") != m.end() && !m["accessKey"].empty()) {
      accessKey = make_shared<string>(boost::any_cast<string>(m["accessKey"]));
    }
    if (m.find("integrationConfigId") != m.end() && !m["integrationConfigId"].empty()) {
      integrationConfigId = make_shared<long>(boost::any_cast<long>(m["integrationConfigId"]));
    }
    if (m.find("isReceivedEvent") != m.end() && !m["isReceivedEvent"].empty()) {
      isReceivedEvent = make_shared<bool>(boost::any_cast<bool>(m["isReceivedEvent"]));
    }
    if (m.find("monitorSourceId") != m.end() && !m["monitorSourceId"].empty()) {
      monitorSourceId = make_shared<long>(boost::any_cast<long>(m["monitorSourceId"]));
    }
    if (m.find("monitorSourceName") != m.end() && !m["monitorSourceName"].empty()) {
      monitorSourceName = make_shared<string>(boost::any_cast<string>(m["monitorSourceName"]));
    }
    if (m.find("monitorSourceShortName") != m.end() && !m["monitorSourceShortName"].empty()) {
      monitorSourceShortName = make_shared<string>(boost::any_cast<string>(m["monitorSourceShortName"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~GetIntegrationConfigResponseBodyData() = default;
};
class GetIntegrationConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetIntegrationConfigResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetIntegrationConfigResponseBody() {}

  explicit GetIntegrationConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GetIntegrationConfigResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GetIntegrationConfigResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetIntegrationConfigResponseBody() = default;
};
class GetIntegrationConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetIntegrationConfigResponseBody> body{};

  GetIntegrationConfigResponse() {}

  explicit GetIntegrationConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetIntegrationConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetIntegrationConfigResponseBody>(model1);
      }
    }
  }


  virtual ~GetIntegrationConfigResponse() = default;
};
class GetProblemRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> problemId{};

  GetProblemRequest() {}

  explicit GetProblemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
  }


  virtual ~GetProblemRequest() = default;
};
class GetProblemResponseBodyDataCancelProblemOperateLogs : public Darabonba::Model {
public:
  shared_ptr<string> actionName{};
  shared_ptr<string> actionTime{};
  shared_ptr<string> operator_{};
  shared_ptr<long> userId{};

  GetProblemResponseBodyDataCancelProblemOperateLogs() {}

  explicit GetProblemResponseBodyDataCancelProblemOperateLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionName) {
      res["actionName"] = boost::any(*actionName);
    }
    if (actionTime) {
      res["actionTime"] = boost::any(*actionTime);
    }
    if (operator_) {
      res["operator"] = boost::any(*operator_);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("actionName") != m.end() && !m["actionName"].empty()) {
      actionName = make_shared<string>(boost::any_cast<string>(m["actionName"]));
    }
    if (m.find("actionTime") != m.end() && !m["actionTime"].empty()) {
      actionTime = make_shared<string>(boost::any_cast<string>(m["actionTime"]));
    }
    if (m.find("operator") != m.end() && !m["operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["operator"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
  }


  virtual ~GetProblemResponseBodyDataCancelProblemOperateLogs() = default;
};
class GetProblemResponseBodyDataCoordinationGroups : public Darabonba::Model {
public:
  shared_ptr<long> isValid{};
  shared_ptr<long> serviceGroupId{};
  shared_ptr<string> serviceGroupName{};

  GetProblemResponseBodyDataCoordinationGroups() {}

  explicit GetProblemResponseBodyDataCoordinationGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isValid) {
      res["isValid"] = boost::any(*isValid);
    }
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    if (serviceGroupName) {
      res["serviceGroupName"] = boost::any(*serviceGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("isValid") != m.end() && !m["isValid"].empty()) {
      isValid = make_shared<long>(boost::any_cast<long>(m["isValid"]));
    }
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
    if (m.find("serviceGroupName") != m.end() && !m["serviceGroupName"].empty()) {
      serviceGroupName = make_shared<string>(boost::any_cast<string>(m["serviceGroupName"]));
    }
  }


  virtual ~GetProblemResponseBodyDataCoordinationGroups() = default;
};
class GetProblemResponseBodyDataEffectionServices : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> effectionLevel{};
  shared_ptr<long> effectionServiceId{};
  shared_ptr<long> effectionStatus{};
  shared_ptr<long> serviceDeleteType{};
  shared_ptr<string> serviceName{};

  GetProblemResponseBodyDataEffectionServices() {}

  explicit GetProblemResponseBodyDataEffectionServices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (effectionLevel) {
      res["effectionLevel"] = boost::any(*effectionLevel);
    }
    if (effectionServiceId) {
      res["effectionServiceId"] = boost::any(*effectionServiceId);
    }
    if (effectionStatus) {
      res["effectionStatus"] = boost::any(*effectionStatus);
    }
    if (serviceDeleteType) {
      res["serviceDeleteType"] = boost::any(*serviceDeleteType);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("effectionLevel") != m.end() && !m["effectionLevel"].empty()) {
      effectionLevel = make_shared<long>(boost::any_cast<long>(m["effectionLevel"]));
    }
    if (m.find("effectionServiceId") != m.end() && !m["effectionServiceId"].empty()) {
      effectionServiceId = make_shared<long>(boost::any_cast<long>(m["effectionServiceId"]));
    }
    if (m.find("effectionStatus") != m.end() && !m["effectionStatus"].empty()) {
      effectionStatus = make_shared<long>(boost::any_cast<long>(m["effectionStatus"]));
    }
    if (m.find("serviceDeleteType") != m.end() && !m["serviceDeleteType"].empty()) {
      serviceDeleteType = make_shared<long>(boost::any_cast<long>(m["serviceDeleteType"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
  }


  virtual ~GetProblemResponseBodyDataEffectionServices() = default;
};
class GetProblemResponseBodyDataHandingProblemOperateLogs : public Darabonba::Model {
public:
  shared_ptr<string> actionName{};
  shared_ptr<string> actionTime{};
  shared_ptr<string> operator_{};
  shared_ptr<long> userId{};
  shared_ptr<long> userIsValid{};

  GetProblemResponseBodyDataHandingProblemOperateLogs() {}

  explicit GetProblemResponseBodyDataHandingProblemOperateLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionName) {
      res["actionName"] = boost::any(*actionName);
    }
    if (actionTime) {
      res["actionTime"] = boost::any(*actionTime);
    }
    if (operator_) {
      res["operator"] = boost::any(*operator_);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    if (userIsValid) {
      res["userIsValid"] = boost::any(*userIsValid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("actionName") != m.end() && !m["actionName"].empty()) {
      actionName = make_shared<string>(boost::any_cast<string>(m["actionName"]));
    }
    if (m.find("actionTime") != m.end() && !m["actionTime"].empty()) {
      actionTime = make_shared<string>(boost::any_cast<string>(m["actionTime"]));
    }
    if (m.find("operator") != m.end() && !m["operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["operator"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
    if (m.find("userIsValid") != m.end() && !m["userIsValid"].empty()) {
      userIsValid = make_shared<long>(boost::any_cast<long>(m["userIsValid"]));
    }
  }


  virtual ~GetProblemResponseBodyDataHandingProblemOperateLogs() = default;
};
class GetProblemResponseBodyDataReplayProblemOperateLogs : public Darabonba::Model {
public:
  shared_ptr<string> actionName{};
  shared_ptr<string> actionTime{};
  shared_ptr<string> operator_{};
  shared_ptr<long> userId{};
  shared_ptr<long> userIsValid{};

  GetProblemResponseBodyDataReplayProblemOperateLogs() {}

  explicit GetProblemResponseBodyDataReplayProblemOperateLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionName) {
      res["actionName"] = boost::any(*actionName);
    }
    if (actionTime) {
      res["actionTime"] = boost::any(*actionTime);
    }
    if (operator_) {
      res["operator"] = boost::any(*operator_);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    if (userIsValid) {
      res["userIsValid"] = boost::any(*userIsValid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("actionName") != m.end() && !m["actionName"].empty()) {
      actionName = make_shared<string>(boost::any_cast<string>(m["actionName"]));
    }
    if (m.find("actionTime") != m.end() && !m["actionTime"].empty()) {
      actionTime = make_shared<string>(boost::any_cast<string>(m["actionTime"]));
    }
    if (m.find("operator") != m.end() && !m["operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["operator"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
    if (m.find("userIsValid") != m.end() && !m["userIsValid"].empty()) {
      userIsValid = make_shared<long>(boost::any_cast<long>(m["userIsValid"]));
    }
  }


  virtual ~GetProblemResponseBodyDataReplayProblemOperateLogs() = default;
};
class GetProblemResponseBodyDataReplayingProblemOperateLogs : public Darabonba::Model {
public:
  shared_ptr<string> actionName{};
  shared_ptr<string> actionTime{};
  shared_ptr<string> operator_{};
  shared_ptr<long> userId{};
  shared_ptr<long> userIsValid{};

  GetProblemResponseBodyDataReplayingProblemOperateLogs() {}

  explicit GetProblemResponseBodyDataReplayingProblemOperateLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionName) {
      res["actionName"] = boost::any(*actionName);
    }
    if (actionTime) {
      res["actionTime"] = boost::any(*actionTime);
    }
    if (operator_) {
      res["operator"] = boost::any(*operator_);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    if (userIsValid) {
      res["userIsValid"] = boost::any(*userIsValid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("actionName") != m.end() && !m["actionName"].empty()) {
      actionName = make_shared<string>(boost::any_cast<string>(m["actionName"]));
    }
    if (m.find("actionTime") != m.end() && !m["actionTime"].empty()) {
      actionTime = make_shared<string>(boost::any_cast<string>(m["actionTime"]));
    }
    if (m.find("operator") != m.end() && !m["operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["operator"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
    if (m.find("userIsValid") != m.end() && !m["userIsValid"].empty()) {
      userIsValid = make_shared<long>(boost::any_cast<long>(m["userIsValid"]));
    }
  }


  virtual ~GetProblemResponseBodyDataReplayingProblemOperateLogs() = default;
};
class GetProblemResponseBodyDataRestoredProblemOperateLogs : public Darabonba::Model {
public:
  shared_ptr<string> actionName{};
  shared_ptr<string> actionTime{};
  shared_ptr<string> operator_{};
  shared_ptr<long> userId{};
  shared_ptr<long> userIsValid{};

  GetProblemResponseBodyDataRestoredProblemOperateLogs() {}

  explicit GetProblemResponseBodyDataRestoredProblemOperateLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionName) {
      res["actionName"] = boost::any(*actionName);
    }
    if (actionTime) {
      res["actionTime"] = boost::any(*actionTime);
    }
    if (operator_) {
      res["operator"] = boost::any(*operator_);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    if (userIsValid) {
      res["userIsValid"] = boost::any(*userIsValid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("actionName") != m.end() && !m["actionName"].empty()) {
      actionName = make_shared<string>(boost::any_cast<string>(m["actionName"]));
    }
    if (m.find("actionTime") != m.end() && !m["actionTime"].empty()) {
      actionTime = make_shared<string>(boost::any_cast<string>(m["actionTime"]));
    }
    if (m.find("operator") != m.end() && !m["operator"].empty()) {
      operator_ = make_shared<string>(boost::any_cast<string>(m["operator"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
    if (m.find("userIsValid") != m.end() && !m["userIsValid"].empty()) {
      userIsValid = make_shared<long>(boost::any_cast<long>(m["userIsValid"]));
    }
  }


  virtual ~GetProblemResponseBodyDataRestoredProblemOperateLogs() = default;
};
class GetProblemResponseBodyDataTimelines : public Darabonba::Model {
public:
  shared_ptr<string> keyNode{};

  GetProblemResponseBodyDataTimelines() {}

  explicit GetProblemResponseBodyDataTimelines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyNode) {
      res["keyNode"] = boost::any(*keyNode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("keyNode") != m.end() && !m["keyNode"].empty()) {
      keyNode = make_shared<string>(boost::any_cast<string>(m["keyNode"]));
    }
  }


  virtual ~GetProblemResponseBodyDataTimelines() = default;
};
class GetProblemResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<GetProblemResponseBodyDataCancelProblemOperateLogs>> cancelProblemOperateLogs{};
  shared_ptr<long> cancelReason{};
  shared_ptr<string> cancelReasonDescription{};
  shared_ptr<vector<GetProblemResponseBodyDataCoordinationGroups>> coordinationGroups{};
  shared_ptr<string> createTime{};
  shared_ptr<string> discoverTime{};
  shared_ptr<long> durationTime{};
  shared_ptr<vector<GetProblemResponseBodyDataEffectionServices>> effectionServices{};
  shared_ptr<string> feedback{};
  shared_ptr<vector<GetProblemResponseBodyDataHandingProblemOperateLogs>> handingProblemOperateLogs{};
  shared_ptr<long> incidentId{};
  shared_ptr<string> incidentNumber{};
  shared_ptr<bool> isRuleTrigger{};
  shared_ptr<long> mainHandler{};
  shared_ptr<long> mainHandlerId{};
  shared_ptr<long> mainHandlerIsValid{};
  shared_ptr<string> mainHandlerPhone{};
  shared_ptr<string> preliminaryReason{};
  shared_ptr<long> problemId{};
  shared_ptr<long> problemLevel{};
  shared_ptr<string> problemName{};
  shared_ptr<string> problemNumber{};
  shared_ptr<long> problemStatus{};
  shared_ptr<string> progressSummary{};
  shared_ptr<long> progressSummaryRichTextId{};
  shared_ptr<string> recoveryTime{};
  shared_ptr<long> relatedServiceId{};
  shared_ptr<vector<GetProblemResponseBodyDataReplayProblemOperateLogs>> replayProblemOperateLogs{};
  shared_ptr<vector<GetProblemResponseBodyDataReplayingProblemOperateLogs>> replayingProblemOperateLogs{};
  shared_ptr<vector<GetProblemResponseBodyDataRestoredProblemOperateLogs>> restoredProblemOperateLogs{};
  shared_ptr<long> serviceDeleteType{};
  shared_ptr<string> serviceName{};
  shared_ptr<vector<GetProblemResponseBodyDataTimelines>> timelines{};

  GetProblemResponseBodyData() {}

  explicit GetProblemResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cancelProblemOperateLogs) {
      vector<boost::any> temp1;
      for(auto item1:*cancelProblemOperateLogs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["cancelProblemOperateLogs"] = boost::any(temp1);
    }
    if (cancelReason) {
      res["cancelReason"] = boost::any(*cancelReason);
    }
    if (cancelReasonDescription) {
      res["cancelReasonDescription"] = boost::any(*cancelReasonDescription);
    }
    if (coordinationGroups) {
      vector<boost::any> temp1;
      for(auto item1:*coordinationGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["coordinationGroups"] = boost::any(temp1);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (discoverTime) {
      res["discoverTime"] = boost::any(*discoverTime);
    }
    if (durationTime) {
      res["durationTime"] = boost::any(*durationTime);
    }
    if (effectionServices) {
      vector<boost::any> temp1;
      for(auto item1:*effectionServices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["effectionServices"] = boost::any(temp1);
    }
    if (feedback) {
      res["feedback"] = boost::any(*feedback);
    }
    if (handingProblemOperateLogs) {
      vector<boost::any> temp1;
      for(auto item1:*handingProblemOperateLogs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["handingProblemOperateLogs"] = boost::any(temp1);
    }
    if (incidentId) {
      res["incidentId"] = boost::any(*incidentId);
    }
    if (incidentNumber) {
      res["incidentNumber"] = boost::any(*incidentNumber);
    }
    if (isRuleTrigger) {
      res["isRuleTrigger"] = boost::any(*isRuleTrigger);
    }
    if (mainHandler) {
      res["mainHandler"] = boost::any(*mainHandler);
    }
    if (mainHandlerId) {
      res["mainHandlerId"] = boost::any(*mainHandlerId);
    }
    if (mainHandlerIsValid) {
      res["mainHandlerIsValid"] = boost::any(*mainHandlerIsValid);
    }
    if (mainHandlerPhone) {
      res["mainHandlerPhone"] = boost::any(*mainHandlerPhone);
    }
    if (preliminaryReason) {
      res["preliminaryReason"] = boost::any(*preliminaryReason);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    if (problemLevel) {
      res["problemLevel"] = boost::any(*problemLevel);
    }
    if (problemName) {
      res["problemName"] = boost::any(*problemName);
    }
    if (problemNumber) {
      res["problemNumber"] = boost::any(*problemNumber);
    }
    if (problemStatus) {
      res["problemStatus"] = boost::any(*problemStatus);
    }
    if (progressSummary) {
      res["progressSummary"] = boost::any(*progressSummary);
    }
    if (progressSummaryRichTextId) {
      res["progressSummaryRichTextId"] = boost::any(*progressSummaryRichTextId);
    }
    if (recoveryTime) {
      res["recoveryTime"] = boost::any(*recoveryTime);
    }
    if (relatedServiceId) {
      res["relatedServiceId"] = boost::any(*relatedServiceId);
    }
    if (replayProblemOperateLogs) {
      vector<boost::any> temp1;
      for(auto item1:*replayProblemOperateLogs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["replayProblemOperateLogs"] = boost::any(temp1);
    }
    if (replayingProblemOperateLogs) {
      vector<boost::any> temp1;
      for(auto item1:*replayingProblemOperateLogs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["replayingProblemOperateLogs"] = boost::any(temp1);
    }
    if (restoredProblemOperateLogs) {
      vector<boost::any> temp1;
      for(auto item1:*restoredProblemOperateLogs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["restoredProblemOperateLogs"] = boost::any(temp1);
    }
    if (serviceDeleteType) {
      res["serviceDeleteType"] = boost::any(*serviceDeleteType);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    if (timelines) {
      vector<boost::any> temp1;
      for(auto item1:*timelines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["timelines"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cancelProblemOperateLogs") != m.end() && !m["cancelProblemOperateLogs"].empty()) {
      if (typeid(vector<boost::any>) == m["cancelProblemOperateLogs"].type()) {
        vector<GetProblemResponseBodyDataCancelProblemOperateLogs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["cancelProblemOperateLogs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetProblemResponseBodyDataCancelProblemOperateLogs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cancelProblemOperateLogs = make_shared<vector<GetProblemResponseBodyDataCancelProblemOperateLogs>>(expect1);
      }
    }
    if (m.find("cancelReason") != m.end() && !m["cancelReason"].empty()) {
      cancelReason = make_shared<long>(boost::any_cast<long>(m["cancelReason"]));
    }
    if (m.find("cancelReasonDescription") != m.end() && !m["cancelReasonDescription"].empty()) {
      cancelReasonDescription = make_shared<string>(boost::any_cast<string>(m["cancelReasonDescription"]));
    }
    if (m.find("coordinationGroups") != m.end() && !m["coordinationGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["coordinationGroups"].type()) {
        vector<GetProblemResponseBodyDataCoordinationGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["coordinationGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetProblemResponseBodyDataCoordinationGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        coordinationGroups = make_shared<vector<GetProblemResponseBodyDataCoordinationGroups>>(expect1);
      }
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("discoverTime") != m.end() && !m["discoverTime"].empty()) {
      discoverTime = make_shared<string>(boost::any_cast<string>(m["discoverTime"]));
    }
    if (m.find("durationTime") != m.end() && !m["durationTime"].empty()) {
      durationTime = make_shared<long>(boost::any_cast<long>(m["durationTime"]));
    }
    if (m.find("effectionServices") != m.end() && !m["effectionServices"].empty()) {
      if (typeid(vector<boost::any>) == m["effectionServices"].type()) {
        vector<GetProblemResponseBodyDataEffectionServices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["effectionServices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetProblemResponseBodyDataEffectionServices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        effectionServices = make_shared<vector<GetProblemResponseBodyDataEffectionServices>>(expect1);
      }
    }
    if (m.find("feedback") != m.end() && !m["feedback"].empty()) {
      feedback = make_shared<string>(boost::any_cast<string>(m["feedback"]));
    }
    if (m.find("handingProblemOperateLogs") != m.end() && !m["handingProblemOperateLogs"].empty()) {
      if (typeid(vector<boost::any>) == m["handingProblemOperateLogs"].type()) {
        vector<GetProblemResponseBodyDataHandingProblemOperateLogs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["handingProblemOperateLogs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetProblemResponseBodyDataHandingProblemOperateLogs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        handingProblemOperateLogs = make_shared<vector<GetProblemResponseBodyDataHandingProblemOperateLogs>>(expect1);
      }
    }
    if (m.find("incidentId") != m.end() && !m["incidentId"].empty()) {
      incidentId = make_shared<long>(boost::any_cast<long>(m["incidentId"]));
    }
    if (m.find("incidentNumber") != m.end() && !m["incidentNumber"].empty()) {
      incidentNumber = make_shared<string>(boost::any_cast<string>(m["incidentNumber"]));
    }
    if (m.find("isRuleTrigger") != m.end() && !m["isRuleTrigger"].empty()) {
      isRuleTrigger = make_shared<bool>(boost::any_cast<bool>(m["isRuleTrigger"]));
    }
    if (m.find("mainHandler") != m.end() && !m["mainHandler"].empty()) {
      mainHandler = make_shared<long>(boost::any_cast<long>(m["mainHandler"]));
    }
    if (m.find("mainHandlerId") != m.end() && !m["mainHandlerId"].empty()) {
      mainHandlerId = make_shared<long>(boost::any_cast<long>(m["mainHandlerId"]));
    }
    if (m.find("mainHandlerIsValid") != m.end() && !m["mainHandlerIsValid"].empty()) {
      mainHandlerIsValid = make_shared<long>(boost::any_cast<long>(m["mainHandlerIsValid"]));
    }
    if (m.find("mainHandlerPhone") != m.end() && !m["mainHandlerPhone"].empty()) {
      mainHandlerPhone = make_shared<string>(boost::any_cast<string>(m["mainHandlerPhone"]));
    }
    if (m.find("preliminaryReason") != m.end() && !m["preliminaryReason"].empty()) {
      preliminaryReason = make_shared<string>(boost::any_cast<string>(m["preliminaryReason"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
    if (m.find("problemLevel") != m.end() && !m["problemLevel"].empty()) {
      problemLevel = make_shared<long>(boost::any_cast<long>(m["problemLevel"]));
    }
    if (m.find("problemName") != m.end() && !m["problemName"].empty()) {
      problemName = make_shared<string>(boost::any_cast<string>(m["problemName"]));
    }
    if (m.find("problemNumber") != m.end() && !m["problemNumber"].empty()) {
      problemNumber = make_shared<string>(boost::any_cast<string>(m["problemNumber"]));
    }
    if (m.find("problemStatus") != m.end() && !m["problemStatus"].empty()) {
      problemStatus = make_shared<long>(boost::any_cast<long>(m["problemStatus"]));
    }
    if (m.find("progressSummary") != m.end() && !m["progressSummary"].empty()) {
      progressSummary = make_shared<string>(boost::any_cast<string>(m["progressSummary"]));
    }
    if (m.find("progressSummaryRichTextId") != m.end() && !m["progressSummaryRichTextId"].empty()) {
      progressSummaryRichTextId = make_shared<long>(boost::any_cast<long>(m["progressSummaryRichTextId"]));
    }
    if (m.find("recoveryTime") != m.end() && !m["recoveryTime"].empty()) {
      recoveryTime = make_shared<string>(boost::any_cast<string>(m["recoveryTime"]));
    }
    if (m.find("relatedServiceId") != m.end() && !m["relatedServiceId"].empty()) {
      relatedServiceId = make_shared<long>(boost::any_cast<long>(m["relatedServiceId"]));
    }
    if (m.find("replayProblemOperateLogs") != m.end() && !m["replayProblemOperateLogs"].empty()) {
      if (typeid(vector<boost::any>) == m["replayProblemOperateLogs"].type()) {
        vector<GetProblemResponseBodyDataReplayProblemOperateLogs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["replayProblemOperateLogs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetProblemResponseBodyDataReplayProblemOperateLogs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        replayProblemOperateLogs = make_shared<vector<GetProblemResponseBodyDataReplayProblemOperateLogs>>(expect1);
      }
    }
    if (m.find("replayingProblemOperateLogs") != m.end() && !m["replayingProblemOperateLogs"].empty()) {
      if (typeid(vector<boost::any>) == m["replayingProblemOperateLogs"].type()) {
        vector<GetProblemResponseBodyDataReplayingProblemOperateLogs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["replayingProblemOperateLogs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetProblemResponseBodyDataReplayingProblemOperateLogs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        replayingProblemOperateLogs = make_shared<vector<GetProblemResponseBodyDataReplayingProblemOperateLogs>>(expect1);
      }
    }
    if (m.find("restoredProblemOperateLogs") != m.end() && !m["restoredProblemOperateLogs"].empty()) {
      if (typeid(vector<boost::any>) == m["restoredProblemOperateLogs"].type()) {
        vector<GetProblemResponseBodyDataRestoredProblemOperateLogs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["restoredProblemOperateLogs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetProblemResponseBodyDataRestoredProblemOperateLogs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        restoredProblemOperateLogs = make_shared<vector<GetProblemResponseBodyDataRestoredProblemOperateLogs>>(expect1);
      }
    }
    if (m.find("serviceDeleteType") != m.end() && !m["serviceDeleteType"].empty()) {
      serviceDeleteType = make_shared<long>(boost::any_cast<long>(m["serviceDeleteType"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
    if (m.find("timelines") != m.end() && !m["timelines"].empty()) {
      if (typeid(vector<boost::any>) == m["timelines"].type()) {
        vector<GetProblemResponseBodyDataTimelines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["timelines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetProblemResponseBodyDataTimelines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        timelines = make_shared<vector<GetProblemResponseBodyDataTimelines>>(expect1);
      }
    }
  }


  virtual ~GetProblemResponseBodyData() = default;
};
class GetProblemResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetProblemResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetProblemResponseBody() {}

  explicit GetProblemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GetProblemResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GetProblemResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetProblemResponseBody() = default;
};
class GetProblemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetProblemResponseBody> body{};

  GetProblemResponse() {}

  explicit GetProblemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetProblemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetProblemResponseBody>(model1);
      }
    }
  }


  virtual ~GetProblemResponse() = default;
};
class GetProblemEffectionServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> effectionServiceId{};
  shared_ptr<long> problemId{};

  GetProblemEffectionServiceRequest() {}

  explicit GetProblemEffectionServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (effectionServiceId) {
      res["effectionServiceId"] = boost::any(*effectionServiceId);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("effectionServiceId") != m.end() && !m["effectionServiceId"].empty()) {
      effectionServiceId = make_shared<long>(boost::any_cast<long>(m["effectionServiceId"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
  }


  virtual ~GetProblemEffectionServiceRequest() = default;
};
class GetProblemEffectionServiceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<long> effectionServiceId{};
  shared_ptr<long> level{};
  shared_ptr<vector<string>> picUrl{};
  shared_ptr<long> serviceId{};
  shared_ptr<string> serviceName{};
  shared_ptr<long> status{};

  GetProblemEffectionServiceResponseBodyData() {}

  explicit GetProblemEffectionServiceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (effectionServiceId) {
      res["effectionServiceId"] = boost::any(*effectionServiceId);
    }
    if (level) {
      res["level"] = boost::any(*level);
    }
    if (picUrl) {
      res["picUrl"] = boost::any(*picUrl);
    }
    if (serviceId) {
      res["serviceId"] = boost::any(*serviceId);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("effectionServiceId") != m.end() && !m["effectionServiceId"].empty()) {
      effectionServiceId = make_shared<long>(boost::any_cast<long>(m["effectionServiceId"]));
    }
    if (m.find("level") != m.end() && !m["level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["level"]));
    }
    if (m.find("picUrl") != m.end() && !m["picUrl"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["picUrl"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["picUrl"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      picUrl = make_shared<vector<string>>(toVec1);
    }
    if (m.find("serviceId") != m.end() && !m["serviceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["serviceId"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<long>(boost::any_cast<long>(m["status"]));
    }
  }


  virtual ~GetProblemEffectionServiceResponseBodyData() = default;
};
class GetProblemEffectionServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetProblemEffectionServiceResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetProblemEffectionServiceResponseBody() {}

  explicit GetProblemEffectionServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GetProblemEffectionServiceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GetProblemEffectionServiceResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetProblemEffectionServiceResponseBody() = default;
};
class GetProblemEffectionServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetProblemEffectionServiceResponseBody> body{};

  GetProblemEffectionServiceResponse() {}

  explicit GetProblemEffectionServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetProblemEffectionServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetProblemEffectionServiceResponseBody>(model1);
      }
    }
  }


  virtual ~GetProblemEffectionServiceResponse() = default;
};
class GetProblemImprovementRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> problemId{};

  GetProblemImprovementRequest() {}

  explicit GetProblemImprovementRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<string>(boost::any_cast<string>(m["problemId"]));
    }
  }


  virtual ~GetProblemImprovementRequest() = default;
};
class GetProblemImprovementResponseBodyDataMeasureList : public Darabonba::Model {
public:
  shared_ptr<string> checkStandard{};
  shared_ptr<long> checkUserId{};
  shared_ptr<long> checkUserIsValid{};
  shared_ptr<string> checkUserName{};
  shared_ptr<string> content{};
  shared_ptr<long> directorId{};
  shared_ptr<long> directorIsValid{};
  shared_ptr<string> directorName{};
  shared_ptr<long> measureId{};
  shared_ptr<string> planFinishTime{};
  shared_ptr<long> stalkerId{};
  shared_ptr<long> stalkerIsValid{};
  shared_ptr<string> stalkerName{};
  shared_ptr<string> status{};
  shared_ptr<long> type{};

  GetProblemImprovementResponseBodyDataMeasureList() {}

  explicit GetProblemImprovementResponseBodyDataMeasureList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkStandard) {
      res["checkStandard"] = boost::any(*checkStandard);
    }
    if (checkUserId) {
      res["checkUserId"] = boost::any(*checkUserId);
    }
    if (checkUserIsValid) {
      res["checkUserIsValid"] = boost::any(*checkUserIsValid);
    }
    if (checkUserName) {
      res["checkUserName"] = boost::any(*checkUserName);
    }
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (directorId) {
      res["directorId"] = boost::any(*directorId);
    }
    if (directorIsValid) {
      res["directorIsValid"] = boost::any(*directorIsValid);
    }
    if (directorName) {
      res["directorName"] = boost::any(*directorName);
    }
    if (measureId) {
      res["measureId"] = boost::any(*measureId);
    }
    if (planFinishTime) {
      res["planFinishTime"] = boost::any(*planFinishTime);
    }
    if (stalkerId) {
      res["stalkerId"] = boost::any(*stalkerId);
    }
    if (stalkerIsValid) {
      res["stalkerIsValid"] = boost::any(*stalkerIsValid);
    }
    if (stalkerName) {
      res["stalkerName"] = boost::any(*stalkerName);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("checkStandard") != m.end() && !m["checkStandard"].empty()) {
      checkStandard = make_shared<string>(boost::any_cast<string>(m["checkStandard"]));
    }
    if (m.find("checkUserId") != m.end() && !m["checkUserId"].empty()) {
      checkUserId = make_shared<long>(boost::any_cast<long>(m["checkUserId"]));
    }
    if (m.find("checkUserIsValid") != m.end() && !m["checkUserIsValid"].empty()) {
      checkUserIsValid = make_shared<long>(boost::any_cast<long>(m["checkUserIsValid"]));
    }
    if (m.find("checkUserName") != m.end() && !m["checkUserName"].empty()) {
      checkUserName = make_shared<string>(boost::any_cast<string>(m["checkUserName"]));
    }
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("directorId") != m.end() && !m["directorId"].empty()) {
      directorId = make_shared<long>(boost::any_cast<long>(m["directorId"]));
    }
    if (m.find("directorIsValid") != m.end() && !m["directorIsValid"].empty()) {
      directorIsValid = make_shared<long>(boost::any_cast<long>(m["directorIsValid"]));
    }
    if (m.find("directorName") != m.end() && !m["directorName"].empty()) {
      directorName = make_shared<string>(boost::any_cast<string>(m["directorName"]));
    }
    if (m.find("measureId") != m.end() && !m["measureId"].empty()) {
      measureId = make_shared<long>(boost::any_cast<long>(m["measureId"]));
    }
    if (m.find("planFinishTime") != m.end() && !m["planFinishTime"].empty()) {
      planFinishTime = make_shared<string>(boost::any_cast<string>(m["planFinishTime"]));
    }
    if (m.find("stalkerId") != m.end() && !m["stalkerId"].empty()) {
      stalkerId = make_shared<long>(boost::any_cast<long>(m["stalkerId"]));
    }
    if (m.find("stalkerIsValid") != m.end() && !m["stalkerIsValid"].empty()) {
      stalkerIsValid = make_shared<long>(boost::any_cast<long>(m["stalkerIsValid"]));
    }
    if (m.find("stalkerName") != m.end() && !m["stalkerName"].empty()) {
      stalkerName = make_shared<string>(boost::any_cast<string>(m["stalkerName"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~GetProblemImprovementResponseBodyDataMeasureList() = default;
};
class GetProblemImprovementResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> customProblemReason{};
  shared_ptr<string> discoverSource{};
  shared_ptr<string> dutyDepartmentId{};
  shared_ptr<string> dutyDepartmentName{};
  shared_ptr<long> dutyUserId{};
  shared_ptr<long> dutyUserIsValid{};
  shared_ptr<string> dutyUserName{};
  shared_ptr<string> dutyUserPhone{};
  shared_ptr<string> injectionMode{};
  shared_ptr<bool> isManual{};
  shared_ptr<vector<GetProblemImprovementResponseBodyDataMeasureList>> measureList{};
  shared_ptr<string> monitorSourceName{};
  shared_ptr<string> problemId{};
  shared_ptr<string> problemReason{};
  shared_ptr<string> recentActivity{};
  shared_ptr<string> recoveryMode{};
  shared_ptr<string> relationChanges{};
  shared_ptr<string> remark{};
  shared_ptr<long> replayDutyUserId{};
  shared_ptr<long> replayDutyUserIsValid{};
  shared_ptr<string> replayDutyUserName{};
  shared_ptr<string> replayDutyUserPhone{};
  shared_ptr<long> userReport{};

  GetProblemImprovementResponseBodyData() {}

  explicit GetProblemImprovementResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customProblemReason) {
      res["customProblemReason"] = boost::any(*customProblemReason);
    }
    if (discoverSource) {
      res["discoverSource"] = boost::any(*discoverSource);
    }
    if (dutyDepartmentId) {
      res["dutyDepartmentId"] = boost::any(*dutyDepartmentId);
    }
    if (dutyDepartmentName) {
      res["dutyDepartmentName"] = boost::any(*dutyDepartmentName);
    }
    if (dutyUserId) {
      res["dutyUserId"] = boost::any(*dutyUserId);
    }
    if (dutyUserIsValid) {
      res["dutyUserIsValid"] = boost::any(*dutyUserIsValid);
    }
    if (dutyUserName) {
      res["dutyUserName"] = boost::any(*dutyUserName);
    }
    if (dutyUserPhone) {
      res["dutyUserPhone"] = boost::any(*dutyUserPhone);
    }
    if (injectionMode) {
      res["injectionMode"] = boost::any(*injectionMode);
    }
    if (isManual) {
      res["isManual"] = boost::any(*isManual);
    }
    if (measureList) {
      vector<boost::any> temp1;
      for(auto item1:*measureList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["measureList"] = boost::any(temp1);
    }
    if (monitorSourceName) {
      res["monitorSourceName"] = boost::any(*monitorSourceName);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    if (problemReason) {
      res["problemReason"] = boost::any(*problemReason);
    }
    if (recentActivity) {
      res["recentActivity"] = boost::any(*recentActivity);
    }
    if (recoveryMode) {
      res["recoveryMode"] = boost::any(*recoveryMode);
    }
    if (relationChanges) {
      res["relationChanges"] = boost::any(*relationChanges);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (replayDutyUserId) {
      res["replayDutyUserId"] = boost::any(*replayDutyUserId);
    }
    if (replayDutyUserIsValid) {
      res["replayDutyUserIsValid"] = boost::any(*replayDutyUserIsValid);
    }
    if (replayDutyUserName) {
      res["replayDutyUserName"] = boost::any(*replayDutyUserName);
    }
    if (replayDutyUserPhone) {
      res["replayDutyUserPhone"] = boost::any(*replayDutyUserPhone);
    }
    if (userReport) {
      res["userReport"] = boost::any(*userReport);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("customProblemReason") != m.end() && !m["customProblemReason"].empty()) {
      customProblemReason = make_shared<string>(boost::any_cast<string>(m["customProblemReason"]));
    }
    if (m.find("discoverSource") != m.end() && !m["discoverSource"].empty()) {
      discoverSource = make_shared<string>(boost::any_cast<string>(m["discoverSource"]));
    }
    if (m.find("dutyDepartmentId") != m.end() && !m["dutyDepartmentId"].empty()) {
      dutyDepartmentId = make_shared<string>(boost::any_cast<string>(m["dutyDepartmentId"]));
    }
    if (m.find("dutyDepartmentName") != m.end() && !m["dutyDepartmentName"].empty()) {
      dutyDepartmentName = make_shared<string>(boost::any_cast<string>(m["dutyDepartmentName"]));
    }
    if (m.find("dutyUserId") != m.end() && !m["dutyUserId"].empty()) {
      dutyUserId = make_shared<long>(boost::any_cast<long>(m["dutyUserId"]));
    }
    if (m.find("dutyUserIsValid") != m.end() && !m["dutyUserIsValid"].empty()) {
      dutyUserIsValid = make_shared<long>(boost::any_cast<long>(m["dutyUserIsValid"]));
    }
    if (m.find("dutyUserName") != m.end() && !m["dutyUserName"].empty()) {
      dutyUserName = make_shared<string>(boost::any_cast<string>(m["dutyUserName"]));
    }
    if (m.find("dutyUserPhone") != m.end() && !m["dutyUserPhone"].empty()) {
      dutyUserPhone = make_shared<string>(boost::any_cast<string>(m["dutyUserPhone"]));
    }
    if (m.find("injectionMode") != m.end() && !m["injectionMode"].empty()) {
      injectionMode = make_shared<string>(boost::any_cast<string>(m["injectionMode"]));
    }
    if (m.find("isManual") != m.end() && !m["isManual"].empty()) {
      isManual = make_shared<bool>(boost::any_cast<bool>(m["isManual"]));
    }
    if (m.find("measureList") != m.end() && !m["measureList"].empty()) {
      if (typeid(vector<boost::any>) == m["measureList"].type()) {
        vector<GetProblemImprovementResponseBodyDataMeasureList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["measureList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetProblemImprovementResponseBodyDataMeasureList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        measureList = make_shared<vector<GetProblemImprovementResponseBodyDataMeasureList>>(expect1);
      }
    }
    if (m.find("monitorSourceName") != m.end() && !m["monitorSourceName"].empty()) {
      monitorSourceName = make_shared<string>(boost::any_cast<string>(m["monitorSourceName"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<string>(boost::any_cast<string>(m["problemId"]));
    }
    if (m.find("problemReason") != m.end() && !m["problemReason"].empty()) {
      problemReason = make_shared<string>(boost::any_cast<string>(m["problemReason"]));
    }
    if (m.find("recentActivity") != m.end() && !m["recentActivity"].empty()) {
      recentActivity = make_shared<string>(boost::any_cast<string>(m["recentActivity"]));
    }
    if (m.find("recoveryMode") != m.end() && !m["recoveryMode"].empty()) {
      recoveryMode = make_shared<string>(boost::any_cast<string>(m["recoveryMode"]));
    }
    if (m.find("relationChanges") != m.end() && !m["relationChanges"].empty()) {
      relationChanges = make_shared<string>(boost::any_cast<string>(m["relationChanges"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("replayDutyUserId") != m.end() && !m["replayDutyUserId"].empty()) {
      replayDutyUserId = make_shared<long>(boost::any_cast<long>(m["replayDutyUserId"]));
    }
    if (m.find("replayDutyUserIsValid") != m.end() && !m["replayDutyUserIsValid"].empty()) {
      replayDutyUserIsValid = make_shared<long>(boost::any_cast<long>(m["replayDutyUserIsValid"]));
    }
    if (m.find("replayDutyUserName") != m.end() && !m["replayDutyUserName"].empty()) {
      replayDutyUserName = make_shared<string>(boost::any_cast<string>(m["replayDutyUserName"]));
    }
    if (m.find("replayDutyUserPhone") != m.end() && !m["replayDutyUserPhone"].empty()) {
      replayDutyUserPhone = make_shared<string>(boost::any_cast<string>(m["replayDutyUserPhone"]));
    }
    if (m.find("userReport") != m.end() && !m["userReport"].empty()) {
      userReport = make_shared<long>(boost::any_cast<long>(m["userReport"]));
    }
  }


  virtual ~GetProblemImprovementResponseBodyData() = default;
};
class GetProblemImprovementResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetProblemImprovementResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetProblemImprovementResponseBody() {}

  explicit GetProblemImprovementResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GetProblemImprovementResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GetProblemImprovementResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetProblemImprovementResponseBody() = default;
};
class GetProblemImprovementResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetProblemImprovementResponseBody> body{};

  GetProblemImprovementResponse() {}

  explicit GetProblemImprovementResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetProblemImprovementResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetProblemImprovementResponseBody>(model1);
      }
    }
  }


  virtual ~GetProblemImprovementResponse() = default;
};
class GetProblemPreviewRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<vector<long>> effectServiceIds{};
  shared_ptr<long> incidentId{};
  shared_ptr<long> problemId{};
  shared_ptr<string> problemLevel{};
  shared_ptr<string> problemNotifyType{};
  shared_ptr<long> relatedServiceId{};
  shared_ptr<vector<long>> serviceGroupIds{};

  GetProblemPreviewRequest() {}

  explicit GetProblemPreviewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (effectServiceIds) {
      res["effectServiceIds"] = boost::any(*effectServiceIds);
    }
    if (incidentId) {
      res["incidentId"] = boost::any(*incidentId);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    if (problemLevel) {
      res["problemLevel"] = boost::any(*problemLevel);
    }
    if (problemNotifyType) {
      res["problemNotifyType"] = boost::any(*problemNotifyType);
    }
    if (relatedServiceId) {
      res["relatedServiceId"] = boost::any(*relatedServiceId);
    }
    if (serviceGroupIds) {
      res["serviceGroupIds"] = boost::any(*serviceGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("effectServiceIds") != m.end() && !m["effectServiceIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["effectServiceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["effectServiceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      effectServiceIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("incidentId") != m.end() && !m["incidentId"].empty()) {
      incidentId = make_shared<long>(boost::any_cast<long>(m["incidentId"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
    if (m.find("problemLevel") != m.end() && !m["problemLevel"].empty()) {
      problemLevel = make_shared<string>(boost::any_cast<string>(m["problemLevel"]));
    }
    if (m.find("problemNotifyType") != m.end() && !m["problemNotifyType"].empty()) {
      problemNotifyType = make_shared<string>(boost::any_cast<string>(m["problemNotifyType"]));
    }
    if (m.find("relatedServiceId") != m.end() && !m["relatedServiceId"].empty()) {
      relatedServiceId = make_shared<long>(boost::any_cast<long>(m["relatedServiceId"]));
    }
    if (m.find("serviceGroupIds") != m.end() && !m["serviceGroupIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["serviceGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["serviceGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      serviceGroupIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~GetProblemPreviewRequest() = default;
};
class GetProblemPreviewResponseBodyDataMailUsers : public Darabonba::Model {
public:
  shared_ptr<string> username{};

  GetProblemPreviewResponseBodyDataMailUsers() {}

  explicit GetProblemPreviewResponseBodyDataMailUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~GetProblemPreviewResponseBodyDataMailUsers() = default;
};
class GetProblemPreviewResponseBodyDataMail : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<GetProblemPreviewResponseBodyDataMailUsers>> users{};

  GetProblemPreviewResponseBodyDataMail() {}

  explicit GetProblemPreviewResponseBodyDataMail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["count"] = boost::any(*count);
    }
    if (users) {
      vector<boost::any> temp1;
      for(auto item1:*users){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["users"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("count") != m.end() && !m["count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["count"]));
    }
    if (m.find("users") != m.end() && !m["users"].empty()) {
      if (typeid(vector<boost::any>) == m["users"].type()) {
        vector<GetProblemPreviewResponseBodyDataMailUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["users"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetProblemPreviewResponseBodyDataMailUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        users = make_shared<vector<GetProblemPreviewResponseBodyDataMailUsers>>(expect1);
      }
    }
  }


  virtual ~GetProblemPreviewResponseBodyDataMail() = default;
};
class GetProblemPreviewResponseBodyDataProblemCoordinationGroups : public Darabonba::Model {
public:
  shared_ptr<string> serviceGroupDescription{};
  shared_ptr<long> serviceGroupId{};
  shared_ptr<string> serviceGroupName{};

  GetProblemPreviewResponseBodyDataProblemCoordinationGroups() {}

  explicit GetProblemPreviewResponseBodyDataProblemCoordinationGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceGroupDescription) {
      res["serviceGroupDescription"] = boost::any(*serviceGroupDescription);
    }
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    if (serviceGroupName) {
      res["serviceGroupName"] = boost::any(*serviceGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("serviceGroupDescription") != m.end() && !m["serviceGroupDescription"].empty()) {
      serviceGroupDescription = make_shared<string>(boost::any_cast<string>(m["serviceGroupDescription"]));
    }
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
    if (m.find("serviceGroupName") != m.end() && !m["serviceGroupName"].empty()) {
      serviceGroupName = make_shared<string>(boost::any_cast<string>(m["serviceGroupName"]));
    }
  }


  virtual ~GetProblemPreviewResponseBodyDataProblemCoordinationGroups() = default;
};
class GetProblemPreviewResponseBodyDataProblemEffectionServices : public Darabonba::Model {
public:
  shared_ptr<long> serviceId{};
  shared_ptr<string> serviceName{};

  GetProblemPreviewResponseBodyDataProblemEffectionServices() {}

  explicit GetProblemPreviewResponseBodyDataProblemEffectionServices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceId) {
      res["serviceId"] = boost::any(*serviceId);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("serviceId") != m.end() && !m["serviceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["serviceId"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
  }


  virtual ~GetProblemPreviewResponseBodyDataProblemEffectionServices() = default;
};
class GetProblemPreviewResponseBodyDataProblem : public Darabonba::Model {
public:
  shared_ptr<vector<GetProblemPreviewResponseBodyDataProblemCoordinationGroups>> coordinationGroups{};
  shared_ptr<string> createTime{};
  shared_ptr<string> discoverTime{};
  shared_ptr<vector<GetProblemPreviewResponseBodyDataProblemEffectionServices>> effectionServices{};
  shared_ptr<bool> isManual{};
  shared_ptr<bool> isUpgrade{};
  shared_ptr<string> mainHandlerId{};
  shared_ptr<string> mainHandlerName{};
  shared_ptr<string> preliminaryReason{};
  shared_ptr<long> problemId{};
  shared_ptr<string> problemLevel{};
  shared_ptr<string> problemName{};
  shared_ptr<string> problemStatus{};
  shared_ptr<string> progressSummary{};
  shared_ptr<long> progressSummaryRichTextId{};
  shared_ptr<string> recoveryTime{};
  shared_ptr<long> relatedServiceId{};
  shared_ptr<string> serviceName{};

  GetProblemPreviewResponseBodyDataProblem() {}

  explicit GetProblemPreviewResponseBodyDataProblem(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coordinationGroups) {
      vector<boost::any> temp1;
      for(auto item1:*coordinationGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["coordinationGroups"] = boost::any(temp1);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (discoverTime) {
      res["discoverTime"] = boost::any(*discoverTime);
    }
    if (effectionServices) {
      vector<boost::any> temp1;
      for(auto item1:*effectionServices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["effectionServices"] = boost::any(temp1);
    }
    if (isManual) {
      res["isManual"] = boost::any(*isManual);
    }
    if (isUpgrade) {
      res["isUpgrade"] = boost::any(*isUpgrade);
    }
    if (mainHandlerId) {
      res["mainHandlerId"] = boost::any(*mainHandlerId);
    }
    if (mainHandlerName) {
      res["mainHandlerName"] = boost::any(*mainHandlerName);
    }
    if (preliminaryReason) {
      res["preliminaryReason"] = boost::any(*preliminaryReason);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    if (problemLevel) {
      res["problemLevel"] = boost::any(*problemLevel);
    }
    if (problemName) {
      res["problemName"] = boost::any(*problemName);
    }
    if (problemStatus) {
      res["problemStatus"] = boost::any(*problemStatus);
    }
    if (progressSummary) {
      res["progressSummary"] = boost::any(*progressSummary);
    }
    if (progressSummaryRichTextId) {
      res["progressSummaryRichTextId"] = boost::any(*progressSummaryRichTextId);
    }
    if (recoveryTime) {
      res["recoveryTime"] = boost::any(*recoveryTime);
    }
    if (relatedServiceId) {
      res["relatedServiceId"] = boost::any(*relatedServiceId);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("coordinationGroups") != m.end() && !m["coordinationGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["coordinationGroups"].type()) {
        vector<GetProblemPreviewResponseBodyDataProblemCoordinationGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["coordinationGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetProblemPreviewResponseBodyDataProblemCoordinationGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        coordinationGroups = make_shared<vector<GetProblemPreviewResponseBodyDataProblemCoordinationGroups>>(expect1);
      }
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("discoverTime") != m.end() && !m["discoverTime"].empty()) {
      discoverTime = make_shared<string>(boost::any_cast<string>(m["discoverTime"]));
    }
    if (m.find("effectionServices") != m.end() && !m["effectionServices"].empty()) {
      if (typeid(vector<boost::any>) == m["effectionServices"].type()) {
        vector<GetProblemPreviewResponseBodyDataProblemEffectionServices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["effectionServices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetProblemPreviewResponseBodyDataProblemEffectionServices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        effectionServices = make_shared<vector<GetProblemPreviewResponseBodyDataProblemEffectionServices>>(expect1);
      }
    }
    if (m.find("isManual") != m.end() && !m["isManual"].empty()) {
      isManual = make_shared<bool>(boost::any_cast<bool>(m["isManual"]));
    }
    if (m.find("isUpgrade") != m.end() && !m["isUpgrade"].empty()) {
      isUpgrade = make_shared<bool>(boost::any_cast<bool>(m["isUpgrade"]));
    }
    if (m.find("mainHandlerId") != m.end() && !m["mainHandlerId"].empty()) {
      mainHandlerId = make_shared<string>(boost::any_cast<string>(m["mainHandlerId"]));
    }
    if (m.find("mainHandlerName") != m.end() && !m["mainHandlerName"].empty()) {
      mainHandlerName = make_shared<string>(boost::any_cast<string>(m["mainHandlerName"]));
    }
    if (m.find("preliminaryReason") != m.end() && !m["preliminaryReason"].empty()) {
      preliminaryReason = make_shared<string>(boost::any_cast<string>(m["preliminaryReason"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
    if (m.find("problemLevel") != m.end() && !m["problemLevel"].empty()) {
      problemLevel = make_shared<string>(boost::any_cast<string>(m["problemLevel"]));
    }
    if (m.find("problemName") != m.end() && !m["problemName"].empty()) {
      problemName = make_shared<string>(boost::any_cast<string>(m["problemName"]));
    }
    if (m.find("problemStatus") != m.end() && !m["problemStatus"].empty()) {
      problemStatus = make_shared<string>(boost::any_cast<string>(m["problemStatus"]));
    }
    if (m.find("progressSummary") != m.end() && !m["progressSummary"].empty()) {
      progressSummary = make_shared<string>(boost::any_cast<string>(m["progressSummary"]));
    }
    if (m.find("progressSummaryRichTextId") != m.end() && !m["progressSummaryRichTextId"].empty()) {
      progressSummaryRichTextId = make_shared<long>(boost::any_cast<long>(m["progressSummaryRichTextId"]));
    }
    if (m.find("recoveryTime") != m.end() && !m["recoveryTime"].empty()) {
      recoveryTime = make_shared<string>(boost::any_cast<string>(m["recoveryTime"]));
    }
    if (m.find("relatedServiceId") != m.end() && !m["relatedServiceId"].empty()) {
      relatedServiceId = make_shared<long>(boost::any_cast<long>(m["relatedServiceId"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
  }


  virtual ~GetProblemPreviewResponseBodyDataProblem() = default;
};
class GetProblemPreviewResponseBodyDataSmsUsers : public Darabonba::Model {
public:
  shared_ptr<string> username{};

  GetProblemPreviewResponseBodyDataSmsUsers() {}

  explicit GetProblemPreviewResponseBodyDataSmsUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~GetProblemPreviewResponseBodyDataSmsUsers() = default;
};
class GetProblemPreviewResponseBodyDataSms : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<GetProblemPreviewResponseBodyDataSmsUsers>> users{};

  GetProblemPreviewResponseBodyDataSms() {}

  explicit GetProblemPreviewResponseBodyDataSms(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["count"] = boost::any(*count);
    }
    if (users) {
      vector<boost::any> temp1;
      for(auto item1:*users){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["users"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("count") != m.end() && !m["count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["count"]));
    }
    if (m.find("users") != m.end() && !m["users"].empty()) {
      if (typeid(vector<boost::any>) == m["users"].type()) {
        vector<GetProblemPreviewResponseBodyDataSmsUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["users"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetProblemPreviewResponseBodyDataSmsUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        users = make_shared<vector<GetProblemPreviewResponseBodyDataSmsUsers>>(expect1);
      }
    }
  }


  virtual ~GetProblemPreviewResponseBodyDataSms() = default;
};
class GetProblemPreviewResponseBodyDataVoiceUsers : public Darabonba::Model {
public:
  shared_ptr<string> username{};

  GetProblemPreviewResponseBodyDataVoiceUsers() {}

  explicit GetProblemPreviewResponseBodyDataVoiceUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~GetProblemPreviewResponseBodyDataVoiceUsers() = default;
};
class GetProblemPreviewResponseBodyDataVoice : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<GetProblemPreviewResponseBodyDataVoiceUsers>> users{};

  GetProblemPreviewResponseBodyDataVoice() {}

  explicit GetProblemPreviewResponseBodyDataVoice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["count"] = boost::any(*count);
    }
    if (users) {
      vector<boost::any> temp1;
      for(auto item1:*users){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["users"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("count") != m.end() && !m["count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["count"]));
    }
    if (m.find("users") != m.end() && !m["users"].empty()) {
      if (typeid(vector<boost::any>) == m["users"].type()) {
        vector<GetProblemPreviewResponseBodyDataVoiceUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["users"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetProblemPreviewResponseBodyDataVoiceUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        users = make_shared<vector<GetProblemPreviewResponseBodyDataVoiceUsers>>(expect1);
      }
    }
  }


  virtual ~GetProblemPreviewResponseBodyDataVoice() = default;
};
class GetProblemPreviewResponseBodyDataWebhookServiceGroups : public Darabonba::Model {
public:
  shared_ptr<string> serviceName{};

  GetProblemPreviewResponseBodyDataWebhookServiceGroups() {}

  explicit GetProblemPreviewResponseBodyDataWebhookServiceGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
  }


  virtual ~GetProblemPreviewResponseBodyDataWebhookServiceGroups() = default;
};
class GetProblemPreviewResponseBodyDataWebhook : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<vector<GetProblemPreviewResponseBodyDataWebhookServiceGroups>> serviceGroups{};

  GetProblemPreviewResponseBodyDataWebhook() {}

  explicit GetProblemPreviewResponseBodyDataWebhook(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["count"] = boost::any(*count);
    }
    if (serviceGroups) {
      vector<boost::any> temp1;
      for(auto item1:*serviceGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["serviceGroups"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("count") != m.end() && !m["count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["count"]));
    }
    if (m.find("serviceGroups") != m.end() && !m["serviceGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["serviceGroups"].type()) {
        vector<GetProblemPreviewResponseBodyDataWebhookServiceGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["serviceGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetProblemPreviewResponseBodyDataWebhookServiceGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceGroups = make_shared<vector<GetProblemPreviewResponseBodyDataWebhookServiceGroups>>(expect1);
      }
    }
  }


  virtual ~GetProblemPreviewResponseBodyDataWebhook() = default;
};
class GetProblemPreviewResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> deAfterData{};
  shared_ptr<string> deBeforeData{};
  shared_ptr<GetProblemPreviewResponseBodyDataMail> mail{};
  shared_ptr<GetProblemPreviewResponseBodyDataProblem> problem{};
  shared_ptr<GetProblemPreviewResponseBodyDataSms> sms{};
  shared_ptr<string> upAfterData{};
  shared_ptr<string> upBeforeData{};
  shared_ptr<GetProblemPreviewResponseBodyDataVoice> voice{};
  shared_ptr<GetProblemPreviewResponseBodyDataWebhook> webhook{};

  GetProblemPreviewResponseBodyData() {}

  explicit GetProblemPreviewResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deAfterData) {
      res["deAfterData"] = boost::any(*deAfterData);
    }
    if (deBeforeData) {
      res["deBeforeData"] = boost::any(*deBeforeData);
    }
    if (mail) {
      res["mail"] = mail ? boost::any(mail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (problem) {
      res["problem"] = problem ? boost::any(problem->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sms) {
      res["sms"] = sms ? boost::any(sms->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (upAfterData) {
      res["upAfterData"] = boost::any(*upAfterData);
    }
    if (upBeforeData) {
      res["upBeforeData"] = boost::any(*upBeforeData);
    }
    if (voice) {
      res["voice"] = voice ? boost::any(voice->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (webhook) {
      res["webhook"] = webhook ? boost::any(webhook->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("deAfterData") != m.end() && !m["deAfterData"].empty()) {
      deAfterData = make_shared<string>(boost::any_cast<string>(m["deAfterData"]));
    }
    if (m.find("deBeforeData") != m.end() && !m["deBeforeData"].empty()) {
      deBeforeData = make_shared<string>(boost::any_cast<string>(m["deBeforeData"]));
    }
    if (m.find("mail") != m.end() && !m["mail"].empty()) {
      if (typeid(map<string, boost::any>) == m["mail"].type()) {
        GetProblemPreviewResponseBodyDataMail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["mail"]));
        mail = make_shared<GetProblemPreviewResponseBodyDataMail>(model1);
      }
    }
    if (m.find("problem") != m.end() && !m["problem"].empty()) {
      if (typeid(map<string, boost::any>) == m["problem"].type()) {
        GetProblemPreviewResponseBodyDataProblem model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["problem"]));
        problem = make_shared<GetProblemPreviewResponseBodyDataProblem>(model1);
      }
    }
    if (m.find("sms") != m.end() && !m["sms"].empty()) {
      if (typeid(map<string, boost::any>) == m["sms"].type()) {
        GetProblemPreviewResponseBodyDataSms model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["sms"]));
        sms = make_shared<GetProblemPreviewResponseBodyDataSms>(model1);
      }
    }
    if (m.find("upAfterData") != m.end() && !m["upAfterData"].empty()) {
      upAfterData = make_shared<string>(boost::any_cast<string>(m["upAfterData"]));
    }
    if (m.find("upBeforeData") != m.end() && !m["upBeforeData"].empty()) {
      upBeforeData = make_shared<string>(boost::any_cast<string>(m["upBeforeData"]));
    }
    if (m.find("voice") != m.end() && !m["voice"].empty()) {
      if (typeid(map<string, boost::any>) == m["voice"].type()) {
        GetProblemPreviewResponseBodyDataVoice model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["voice"]));
        voice = make_shared<GetProblemPreviewResponseBodyDataVoice>(model1);
      }
    }
    if (m.find("webhook") != m.end() && !m["webhook"].empty()) {
      if (typeid(map<string, boost::any>) == m["webhook"].type()) {
        GetProblemPreviewResponseBodyDataWebhook model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["webhook"]));
        webhook = make_shared<GetProblemPreviewResponseBodyDataWebhook>(model1);
      }
    }
  }


  virtual ~GetProblemPreviewResponseBodyData() = default;
};
class GetProblemPreviewResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetProblemPreviewResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetProblemPreviewResponseBody() {}

  explicit GetProblemPreviewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GetProblemPreviewResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GetProblemPreviewResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetProblemPreviewResponseBody() = default;
};
class GetProblemPreviewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetProblemPreviewResponseBody> body{};

  GetProblemPreviewResponse() {}

  explicit GetProblemPreviewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetProblemPreviewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetProblemPreviewResponseBody>(model1);
      }
    }
  }


  virtual ~GetProblemPreviewResponse() = default;
};
class GetResourceStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};

  GetResourceStatisticsRequest() {}

  explicit GetResourceStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~GetResourceStatisticsRequest() = default;
};
class GetResourceStatisticsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> alertCount{};
  shared_ptr<long> incidentCount{};
  shared_ptr<long> integrationCount{};
  shared_ptr<long> problemCount{};

  GetResourceStatisticsResponseBodyData() {}

  explicit GetResourceStatisticsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertCount) {
      res["alertCount"] = boost::any(*alertCount);
    }
    if (incidentCount) {
      res["incidentCount"] = boost::any(*incidentCount);
    }
    if (integrationCount) {
      res["integrationCount"] = boost::any(*integrationCount);
    }
    if (problemCount) {
      res["problemCount"] = boost::any(*problemCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alertCount") != m.end() && !m["alertCount"].empty()) {
      alertCount = make_shared<long>(boost::any_cast<long>(m["alertCount"]));
    }
    if (m.find("incidentCount") != m.end() && !m["incidentCount"].empty()) {
      incidentCount = make_shared<long>(boost::any_cast<long>(m["incidentCount"]));
    }
    if (m.find("integrationCount") != m.end() && !m["integrationCount"].empty()) {
      integrationCount = make_shared<long>(boost::any_cast<long>(m["integrationCount"]));
    }
    if (m.find("problemCount") != m.end() && !m["problemCount"].empty()) {
      problemCount = make_shared<long>(boost::any_cast<long>(m["problemCount"]));
    }
  }


  virtual ~GetResourceStatisticsResponseBodyData() = default;
};
class GetResourceStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetResourceStatisticsResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetResourceStatisticsResponseBody() {}

  explicit GetResourceStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GetResourceStatisticsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GetResourceStatisticsResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetResourceStatisticsResponseBody() = default;
};
class GetResourceStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetResourceStatisticsResponseBody> body{};

  GetResourceStatisticsResponse() {}

  explicit GetResourceStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetResourceStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetResourceStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~GetResourceStatisticsResponse() = default;
};
class GetRichTextRequest : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> richTextId{};

  GetRichTextRequest() {}

  explicit GetRichTextRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["instanceType"] = boost::any(*instanceType);
    }
    if (richTextId) {
      res["richTextId"] = boost::any(*richTextId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["instanceId"]));
    }
    if (m.find("instanceType") != m.end() && !m["instanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["instanceType"]));
    }
    if (m.find("richTextId") != m.end() && !m["richTextId"].empty()) {
      richTextId = make_shared<long>(boost::any_cast<long>(m["richTextId"]));
    }
  }


  virtual ~GetRichTextRequest() = default;
};
class GetRichTextResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<long> instanceType{};
  shared_ptr<string> richText{};

  GetRichTextResponseBodyData() {}

  explicit GetRichTextResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["instanceType"] = boost::any(*instanceType);
    }
    if (richText) {
      res["richText"] = boost::any(*richText);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["instanceId"]));
    }
    if (m.find("instanceType") != m.end() && !m["instanceType"].empty()) {
      instanceType = make_shared<long>(boost::any_cast<long>(m["instanceType"]));
    }
    if (m.find("richText") != m.end() && !m["richText"].empty()) {
      richText = make_shared<string>(boost::any_cast<string>(m["richText"]));
    }
  }


  virtual ~GetRichTextResponseBodyData() = default;
};
class GetRichTextResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetRichTextResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetRichTextResponseBody() {}

  explicit GetRichTextResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GetRichTextResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GetRichTextResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetRichTextResponseBody() = default;
};
class GetRichTextResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRichTextResponseBody> body{};

  GetRichTextResponse() {}

  explicit GetRichTextResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRichTextResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRichTextResponseBody>(model1);
      }
    }
  }


  virtual ~GetRichTextResponse() = default;
};
class GetRouteRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> routeRuleId{};

  GetRouteRuleRequest() {}

  explicit GetRouteRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (routeRuleId) {
      res["routeRuleId"] = boost::any(*routeRuleId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("routeRuleId") != m.end() && !m["routeRuleId"].empty()) {
      routeRuleId = make_shared<long>(boost::any_cast<long>(m["routeRuleId"]));
    }
  }


  virtual ~GetRouteRuleRequest() = default;
};
class GetRouteRuleResponseBodyDataEventRouteChildRulesConditions : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> operationSymbol{};
  shared_ptr<string> value{};

  GetRouteRuleResponseBodyDataEventRouteChildRulesConditions() {}

  explicit GetRouteRuleResponseBodyDataEventRouteChildRulesConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (operationSymbol) {
      res["operationSymbol"] = boost::any(*operationSymbol);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("operationSymbol") != m.end() && !m["operationSymbol"].empty()) {
      operationSymbol = make_shared<string>(boost::any_cast<string>(m["operationSymbol"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~GetRouteRuleResponseBodyDataEventRouteChildRulesConditions() = default;
};
class GetRouteRuleResponseBodyDataEventRouteChildRules : public Darabonba::Model {
public:
  shared_ptr<long> childConditionRelation{};
  shared_ptr<long> childRouteRuleId{};
  shared_ptr<vector<GetRouteRuleResponseBodyDataEventRouteChildRulesConditions>> conditions{};
  shared_ptr<bool> isValidChildRule{};
  shared_ptr<long> monitorIntegrationConfigId{};
  shared_ptr<long> monitorSourceId{};
  shared_ptr<string> monitorSourceName{};
  shared_ptr<long> parentRuleId{};
  shared_ptr<string> problemLevel{};

  GetRouteRuleResponseBodyDataEventRouteChildRules() {}

  explicit GetRouteRuleResponseBodyDataEventRouteChildRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (childConditionRelation) {
      res["childConditionRelation"] = boost::any(*childConditionRelation);
    }
    if (childRouteRuleId) {
      res["childRouteRuleId"] = boost::any(*childRouteRuleId);
    }
    if (conditions) {
      vector<boost::any> temp1;
      for(auto item1:*conditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["conditions"] = boost::any(temp1);
    }
    if (isValidChildRule) {
      res["isValidChildRule"] = boost::any(*isValidChildRule);
    }
    if (monitorIntegrationConfigId) {
      res["monitorIntegrationConfigId"] = boost::any(*monitorIntegrationConfigId);
    }
    if (monitorSourceId) {
      res["monitorSourceId"] = boost::any(*monitorSourceId);
    }
    if (monitorSourceName) {
      res["monitorSourceName"] = boost::any(*monitorSourceName);
    }
    if (parentRuleId) {
      res["parentRuleId"] = boost::any(*parentRuleId);
    }
    if (problemLevel) {
      res["problemLevel"] = boost::any(*problemLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("childConditionRelation") != m.end() && !m["childConditionRelation"].empty()) {
      childConditionRelation = make_shared<long>(boost::any_cast<long>(m["childConditionRelation"]));
    }
    if (m.find("childRouteRuleId") != m.end() && !m["childRouteRuleId"].empty()) {
      childRouteRuleId = make_shared<long>(boost::any_cast<long>(m["childRouteRuleId"]));
    }
    if (m.find("conditions") != m.end() && !m["conditions"].empty()) {
      if (typeid(vector<boost::any>) == m["conditions"].type()) {
        vector<GetRouteRuleResponseBodyDataEventRouteChildRulesConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["conditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRouteRuleResponseBodyDataEventRouteChildRulesConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditions = make_shared<vector<GetRouteRuleResponseBodyDataEventRouteChildRulesConditions>>(expect1);
      }
    }
    if (m.find("isValidChildRule") != m.end() && !m["isValidChildRule"].empty()) {
      isValidChildRule = make_shared<bool>(boost::any_cast<bool>(m["isValidChildRule"]));
    }
    if (m.find("monitorIntegrationConfigId") != m.end() && !m["monitorIntegrationConfigId"].empty()) {
      monitorIntegrationConfigId = make_shared<long>(boost::any_cast<long>(m["monitorIntegrationConfigId"]));
    }
    if (m.find("monitorSourceId") != m.end() && !m["monitorSourceId"].empty()) {
      monitorSourceId = make_shared<long>(boost::any_cast<long>(m["monitorSourceId"]));
    }
    if (m.find("monitorSourceName") != m.end() && !m["monitorSourceName"].empty()) {
      monitorSourceName = make_shared<string>(boost::any_cast<string>(m["monitorSourceName"]));
    }
    if (m.find("parentRuleId") != m.end() && !m["parentRuleId"].empty()) {
      parentRuleId = make_shared<long>(boost::any_cast<long>(m["parentRuleId"]));
    }
    if (m.find("problemLevel") != m.end() && !m["problemLevel"].empty()) {
      problemLevel = make_shared<string>(boost::any_cast<string>(m["problemLevel"]));
    }
  }


  virtual ~GetRouteRuleResponseBodyDataEventRouteChildRules() = default;
};
class GetRouteRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> assignObjectId{};
  shared_ptr<string> assignObjectName{};
  shared_ptr<string> assignObjectType{};
  shared_ptr<string> childRuleRelation{};
  shared_ptr<vector<string>> convergenceFields{};
  shared_ptr<long> convergenceType{};
  shared_ptr<vector<string>> coverageProblemLevels{};
  shared_ptr<string> createTime{};
  shared_ptr<string> effection{};
  shared_ptr<string> enableStatus{};
  shared_ptr<vector<GetRouteRuleResponseBodyDataEventRouteChildRules>> eventRouteChildRules{};
  shared_ptr<string> incidentLevel{};
  shared_ptr<long> matchCount{};
  shared_ptr<vector<string>> notifyChannelNames{};
  shared_ptr<vector<string>> notifyChannels{};
  shared_ptr<vector<long>> problemEffectionServices{};
  shared_ptr<map<string, DataProblemLevelGroupValue>> problemLevelGroup{};
  shared_ptr<long> relServiceDeleteType{};
  shared_ptr<long> relatedServiceId{};
  shared_ptr<string> relatedServiceName{};
  shared_ptr<long> routeRuleId{};
  shared_ptr<string> routeType{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> timeWindow{};
  shared_ptr<string> updateTime{};

  GetRouteRuleResponseBodyData() {}

  explicit GetRouteRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignObjectId) {
      res["assignObjectId"] = boost::any(*assignObjectId);
    }
    if (assignObjectName) {
      res["assignObjectName"] = boost::any(*assignObjectName);
    }
    if (assignObjectType) {
      res["assignObjectType"] = boost::any(*assignObjectType);
    }
    if (childRuleRelation) {
      res["childRuleRelation"] = boost::any(*childRuleRelation);
    }
    if (convergenceFields) {
      res["convergenceFields"] = boost::any(*convergenceFields);
    }
    if (convergenceType) {
      res["convergenceType"] = boost::any(*convergenceType);
    }
    if (coverageProblemLevels) {
      res["coverageProblemLevels"] = boost::any(*coverageProblemLevels);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (effection) {
      res["effection"] = boost::any(*effection);
    }
    if (enableStatus) {
      res["enableStatus"] = boost::any(*enableStatus);
    }
    if (eventRouteChildRules) {
      vector<boost::any> temp1;
      for(auto item1:*eventRouteChildRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["eventRouteChildRules"] = boost::any(temp1);
    }
    if (incidentLevel) {
      res["incidentLevel"] = boost::any(*incidentLevel);
    }
    if (matchCount) {
      res["matchCount"] = boost::any(*matchCount);
    }
    if (notifyChannelNames) {
      res["notifyChannelNames"] = boost::any(*notifyChannelNames);
    }
    if (notifyChannels) {
      res["notifyChannels"] = boost::any(*notifyChannels);
    }
    if (problemEffectionServices) {
      res["problemEffectionServices"] = boost::any(*problemEffectionServices);
    }
    if (problemLevelGroup) {
      map<string, boost::any> temp1;
      for(auto item1:*problemLevelGroup){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["problemLevelGroup"] = boost::any(temp1);
    }
    if (relServiceDeleteType) {
      res["relServiceDeleteType"] = boost::any(*relServiceDeleteType);
    }
    if (relatedServiceId) {
      res["relatedServiceId"] = boost::any(*relatedServiceId);
    }
    if (relatedServiceName) {
      res["relatedServiceName"] = boost::any(*relatedServiceName);
    }
    if (routeRuleId) {
      res["routeRuleId"] = boost::any(*routeRuleId);
    }
    if (routeType) {
      res["routeType"] = boost::any(*routeType);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    if (timeWindow) {
      res["timeWindow"] = boost::any(*timeWindow);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignObjectId") != m.end() && !m["assignObjectId"].empty()) {
      assignObjectId = make_shared<long>(boost::any_cast<long>(m["assignObjectId"]));
    }
    if (m.find("assignObjectName") != m.end() && !m["assignObjectName"].empty()) {
      assignObjectName = make_shared<string>(boost::any_cast<string>(m["assignObjectName"]));
    }
    if (m.find("assignObjectType") != m.end() && !m["assignObjectType"].empty()) {
      assignObjectType = make_shared<string>(boost::any_cast<string>(m["assignObjectType"]));
    }
    if (m.find("childRuleRelation") != m.end() && !m["childRuleRelation"].empty()) {
      childRuleRelation = make_shared<string>(boost::any_cast<string>(m["childRuleRelation"]));
    }
    if (m.find("convergenceFields") != m.end() && !m["convergenceFields"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["convergenceFields"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["convergenceFields"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      convergenceFields = make_shared<vector<string>>(toVec1);
    }
    if (m.find("convergenceType") != m.end() && !m["convergenceType"].empty()) {
      convergenceType = make_shared<long>(boost::any_cast<long>(m["convergenceType"]));
    }
    if (m.find("coverageProblemLevels") != m.end() && !m["coverageProblemLevels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["coverageProblemLevels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["coverageProblemLevels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      coverageProblemLevels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("effection") != m.end() && !m["effection"].empty()) {
      effection = make_shared<string>(boost::any_cast<string>(m["effection"]));
    }
    if (m.find("enableStatus") != m.end() && !m["enableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["enableStatus"]));
    }
    if (m.find("eventRouteChildRules") != m.end() && !m["eventRouteChildRules"].empty()) {
      if (typeid(vector<boost::any>) == m["eventRouteChildRules"].type()) {
        vector<GetRouteRuleResponseBodyDataEventRouteChildRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["eventRouteChildRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRouteRuleResponseBodyDataEventRouteChildRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        eventRouteChildRules = make_shared<vector<GetRouteRuleResponseBodyDataEventRouteChildRules>>(expect1);
      }
    }
    if (m.find("incidentLevel") != m.end() && !m["incidentLevel"].empty()) {
      incidentLevel = make_shared<string>(boost::any_cast<string>(m["incidentLevel"]));
    }
    if (m.find("matchCount") != m.end() && !m["matchCount"].empty()) {
      matchCount = make_shared<long>(boost::any_cast<long>(m["matchCount"]));
    }
    if (m.find("notifyChannelNames") != m.end() && !m["notifyChannelNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["notifyChannelNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["notifyChannelNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      notifyChannelNames = make_shared<vector<string>>(toVec1);
    }
    if (m.find("notifyChannels") != m.end() && !m["notifyChannels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["notifyChannels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["notifyChannels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      notifyChannels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("problemEffectionServices") != m.end() && !m["problemEffectionServices"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["problemEffectionServices"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["problemEffectionServices"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      problemEffectionServices = make_shared<vector<long>>(toVec1);
    }
    if (m.find("problemLevelGroup") != m.end() && !m["problemLevelGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["problemLevelGroup"].type()) {
        map<string, DataProblemLevelGroupValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["problemLevelGroup"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            DataProblemLevelGroupValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        problemLevelGroup = make_shared<map<string, DataProblemLevelGroupValue>>(expect1);
      }
    }
    if (m.find("relServiceDeleteType") != m.end() && !m["relServiceDeleteType"].empty()) {
      relServiceDeleteType = make_shared<long>(boost::any_cast<long>(m["relServiceDeleteType"]));
    }
    if (m.find("relatedServiceId") != m.end() && !m["relatedServiceId"].empty()) {
      relatedServiceId = make_shared<long>(boost::any_cast<long>(m["relatedServiceId"]));
    }
    if (m.find("relatedServiceName") != m.end() && !m["relatedServiceName"].empty()) {
      relatedServiceName = make_shared<string>(boost::any_cast<string>(m["relatedServiceName"]));
    }
    if (m.find("routeRuleId") != m.end() && !m["routeRuleId"].empty()) {
      routeRuleId = make_shared<long>(boost::any_cast<long>(m["routeRuleId"]));
    }
    if (m.find("routeType") != m.end() && !m["routeType"].empty()) {
      routeType = make_shared<string>(boost::any_cast<string>(m["routeType"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
    if (m.find("timeWindow") != m.end() && !m["timeWindow"].empty()) {
      timeWindow = make_shared<long>(boost::any_cast<long>(m["timeWindow"]));
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["updateTime"]));
    }
  }


  virtual ~GetRouteRuleResponseBodyData() = default;
};
class GetRouteRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetRouteRuleResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetRouteRuleResponseBody() {}

  explicit GetRouteRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GetRouteRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GetRouteRuleResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetRouteRuleResponseBody() = default;
};
class GetRouteRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRouteRuleResponseBody> body{};

  GetRouteRuleResponse() {}

  explicit GetRouteRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRouteRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRouteRuleResponseBody>(model1);
      }
    }
  }


  virtual ~GetRouteRuleResponse() = default;
};
class GetServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> serviceId{};

  GetServiceRequest() {}

  explicit GetServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (serviceId) {
      res["serviceId"] = boost::any(*serviceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("serviceId") != m.end() && !m["serviceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["serviceId"]));
    }
  }


  virtual ~GetServiceRequest() = default;
};
class GetServiceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> serviceDescription{};
  shared_ptr<long> serviceId{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> updateTime{};

  GetServiceResponseBodyData() {}

  explicit GetServiceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceDescription) {
      res["serviceDescription"] = boost::any(*serviceDescription);
    }
    if (serviceId) {
      res["serviceId"] = boost::any(*serviceId);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("serviceDescription") != m.end() && !m["serviceDescription"].empty()) {
      serviceDescription = make_shared<string>(boost::any_cast<string>(m["serviceDescription"]));
    }
    if (m.find("serviceId") != m.end() && !m["serviceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["serviceId"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["updateTime"]));
    }
  }


  virtual ~GetServiceResponseBodyData() = default;
};
class GetServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetServiceResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetServiceResponseBody() {}

  explicit GetServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GetServiceResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GetServiceResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetServiceResponseBody() = default;
};
class GetServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetServiceResponseBody> body{};

  GetServiceResponse() {}

  explicit GetServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetServiceResponseBody>(model1);
      }
    }
  }


  virtual ~GetServiceResponse() = default;
};
class GetServiceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> serviceGroupId{};

  GetServiceGroupRequest() {}

  explicit GetServiceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
  }


  virtual ~GetServiceGroupRequest() = default;
};
class GetServiceGroupResponseBodyDataUsers : public Darabonba::Model {
public:
  shared_ptr<string> phone{};
  shared_ptr<long> serviceGroupId{};
  shared_ptr<long> userId{};
  shared_ptr<string> userName{};

  GetServiceGroupResponseBodyDataUsers() {}

  explicit GetServiceGroupResponseBodyDataUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    if (userName) {
      res["userName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
    if (m.find("userName") != m.end() && !m["userName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["userName"]));
    }
  }


  virtual ~GetServiceGroupResponseBodyDataUsers() = default;
};
class GetServiceGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> enableWebhook{};
  shared_ptr<string> serviceGroupDescription{};
  shared_ptr<long> serviceGroupId{};
  shared_ptr<string> serviceGroupName{};
  shared_ptr<string> updateTime{};
  shared_ptr<vector<GetServiceGroupResponseBodyDataUsers>> users{};
  shared_ptr<string> webhookLink{};
  shared_ptr<string> webhookType{};

  GetServiceGroupResponseBodyData() {}

  explicit GetServiceGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (enableWebhook) {
      res["enableWebhook"] = boost::any(*enableWebhook);
    }
    if (serviceGroupDescription) {
      res["serviceGroupDescription"] = boost::any(*serviceGroupDescription);
    }
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    if (serviceGroupName) {
      res["serviceGroupName"] = boost::any(*serviceGroupName);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    if (users) {
      vector<boost::any> temp1;
      for(auto item1:*users){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["users"] = boost::any(temp1);
    }
    if (webhookLink) {
      res["webhookLink"] = boost::any(*webhookLink);
    }
    if (webhookType) {
      res["webhookType"] = boost::any(*webhookType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("enableWebhook") != m.end() && !m["enableWebhook"].empty()) {
      enableWebhook = make_shared<string>(boost::any_cast<string>(m["enableWebhook"]));
    }
    if (m.find("serviceGroupDescription") != m.end() && !m["serviceGroupDescription"].empty()) {
      serviceGroupDescription = make_shared<string>(boost::any_cast<string>(m["serviceGroupDescription"]));
    }
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
    if (m.find("serviceGroupName") != m.end() && !m["serviceGroupName"].empty()) {
      serviceGroupName = make_shared<string>(boost::any_cast<string>(m["serviceGroupName"]));
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["updateTime"]));
    }
    if (m.find("users") != m.end() && !m["users"].empty()) {
      if (typeid(vector<boost::any>) == m["users"].type()) {
        vector<GetServiceGroupResponseBodyDataUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["users"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetServiceGroupResponseBodyDataUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        users = make_shared<vector<GetServiceGroupResponseBodyDataUsers>>(expect1);
      }
    }
    if (m.find("webhookLink") != m.end() && !m["webhookLink"].empty()) {
      webhookLink = make_shared<string>(boost::any_cast<string>(m["webhookLink"]));
    }
    if (m.find("webhookType") != m.end() && !m["webhookType"].empty()) {
      webhookType = make_shared<string>(boost::any_cast<string>(m["webhookType"]));
    }
  }


  virtual ~GetServiceGroupResponseBodyData() = default;
};
class GetServiceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetServiceGroupResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetServiceGroupResponseBody() {}

  explicit GetServiceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GetServiceGroupResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GetServiceGroupResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetServiceGroupResponseBody() = default;
};
class GetServiceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetServiceGroupResponseBody> body{};

  GetServiceGroupResponse() {}

  explicit GetServiceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetServiceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetServiceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~GetServiceGroupResponse() = default;
};
class GetServiceGroupPersonSchedulingRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> endTime{};
  shared_ptr<long> serviceGroupId{};
  shared_ptr<string> startTime{};
  shared_ptr<long> userId{};

  GetServiceGroupPersonSchedulingRequest() {}

  explicit GetServiceGroupPersonSchedulingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
  }


  virtual ~GetServiceGroupPersonSchedulingRequest() = default;
};
class GetServiceGroupPersonSchedulingResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> data{};
  shared_ptr<string> requestId{};

  GetServiceGroupPersonSchedulingResponseBody() {}

  explicit GetServiceGroupPersonSchedulingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["data"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      data = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetServiceGroupPersonSchedulingResponseBody() = default;
};
class GetServiceGroupPersonSchedulingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetServiceGroupPersonSchedulingResponseBody> body{};

  GetServiceGroupPersonSchedulingResponse() {}

  explicit GetServiceGroupPersonSchedulingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetServiceGroupPersonSchedulingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetServiceGroupPersonSchedulingResponseBody>(model1);
      }
    }
  }


  virtual ~GetServiceGroupPersonSchedulingResponse() = default;
};
class GetServiceGroupSchedulingRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> serviceGroupId{};

  GetServiceGroupSchedulingRequest() {}

  explicit GetServiceGroupSchedulingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
  }


  virtual ~GetServiceGroupSchedulingRequest() = default;
};
class GetServiceGroupSchedulingResponseBodyDataFastSchedulingSchedulingUsers : public Darabonba::Model {
public:
  shared_ptr<string> schedulingObjectType{};
  shared_ptr<long> schedulingOrder{};
  shared_ptr<long> schedulingUserId{};
  shared_ptr<vector<long>> schedulingUserIdList{};
  shared_ptr<string> schedulingUserName{};

  GetServiceGroupSchedulingResponseBodyDataFastSchedulingSchedulingUsers() {}

  explicit GetServiceGroupSchedulingResponseBodyDataFastSchedulingSchedulingUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (schedulingObjectType) {
      res["schedulingObjectType"] = boost::any(*schedulingObjectType);
    }
    if (schedulingOrder) {
      res["schedulingOrder"] = boost::any(*schedulingOrder);
    }
    if (schedulingUserId) {
      res["schedulingUserId"] = boost::any(*schedulingUserId);
    }
    if (schedulingUserIdList) {
      res["schedulingUserIdList"] = boost::any(*schedulingUserIdList);
    }
    if (schedulingUserName) {
      res["schedulingUserName"] = boost::any(*schedulingUserName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("schedulingObjectType") != m.end() && !m["schedulingObjectType"].empty()) {
      schedulingObjectType = make_shared<string>(boost::any_cast<string>(m["schedulingObjectType"]));
    }
    if (m.find("schedulingOrder") != m.end() && !m["schedulingOrder"].empty()) {
      schedulingOrder = make_shared<long>(boost::any_cast<long>(m["schedulingOrder"]));
    }
    if (m.find("schedulingUserId") != m.end() && !m["schedulingUserId"].empty()) {
      schedulingUserId = make_shared<long>(boost::any_cast<long>(m["schedulingUserId"]));
    }
    if (m.find("schedulingUserIdList") != m.end() && !m["schedulingUserIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["schedulingUserIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["schedulingUserIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      schedulingUserIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("schedulingUserName") != m.end() && !m["schedulingUserName"].empty()) {
      schedulingUserName = make_shared<string>(boost::any_cast<string>(m["schedulingUserName"]));
    }
  }


  virtual ~GetServiceGroupSchedulingResponseBodyDataFastSchedulingSchedulingUsers() = default;
};
class GetServiceGroupSchedulingResponseBodyDataFastScheduling : public Darabonba::Model {
public:
  shared_ptr<string> dutyPlan{};
  shared_ptr<long> id{};
  shared_ptr<vector<GetServiceGroupSchedulingResponseBodyDataFastSchedulingSchedulingUsers>> schedulingUsers{};
  shared_ptr<long> singleDuration{};
  shared_ptr<string> singleDurationUnit{};

  GetServiceGroupSchedulingResponseBodyDataFastScheduling() {}

  explicit GetServiceGroupSchedulingResponseBodyDataFastScheduling(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dutyPlan) {
      res["dutyPlan"] = boost::any(*dutyPlan);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (schedulingUsers) {
      vector<boost::any> temp1;
      for(auto item1:*schedulingUsers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["schedulingUsers"] = boost::any(temp1);
    }
    if (singleDuration) {
      res["singleDuration"] = boost::any(*singleDuration);
    }
    if (singleDurationUnit) {
      res["singleDurationUnit"] = boost::any(*singleDurationUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dutyPlan") != m.end() && !m["dutyPlan"].empty()) {
      dutyPlan = make_shared<string>(boost::any_cast<string>(m["dutyPlan"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("schedulingUsers") != m.end() && !m["schedulingUsers"].empty()) {
      if (typeid(vector<boost::any>) == m["schedulingUsers"].type()) {
        vector<GetServiceGroupSchedulingResponseBodyDataFastSchedulingSchedulingUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["schedulingUsers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetServiceGroupSchedulingResponseBodyDataFastSchedulingSchedulingUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        schedulingUsers = make_shared<vector<GetServiceGroupSchedulingResponseBodyDataFastSchedulingSchedulingUsers>>(expect1);
      }
    }
    if (m.find("singleDuration") != m.end() && !m["singleDuration"].empty()) {
      singleDuration = make_shared<long>(boost::any_cast<long>(m["singleDuration"]));
    }
    if (m.find("singleDurationUnit") != m.end() && !m["singleDurationUnit"].empty()) {
      singleDurationUnit = make_shared<string>(boost::any_cast<string>(m["singleDurationUnit"]));
    }
  }


  virtual ~GetServiceGroupSchedulingResponseBodyDataFastScheduling() = default;
};
class GetServiceGroupSchedulingResponseBodyDataFineSchedulingSchedulingFineShifts : public Darabonba::Model {
public:
  shared_ptr<long> cycleOrder{};
  shared_ptr<string> schedulingEndTime{};
  shared_ptr<string> schedulingObjectType{};
  shared_ptr<long> schedulingOrder{};
  shared_ptr<string> schedulingStartTime{};
  shared_ptr<long> schedulingUserId{};
  shared_ptr<vector<long>> schedulingUserIdList{};
  shared_ptr<string> schedulingUserName{};
  shared_ptr<string> shiftName{};
  shared_ptr<bool> skipOneDay{};

  GetServiceGroupSchedulingResponseBodyDataFineSchedulingSchedulingFineShifts() {}

  explicit GetServiceGroupSchedulingResponseBodyDataFineSchedulingSchedulingFineShifts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleOrder) {
      res["cycleOrder"] = boost::any(*cycleOrder);
    }
    if (schedulingEndTime) {
      res["schedulingEndTime"] = boost::any(*schedulingEndTime);
    }
    if (schedulingObjectType) {
      res["schedulingObjectType"] = boost::any(*schedulingObjectType);
    }
    if (schedulingOrder) {
      res["schedulingOrder"] = boost::any(*schedulingOrder);
    }
    if (schedulingStartTime) {
      res["schedulingStartTime"] = boost::any(*schedulingStartTime);
    }
    if (schedulingUserId) {
      res["schedulingUserId"] = boost::any(*schedulingUserId);
    }
    if (schedulingUserIdList) {
      res["schedulingUserIdList"] = boost::any(*schedulingUserIdList);
    }
    if (schedulingUserName) {
      res["schedulingUserName"] = boost::any(*schedulingUserName);
    }
    if (shiftName) {
      res["shiftName"] = boost::any(*shiftName);
    }
    if (skipOneDay) {
      res["skipOneDay"] = boost::any(*skipOneDay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cycleOrder") != m.end() && !m["cycleOrder"].empty()) {
      cycleOrder = make_shared<long>(boost::any_cast<long>(m["cycleOrder"]));
    }
    if (m.find("schedulingEndTime") != m.end() && !m["schedulingEndTime"].empty()) {
      schedulingEndTime = make_shared<string>(boost::any_cast<string>(m["schedulingEndTime"]));
    }
    if (m.find("schedulingObjectType") != m.end() && !m["schedulingObjectType"].empty()) {
      schedulingObjectType = make_shared<string>(boost::any_cast<string>(m["schedulingObjectType"]));
    }
    if (m.find("schedulingOrder") != m.end() && !m["schedulingOrder"].empty()) {
      schedulingOrder = make_shared<long>(boost::any_cast<long>(m["schedulingOrder"]));
    }
    if (m.find("schedulingStartTime") != m.end() && !m["schedulingStartTime"].empty()) {
      schedulingStartTime = make_shared<string>(boost::any_cast<string>(m["schedulingStartTime"]));
    }
    if (m.find("schedulingUserId") != m.end() && !m["schedulingUserId"].empty()) {
      schedulingUserId = make_shared<long>(boost::any_cast<long>(m["schedulingUserId"]));
    }
    if (m.find("schedulingUserIdList") != m.end() && !m["schedulingUserIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["schedulingUserIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["schedulingUserIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      schedulingUserIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("schedulingUserName") != m.end() && !m["schedulingUserName"].empty()) {
      schedulingUserName = make_shared<string>(boost::any_cast<string>(m["schedulingUserName"]));
    }
    if (m.find("shiftName") != m.end() && !m["shiftName"].empty()) {
      shiftName = make_shared<string>(boost::any_cast<string>(m["shiftName"]));
    }
    if (m.find("skipOneDay") != m.end() && !m["skipOneDay"].empty()) {
      skipOneDay = make_shared<bool>(boost::any_cast<bool>(m["skipOneDay"]));
    }
  }


  virtual ~GetServiceGroupSchedulingResponseBodyDataFineSchedulingSchedulingFineShifts() = default;
};
class GetServiceGroupSchedulingResponseBodyDataFineSchedulingSchedulingTemplateFineShifts : public Darabonba::Model {
public:
  shared_ptr<string> schedulingEndTime{};
  shared_ptr<string> schedulingObjectType{};
  shared_ptr<long> schedulingOrder{};
  shared_ptr<string> schedulingStartTime{};
  shared_ptr<string> schedulingUserId{};
  shared_ptr<vector<long>> schedulingUserIdList{};
  shared_ptr<string> schedulingUserName{};
  shared_ptr<string> shiftName{};
  shared_ptr<bool> skipOneDay{};

  GetServiceGroupSchedulingResponseBodyDataFineSchedulingSchedulingTemplateFineShifts() {}

  explicit GetServiceGroupSchedulingResponseBodyDataFineSchedulingSchedulingTemplateFineShifts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (schedulingEndTime) {
      res["schedulingEndTime"] = boost::any(*schedulingEndTime);
    }
    if (schedulingObjectType) {
      res["schedulingObjectType"] = boost::any(*schedulingObjectType);
    }
    if (schedulingOrder) {
      res["schedulingOrder"] = boost::any(*schedulingOrder);
    }
    if (schedulingStartTime) {
      res["schedulingStartTime"] = boost::any(*schedulingStartTime);
    }
    if (schedulingUserId) {
      res["schedulingUserId"] = boost::any(*schedulingUserId);
    }
    if (schedulingUserIdList) {
      res["schedulingUserIdList"] = boost::any(*schedulingUserIdList);
    }
    if (schedulingUserName) {
      res["schedulingUserName"] = boost::any(*schedulingUserName);
    }
    if (shiftName) {
      res["shiftName"] = boost::any(*shiftName);
    }
    if (skipOneDay) {
      res["skipOneDay"] = boost::any(*skipOneDay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("schedulingEndTime") != m.end() && !m["schedulingEndTime"].empty()) {
      schedulingEndTime = make_shared<string>(boost::any_cast<string>(m["schedulingEndTime"]));
    }
    if (m.find("schedulingObjectType") != m.end() && !m["schedulingObjectType"].empty()) {
      schedulingObjectType = make_shared<string>(boost::any_cast<string>(m["schedulingObjectType"]));
    }
    if (m.find("schedulingOrder") != m.end() && !m["schedulingOrder"].empty()) {
      schedulingOrder = make_shared<long>(boost::any_cast<long>(m["schedulingOrder"]));
    }
    if (m.find("schedulingStartTime") != m.end() && !m["schedulingStartTime"].empty()) {
      schedulingStartTime = make_shared<string>(boost::any_cast<string>(m["schedulingStartTime"]));
    }
    if (m.find("schedulingUserId") != m.end() && !m["schedulingUserId"].empty()) {
      schedulingUserId = make_shared<string>(boost::any_cast<string>(m["schedulingUserId"]));
    }
    if (m.find("schedulingUserIdList") != m.end() && !m["schedulingUserIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["schedulingUserIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["schedulingUserIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      schedulingUserIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("schedulingUserName") != m.end() && !m["schedulingUserName"].empty()) {
      schedulingUserName = make_shared<string>(boost::any_cast<string>(m["schedulingUserName"]));
    }
    if (m.find("shiftName") != m.end() && !m["shiftName"].empty()) {
      shiftName = make_shared<string>(boost::any_cast<string>(m["shiftName"]));
    }
    if (m.find("skipOneDay") != m.end() && !m["skipOneDay"].empty()) {
      skipOneDay = make_shared<bool>(boost::any_cast<bool>(m["skipOneDay"]));
    }
  }


  virtual ~GetServiceGroupSchedulingResponseBodyDataFineSchedulingSchedulingTemplateFineShifts() = default;
};
class GetServiceGroupSchedulingResponseBodyDataFineScheduling : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<vector<GetServiceGroupSchedulingResponseBodyDataFineSchedulingSchedulingFineShifts>> schedulingFineShifts{};
  shared_ptr<vector<GetServiceGroupSchedulingResponseBodyDataFineSchedulingSchedulingTemplateFineShifts>> schedulingTemplateFineShifts{};
  shared_ptr<string> shiftType{};

  GetServiceGroupSchedulingResponseBodyDataFineScheduling() {}

  explicit GetServiceGroupSchedulingResponseBodyDataFineScheduling(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (period) {
      res["period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["periodUnit"] = boost::any(*periodUnit);
    }
    if (schedulingFineShifts) {
      vector<boost::any> temp1;
      for(auto item1:*schedulingFineShifts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["schedulingFineShifts"] = boost::any(temp1);
    }
    if (schedulingTemplateFineShifts) {
      vector<boost::any> temp1;
      for(auto item1:*schedulingTemplateFineShifts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["schedulingTemplateFineShifts"] = boost::any(temp1);
    }
    if (shiftType) {
      res["shiftType"] = boost::any(*shiftType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("period") != m.end() && !m["period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["period"]));
    }
    if (m.find("periodUnit") != m.end() && !m["periodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["periodUnit"]));
    }
    if (m.find("schedulingFineShifts") != m.end() && !m["schedulingFineShifts"].empty()) {
      if (typeid(vector<boost::any>) == m["schedulingFineShifts"].type()) {
        vector<GetServiceGroupSchedulingResponseBodyDataFineSchedulingSchedulingFineShifts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["schedulingFineShifts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetServiceGroupSchedulingResponseBodyDataFineSchedulingSchedulingFineShifts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        schedulingFineShifts = make_shared<vector<GetServiceGroupSchedulingResponseBodyDataFineSchedulingSchedulingFineShifts>>(expect1);
      }
    }
    if (m.find("schedulingTemplateFineShifts") != m.end() && !m["schedulingTemplateFineShifts"].empty()) {
      if (typeid(vector<boost::any>) == m["schedulingTemplateFineShifts"].type()) {
        vector<GetServiceGroupSchedulingResponseBodyDataFineSchedulingSchedulingTemplateFineShifts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["schedulingTemplateFineShifts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetServiceGroupSchedulingResponseBodyDataFineSchedulingSchedulingTemplateFineShifts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        schedulingTemplateFineShifts = make_shared<vector<GetServiceGroupSchedulingResponseBodyDataFineSchedulingSchedulingTemplateFineShifts>>(expect1);
      }
    }
    if (m.find("shiftType") != m.end() && !m["shiftType"].empty()) {
      shiftType = make_shared<string>(boost::any_cast<string>(m["shiftType"]));
    }
  }


  virtual ~GetServiceGroupSchedulingResponseBodyDataFineScheduling() = default;
};
class GetServiceGroupSchedulingResponseBodyDataUsers : public Darabonba::Model {
public:
  shared_ptr<long> userId{};
  shared_ptr<string> userName{};

  GetServiceGroupSchedulingResponseBodyDataUsers() {}

  explicit GetServiceGroupSchedulingResponseBodyDataUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    if (userName) {
      res["userName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
    if (m.find("userName") != m.end() && !m["userName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["userName"]));
    }
  }


  virtual ~GetServiceGroupSchedulingResponseBodyDataUsers() = default;
};
class GetServiceGroupSchedulingResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<GetServiceGroupSchedulingResponseBodyDataFastScheduling> fastScheduling{};
  shared_ptr<GetServiceGroupSchedulingResponseBodyDataFineScheduling> fineScheduling{};
  shared_ptr<string> schedulingWay{};
  shared_ptr<long> serviceGroupId{};
  shared_ptr<vector<GetServiceGroupSchedulingResponseBodyDataUsers>> users{};

  GetServiceGroupSchedulingResponseBodyData() {}

  explicit GetServiceGroupSchedulingResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fastScheduling) {
      res["fastScheduling"] = fastScheduling ? boost::any(fastScheduling->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fineScheduling) {
      res["fineScheduling"] = fineScheduling ? boost::any(fineScheduling->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (schedulingWay) {
      res["schedulingWay"] = boost::any(*schedulingWay);
    }
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    if (users) {
      vector<boost::any> temp1;
      for(auto item1:*users){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["users"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fastScheduling") != m.end() && !m["fastScheduling"].empty()) {
      if (typeid(map<string, boost::any>) == m["fastScheduling"].type()) {
        GetServiceGroupSchedulingResponseBodyDataFastScheduling model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["fastScheduling"]));
        fastScheduling = make_shared<GetServiceGroupSchedulingResponseBodyDataFastScheduling>(model1);
      }
    }
    if (m.find("fineScheduling") != m.end() && !m["fineScheduling"].empty()) {
      if (typeid(map<string, boost::any>) == m["fineScheduling"].type()) {
        GetServiceGroupSchedulingResponseBodyDataFineScheduling model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["fineScheduling"]));
        fineScheduling = make_shared<GetServiceGroupSchedulingResponseBodyDataFineScheduling>(model1);
      }
    }
    if (m.find("schedulingWay") != m.end() && !m["schedulingWay"].empty()) {
      schedulingWay = make_shared<string>(boost::any_cast<string>(m["schedulingWay"]));
    }
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
    if (m.find("users") != m.end() && !m["users"].empty()) {
      if (typeid(vector<boost::any>) == m["users"].type()) {
        vector<GetServiceGroupSchedulingResponseBodyDataUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["users"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetServiceGroupSchedulingResponseBodyDataUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        users = make_shared<vector<GetServiceGroupSchedulingResponseBodyDataUsers>>(expect1);
      }
    }
  }


  virtual ~GetServiceGroupSchedulingResponseBodyData() = default;
};
class GetServiceGroupSchedulingResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetServiceGroupSchedulingResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetServiceGroupSchedulingResponseBody() {}

  explicit GetServiceGroupSchedulingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GetServiceGroupSchedulingResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GetServiceGroupSchedulingResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetServiceGroupSchedulingResponseBody() = default;
};
class GetServiceGroupSchedulingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetServiceGroupSchedulingResponseBody> body{};

  GetServiceGroupSchedulingResponse() {}

  explicit GetServiceGroupSchedulingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetServiceGroupSchedulingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetServiceGroupSchedulingResponseBody>(model1);
      }
    }
  }


  virtual ~GetServiceGroupSchedulingResponse() = default;
};
class GetServiceGroupSchedulingPreviewRequestFastSchedulingSchedulingUsers : public Darabonba::Model {
public:
  shared_ptr<long> schedulingOrder{};
  shared_ptr<long> schedulingUserId{};

  GetServiceGroupSchedulingPreviewRequestFastSchedulingSchedulingUsers() {}

  explicit GetServiceGroupSchedulingPreviewRequestFastSchedulingSchedulingUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (schedulingOrder) {
      res["schedulingOrder"] = boost::any(*schedulingOrder);
    }
    if (schedulingUserId) {
      res["schedulingUserId"] = boost::any(*schedulingUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("schedulingOrder") != m.end() && !m["schedulingOrder"].empty()) {
      schedulingOrder = make_shared<long>(boost::any_cast<long>(m["schedulingOrder"]));
    }
    if (m.find("schedulingUserId") != m.end() && !m["schedulingUserId"].empty()) {
      schedulingUserId = make_shared<long>(boost::any_cast<long>(m["schedulingUserId"]));
    }
  }


  virtual ~GetServiceGroupSchedulingPreviewRequestFastSchedulingSchedulingUsers() = default;
};
class GetServiceGroupSchedulingPreviewRequestFastScheduling : public Darabonba::Model {
public:
  shared_ptr<string> dutyPlan{};
  shared_ptr<vector<GetServiceGroupSchedulingPreviewRequestFastSchedulingSchedulingUsers>> schedulingUsers{};
  shared_ptr<long> singleDuration{};
  shared_ptr<string> singleDurationUnit{};

  GetServiceGroupSchedulingPreviewRequestFastScheduling() {}

  explicit GetServiceGroupSchedulingPreviewRequestFastScheduling(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dutyPlan) {
      res["dutyPlan"] = boost::any(*dutyPlan);
    }
    if (schedulingUsers) {
      vector<boost::any> temp1;
      for(auto item1:*schedulingUsers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["schedulingUsers"] = boost::any(temp1);
    }
    if (singleDuration) {
      res["singleDuration"] = boost::any(*singleDuration);
    }
    if (singleDurationUnit) {
      res["singleDurationUnit"] = boost::any(*singleDurationUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dutyPlan") != m.end() && !m["dutyPlan"].empty()) {
      dutyPlan = make_shared<string>(boost::any_cast<string>(m["dutyPlan"]));
    }
    if (m.find("schedulingUsers") != m.end() && !m["schedulingUsers"].empty()) {
      if (typeid(vector<boost::any>) == m["schedulingUsers"].type()) {
        vector<GetServiceGroupSchedulingPreviewRequestFastSchedulingSchedulingUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["schedulingUsers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetServiceGroupSchedulingPreviewRequestFastSchedulingSchedulingUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        schedulingUsers = make_shared<vector<GetServiceGroupSchedulingPreviewRequestFastSchedulingSchedulingUsers>>(expect1);
      }
    }
    if (m.find("singleDuration") != m.end() && !m["singleDuration"].empty()) {
      singleDuration = make_shared<long>(boost::any_cast<long>(m["singleDuration"]));
    }
    if (m.find("singleDurationUnit") != m.end() && !m["singleDurationUnit"].empty()) {
      singleDurationUnit = make_shared<string>(boost::any_cast<string>(m["singleDurationUnit"]));
    }
  }


  virtual ~GetServiceGroupSchedulingPreviewRequestFastScheduling() = default;
};
class GetServiceGroupSchedulingPreviewRequestFineSchedulingSchedulingFineShifts : public Darabonba::Model {
public:
  shared_ptr<string> schedulingEndTime{};
  shared_ptr<long> schedulingOrder{};
  shared_ptr<string> schedulingStartTime{};
  shared_ptr<string> shiftName{};

  GetServiceGroupSchedulingPreviewRequestFineSchedulingSchedulingFineShifts() {}

  explicit GetServiceGroupSchedulingPreviewRequestFineSchedulingSchedulingFineShifts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (schedulingEndTime) {
      res["schedulingEndTime"] = boost::any(*schedulingEndTime);
    }
    if (schedulingOrder) {
      res["schedulingOrder"] = boost::any(*schedulingOrder);
    }
    if (schedulingStartTime) {
      res["schedulingStartTime"] = boost::any(*schedulingStartTime);
    }
    if (shiftName) {
      res["shiftName"] = boost::any(*shiftName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("schedulingEndTime") != m.end() && !m["schedulingEndTime"].empty()) {
      schedulingEndTime = make_shared<string>(boost::any_cast<string>(m["schedulingEndTime"]));
    }
    if (m.find("schedulingOrder") != m.end() && !m["schedulingOrder"].empty()) {
      schedulingOrder = make_shared<long>(boost::any_cast<long>(m["schedulingOrder"]));
    }
    if (m.find("schedulingStartTime") != m.end() && !m["schedulingStartTime"].empty()) {
      schedulingStartTime = make_shared<string>(boost::any_cast<string>(m["schedulingStartTime"]));
    }
    if (m.find("shiftName") != m.end() && !m["shiftName"].empty()) {
      shiftName = make_shared<string>(boost::any_cast<string>(m["shiftName"]));
    }
  }


  virtual ~GetServiceGroupSchedulingPreviewRequestFineSchedulingSchedulingFineShifts() = default;
};
class GetServiceGroupSchedulingPreviewRequestFineScheduling : public Darabonba::Model {
public:
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<vector<GetServiceGroupSchedulingPreviewRequestFineSchedulingSchedulingFineShifts>> schedulingFineShifts{};
  shared_ptr<string> shiftType{};

  GetServiceGroupSchedulingPreviewRequestFineScheduling() {}

  explicit GetServiceGroupSchedulingPreviewRequestFineScheduling(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (period) {
      res["period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["periodUnit"] = boost::any(*periodUnit);
    }
    if (schedulingFineShifts) {
      vector<boost::any> temp1;
      for(auto item1:*schedulingFineShifts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["schedulingFineShifts"] = boost::any(temp1);
    }
    if (shiftType) {
      res["shiftType"] = boost::any(*shiftType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("period") != m.end() && !m["period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["period"]));
    }
    if (m.find("periodUnit") != m.end() && !m["periodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["periodUnit"]));
    }
    if (m.find("schedulingFineShifts") != m.end() && !m["schedulingFineShifts"].empty()) {
      if (typeid(vector<boost::any>) == m["schedulingFineShifts"].type()) {
        vector<GetServiceGroupSchedulingPreviewRequestFineSchedulingSchedulingFineShifts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["schedulingFineShifts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetServiceGroupSchedulingPreviewRequestFineSchedulingSchedulingFineShifts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        schedulingFineShifts = make_shared<vector<GetServiceGroupSchedulingPreviewRequestFineSchedulingSchedulingFineShifts>>(expect1);
      }
    }
    if (m.find("shiftType") != m.end() && !m["shiftType"].empty()) {
      shiftType = make_shared<string>(boost::any_cast<string>(m["shiftType"]));
    }
  }


  virtual ~GetServiceGroupSchedulingPreviewRequestFineScheduling() = default;
};
class GetServiceGroupSchedulingPreviewRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> endTime{};
  shared_ptr<GetServiceGroupSchedulingPreviewRequestFastScheduling> fastScheduling{};
  shared_ptr<GetServiceGroupSchedulingPreviewRequestFineScheduling> fineScheduling{};
  shared_ptr<string> schedulingWay{};
  shared_ptr<long> serviceGroupId{};
  shared_ptr<string> startTime{};

  GetServiceGroupSchedulingPreviewRequest() {}

  explicit GetServiceGroupSchedulingPreviewRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (fastScheduling) {
      res["fastScheduling"] = fastScheduling ? boost::any(fastScheduling->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fineScheduling) {
      res["fineScheduling"] = fineScheduling ? boost::any(fineScheduling->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (schedulingWay) {
      res["schedulingWay"] = boost::any(*schedulingWay);
    }
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("fastScheduling") != m.end() && !m["fastScheduling"].empty()) {
      if (typeid(map<string, boost::any>) == m["fastScheduling"].type()) {
        GetServiceGroupSchedulingPreviewRequestFastScheduling model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["fastScheduling"]));
        fastScheduling = make_shared<GetServiceGroupSchedulingPreviewRequestFastScheduling>(model1);
      }
    }
    if (m.find("fineScheduling") != m.end() && !m["fineScheduling"].empty()) {
      if (typeid(map<string, boost::any>) == m["fineScheduling"].type()) {
        GetServiceGroupSchedulingPreviewRequestFineScheduling model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["fineScheduling"]));
        fineScheduling = make_shared<GetServiceGroupSchedulingPreviewRequestFineScheduling>(model1);
      }
    }
    if (m.find("schedulingWay") != m.end() && !m["schedulingWay"].empty()) {
      schedulingWay = make_shared<string>(boost::any_cast<string>(m["schedulingWay"]));
    }
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
  }


  virtual ~GetServiceGroupSchedulingPreviewRequest() = default;
};
class GetServiceGroupSchedulingPreviewResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> data{};
  shared_ptr<string> requestId{};

  GetServiceGroupSchedulingPreviewResponseBody() {}

  explicit GetServiceGroupSchedulingPreviewResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["data"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      data = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetServiceGroupSchedulingPreviewResponseBody() = default;
};
class GetServiceGroupSchedulingPreviewResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetServiceGroupSchedulingPreviewResponseBody> body{};

  GetServiceGroupSchedulingPreviewResponse() {}

  explicit GetServiceGroupSchedulingPreviewResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetServiceGroupSchedulingPreviewResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetServiceGroupSchedulingPreviewResponseBody>(model1);
      }
    }
  }


  virtual ~GetServiceGroupSchedulingPreviewResponse() = default;
};
class GetServiceGroupSpecialPersonSchedulingRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> serviceGroupId{};
  shared_ptr<long> userId{};

  GetServiceGroupSpecialPersonSchedulingRequest() {}

  explicit GetServiceGroupSpecialPersonSchedulingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
  }


  virtual ~GetServiceGroupSpecialPersonSchedulingRequest() = default;
};
class GetServiceGroupSpecialPersonSchedulingResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> schedulingDate{};
  shared_ptr<string> schedulingEndTime{};
  shared_ptr<string> schedulingStartTime{};
  shared_ptr<long> schedulingUserId{};
  shared_ptr<long> serviceGroupId{};
  shared_ptr<string> serviceGroupName{};

  GetServiceGroupSpecialPersonSchedulingResponseBodyData() {}

  explicit GetServiceGroupSpecialPersonSchedulingResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (schedulingDate) {
      res["schedulingDate"] = boost::any(*schedulingDate);
    }
    if (schedulingEndTime) {
      res["schedulingEndTime"] = boost::any(*schedulingEndTime);
    }
    if (schedulingStartTime) {
      res["schedulingStartTime"] = boost::any(*schedulingStartTime);
    }
    if (schedulingUserId) {
      res["schedulingUserId"] = boost::any(*schedulingUserId);
    }
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    if (serviceGroupName) {
      res["serviceGroupName"] = boost::any(*serviceGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("schedulingDate") != m.end() && !m["schedulingDate"].empty()) {
      schedulingDate = make_shared<string>(boost::any_cast<string>(m["schedulingDate"]));
    }
    if (m.find("schedulingEndTime") != m.end() && !m["schedulingEndTime"].empty()) {
      schedulingEndTime = make_shared<string>(boost::any_cast<string>(m["schedulingEndTime"]));
    }
    if (m.find("schedulingStartTime") != m.end() && !m["schedulingStartTime"].empty()) {
      schedulingStartTime = make_shared<string>(boost::any_cast<string>(m["schedulingStartTime"]));
    }
    if (m.find("schedulingUserId") != m.end() && !m["schedulingUserId"].empty()) {
      schedulingUserId = make_shared<long>(boost::any_cast<long>(m["schedulingUserId"]));
    }
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
    if (m.find("serviceGroupName") != m.end() && !m["serviceGroupName"].empty()) {
      serviceGroupName = make_shared<string>(boost::any_cast<string>(m["serviceGroupName"]));
    }
  }


  virtual ~GetServiceGroupSpecialPersonSchedulingResponseBodyData() = default;
};
class GetServiceGroupSpecialPersonSchedulingResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetServiceGroupSpecialPersonSchedulingResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  GetServiceGroupSpecialPersonSchedulingResponseBody() {}

  explicit GetServiceGroupSpecialPersonSchedulingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<GetServiceGroupSpecialPersonSchedulingResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetServiceGroupSpecialPersonSchedulingResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<GetServiceGroupSpecialPersonSchedulingResponseBodyData>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetServiceGroupSpecialPersonSchedulingResponseBody() = default;
};
class GetServiceGroupSpecialPersonSchedulingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetServiceGroupSpecialPersonSchedulingResponseBody> body{};

  GetServiceGroupSpecialPersonSchedulingResponse() {}

  explicit GetServiceGroupSpecialPersonSchedulingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetServiceGroupSpecialPersonSchedulingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetServiceGroupSpecialPersonSchedulingResponseBody>(model1);
      }
    }
  }


  virtual ~GetServiceGroupSpecialPersonSchedulingResponse() = default;
};
class GetSimilarIncidentStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> createTime{};
  shared_ptr<vector<string>> events{};
  shared_ptr<long> incidentId{};
  shared_ptr<string> incidentTitle{};
  shared_ptr<long> relatedServiceId{};

  GetSimilarIncidentStatisticsRequest() {}

  explicit GetSimilarIncidentStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (events) {
      res["events"] = boost::any(*events);
    }
    if (incidentId) {
      res["incidentId"] = boost::any(*incidentId);
    }
    if (incidentTitle) {
      res["incidentTitle"] = boost::any(*incidentTitle);
    }
    if (relatedServiceId) {
      res["relatedServiceId"] = boost::any(*relatedServiceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("events") != m.end() && !m["events"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["events"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["events"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      events = make_shared<vector<string>>(toVec1);
    }
    if (m.find("incidentId") != m.end() && !m["incidentId"].empty()) {
      incidentId = make_shared<long>(boost::any_cast<long>(m["incidentId"]));
    }
    if (m.find("incidentTitle") != m.end() && !m["incidentTitle"].empty()) {
      incidentTitle = make_shared<string>(boost::any_cast<string>(m["incidentTitle"]));
    }
    if (m.find("relatedServiceId") != m.end() && !m["relatedServiceId"].empty()) {
      relatedServiceId = make_shared<long>(boost::any_cast<long>(m["relatedServiceId"]));
    }
  }


  virtual ~GetSimilarIncidentStatisticsRequest() = default;
};
class GetSimilarIncidentStatisticsResponseBodyDataDailySimilarIncidentsSimilarIncidents : public Darabonba::Model {
public:
  shared_ptr<long> assignUserId{};
  shared_ptr<string> assignUserName{};
  shared_ptr<string> createTime{};
  shared_ptr<long> durationTime{};
  shared_ptr<long> finishReason{};
  shared_ptr<string> finishReasonDescription{};
  shared_ptr<string> finishSolutionDescription{};
  shared_ptr<long> incidentFinishSolution{};
  shared_ptr<long> incidentId{};
  shared_ptr<string> incidentNumber{};
  shared_ptr<string> incidentTitle{};
  shared_ptr<long> relatedRouteRuleId{};
  shared_ptr<string> relatedRouteRuleName{};
  shared_ptr<string> similarScore{};

  GetSimilarIncidentStatisticsResponseBodyDataDailySimilarIncidentsSimilarIncidents() {}

  explicit GetSimilarIncidentStatisticsResponseBodyDataDailySimilarIncidentsSimilarIncidents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignUserId) {
      res["assignUserId"] = boost::any(*assignUserId);
    }
    if (assignUserName) {
      res["assignUserName"] = boost::any(*assignUserName);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (durationTime) {
      res["durationTime"] = boost::any(*durationTime);
    }
    if (finishReason) {
      res["finishReason"] = boost::any(*finishReason);
    }
    if (finishReasonDescription) {
      res["finishReasonDescription"] = boost::any(*finishReasonDescription);
    }
    if (finishSolutionDescription) {
      res["finishSolutionDescription"] = boost::any(*finishSolutionDescription);
    }
    if (incidentFinishSolution) {
      res["incidentFinishSolution"] = boost::any(*incidentFinishSolution);
    }
    if (incidentId) {
      res["incidentId"] = boost::any(*incidentId);
    }
    if (incidentNumber) {
      res["incidentNumber"] = boost::any(*incidentNumber);
    }
    if (incidentTitle) {
      res["incidentTitle"] = boost::any(*incidentTitle);
    }
    if (relatedRouteRuleId) {
      res["relatedRouteRuleId"] = boost::any(*relatedRouteRuleId);
    }
    if (relatedRouteRuleName) {
      res["relatedRouteRuleName"] = boost::any(*relatedRouteRuleName);
    }
    if (similarScore) {
      res["similarScore"] = boost::any(*similarScore);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignUserId") != m.end() && !m["assignUserId"].empty()) {
      assignUserId = make_shared<long>(boost::any_cast<long>(m["assignUserId"]));
    }
    if (m.find("assignUserName") != m.end() && !m["assignUserName"].empty()) {
      assignUserName = make_shared<string>(boost::any_cast<string>(m["assignUserName"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("durationTime") != m.end() && !m["durationTime"].empty()) {
      durationTime = make_shared<long>(boost::any_cast<long>(m["durationTime"]));
    }
    if (m.find("finishReason") != m.end() && !m["finishReason"].empty()) {
      finishReason = make_shared<long>(boost::any_cast<long>(m["finishReason"]));
    }
    if (m.find("finishReasonDescription") != m.end() && !m["finishReasonDescription"].empty()) {
      finishReasonDescription = make_shared<string>(boost::any_cast<string>(m["finishReasonDescription"]));
    }
    if (m.find("finishSolutionDescription") != m.end() && !m["finishSolutionDescription"].empty()) {
      finishSolutionDescription = make_shared<string>(boost::any_cast<string>(m["finishSolutionDescription"]));
    }
    if (m.find("incidentFinishSolution") != m.end() && !m["incidentFinishSolution"].empty()) {
      incidentFinishSolution = make_shared<long>(boost::any_cast<long>(m["incidentFinishSolution"]));
    }
    if (m.find("incidentId") != m.end() && !m["incidentId"].empty()) {
      incidentId = make_shared<long>(boost::any_cast<long>(m["incidentId"]));
    }
    if (m.find("incidentNumber") != m.end() && !m["incidentNumber"].empty()) {
      incidentNumber = make_shared<string>(boost::any_cast<string>(m["incidentNumber"]));
    }
    if (m.find("incidentTitle") != m.end() && !m["incidentTitle"].empty()) {
      incidentTitle = make_shared<string>(boost::any_cast<string>(m["incidentTitle"]));
    }
    if (m.find("relatedRouteRuleId") != m.end() && !m["relatedRouteRuleId"].empty()) {
      relatedRouteRuleId = make_shared<long>(boost::any_cast<long>(m["relatedRouteRuleId"]));
    }
    if (m.find("relatedRouteRuleName") != m.end() && !m["relatedRouteRuleName"].empty()) {
      relatedRouteRuleName = make_shared<string>(boost::any_cast<string>(m["relatedRouteRuleName"]));
    }
    if (m.find("similarScore") != m.end() && !m["similarScore"].empty()) {
      similarScore = make_shared<string>(boost::any_cast<string>(m["similarScore"]));
    }
  }


  virtual ~GetSimilarIncidentStatisticsResponseBodyDataDailySimilarIncidentsSimilarIncidents() = default;
};
class GetSimilarIncidentStatisticsResponseBodyDataDailySimilarIncidents : public Darabonba::Model {
public:
  shared_ptr<long> commitment{};
  shared_ptr<string> date{};
  shared_ptr<long> day{};
  shared_ptr<long> month{};
  shared_ptr<vector<GetSimilarIncidentStatisticsResponseBodyDataDailySimilarIncidentsSimilarIncidents>> similarIncidents{};
  shared_ptr<string> week{};

  GetSimilarIncidentStatisticsResponseBodyDataDailySimilarIncidents() {}

  explicit GetSimilarIncidentStatisticsResponseBodyDataDailySimilarIncidents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (commitment) {
      res["commitment"] = boost::any(*commitment);
    }
    if (date) {
      res["date"] = boost::any(*date);
    }
    if (day) {
      res["day"] = boost::any(*day);
    }
    if (month) {
      res["month"] = boost::any(*month);
    }
    if (similarIncidents) {
      vector<boost::any> temp1;
      for(auto item1:*similarIncidents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["similarIncidents"] = boost::any(temp1);
    }
    if (week) {
      res["week"] = boost::any(*week);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("commitment") != m.end() && !m["commitment"].empty()) {
      commitment = make_shared<long>(boost::any_cast<long>(m["commitment"]));
    }
    if (m.find("date") != m.end() && !m["date"].empty()) {
      date = make_shared<string>(boost::any_cast<string>(m["date"]));
    }
    if (m.find("day") != m.end() && !m["day"].empty()) {
      day = make_shared<long>(boost::any_cast<long>(m["day"]));
    }
    if (m.find("month") != m.end() && !m["month"].empty()) {
      month = make_shared<long>(boost::any_cast<long>(m["month"]));
    }
    if (m.find("similarIncidents") != m.end() && !m["similarIncidents"].empty()) {
      if (typeid(vector<boost::any>) == m["similarIncidents"].type()) {
        vector<GetSimilarIncidentStatisticsResponseBodyDataDailySimilarIncidentsSimilarIncidents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["similarIncidents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSimilarIncidentStatisticsResponseBodyDataDailySimilarIncidentsSimilarIncidents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        similarIncidents = make_shared<vector<GetSimilarIncidentStatisticsResponseBodyDataDailySimilarIncidentsSimilarIncidents>>(expect1);
      }
    }
    if (m.find("week") != m.end() && !m["week"].empty()) {
      week = make_shared<string>(boost::any_cast<string>(m["week"]));
    }
  }


  virtual ~GetSimilarIncidentStatisticsResponseBodyDataDailySimilarIncidents() = default;
};
class GetSimilarIncidentStatisticsResponseBodyDataTopFiveIncidents : public Darabonba::Model {
public:
  shared_ptr<string> assignUserId{};
  shared_ptr<string> assignUserName{};
  shared_ptr<string> createTime{};
  shared_ptr<long> durationTime{};
  shared_ptr<long> finishReason{};
  shared_ptr<string> finishReasonDescription{};
  shared_ptr<string> finishSolutionDescription{};
  shared_ptr<long> incidentFinishSolution{};
  shared_ptr<long> incidentId{};
  shared_ptr<string> incidentNumber{};
  shared_ptr<string> incidentTitle{};
  shared_ptr<long> relatedRouteRuleId{};
  shared_ptr<string> relatedRouteRuleName{};
  shared_ptr<string> similarScore{};

  GetSimilarIncidentStatisticsResponseBodyDataTopFiveIncidents() {}

  explicit GetSimilarIncidentStatisticsResponseBodyDataTopFiveIncidents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignUserId) {
      res["assignUserId"] = boost::any(*assignUserId);
    }
    if (assignUserName) {
      res["assignUserName"] = boost::any(*assignUserName);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (durationTime) {
      res["durationTime"] = boost::any(*durationTime);
    }
    if (finishReason) {
      res["finishReason"] = boost::any(*finishReason);
    }
    if (finishReasonDescription) {
      res["finishReasonDescription"] = boost::any(*finishReasonDescription);
    }
    if (finishSolutionDescription) {
      res["finishSolutionDescription"] = boost::any(*finishSolutionDescription);
    }
    if (incidentFinishSolution) {
      res["incidentFinishSolution"] = boost::any(*incidentFinishSolution);
    }
    if (incidentId) {
      res["incidentId"] = boost::any(*incidentId);
    }
    if (incidentNumber) {
      res["incidentNumber"] = boost::any(*incidentNumber);
    }
    if (incidentTitle) {
      res["incidentTitle"] = boost::any(*incidentTitle);
    }
    if (relatedRouteRuleId) {
      res["relatedRouteRuleId"] = boost::any(*relatedRouteRuleId);
    }
    if (relatedRouteRuleName) {
      res["relatedRouteRuleName"] = boost::any(*relatedRouteRuleName);
    }
    if (similarScore) {
      res["similarScore"] = boost::any(*similarScore);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignUserId") != m.end() && !m["assignUserId"].empty()) {
      assignUserId = make_shared<string>(boost::any_cast<string>(m["assignUserId"]));
    }
    if (m.find("assignUserName") != m.end() && !m["assignUserName"].empty()) {
      assignUserName = make_shared<string>(boost::any_cast<string>(m["assignUserName"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("durationTime") != m.end() && !m["durationTime"].empty()) {
      durationTime = make_shared<long>(boost::any_cast<long>(m["durationTime"]));
    }
    if (m.find("finishReason") != m.end() && !m["finishReason"].empty()) {
      finishReason = make_shared<long>(boost::any_cast<long>(m["finishReason"]));
    }
    if (m.find("finishReasonDescription") != m.end() && !m["finishReasonDescription"].empty()) {
      finishReasonDescription = make_shared<string>(boost::any_cast<string>(m["finishReasonDescription"]));
    }
    if (m.find("finishSolutionDescription") != m.end() && !m["finishSolutionDescription"].empty()) {
      finishSolutionDescription = make_shared<string>(boost::any_cast<string>(m["finishSolutionDescription"]));
    }
    if (m.find("incidentFinishSolution") != m.end() && !m["incidentFinishSolution"].empty()) {
      incidentFinishSolution = make_shared<long>(boost::any_cast<long>(m["incidentFinishSolution"]));
    }
    if (m.find("incidentId") != m.end() && !m["incidentId"].empty()) {
      incidentId = make_shared<long>(boost::any_cast<long>(m["incidentId"]));
    }
    if (m.find("incidentNumber") != m.end() && !m["incidentNumber"].empty()) {
      incidentNumber = make_shared<string>(boost::any_cast<string>(m["incidentNumber"]));
    }
    if (m.find("incidentTitle") != m.end() && !m["incidentTitle"].empty()) {
      incidentTitle = make_shared<string>(boost::any_cast<string>(m["incidentTitle"]));
    }
    if (m.find("relatedRouteRuleId") != m.end() && !m["relatedRouteRuleId"].empty()) {
      relatedRouteRuleId = make_shared<long>(boost::any_cast<long>(m["relatedRouteRuleId"]));
    }
    if (m.find("relatedRouteRuleName") != m.end() && !m["relatedRouteRuleName"].empty()) {
      relatedRouteRuleName = make_shared<string>(boost::any_cast<string>(m["relatedRouteRuleName"]));
    }
    if (m.find("similarScore") != m.end() && !m["similarScore"].empty()) {
      similarScore = make_shared<string>(boost::any_cast<string>(m["similarScore"]));
    }
  }


  virtual ~GetSimilarIncidentStatisticsResponseBodyDataTopFiveIncidents() = default;
};
class GetSimilarIncidentStatisticsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> countInSevenDays{};
  shared_ptr<long> countInSixMonths{};
  shared_ptr<vector<GetSimilarIncidentStatisticsResponseBodyDataDailySimilarIncidents>> dailySimilarIncidents{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetSimilarIncidentStatisticsResponseBodyDataTopFiveIncidents>> topFiveIncidents{};

  GetSimilarIncidentStatisticsResponseBodyData() {}

  explicit GetSimilarIncidentStatisticsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (countInSevenDays) {
      res["countInSevenDays"] = boost::any(*countInSevenDays);
    }
    if (countInSixMonths) {
      res["countInSixMonths"] = boost::any(*countInSixMonths);
    }
    if (dailySimilarIncidents) {
      vector<boost::any> temp1;
      for(auto item1:*dailySimilarIncidents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["dailySimilarIncidents"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (topFiveIncidents) {
      vector<boost::any> temp1;
      for(auto item1:*topFiveIncidents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["topFiveIncidents"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("countInSevenDays") != m.end() && !m["countInSevenDays"].empty()) {
      countInSevenDays = make_shared<long>(boost::any_cast<long>(m["countInSevenDays"]));
    }
    if (m.find("countInSixMonths") != m.end() && !m["countInSixMonths"].empty()) {
      countInSixMonths = make_shared<long>(boost::any_cast<long>(m["countInSixMonths"]));
    }
    if (m.find("dailySimilarIncidents") != m.end() && !m["dailySimilarIncidents"].empty()) {
      if (typeid(vector<boost::any>) == m["dailySimilarIncidents"].type()) {
        vector<GetSimilarIncidentStatisticsResponseBodyDataDailySimilarIncidents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["dailySimilarIncidents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSimilarIncidentStatisticsResponseBodyDataDailySimilarIncidents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dailySimilarIncidents = make_shared<vector<GetSimilarIncidentStatisticsResponseBodyDataDailySimilarIncidents>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("topFiveIncidents") != m.end() && !m["topFiveIncidents"].empty()) {
      if (typeid(vector<boost::any>) == m["topFiveIncidents"].type()) {
        vector<GetSimilarIncidentStatisticsResponseBodyDataTopFiveIncidents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["topFiveIncidents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSimilarIncidentStatisticsResponseBodyDataTopFiveIncidents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        topFiveIncidents = make_shared<vector<GetSimilarIncidentStatisticsResponseBodyDataTopFiveIncidents>>(expect1);
      }
    }
  }


  virtual ~GetSimilarIncidentStatisticsResponseBodyData() = default;
};
class GetSimilarIncidentStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetSimilarIncidentStatisticsResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetSimilarIncidentStatisticsResponseBody() {}

  explicit GetSimilarIncidentStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GetSimilarIncidentStatisticsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GetSimilarIncidentStatisticsResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetSimilarIncidentStatisticsResponseBody() = default;
};
class GetSimilarIncidentStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSimilarIncidentStatisticsResponseBody> body{};

  GetSimilarIncidentStatisticsResponse() {}

  explicit GetSimilarIncidentStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSimilarIncidentStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSimilarIncidentStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~GetSimilarIncidentStatisticsResponse() = default;
};
class GetSubscriptionRequest : public Darabonba::Model {
public:
  shared_ptr<bool> notFilterScopeObjectDeleted{};
  shared_ptr<long> subscriptionId{};

  GetSubscriptionRequest() {}

  explicit GetSubscriptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (notFilterScopeObjectDeleted) {
      res["notFilterScopeObjectDeleted"] = boost::any(*notFilterScopeObjectDeleted);
    }
    if (subscriptionId) {
      res["subscriptionId"] = boost::any(*subscriptionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("notFilterScopeObjectDeleted") != m.end() && !m["notFilterScopeObjectDeleted"].empty()) {
      notFilterScopeObjectDeleted = make_shared<bool>(boost::any_cast<bool>(m["notFilterScopeObjectDeleted"]));
    }
    if (m.find("subscriptionId") != m.end() && !m["subscriptionId"].empty()) {
      subscriptionId = make_shared<long>(boost::any_cast<long>(m["subscriptionId"]));
    }
  }


  virtual ~GetSubscriptionRequest() = default;
};
class GetSubscriptionResponseBodyDataNotifyObjectList : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};
  shared_ptr<long> notifyObjectId{};
  shared_ptr<long> notifyObjectType{};

  GetSubscriptionResponseBodyDataNotifyObjectList() {}

  explicit GetSubscriptionResponseBodyDataNotifyObjectList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (notifyObjectId) {
      res["notifyObjectId"] = boost::any(*notifyObjectId);
    }
    if (notifyObjectType) {
      res["notifyObjectType"] = boost::any(*notifyObjectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("notifyObjectId") != m.end() && !m["notifyObjectId"].empty()) {
      notifyObjectId = make_shared<long>(boost::any_cast<long>(m["notifyObjectId"]));
    }
    if (m.find("notifyObjectType") != m.end() && !m["notifyObjectType"].empty()) {
      notifyObjectType = make_shared<long>(boost::any_cast<long>(m["notifyObjectType"]));
    }
  }


  virtual ~GetSubscriptionResponseBodyDataNotifyObjectList() = default;
};
class GetSubscriptionResponseBodyDataNotifyStrategyListStrategiesConditions : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> effection{};
  shared_ptr<string> level{};
  shared_ptr<string> problemNotifyType{};

  GetSubscriptionResponseBodyDataNotifyStrategyListStrategiesConditions() {}

  explicit GetSubscriptionResponseBodyDataNotifyStrategyListStrategiesConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["action"] = boost::any(*action);
    }
    if (effection) {
      res["effection"] = boost::any(*effection);
    }
    if (level) {
      res["level"] = boost::any(*level);
    }
    if (problemNotifyType) {
      res["problemNotifyType"] = boost::any(*problemNotifyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("action") != m.end() && !m["action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["action"]));
    }
    if (m.find("effection") != m.end() && !m["effection"].empty()) {
      effection = make_shared<string>(boost::any_cast<string>(m["effection"]));
    }
    if (m.find("level") != m.end() && !m["level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["level"]));
    }
    if (m.find("problemNotifyType") != m.end() && !m["problemNotifyType"].empty()) {
      problemNotifyType = make_shared<string>(boost::any_cast<string>(m["problemNotifyType"]));
    }
  }


  virtual ~GetSubscriptionResponseBodyDataNotifyStrategyListStrategiesConditions() = default;
};
class GetSubscriptionResponseBodyDataNotifyStrategyListStrategiesPeriodChannel : public Darabonba::Model {
public:
  shared_ptr<string> nonWorkday{};
  shared_ptr<string> workday{};

  GetSubscriptionResponseBodyDataNotifyStrategyListStrategiesPeriodChannel() {}

  explicit GetSubscriptionResponseBodyDataNotifyStrategyListStrategiesPeriodChannel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonWorkday) {
      res["nonWorkday"] = boost::any(*nonWorkday);
    }
    if (workday) {
      res["workday"] = boost::any(*workday);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("nonWorkday") != m.end() && !m["nonWorkday"].empty()) {
      nonWorkday = make_shared<string>(boost::any_cast<string>(m["nonWorkday"]));
    }
    if (m.find("workday") != m.end() && !m["workday"].empty()) {
      workday = make_shared<string>(boost::any_cast<string>(m["workday"]));
    }
  }


  virtual ~GetSubscriptionResponseBodyDataNotifyStrategyListStrategiesPeriodChannel() = default;
};
class GetSubscriptionResponseBodyDataNotifyStrategyListStrategies : public Darabonba::Model {
public:
  shared_ptr<string> channels{};
  shared_ptr<vector<GetSubscriptionResponseBodyDataNotifyStrategyListStrategiesConditions>> conditions{};
  shared_ptr<long> id{};
  shared_ptr<GetSubscriptionResponseBodyDataNotifyStrategyListStrategiesPeriodChannel> periodChannel{};

  GetSubscriptionResponseBodyDataNotifyStrategyListStrategies() {}

  explicit GetSubscriptionResponseBodyDataNotifyStrategyListStrategies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["channels"] = boost::any(*channels);
    }
    if (conditions) {
      vector<boost::any> temp1;
      for(auto item1:*conditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["conditions"] = boost::any(temp1);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (periodChannel) {
      res["periodChannel"] = periodChannel ? boost::any(periodChannel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("channels") != m.end() && !m["channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["channels"]));
    }
    if (m.find("conditions") != m.end() && !m["conditions"].empty()) {
      if (typeid(vector<boost::any>) == m["conditions"].type()) {
        vector<GetSubscriptionResponseBodyDataNotifyStrategyListStrategiesConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["conditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSubscriptionResponseBodyDataNotifyStrategyListStrategiesConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditions = make_shared<vector<GetSubscriptionResponseBodyDataNotifyStrategyListStrategiesConditions>>(expect1);
      }
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("periodChannel") != m.end() && !m["periodChannel"].empty()) {
      if (typeid(map<string, boost::any>) == m["periodChannel"].type()) {
        GetSubscriptionResponseBodyDataNotifyStrategyListStrategiesPeriodChannel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["periodChannel"]));
        periodChannel = make_shared<GetSubscriptionResponseBodyDataNotifyStrategyListStrategiesPeriodChannel>(model1);
      }
    }
  }


  virtual ~GetSubscriptionResponseBodyDataNotifyStrategyListStrategies() = default;
};
class GetSubscriptionResponseBodyDataNotifyStrategyList : public Darabonba::Model {
public:
  shared_ptr<long> instanceType{};
  shared_ptr<vector<GetSubscriptionResponseBodyDataNotifyStrategyListStrategies>> strategies{};

  GetSubscriptionResponseBodyDataNotifyStrategyList() {}

  explicit GetSubscriptionResponseBodyDataNotifyStrategyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["instanceType"] = boost::any(*instanceType);
    }
    if (strategies) {
      vector<boost::any> temp1;
      for(auto item1:*strategies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["strategies"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instanceType") != m.end() && !m["instanceType"].empty()) {
      instanceType = make_shared<long>(boost::any_cast<long>(m["instanceType"]));
    }
    if (m.find("strategies") != m.end() && !m["strategies"].empty()) {
      if (typeid(vector<boost::any>) == m["strategies"].type()) {
        vector<GetSubscriptionResponseBodyDataNotifyStrategyListStrategies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["strategies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSubscriptionResponseBodyDataNotifyStrategyListStrategies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        strategies = make_shared<vector<GetSubscriptionResponseBodyDataNotifyStrategyListStrategies>>(expect1);
      }
    }
  }


  virtual ~GetSubscriptionResponseBodyDataNotifyStrategyList() = default;
};
class GetSubscriptionResponseBodyDataScopeObjectList : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> isValid{};
  shared_ptr<string> scope{};
  shared_ptr<string> scopeObject{};
  shared_ptr<long> scopeObjectId{};

  GetSubscriptionResponseBodyDataScopeObjectList() {}

  explicit GetSubscriptionResponseBodyDataScopeObjectList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isValid) {
      res["isValid"] = boost::any(*isValid);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (scopeObject) {
      res["scopeObject"] = boost::any(*scopeObject);
    }
    if (scopeObjectId) {
      res["scopeObjectId"] = boost::any(*scopeObjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("isValid") != m.end() && !m["isValid"].empty()) {
      isValid = make_shared<long>(boost::any_cast<long>(m["isValid"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
    if (m.find("scopeObject") != m.end() && !m["scopeObject"].empty()) {
      scopeObject = make_shared<string>(boost::any_cast<string>(m["scopeObject"]));
    }
    if (m.find("scopeObjectId") != m.end() && !m["scopeObjectId"].empty()) {
      scopeObjectId = make_shared<long>(boost::any_cast<long>(m["scopeObjectId"]));
    }
  }


  virtual ~GetSubscriptionResponseBodyDataScopeObjectList() = default;
};
class GetSubscriptionResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> expiredType{};
  shared_ptr<vector<GetSubscriptionResponseBodyDataNotifyObjectList>> notifyObjectList{};
  shared_ptr<string> notifyObjectType{};
  shared_ptr<vector<GetSubscriptionResponseBodyDataNotifyStrategyList>> notifyStrategyList{};
  shared_ptr<string> period{};
  shared_ptr<string> scope{};
  shared_ptr<vector<GetSubscriptionResponseBodyDataScopeObjectList>> scopeObjectList{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<long> subscriptionId{};
  shared_ptr<string> subscriptionTitle{};

  GetSubscriptionResponseBodyData() {}

  explicit GetSubscriptionResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (expiredType) {
      res["expiredType"] = boost::any(*expiredType);
    }
    if (notifyObjectList) {
      vector<boost::any> temp1;
      for(auto item1:*notifyObjectList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["notifyObjectList"] = boost::any(temp1);
    }
    if (notifyObjectType) {
      res["notifyObjectType"] = boost::any(*notifyObjectType);
    }
    if (notifyStrategyList) {
      vector<boost::any> temp1;
      for(auto item1:*notifyStrategyList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["notifyStrategyList"] = boost::any(temp1);
    }
    if (period) {
      res["period"] = boost::any(*period);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (scopeObjectList) {
      vector<boost::any> temp1;
      for(auto item1:*scopeObjectList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["scopeObjectList"] = boost::any(temp1);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (subscriptionId) {
      res["subscriptionId"] = boost::any(*subscriptionId);
    }
    if (subscriptionTitle) {
      res["subscriptionTitle"] = boost::any(*subscriptionTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("expiredType") != m.end() && !m["expiredType"].empty()) {
      expiredType = make_shared<string>(boost::any_cast<string>(m["expiredType"]));
    }
    if (m.find("notifyObjectList") != m.end() && !m["notifyObjectList"].empty()) {
      if (typeid(vector<boost::any>) == m["notifyObjectList"].type()) {
        vector<GetSubscriptionResponseBodyDataNotifyObjectList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["notifyObjectList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSubscriptionResponseBodyDataNotifyObjectList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifyObjectList = make_shared<vector<GetSubscriptionResponseBodyDataNotifyObjectList>>(expect1);
      }
    }
    if (m.find("notifyObjectType") != m.end() && !m["notifyObjectType"].empty()) {
      notifyObjectType = make_shared<string>(boost::any_cast<string>(m["notifyObjectType"]));
    }
    if (m.find("notifyStrategyList") != m.end() && !m["notifyStrategyList"].empty()) {
      if (typeid(vector<boost::any>) == m["notifyStrategyList"].type()) {
        vector<GetSubscriptionResponseBodyDataNotifyStrategyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["notifyStrategyList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSubscriptionResponseBodyDataNotifyStrategyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifyStrategyList = make_shared<vector<GetSubscriptionResponseBodyDataNotifyStrategyList>>(expect1);
      }
    }
    if (m.find("period") != m.end() && !m["period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["period"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
    if (m.find("scopeObjectList") != m.end() && !m["scopeObjectList"].empty()) {
      if (typeid(vector<boost::any>) == m["scopeObjectList"].type()) {
        vector<GetSubscriptionResponseBodyDataScopeObjectList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["scopeObjectList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSubscriptionResponseBodyDataScopeObjectList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scopeObjectList = make_shared<vector<GetSubscriptionResponseBodyDataScopeObjectList>>(expect1);
      }
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("subscriptionId") != m.end() && !m["subscriptionId"].empty()) {
      subscriptionId = make_shared<long>(boost::any_cast<long>(m["subscriptionId"]));
    }
    if (m.find("subscriptionTitle") != m.end() && !m["subscriptionTitle"].empty()) {
      subscriptionTitle = make_shared<string>(boost::any_cast<string>(m["subscriptionTitle"]));
    }
  }


  virtual ~GetSubscriptionResponseBodyData() = default;
};
class GetSubscriptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetSubscriptionResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetSubscriptionResponseBody() {}

  explicit GetSubscriptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GetSubscriptionResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GetSubscriptionResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetSubscriptionResponseBody() = default;
};
class GetSubscriptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSubscriptionResponseBody> body{};

  GetSubscriptionResponse() {}

  explicit GetSubscriptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSubscriptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSubscriptionResponseBody>(model1);
      }
    }
  }


  virtual ~GetSubscriptionResponse() = default;
};
class GetTenantApplicationRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};

  GetTenantApplicationRequest() {}

  explicit GetTenantApplicationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~GetTenantApplicationRequest() = default;
};
class GetTenantApplicationResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> bizId{};
  shared_ptr<string> channel{};
  shared_ptr<string> corporationId{};
  shared_ptr<string> originalCorpId{};
  shared_ptr<string> progress{};

  GetTenantApplicationResponseBodyData() {}

  explicit GetTenantApplicationResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bizId) {
      res["bizId"] = boost::any(*bizId);
    }
    if (channel) {
      res["channel"] = boost::any(*channel);
    }
    if (corporationId) {
      res["corporationId"] = boost::any(*corporationId);
    }
    if (originalCorpId) {
      res["originalCorpId"] = boost::any(*originalCorpId);
    }
    if (progress) {
      res["progress"] = boost::any(*progress);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bizId") != m.end() && !m["bizId"].empty()) {
      bizId = make_shared<string>(boost::any_cast<string>(m["bizId"]));
    }
    if (m.find("channel") != m.end() && !m["channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["channel"]));
    }
    if (m.find("corporationId") != m.end() && !m["corporationId"].empty()) {
      corporationId = make_shared<string>(boost::any_cast<string>(m["corporationId"]));
    }
    if (m.find("originalCorpId") != m.end() && !m["originalCorpId"].empty()) {
      originalCorpId = make_shared<string>(boost::any_cast<string>(m["originalCorpId"]));
    }
    if (m.find("progress") != m.end() && !m["progress"].empty()) {
      progress = make_shared<string>(boost::any_cast<string>(m["progress"]));
    }
  }


  virtual ~GetTenantApplicationResponseBodyData() = default;
};
class GetTenantApplicationResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetTenantApplicationResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetTenantApplicationResponseBody() {}

  explicit GetTenantApplicationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GetTenantApplicationResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GetTenantApplicationResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetTenantApplicationResponseBody() = default;
};
class GetTenantApplicationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTenantApplicationResponseBody> body{};

  GetTenantApplicationResponse() {}

  explicit GetTenantApplicationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTenantApplicationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTenantApplicationResponseBody>(model1);
      }
    }
  }


  virtual ~GetTenantApplicationResponse() = default;
};
class GetTenantStatusRequest : public Darabonba::Model {
public:
  shared_ptr<long> tenantRamId{};

  GetTenantStatusRequest() {}

  explicit GetTenantStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantRamId) {
      res["tenantRamId"] = boost::any(*tenantRamId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantRamId") != m.end() && !m["tenantRamId"].empty()) {
      tenantRamId = make_shared<long>(boost::any_cast<long>(m["tenantRamId"]));
    }
  }


  virtual ~GetTenantStatusRequest() = default;
};
class GetTenantStatusResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> tenantStatus{};

  GetTenantStatusResponseBodyData() {}

  explicit GetTenantStatusResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tenantStatus) {
      res["tenantStatus"] = boost::any(*tenantStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tenantStatus") != m.end() && !m["tenantStatus"].empty()) {
      tenantStatus = make_shared<long>(boost::any_cast<long>(m["tenantStatus"]));
    }
  }


  virtual ~GetTenantStatusResponseBodyData() = default;
};
class GetTenantStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetTenantStatusResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetTenantStatusResponseBody() {}

  explicit GetTenantStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GetTenantStatusResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GetTenantStatusResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetTenantStatusResponseBody() = default;
};
class GetTenantStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTenantStatusResponseBody> body{};

  GetTenantStatusResponse() {}

  explicit GetTenantStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTenantStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTenantStatusResponseBody>(model1);
      }
    }
  }


  virtual ~GetTenantStatusResponse() = default;
};
class GetUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> userId{};

  GetUserRequest() {}

  explicit GetUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
  }


  virtual ~GetUserRequest() = default;
};
class GetUserResponseBodyDataServiceGroups : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> serviceGroupId{};

  GetUserResponseBodyDataServiceGroups() {}

  explicit GetUserResponseBodyDataServiceGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
  }


  virtual ~GetUserResponseBodyDataServiceGroups() = default;
};
class GetUserResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> accountType{};
  shared_ptr<string> createTime{};
  shared_ptr<string> email{};
  shared_ptr<bool> isEditableUser{};
  shared_ptr<string> isRelated{};
  shared_ptr<string> phone{};
  shared_ptr<string> ramId{};
  shared_ptr<vector<GetUserResponseBodyDataServiceGroups>> serviceGroups{};
  shared_ptr<long> userId{};
  shared_ptr<string> username{};

  GetUserResponseBodyData() {}

  explicit GetUserResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["accountType"] = boost::any(*accountType);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (isEditableUser) {
      res["isEditableUser"] = boost::any(*isEditableUser);
    }
    if (isRelated) {
      res["isRelated"] = boost::any(*isRelated);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (ramId) {
      res["ramId"] = boost::any(*ramId);
    }
    if (serviceGroups) {
      vector<boost::any> temp1;
      for(auto item1:*serviceGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["serviceGroups"] = boost::any(temp1);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountType") != m.end() && !m["accountType"].empty()) {
      accountType = make_shared<string>(boost::any_cast<string>(m["accountType"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("isEditableUser") != m.end() && !m["isEditableUser"].empty()) {
      isEditableUser = make_shared<bool>(boost::any_cast<bool>(m["isEditableUser"]));
    }
    if (m.find("isRelated") != m.end() && !m["isRelated"].empty()) {
      isRelated = make_shared<string>(boost::any_cast<string>(m["isRelated"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("ramId") != m.end() && !m["ramId"].empty()) {
      ramId = make_shared<string>(boost::any_cast<string>(m["ramId"]));
    }
    if (m.find("serviceGroups") != m.end() && !m["serviceGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["serviceGroups"].type()) {
        vector<GetUserResponseBodyDataServiceGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["serviceGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetUserResponseBodyDataServiceGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceGroups = make_shared<vector<GetUserResponseBodyDataServiceGroups>>(expect1);
      }
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~GetUserResponseBodyData() = default;
};
class GetUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<GetUserResponseBodyData> data{};
  shared_ptr<string> requestId{};

  GetUserResponseBody() {}

  explicit GetUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        GetUserResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<GetUserResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetUserResponseBody() = default;
};
class GetUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUserResponseBody> body{};

  GetUserResponse() {}

  explicit GetUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUserResponseBody>(model1);
      }
    }
  }


  virtual ~GetUserResponse() = default;
};
class GetUserGuideStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};

  GetUserGuideStatusRequest() {}

  explicit GetUserGuideStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~GetUserGuideStatusRequest() = default;
};
class GetUserGuideStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> data{};
  shared_ptr<string> requestId{};

  GetUserGuideStatusResponseBody() {}

  explicit GetUserGuideStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["data"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      data = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~GetUserGuideStatusResponseBody() = default;
};
class GetUserGuideStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetUserGuideStatusResponseBody> body{};

  GetUserGuideStatusResponse() {}

  explicit GetUserGuideStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetUserGuideStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetUserGuideStatusResponseBody>(model1);
      }
    }
  }


  virtual ~GetUserGuideStatusResponse() = default;
};
class ListAlertsRequest : public Darabonba::Model {
public:
  shared_ptr<string> alertLevel{};
  shared_ptr<string> alertName{};
  shared_ptr<string> alertSourceName{};
  shared_ptr<string> endTime{};
  shared_ptr<string> monitorSourceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> relatedServiceId{};
  shared_ptr<string> ruleName{};
  shared_ptr<string> startTime{};

  ListAlertsRequest() {}

  explicit ListAlertsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertLevel) {
      res["alertLevel"] = boost::any(*alertLevel);
    }
    if (alertName) {
      res["alertName"] = boost::any(*alertName);
    }
    if (alertSourceName) {
      res["alertSourceName"] = boost::any(*alertSourceName);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (monitorSourceId) {
      res["monitorSourceId"] = boost::any(*monitorSourceId);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (relatedServiceId) {
      res["relatedServiceId"] = boost::any(*relatedServiceId);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alertLevel") != m.end() && !m["alertLevel"].empty()) {
      alertLevel = make_shared<string>(boost::any_cast<string>(m["alertLevel"]));
    }
    if (m.find("alertName") != m.end() && !m["alertName"].empty()) {
      alertName = make_shared<string>(boost::any_cast<string>(m["alertName"]));
    }
    if (m.find("alertSourceName") != m.end() && !m["alertSourceName"].empty()) {
      alertSourceName = make_shared<string>(boost::any_cast<string>(m["alertSourceName"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("monitorSourceId") != m.end() && !m["monitorSourceId"].empty()) {
      monitorSourceId = make_shared<string>(boost::any_cast<string>(m["monitorSourceId"]));
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("relatedServiceId") != m.end() && !m["relatedServiceId"].empty()) {
      relatedServiceId = make_shared<long>(boost::any_cast<long>(m["relatedServiceId"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
  }


  virtual ~ListAlertsRequest() = default;
};
class ListAlertsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> alertId{};
  shared_ptr<string> alertLevel{};
  shared_ptr<string> alertNumber{};
  shared_ptr<string> alertSourceName{};
  shared_ptr<string> createTime{};
  shared_ptr<string> firstEventTime{};
  shared_ptr<string> monitorSourceName{};
  shared_ptr<long> relServiceDeleteType{};
  shared_ptr<string> relatedServiceName{};
  shared_ptr<long> routeRuleDeleteType{};
  shared_ptr<long> routeRuleId{};
  shared_ptr<string> routeRuleName{};
  shared_ptr<long> sourceEventCount{};
  shared_ptr<string> title{};

  ListAlertsResponseBodyData() {}

  explicit ListAlertsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alertId) {
      res["alertId"] = boost::any(*alertId);
    }
    if (alertLevel) {
      res["alertLevel"] = boost::any(*alertLevel);
    }
    if (alertNumber) {
      res["alertNumber"] = boost::any(*alertNumber);
    }
    if (alertSourceName) {
      res["alertSourceName"] = boost::any(*alertSourceName);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (firstEventTime) {
      res["firstEventTime"] = boost::any(*firstEventTime);
    }
    if (monitorSourceName) {
      res["monitorSourceName"] = boost::any(*monitorSourceName);
    }
    if (relServiceDeleteType) {
      res["relServiceDeleteType"] = boost::any(*relServiceDeleteType);
    }
    if (relatedServiceName) {
      res["relatedServiceName"] = boost::any(*relatedServiceName);
    }
    if (routeRuleDeleteType) {
      res["routeRuleDeleteType"] = boost::any(*routeRuleDeleteType);
    }
    if (routeRuleId) {
      res["routeRuleId"] = boost::any(*routeRuleId);
    }
    if (routeRuleName) {
      res["routeRuleName"] = boost::any(*routeRuleName);
    }
    if (sourceEventCount) {
      res["sourceEventCount"] = boost::any(*sourceEventCount);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alertId") != m.end() && !m["alertId"].empty()) {
      alertId = make_shared<long>(boost::any_cast<long>(m["alertId"]));
    }
    if (m.find("alertLevel") != m.end() && !m["alertLevel"].empty()) {
      alertLevel = make_shared<string>(boost::any_cast<string>(m["alertLevel"]));
    }
    if (m.find("alertNumber") != m.end() && !m["alertNumber"].empty()) {
      alertNumber = make_shared<string>(boost::any_cast<string>(m["alertNumber"]));
    }
    if (m.find("alertSourceName") != m.end() && !m["alertSourceName"].empty()) {
      alertSourceName = make_shared<string>(boost::any_cast<string>(m["alertSourceName"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("firstEventTime") != m.end() && !m["firstEventTime"].empty()) {
      firstEventTime = make_shared<string>(boost::any_cast<string>(m["firstEventTime"]));
    }
    if (m.find("monitorSourceName") != m.end() && !m["monitorSourceName"].empty()) {
      monitorSourceName = make_shared<string>(boost::any_cast<string>(m["monitorSourceName"]));
    }
    if (m.find("relServiceDeleteType") != m.end() && !m["relServiceDeleteType"].empty()) {
      relServiceDeleteType = make_shared<long>(boost::any_cast<long>(m["relServiceDeleteType"]));
    }
    if (m.find("relatedServiceName") != m.end() && !m["relatedServiceName"].empty()) {
      relatedServiceName = make_shared<string>(boost::any_cast<string>(m["relatedServiceName"]));
    }
    if (m.find("routeRuleDeleteType") != m.end() && !m["routeRuleDeleteType"].empty()) {
      routeRuleDeleteType = make_shared<long>(boost::any_cast<long>(m["routeRuleDeleteType"]));
    }
    if (m.find("routeRuleId") != m.end() && !m["routeRuleId"].empty()) {
      routeRuleId = make_shared<long>(boost::any_cast<long>(m["routeRuleId"]));
    }
    if (m.find("routeRuleName") != m.end() && !m["routeRuleName"].empty()) {
      routeRuleName = make_shared<string>(boost::any_cast<string>(m["routeRuleName"]));
    }
    if (m.find("sourceEventCount") != m.end() && !m["sourceEventCount"].empty()) {
      sourceEventCount = make_shared<long>(boost::any_cast<long>(m["sourceEventCount"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~ListAlertsResponseBodyData() = default;
};
class ListAlertsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListAlertsResponseBodyData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListAlertsResponseBody() {}

  explicit ListAlertsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListAlertsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlertsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListAlertsResponseBodyData>>(expect1);
      }
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ListAlertsResponseBody() = default;
};
class ListAlertsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAlertsResponseBody> body{};

  ListAlertsResponse() {}

  explicit ListAlertsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAlertsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAlertsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAlertsResponse() = default;
};
class ListByMonitorSourceIdRequest : public Darabonba::Model {
public:
  shared_ptr<string> monitorSourceId{};

  ListByMonitorSourceIdRequest() {}

  explicit ListByMonitorSourceIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorSourceId) {
      res["monitorSourceId"] = boost::any(*monitorSourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("monitorSourceId") != m.end() && !m["monitorSourceId"].empty()) {
      monitorSourceId = make_shared<string>(boost::any_cast<string>(m["monitorSourceId"]));
    }
  }


  virtual ~ListByMonitorSourceIdRequest() = default;
};
class ListByMonitorSourceIdResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> ruleName{};

  ListByMonitorSourceIdResponseBodyData() {}

  explicit ListByMonitorSourceIdResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
  }


  virtual ~ListByMonitorSourceIdResponseBodyData() = default;
};
class ListByMonitorSourceIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListByMonitorSourceIdResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  ListByMonitorSourceIdResponseBody() {}

  explicit ListByMonitorSourceIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListByMonitorSourceIdResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListByMonitorSourceIdResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListByMonitorSourceIdResponseBodyData>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListByMonitorSourceIdResponseBody() = default;
};
class ListByMonitorSourceIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListByMonitorSourceIdResponseBody> body{};

  ListByMonitorSourceIdResponse() {}

  explicit ListByMonitorSourceIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListByMonitorSourceIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListByMonitorSourceIdResponseBody>(model1);
      }
    }
  }


  virtual ~ListByMonitorSourceIdResponse() = default;
};
class ListChartDataForServiceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  ListChartDataForServiceGroupRequest() {}

  explicit ListChartDataForServiceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
  }


  virtual ~ListChartDataForServiceGroupRequest() = default;
};
class ListChartDataForServiceGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> effectionLevel{};
  shared_ptr<long> escalationIncidentCount{};
  shared_ptr<long> incidentCount{};
  shared_ptr<long> meanTimeToAcknowledge{};
  shared_ptr<long> meanTimeToRepair{};
  shared_ptr<string> time{};
  shared_ptr<long> totalMeanTimeToAcknowledge{};
  shared_ptr<long> totalMeanTimeToRepair{};
  shared_ptr<long> unAcknowledgedEscalationIncidentCount{};
  shared_ptr<long> unFinishEscalationIncidentCount{};

  ListChartDataForServiceGroupResponseBodyData() {}

  explicit ListChartDataForServiceGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effectionLevel) {
      res["effectionLevel"] = boost::any(*effectionLevel);
    }
    if (escalationIncidentCount) {
      res["escalationIncidentCount"] = boost::any(*escalationIncidentCount);
    }
    if (incidentCount) {
      res["incidentCount"] = boost::any(*incidentCount);
    }
    if (meanTimeToAcknowledge) {
      res["meanTimeToAcknowledge"] = boost::any(*meanTimeToAcknowledge);
    }
    if (meanTimeToRepair) {
      res["meanTimeToRepair"] = boost::any(*meanTimeToRepair);
    }
    if (time) {
      res["time"] = boost::any(*time);
    }
    if (totalMeanTimeToAcknowledge) {
      res["totalMeanTimeToAcknowledge"] = boost::any(*totalMeanTimeToAcknowledge);
    }
    if (totalMeanTimeToRepair) {
      res["totalMeanTimeToRepair"] = boost::any(*totalMeanTimeToRepair);
    }
    if (unAcknowledgedEscalationIncidentCount) {
      res["unAcknowledgedEscalationIncidentCount"] = boost::any(*unAcknowledgedEscalationIncidentCount);
    }
    if (unFinishEscalationIncidentCount) {
      res["unFinishEscalationIncidentCount"] = boost::any(*unFinishEscalationIncidentCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("effectionLevel") != m.end() && !m["effectionLevel"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["effectionLevel"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      effectionLevel = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("escalationIncidentCount") != m.end() && !m["escalationIncidentCount"].empty()) {
      escalationIncidentCount = make_shared<long>(boost::any_cast<long>(m["escalationIncidentCount"]));
    }
    if (m.find("incidentCount") != m.end() && !m["incidentCount"].empty()) {
      incidentCount = make_shared<long>(boost::any_cast<long>(m["incidentCount"]));
    }
    if (m.find("meanTimeToAcknowledge") != m.end() && !m["meanTimeToAcknowledge"].empty()) {
      meanTimeToAcknowledge = make_shared<long>(boost::any_cast<long>(m["meanTimeToAcknowledge"]));
    }
    if (m.find("meanTimeToRepair") != m.end() && !m["meanTimeToRepair"].empty()) {
      meanTimeToRepair = make_shared<long>(boost::any_cast<long>(m["meanTimeToRepair"]));
    }
    if (m.find("time") != m.end() && !m["time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["time"]));
    }
    if (m.find("totalMeanTimeToAcknowledge") != m.end() && !m["totalMeanTimeToAcknowledge"].empty()) {
      totalMeanTimeToAcknowledge = make_shared<long>(boost::any_cast<long>(m["totalMeanTimeToAcknowledge"]));
    }
    if (m.find("totalMeanTimeToRepair") != m.end() && !m["totalMeanTimeToRepair"].empty()) {
      totalMeanTimeToRepair = make_shared<long>(boost::any_cast<long>(m["totalMeanTimeToRepair"]));
    }
    if (m.find("unAcknowledgedEscalationIncidentCount") != m.end() && !m["unAcknowledgedEscalationIncidentCount"].empty()) {
      unAcknowledgedEscalationIncidentCount = make_shared<long>(boost::any_cast<long>(m["unAcknowledgedEscalationIncidentCount"]));
    }
    if (m.find("unFinishEscalationIncidentCount") != m.end() && !m["unFinishEscalationIncidentCount"].empty()) {
      unFinishEscalationIncidentCount = make_shared<long>(boost::any_cast<long>(m["unFinishEscalationIncidentCount"]));
    }
  }


  virtual ~ListChartDataForServiceGroupResponseBodyData() = default;
};
class ListChartDataForServiceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListChartDataForServiceGroupResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  ListChartDataForServiceGroupResponseBody() {}

  explicit ListChartDataForServiceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListChartDataForServiceGroupResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListChartDataForServiceGroupResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListChartDataForServiceGroupResponseBodyData>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListChartDataForServiceGroupResponseBody() = default;
};
class ListChartDataForServiceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListChartDataForServiceGroupResponseBody> body{};

  ListChartDataForServiceGroupResponse() {}

  explicit ListChartDataForServiceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListChartDataForServiceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListChartDataForServiceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListChartDataForServiceGroupResponse() = default;
};
class ListChartDataForUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};

  ListChartDataForUserRequest() {}

  explicit ListChartDataForUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
  }


  virtual ~ListChartDataForUserRequest() = default;
};
class ListChartDataForUserResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> effectionLevel{};
  shared_ptr<long> escalationIncidentCount{};
  shared_ptr<long> incidentCount{};
  shared_ptr<long> meanTimeToAcknowledge{};
  shared_ptr<long> meanTimeToRepair{};
  shared_ptr<string> time{};
  shared_ptr<long> totalMeanTimeToAcknowledge{};
  shared_ptr<long> totalMeanTimeToRepair{};
  shared_ptr<long> unAcknowledgedEscalationIncidentCount{};
  shared_ptr<long> unFinishEscalationIncidentCount{};

  ListChartDataForUserResponseBodyData() {}

  explicit ListChartDataForUserResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effectionLevel) {
      res["effectionLevel"] = boost::any(*effectionLevel);
    }
    if (escalationIncidentCount) {
      res["escalationIncidentCount"] = boost::any(*escalationIncidentCount);
    }
    if (incidentCount) {
      res["incidentCount"] = boost::any(*incidentCount);
    }
    if (meanTimeToAcknowledge) {
      res["meanTimeToAcknowledge"] = boost::any(*meanTimeToAcknowledge);
    }
    if (meanTimeToRepair) {
      res["meanTimeToRepair"] = boost::any(*meanTimeToRepair);
    }
    if (time) {
      res["time"] = boost::any(*time);
    }
    if (totalMeanTimeToAcknowledge) {
      res["totalMeanTimeToAcknowledge"] = boost::any(*totalMeanTimeToAcknowledge);
    }
    if (totalMeanTimeToRepair) {
      res["totalMeanTimeToRepair"] = boost::any(*totalMeanTimeToRepair);
    }
    if (unAcknowledgedEscalationIncidentCount) {
      res["unAcknowledgedEscalationIncidentCount"] = boost::any(*unAcknowledgedEscalationIncidentCount);
    }
    if (unFinishEscalationIncidentCount) {
      res["unFinishEscalationIncidentCount"] = boost::any(*unFinishEscalationIncidentCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("effectionLevel") != m.end() && !m["effectionLevel"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["effectionLevel"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      effectionLevel = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("escalationIncidentCount") != m.end() && !m["escalationIncidentCount"].empty()) {
      escalationIncidentCount = make_shared<long>(boost::any_cast<long>(m["escalationIncidentCount"]));
    }
    if (m.find("incidentCount") != m.end() && !m["incidentCount"].empty()) {
      incidentCount = make_shared<long>(boost::any_cast<long>(m["incidentCount"]));
    }
    if (m.find("meanTimeToAcknowledge") != m.end() && !m["meanTimeToAcknowledge"].empty()) {
      meanTimeToAcknowledge = make_shared<long>(boost::any_cast<long>(m["meanTimeToAcknowledge"]));
    }
    if (m.find("meanTimeToRepair") != m.end() && !m["meanTimeToRepair"].empty()) {
      meanTimeToRepair = make_shared<long>(boost::any_cast<long>(m["meanTimeToRepair"]));
    }
    if (m.find("time") != m.end() && !m["time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["time"]));
    }
    if (m.find("totalMeanTimeToAcknowledge") != m.end() && !m["totalMeanTimeToAcknowledge"].empty()) {
      totalMeanTimeToAcknowledge = make_shared<long>(boost::any_cast<long>(m["totalMeanTimeToAcknowledge"]));
    }
    if (m.find("totalMeanTimeToRepair") != m.end() && !m["totalMeanTimeToRepair"].empty()) {
      totalMeanTimeToRepair = make_shared<long>(boost::any_cast<long>(m["totalMeanTimeToRepair"]));
    }
    if (m.find("unAcknowledgedEscalationIncidentCount") != m.end() && !m["unAcknowledgedEscalationIncidentCount"].empty()) {
      unAcknowledgedEscalationIncidentCount = make_shared<long>(boost::any_cast<long>(m["unAcknowledgedEscalationIncidentCount"]));
    }
    if (m.find("unFinishEscalationIncidentCount") != m.end() && !m["unFinishEscalationIncidentCount"].empty()) {
      unFinishEscalationIncidentCount = make_shared<long>(boost::any_cast<long>(m["unFinishEscalationIncidentCount"]));
    }
  }


  virtual ~ListChartDataForUserResponseBodyData() = default;
};
class ListChartDataForUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListChartDataForUserResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  ListChartDataForUserResponseBody() {}

  explicit ListChartDataForUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListChartDataForUserResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListChartDataForUserResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListChartDataForUserResponseBodyData>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListChartDataForUserResponseBody() = default;
};
class ListChartDataForUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListChartDataForUserResponseBody> body{};

  ListChartDataForUserResponse() {}

  explicit ListChartDataForUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListChartDataForUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListChartDataForUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListChartDataForUserResponse() = default;
};
class ListConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};

  ListConfigsRequest() {}

  explicit ListConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~ListConfigsRequest() = default;
};
class ListConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, vector<DataValue>>> data{};
  shared_ptr<string> requestId{};

  ListConfigsResponseBody() {}

  explicit ListConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      map<string, boost::any> temp1;
      for(auto item1:*data){
        vector<boost::any> temp2;
        for(auto item2:item1.second){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1[item1.first] = boost::any(temp2);
      }
      res["data"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        map<string, vector<DataValue>> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["data"])){
          if (typeid(vector<boost::any>) == item1.second.type()) {
            vector<DataValue> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1.second)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                DataValue model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1[item1.first] = expect2;
          }
        }
        data = make_shared<map<string, vector<DataValue>>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListConfigsResponseBody() = default;
};
class ListConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListConfigsResponseBody> body{};

  ListConfigsResponse() {}

  explicit ListConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~ListConfigsResponse() = default;
};
class ListDataReportForServiceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> serviceGroupName{};
  shared_ptr<string> startTime{};

  ListDataReportForServiceGroupRequest() {}

  explicit ListDataReportForServiceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (serviceGroupName) {
      res["serviceGroupName"] = boost::any(*serviceGroupName);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("serviceGroupName") != m.end() && !m["serviceGroupName"].empty()) {
      serviceGroupName = make_shared<string>(boost::any_cast<string>(m["serviceGroupName"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
  }


  virtual ~ListDataReportForServiceGroupRequest() = default;
};
class ListDataReportForServiceGroupResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> escalationIncidentCount{};
  shared_ptr<long> finishIncidentCount{};
  shared_ptr<string> finishProportion{};
  shared_ptr<long> incidentCount{};
  shared_ptr<long> meanTimeToAcknowledge{};
  shared_ptr<long> meanTimeToRepair{};
  shared_ptr<long> serviceGroupId{};
  shared_ptr<string> serviceGroupName{};
  shared_ptr<long> unAcknowledgedEscalationIncidentCount{};
  shared_ptr<long> unFinishEscalationIncidentCount{};

  ListDataReportForServiceGroupResponseBodyData() {}

  explicit ListDataReportForServiceGroupResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalationIncidentCount) {
      res["escalationIncidentCount"] = boost::any(*escalationIncidentCount);
    }
    if (finishIncidentCount) {
      res["finishIncidentCount"] = boost::any(*finishIncidentCount);
    }
    if (finishProportion) {
      res["finishProportion"] = boost::any(*finishProportion);
    }
    if (incidentCount) {
      res["incidentCount"] = boost::any(*incidentCount);
    }
    if (meanTimeToAcknowledge) {
      res["meanTimeToAcknowledge"] = boost::any(*meanTimeToAcknowledge);
    }
    if (meanTimeToRepair) {
      res["meanTimeToRepair"] = boost::any(*meanTimeToRepair);
    }
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    if (serviceGroupName) {
      res["serviceGroupName"] = boost::any(*serviceGroupName);
    }
    if (unAcknowledgedEscalationIncidentCount) {
      res["unAcknowledgedEscalationIncidentCount"] = boost::any(*unAcknowledgedEscalationIncidentCount);
    }
    if (unFinishEscalationIncidentCount) {
      res["unFinishEscalationIncidentCount"] = boost::any(*unFinishEscalationIncidentCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("escalationIncidentCount") != m.end() && !m["escalationIncidentCount"].empty()) {
      escalationIncidentCount = make_shared<long>(boost::any_cast<long>(m["escalationIncidentCount"]));
    }
    if (m.find("finishIncidentCount") != m.end() && !m["finishIncidentCount"].empty()) {
      finishIncidentCount = make_shared<long>(boost::any_cast<long>(m["finishIncidentCount"]));
    }
    if (m.find("finishProportion") != m.end() && !m["finishProportion"].empty()) {
      finishProportion = make_shared<string>(boost::any_cast<string>(m["finishProportion"]));
    }
    if (m.find("incidentCount") != m.end() && !m["incidentCount"].empty()) {
      incidentCount = make_shared<long>(boost::any_cast<long>(m["incidentCount"]));
    }
    if (m.find("meanTimeToAcknowledge") != m.end() && !m["meanTimeToAcknowledge"].empty()) {
      meanTimeToAcknowledge = make_shared<long>(boost::any_cast<long>(m["meanTimeToAcknowledge"]));
    }
    if (m.find("meanTimeToRepair") != m.end() && !m["meanTimeToRepair"].empty()) {
      meanTimeToRepair = make_shared<long>(boost::any_cast<long>(m["meanTimeToRepair"]));
    }
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
    if (m.find("serviceGroupName") != m.end() && !m["serviceGroupName"].empty()) {
      serviceGroupName = make_shared<string>(boost::any_cast<string>(m["serviceGroupName"]));
    }
    if (m.find("unAcknowledgedEscalationIncidentCount") != m.end() && !m["unAcknowledgedEscalationIncidentCount"].empty()) {
      unAcknowledgedEscalationIncidentCount = make_shared<long>(boost::any_cast<long>(m["unAcknowledgedEscalationIncidentCount"]));
    }
    if (m.find("unFinishEscalationIncidentCount") != m.end() && !m["unFinishEscalationIncidentCount"].empty()) {
      unFinishEscalationIncidentCount = make_shared<long>(boost::any_cast<long>(m["unFinishEscalationIncidentCount"]));
    }
  }


  virtual ~ListDataReportForServiceGroupResponseBodyData() = default;
};
class ListDataReportForServiceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataReportForServiceGroupResponseBodyData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSIze{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListDataReportForServiceGroupResponseBody() {}

  explicit ListDataReportForServiceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSIze) {
      res["pageSIze"] = boost::any(*pageSIze);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListDataReportForServiceGroupResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataReportForServiceGroupResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListDataReportForServiceGroupResponseBodyData>>(expect1);
      }
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSIze") != m.end() && !m["pageSIze"].empty()) {
      pageSIze = make_shared<long>(boost::any_cast<long>(m["pageSIze"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ListDataReportForServiceGroupResponseBody() = default;
};
class ListDataReportForServiceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataReportForServiceGroupResponseBody> body{};

  ListDataReportForServiceGroupResponse() {}

  explicit ListDataReportForServiceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataReportForServiceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataReportForServiceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataReportForServiceGroupResponse() = default;
};
class ListDataReportForUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startTime{};

  ListDataReportForUserRequest() {}

  explicit ListDataReportForUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
  }


  virtual ~ListDataReportForUserRequest() = default;
};
class ListDataReportForUserResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> distributionIncidentCount{};
  shared_ptr<long> escalationIncidentCount{};
  shared_ptr<long> finishIncidentNumber{};
  shared_ptr<string> finishProportion{};
  shared_ptr<string> meanTimeToAcknowledge{};
  shared_ptr<string> meanTimeToRepair{};
  shared_ptr<long> unAcknowledgedEscalationIncidentCount{};
  shared_ptr<long> unDistributionIncidentCount{};
  shared_ptr<long> unFinishEscalationIncidentCount{};
  shared_ptr<long> userId{};
  shared_ptr<string> userName{};

  ListDataReportForUserResponseBodyData() {}

  explicit ListDataReportForUserResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (distributionIncidentCount) {
      res["distributionIncidentCount"] = boost::any(*distributionIncidentCount);
    }
    if (escalationIncidentCount) {
      res["escalationIncidentCount"] = boost::any(*escalationIncidentCount);
    }
    if (finishIncidentNumber) {
      res["finishIncidentNumber"] = boost::any(*finishIncidentNumber);
    }
    if (finishProportion) {
      res["finishProportion"] = boost::any(*finishProportion);
    }
    if (meanTimeToAcknowledge) {
      res["meanTimeToAcknowledge"] = boost::any(*meanTimeToAcknowledge);
    }
    if (meanTimeToRepair) {
      res["meanTimeToRepair"] = boost::any(*meanTimeToRepair);
    }
    if (unAcknowledgedEscalationIncidentCount) {
      res["unAcknowledgedEscalationIncidentCount"] = boost::any(*unAcknowledgedEscalationIncidentCount);
    }
    if (unDistributionIncidentCount) {
      res["unDistributionIncidentCount"] = boost::any(*unDistributionIncidentCount);
    }
    if (unFinishEscalationIncidentCount) {
      res["unFinishEscalationIncidentCount"] = boost::any(*unFinishEscalationIncidentCount);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    if (userName) {
      res["userName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("distributionIncidentCount") != m.end() && !m["distributionIncidentCount"].empty()) {
      distributionIncidentCount = make_shared<long>(boost::any_cast<long>(m["distributionIncidentCount"]));
    }
    if (m.find("escalationIncidentCount") != m.end() && !m["escalationIncidentCount"].empty()) {
      escalationIncidentCount = make_shared<long>(boost::any_cast<long>(m["escalationIncidentCount"]));
    }
    if (m.find("finishIncidentNumber") != m.end() && !m["finishIncidentNumber"].empty()) {
      finishIncidentNumber = make_shared<long>(boost::any_cast<long>(m["finishIncidentNumber"]));
    }
    if (m.find("finishProportion") != m.end() && !m["finishProportion"].empty()) {
      finishProportion = make_shared<string>(boost::any_cast<string>(m["finishProportion"]));
    }
    if (m.find("meanTimeToAcknowledge") != m.end() && !m["meanTimeToAcknowledge"].empty()) {
      meanTimeToAcknowledge = make_shared<string>(boost::any_cast<string>(m["meanTimeToAcknowledge"]));
    }
    if (m.find("meanTimeToRepair") != m.end() && !m["meanTimeToRepair"].empty()) {
      meanTimeToRepair = make_shared<string>(boost::any_cast<string>(m["meanTimeToRepair"]));
    }
    if (m.find("unAcknowledgedEscalationIncidentCount") != m.end() && !m["unAcknowledgedEscalationIncidentCount"].empty()) {
      unAcknowledgedEscalationIncidentCount = make_shared<long>(boost::any_cast<long>(m["unAcknowledgedEscalationIncidentCount"]));
    }
    if (m.find("unDistributionIncidentCount") != m.end() && !m["unDistributionIncidentCount"].empty()) {
      unDistributionIncidentCount = make_shared<long>(boost::any_cast<long>(m["unDistributionIncidentCount"]));
    }
    if (m.find("unFinishEscalationIncidentCount") != m.end() && !m["unFinishEscalationIncidentCount"].empty()) {
      unFinishEscalationIncidentCount = make_shared<long>(boost::any_cast<long>(m["unFinishEscalationIncidentCount"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
    if (m.find("userName") != m.end() && !m["userName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["userName"]));
    }
  }


  virtual ~ListDataReportForUserResponseBodyData() = default;
};
class ListDataReportForUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListDataReportForUserResponseBodyData>> data{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListDataReportForUserResponseBody() {}

  explicit ListDataReportForUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListDataReportForUserResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataReportForUserResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListDataReportForUserResponseBodyData>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ListDataReportForUserResponseBody() = default;
};
class ListDataReportForUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataReportForUserResponseBody> body{};

  ListDataReportForUserResponse() {}

  explicit ListDataReportForUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataReportForUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataReportForUserResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataReportForUserResponse() = default;
};
class ListDictionariesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};

  ListDictionariesRequest() {}

  explicit ListDictionariesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~ListDictionariesRequest() = default;
};
class ListDictionariesResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, vector<DataValue>>> data{};
  shared_ptr<string> requestId{};

  ListDictionariesResponseBody() {}

  explicit ListDictionariesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      map<string, boost::any> temp1;
      for(auto item1:*data){
        vector<boost::any> temp2;
        for(auto item2:item1.second){
          temp2.push_back(boost::any(item2.toMap()));
        }
        temp1[item1.first] = boost::any(temp2);
      }
      res["data"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        map<string, vector<DataValue>> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["data"])){
          if (typeid(vector<boost::any>) == item1.second.type()) {
            vector<DataValue> expect2;
            for(auto item2:boost::any_cast<vector<boost::any>>(item1.second)){
              if (typeid(map<string, boost::any>) == item2.type()) {
                DataValue model3;
                model3.fromMap(boost::any_cast<map<string, boost::any>>(item2));
                expect2.push_back(model3);
              }
            }
            expect1[item1.first] = expect2;
          }
        }
        data = make_shared<map<string, vector<DataValue>>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListDictionariesResponseBody() = default;
};
class ListDictionariesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDictionariesResponseBody> body{};

  ListDictionariesResponse() {}

  explicit ListDictionariesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDictionariesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDictionariesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDictionariesResponse() = default;
};
class ListEscalationPlanServicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};

  ListEscalationPlanServicesRequest() {}

  explicit ListEscalationPlanServicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~ListEscalationPlanServicesRequest() = default;
};
class ListEscalationPlanServicesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> scope{};
  shared_ptr<long> scopeObjectId{};

  ListEscalationPlanServicesResponseBodyData() {}

  explicit ListEscalationPlanServicesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (scopeObjectId) {
      res["scopeObjectId"] = boost::any(*scopeObjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
    if (m.find("scopeObjectId") != m.end() && !m["scopeObjectId"].empty()) {
      scopeObjectId = make_shared<long>(boost::any_cast<long>(m["scopeObjectId"]));
    }
  }


  virtual ~ListEscalationPlanServicesResponseBodyData() = default;
};
class ListEscalationPlanServicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListEscalationPlanServicesResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  ListEscalationPlanServicesResponseBody() {}

  explicit ListEscalationPlanServicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListEscalationPlanServicesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEscalationPlanServicesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListEscalationPlanServicesResponseBodyData>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListEscalationPlanServicesResponseBody() = default;
};
class ListEscalationPlanServicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEscalationPlanServicesResponseBody> body{};

  ListEscalationPlanServicesResponse() {}

  explicit ListEscalationPlanServicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEscalationPlanServicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEscalationPlanServicesResponseBody>(model1);
      }
    }
  }


  virtual ~ListEscalationPlanServicesResponse() = default;
};
class ListEscalationPlansRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> escalationPlanName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> serviceName{};

  ListEscalationPlansRequest() {}

  explicit ListEscalationPlansRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (escalationPlanName) {
      res["escalationPlanName"] = boost::any(*escalationPlanName);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("escalationPlanName") != m.end() && !m["escalationPlanName"].empty()) {
      escalationPlanName = make_shared<string>(boost::any_cast<string>(m["escalationPlanName"]));
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
  }


  virtual ~ListEscalationPlansRequest() = default;
};
class ListEscalationPlansResponseBodyDataEscalationPlanScopeObjects : public Darabonba::Model {
public:
  shared_ptr<string> scope{};
  shared_ptr<long> scopeObjectDeletedType{};
  shared_ptr<long> scopeObjectId{};
  shared_ptr<string> scopeObjectName{};

  ListEscalationPlansResponseBodyDataEscalationPlanScopeObjects() {}

  explicit ListEscalationPlansResponseBodyDataEscalationPlanScopeObjects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (scopeObjectDeletedType) {
      res["scopeObjectDeletedType"] = boost::any(*scopeObjectDeletedType);
    }
    if (scopeObjectId) {
      res["scopeObjectId"] = boost::any(*scopeObjectId);
    }
    if (scopeObjectName) {
      res["scopeObjectName"] = boost::any(*scopeObjectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
    if (m.find("scopeObjectDeletedType") != m.end() && !m["scopeObjectDeletedType"].empty()) {
      scopeObjectDeletedType = make_shared<long>(boost::any_cast<long>(m["scopeObjectDeletedType"]));
    }
    if (m.find("scopeObjectId") != m.end() && !m["scopeObjectId"].empty()) {
      scopeObjectId = make_shared<long>(boost::any_cast<long>(m["scopeObjectId"]));
    }
    if (m.find("scopeObjectName") != m.end() && !m["scopeObjectName"].empty()) {
      scopeObjectName = make_shared<string>(boost::any_cast<string>(m["scopeObjectName"]));
    }
  }


  virtual ~ListEscalationPlansResponseBodyDataEscalationPlanScopeObjects() = default;
};
class ListEscalationPlansResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> escalationPlanId{};
  shared_ptr<string> escalationPlanName{};
  shared_ptr<vector<ListEscalationPlansResponseBodyDataEscalationPlanScopeObjects>> escalationPlanScopeObjects{};
  shared_ptr<string> modifyTime{};
  shared_ptr<string> status{};

  ListEscalationPlansResponseBodyData() {}

  explicit ListEscalationPlansResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalationPlanId) {
      res["escalationPlanId"] = boost::any(*escalationPlanId);
    }
    if (escalationPlanName) {
      res["escalationPlanName"] = boost::any(*escalationPlanName);
    }
    if (escalationPlanScopeObjects) {
      vector<boost::any> temp1;
      for(auto item1:*escalationPlanScopeObjects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["escalationPlanScopeObjects"] = boost::any(temp1);
    }
    if (modifyTime) {
      res["modifyTime"] = boost::any(*modifyTime);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("escalationPlanId") != m.end() && !m["escalationPlanId"].empty()) {
      escalationPlanId = make_shared<long>(boost::any_cast<long>(m["escalationPlanId"]));
    }
    if (m.find("escalationPlanName") != m.end() && !m["escalationPlanName"].empty()) {
      escalationPlanName = make_shared<string>(boost::any_cast<string>(m["escalationPlanName"]));
    }
    if (m.find("escalationPlanScopeObjects") != m.end() && !m["escalationPlanScopeObjects"].empty()) {
      if (typeid(vector<boost::any>) == m["escalationPlanScopeObjects"].type()) {
        vector<ListEscalationPlansResponseBodyDataEscalationPlanScopeObjects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["escalationPlanScopeObjects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEscalationPlansResponseBodyDataEscalationPlanScopeObjects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        escalationPlanScopeObjects = make_shared<vector<ListEscalationPlansResponseBodyDataEscalationPlanScopeObjects>>(expect1);
      }
    }
    if (m.find("modifyTime") != m.end() && !m["modifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["modifyTime"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~ListEscalationPlansResponseBodyData() = default;
};
class ListEscalationPlansResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListEscalationPlansResponseBodyData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListEscalationPlansResponseBody() {}

  explicit ListEscalationPlansResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListEscalationPlansResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEscalationPlansResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListEscalationPlansResponseBodyData>>(expect1);
      }
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ListEscalationPlansResponseBody() = default;
};
class ListEscalationPlansResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEscalationPlansResponseBody> body{};

  ListEscalationPlansResponse() {}

  explicit ListEscalationPlansResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEscalationPlansResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEscalationPlansResponseBody>(model1);
      }
    }
  }


  virtual ~ListEscalationPlansResponse() = default;
};
class ListEscalationPlansByNoticeObjectRequest : public Darabonba::Model {
public:
  shared_ptr<long> noticeObjectId{};
  shared_ptr<long> noticeObjectType{};

  ListEscalationPlansByNoticeObjectRequest() {}

  explicit ListEscalationPlansByNoticeObjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (noticeObjectId) {
      res["noticeObjectId"] = boost::any(*noticeObjectId);
    }
    if (noticeObjectType) {
      res["noticeObjectType"] = boost::any(*noticeObjectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("noticeObjectId") != m.end() && !m["noticeObjectId"].empty()) {
      noticeObjectId = make_shared<long>(boost::any_cast<long>(m["noticeObjectId"]));
    }
    if (m.find("noticeObjectType") != m.end() && !m["noticeObjectType"].empty()) {
      noticeObjectType = make_shared<long>(boost::any_cast<long>(m["noticeObjectType"]));
    }
  }


  virtual ~ListEscalationPlansByNoticeObjectRequest() = default;
};
class ListEscalationPlansByNoticeObjectResponseBodyDataEscalationPlanScopeObjects : public Darabonba::Model {
public:
  shared_ptr<string> scope{};
  shared_ptr<long> scopeObjectDeletedType{};
  shared_ptr<long> scopeObjectId{};
  shared_ptr<string> scopeObjectName{};

  ListEscalationPlansByNoticeObjectResponseBodyDataEscalationPlanScopeObjects() {}

  explicit ListEscalationPlansByNoticeObjectResponseBodyDataEscalationPlanScopeObjects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (scopeObjectDeletedType) {
      res["scopeObjectDeletedType"] = boost::any(*scopeObjectDeletedType);
    }
    if (scopeObjectId) {
      res["scopeObjectId"] = boost::any(*scopeObjectId);
    }
    if (scopeObjectName) {
      res["scopeObjectName"] = boost::any(*scopeObjectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
    if (m.find("scopeObjectDeletedType") != m.end() && !m["scopeObjectDeletedType"].empty()) {
      scopeObjectDeletedType = make_shared<long>(boost::any_cast<long>(m["scopeObjectDeletedType"]));
    }
    if (m.find("scopeObjectId") != m.end() && !m["scopeObjectId"].empty()) {
      scopeObjectId = make_shared<long>(boost::any_cast<long>(m["scopeObjectId"]));
    }
    if (m.find("scopeObjectName") != m.end() && !m["scopeObjectName"].empty()) {
      scopeObjectName = make_shared<string>(boost::any_cast<string>(m["scopeObjectName"]));
    }
  }


  virtual ~ListEscalationPlansByNoticeObjectResponseBodyDataEscalationPlanScopeObjects() = default;
};
class ListEscalationPlansByNoticeObjectResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> escalationPlanId{};
  shared_ptr<string> escalationPlanName{};
  shared_ptr<vector<ListEscalationPlansByNoticeObjectResponseBodyDataEscalationPlanScopeObjects>> escalationPlanScopeObjects{};
  shared_ptr<string> modifyTime{};
  shared_ptr<string> status{};

  ListEscalationPlansByNoticeObjectResponseBodyData() {}

  explicit ListEscalationPlansByNoticeObjectResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalationPlanId) {
      res["escalationPlanId"] = boost::any(*escalationPlanId);
    }
    if (escalationPlanName) {
      res["escalationPlanName"] = boost::any(*escalationPlanName);
    }
    if (escalationPlanScopeObjects) {
      vector<boost::any> temp1;
      for(auto item1:*escalationPlanScopeObjects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["escalationPlanScopeObjects"] = boost::any(temp1);
    }
    if (modifyTime) {
      res["modifyTime"] = boost::any(*modifyTime);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("escalationPlanId") != m.end() && !m["escalationPlanId"].empty()) {
      escalationPlanId = make_shared<long>(boost::any_cast<long>(m["escalationPlanId"]));
    }
    if (m.find("escalationPlanName") != m.end() && !m["escalationPlanName"].empty()) {
      escalationPlanName = make_shared<string>(boost::any_cast<string>(m["escalationPlanName"]));
    }
    if (m.find("escalationPlanScopeObjects") != m.end() && !m["escalationPlanScopeObjects"].empty()) {
      if (typeid(vector<boost::any>) == m["escalationPlanScopeObjects"].type()) {
        vector<ListEscalationPlansByNoticeObjectResponseBodyDataEscalationPlanScopeObjects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["escalationPlanScopeObjects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEscalationPlansByNoticeObjectResponseBodyDataEscalationPlanScopeObjects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        escalationPlanScopeObjects = make_shared<vector<ListEscalationPlansByNoticeObjectResponseBodyDataEscalationPlanScopeObjects>>(expect1);
      }
    }
    if (m.find("modifyTime") != m.end() && !m["modifyTime"].empty()) {
      modifyTime = make_shared<string>(boost::any_cast<string>(m["modifyTime"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~ListEscalationPlansByNoticeObjectResponseBodyData() = default;
};
class ListEscalationPlansByNoticeObjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListEscalationPlansByNoticeObjectResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  ListEscalationPlansByNoticeObjectResponseBody() {}

  explicit ListEscalationPlansByNoticeObjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListEscalationPlansByNoticeObjectResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEscalationPlansByNoticeObjectResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListEscalationPlansByNoticeObjectResponseBodyData>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListEscalationPlansByNoticeObjectResponseBody() = default;
};
class ListEscalationPlansByNoticeObjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEscalationPlansByNoticeObjectResponseBody> body{};

  ListEscalationPlansByNoticeObjectResponse() {}

  explicit ListEscalationPlansByNoticeObjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEscalationPlansByNoticeObjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEscalationPlansByNoticeObjectResponseBody>(model1);
      }
    }
  }


  virtual ~ListEscalationPlansByNoticeObjectResponse() = default;
};
class ListIncidentDetailEscalationPlansRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> incidentId{};

  ListIncidentDetailEscalationPlansRequest() {}

  explicit ListIncidentDetailEscalationPlansRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (incidentId) {
      res["incidentId"] = boost::any(*incidentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("incidentId") != m.end() && !m["incidentId"].empty()) {
      incidentId = make_shared<long>(boost::any_cast<long>(m["incidentId"]));
    }
  }


  virtual ~ListIncidentDetailEscalationPlansRequest() = default;
};
class ListIncidentDetailEscalationPlansResponseBodyDataConvergenceEscalationPlanNoticeObjectList : public Darabonba::Model {
public:
  shared_ptr<long> noticeObjectId{};
  shared_ptr<string> noticeObjectName{};
  shared_ptr<string> noticeObjectPhone{};

  ListIncidentDetailEscalationPlansResponseBodyDataConvergenceEscalationPlanNoticeObjectList() {}

  explicit ListIncidentDetailEscalationPlansResponseBodyDataConvergenceEscalationPlanNoticeObjectList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (noticeObjectId) {
      res["noticeObjectId"] = boost::any(*noticeObjectId);
    }
    if (noticeObjectName) {
      res["noticeObjectName"] = boost::any(*noticeObjectName);
    }
    if (noticeObjectPhone) {
      res["noticeObjectPhone"] = boost::any(*noticeObjectPhone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("noticeObjectId") != m.end() && !m["noticeObjectId"].empty()) {
      noticeObjectId = make_shared<long>(boost::any_cast<long>(m["noticeObjectId"]));
    }
    if (m.find("noticeObjectName") != m.end() && !m["noticeObjectName"].empty()) {
      noticeObjectName = make_shared<string>(boost::any_cast<string>(m["noticeObjectName"]));
    }
    if (m.find("noticeObjectPhone") != m.end() && !m["noticeObjectPhone"].empty()) {
      noticeObjectPhone = make_shared<string>(boost::any_cast<string>(m["noticeObjectPhone"]));
    }
  }


  virtual ~ListIncidentDetailEscalationPlansResponseBodyDataConvergenceEscalationPlanNoticeObjectList() = default;
};
class ListIncidentDetailEscalationPlansResponseBodyDataConvergenceEscalationPlanServiceGroupList : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  ListIncidentDetailEscalationPlansResponseBodyDataConvergenceEscalationPlanServiceGroupList() {}

  explicit ListIncidentDetailEscalationPlansResponseBodyDataConvergenceEscalationPlanServiceGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~ListIncidentDetailEscalationPlansResponseBodyDataConvergenceEscalationPlanServiceGroupList() = default;
};
class ListIncidentDetailEscalationPlansResponseBodyDataConvergenceEscalationPlan : public Darabonba::Model {
public:
  shared_ptr<string> escalationPlanType{};
  shared_ptr<vector<string>> noticeChannels{};
  shared_ptr<vector<ListIncidentDetailEscalationPlansResponseBodyDataConvergenceEscalationPlanNoticeObjectList>> noticeObjectList{};
  shared_ptr<long> noticeTime{};
  shared_ptr<vector<ListIncidentDetailEscalationPlansResponseBodyDataConvergenceEscalationPlanServiceGroupList>> serviceGroupList{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};

  ListIncidentDetailEscalationPlansResponseBodyDataConvergenceEscalationPlan() {}

  explicit ListIncidentDetailEscalationPlansResponseBodyDataConvergenceEscalationPlan(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalationPlanType) {
      res["escalationPlanType"] = boost::any(*escalationPlanType);
    }
    if (noticeChannels) {
      res["noticeChannels"] = boost::any(*noticeChannels);
    }
    if (noticeObjectList) {
      vector<boost::any> temp1;
      for(auto item1:*noticeObjectList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["noticeObjectList"] = boost::any(temp1);
    }
    if (noticeTime) {
      res["noticeTime"] = boost::any(*noticeTime);
    }
    if (serviceGroupList) {
      vector<boost::any> temp1;
      for(auto item1:*serviceGroupList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["serviceGroupList"] = boost::any(temp1);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("escalationPlanType") != m.end() && !m["escalationPlanType"].empty()) {
      escalationPlanType = make_shared<string>(boost::any_cast<string>(m["escalationPlanType"]));
    }
    if (m.find("noticeChannels") != m.end() && !m["noticeChannels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["noticeChannels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["noticeChannels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      noticeChannels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("noticeObjectList") != m.end() && !m["noticeObjectList"].empty()) {
      if (typeid(vector<boost::any>) == m["noticeObjectList"].type()) {
        vector<ListIncidentDetailEscalationPlansResponseBodyDataConvergenceEscalationPlanNoticeObjectList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["noticeObjectList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIncidentDetailEscalationPlansResponseBodyDataConvergenceEscalationPlanNoticeObjectList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        noticeObjectList = make_shared<vector<ListIncidentDetailEscalationPlansResponseBodyDataConvergenceEscalationPlanNoticeObjectList>>(expect1);
      }
    }
    if (m.find("noticeTime") != m.end() && !m["noticeTime"].empty()) {
      noticeTime = make_shared<long>(boost::any_cast<long>(m["noticeTime"]));
    }
    if (m.find("serviceGroupList") != m.end() && !m["serviceGroupList"].empty()) {
      if (typeid(vector<boost::any>) == m["serviceGroupList"].type()) {
        vector<ListIncidentDetailEscalationPlansResponseBodyDataConvergenceEscalationPlanServiceGroupList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["serviceGroupList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIncidentDetailEscalationPlansResponseBodyDataConvergenceEscalationPlanServiceGroupList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceGroupList = make_shared<vector<ListIncidentDetailEscalationPlansResponseBodyDataConvergenceEscalationPlanServiceGroupList>>(expect1);
      }
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~ListIncidentDetailEscalationPlansResponseBodyDataConvergenceEscalationPlan() = default;
};
class ListIncidentDetailEscalationPlansResponseBodyDataNuAcknowledgeEscalationPlanNoticeObjectList : public Darabonba::Model {
public:
  shared_ptr<long> noticeObjectId{};
  shared_ptr<string> noticeObjectName{};
  shared_ptr<string> noticeObjectPhone{};

  ListIncidentDetailEscalationPlansResponseBodyDataNuAcknowledgeEscalationPlanNoticeObjectList() {}

  explicit ListIncidentDetailEscalationPlansResponseBodyDataNuAcknowledgeEscalationPlanNoticeObjectList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (noticeObjectId) {
      res["noticeObjectId"] = boost::any(*noticeObjectId);
    }
    if (noticeObjectName) {
      res["noticeObjectName"] = boost::any(*noticeObjectName);
    }
    if (noticeObjectPhone) {
      res["noticeObjectPhone"] = boost::any(*noticeObjectPhone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("noticeObjectId") != m.end() && !m["noticeObjectId"].empty()) {
      noticeObjectId = make_shared<long>(boost::any_cast<long>(m["noticeObjectId"]));
    }
    if (m.find("noticeObjectName") != m.end() && !m["noticeObjectName"].empty()) {
      noticeObjectName = make_shared<string>(boost::any_cast<string>(m["noticeObjectName"]));
    }
    if (m.find("noticeObjectPhone") != m.end() && !m["noticeObjectPhone"].empty()) {
      noticeObjectPhone = make_shared<string>(boost::any_cast<string>(m["noticeObjectPhone"]));
    }
  }


  virtual ~ListIncidentDetailEscalationPlansResponseBodyDataNuAcknowledgeEscalationPlanNoticeObjectList() = default;
};
class ListIncidentDetailEscalationPlansResponseBodyDataNuAcknowledgeEscalationPlanServiceGroupList : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  ListIncidentDetailEscalationPlansResponseBodyDataNuAcknowledgeEscalationPlanServiceGroupList() {}

  explicit ListIncidentDetailEscalationPlansResponseBodyDataNuAcknowledgeEscalationPlanServiceGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~ListIncidentDetailEscalationPlansResponseBodyDataNuAcknowledgeEscalationPlanServiceGroupList() = default;
};
class ListIncidentDetailEscalationPlansResponseBodyDataNuAcknowledgeEscalationPlan : public Darabonba::Model {
public:
  shared_ptr<string> escalationPlanType{};
  shared_ptr<vector<string>> noticeChannels{};
  shared_ptr<vector<ListIncidentDetailEscalationPlansResponseBodyDataNuAcknowledgeEscalationPlanNoticeObjectList>> noticeObjectList{};
  shared_ptr<long> noticeTime{};
  shared_ptr<vector<ListIncidentDetailEscalationPlansResponseBodyDataNuAcknowledgeEscalationPlanServiceGroupList>> serviceGroupList{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};

  ListIncidentDetailEscalationPlansResponseBodyDataNuAcknowledgeEscalationPlan() {}

  explicit ListIncidentDetailEscalationPlansResponseBodyDataNuAcknowledgeEscalationPlan(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalationPlanType) {
      res["escalationPlanType"] = boost::any(*escalationPlanType);
    }
    if (noticeChannels) {
      res["noticeChannels"] = boost::any(*noticeChannels);
    }
    if (noticeObjectList) {
      vector<boost::any> temp1;
      for(auto item1:*noticeObjectList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["noticeObjectList"] = boost::any(temp1);
    }
    if (noticeTime) {
      res["noticeTime"] = boost::any(*noticeTime);
    }
    if (serviceGroupList) {
      vector<boost::any> temp1;
      for(auto item1:*serviceGroupList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["serviceGroupList"] = boost::any(temp1);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("escalationPlanType") != m.end() && !m["escalationPlanType"].empty()) {
      escalationPlanType = make_shared<string>(boost::any_cast<string>(m["escalationPlanType"]));
    }
    if (m.find("noticeChannels") != m.end() && !m["noticeChannels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["noticeChannels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["noticeChannels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      noticeChannels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("noticeObjectList") != m.end() && !m["noticeObjectList"].empty()) {
      if (typeid(vector<boost::any>) == m["noticeObjectList"].type()) {
        vector<ListIncidentDetailEscalationPlansResponseBodyDataNuAcknowledgeEscalationPlanNoticeObjectList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["noticeObjectList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIncidentDetailEscalationPlansResponseBodyDataNuAcknowledgeEscalationPlanNoticeObjectList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        noticeObjectList = make_shared<vector<ListIncidentDetailEscalationPlansResponseBodyDataNuAcknowledgeEscalationPlanNoticeObjectList>>(expect1);
      }
    }
    if (m.find("noticeTime") != m.end() && !m["noticeTime"].empty()) {
      noticeTime = make_shared<long>(boost::any_cast<long>(m["noticeTime"]));
    }
    if (m.find("serviceGroupList") != m.end() && !m["serviceGroupList"].empty()) {
      if (typeid(vector<boost::any>) == m["serviceGroupList"].type()) {
        vector<ListIncidentDetailEscalationPlansResponseBodyDataNuAcknowledgeEscalationPlanServiceGroupList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["serviceGroupList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIncidentDetailEscalationPlansResponseBodyDataNuAcknowledgeEscalationPlanServiceGroupList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceGroupList = make_shared<vector<ListIncidentDetailEscalationPlansResponseBodyDataNuAcknowledgeEscalationPlanServiceGroupList>>(expect1);
      }
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~ListIncidentDetailEscalationPlansResponseBodyDataNuAcknowledgeEscalationPlan() = default;
};
class ListIncidentDetailEscalationPlansResponseBodyDataUnFinishEscalationPlanNoticeObjectList : public Darabonba::Model {
public:
  shared_ptr<long> noticeObjectId{};
  shared_ptr<string> noticeObjectName{};
  shared_ptr<string> noticeObjectPhone{};

  ListIncidentDetailEscalationPlansResponseBodyDataUnFinishEscalationPlanNoticeObjectList() {}

  explicit ListIncidentDetailEscalationPlansResponseBodyDataUnFinishEscalationPlanNoticeObjectList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (noticeObjectId) {
      res["noticeObjectId"] = boost::any(*noticeObjectId);
    }
    if (noticeObjectName) {
      res["noticeObjectName"] = boost::any(*noticeObjectName);
    }
    if (noticeObjectPhone) {
      res["noticeObjectPhone"] = boost::any(*noticeObjectPhone);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("noticeObjectId") != m.end() && !m["noticeObjectId"].empty()) {
      noticeObjectId = make_shared<long>(boost::any_cast<long>(m["noticeObjectId"]));
    }
    if (m.find("noticeObjectName") != m.end() && !m["noticeObjectName"].empty()) {
      noticeObjectName = make_shared<string>(boost::any_cast<string>(m["noticeObjectName"]));
    }
    if (m.find("noticeObjectPhone") != m.end() && !m["noticeObjectPhone"].empty()) {
      noticeObjectPhone = make_shared<string>(boost::any_cast<string>(m["noticeObjectPhone"]));
    }
  }


  virtual ~ListIncidentDetailEscalationPlansResponseBodyDataUnFinishEscalationPlanNoticeObjectList() = default;
};
class ListIncidentDetailEscalationPlansResponseBodyDataUnFinishEscalationPlanServiceGroupList : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> name{};

  ListIncidentDetailEscalationPlansResponseBodyDataUnFinishEscalationPlanServiceGroupList() {}

  explicit ListIncidentDetailEscalationPlansResponseBodyDataUnFinishEscalationPlanServiceGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~ListIncidentDetailEscalationPlansResponseBodyDataUnFinishEscalationPlanServiceGroupList() = default;
};
class ListIncidentDetailEscalationPlansResponseBodyDataUnFinishEscalationPlan : public Darabonba::Model {
public:
  shared_ptr<string> escalationPlanType{};
  shared_ptr<vector<string>> noticeChannels{};
  shared_ptr<vector<ListIncidentDetailEscalationPlansResponseBodyDataUnFinishEscalationPlanNoticeObjectList>> noticeObjectList{};
  shared_ptr<long> noticeTime{};
  shared_ptr<vector<ListIncidentDetailEscalationPlansResponseBodyDataUnFinishEscalationPlanServiceGroupList>> serviceGroupList{};
  shared_ptr<long> startTime{};
  shared_ptr<string> status{};

  ListIncidentDetailEscalationPlansResponseBodyDataUnFinishEscalationPlan() {}

  explicit ListIncidentDetailEscalationPlansResponseBodyDataUnFinishEscalationPlan(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalationPlanType) {
      res["escalationPlanType"] = boost::any(*escalationPlanType);
    }
    if (noticeChannels) {
      res["noticeChannels"] = boost::any(*noticeChannels);
    }
    if (noticeObjectList) {
      vector<boost::any> temp1;
      for(auto item1:*noticeObjectList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["noticeObjectList"] = boost::any(temp1);
    }
    if (noticeTime) {
      res["noticeTime"] = boost::any(*noticeTime);
    }
    if (serviceGroupList) {
      vector<boost::any> temp1;
      for(auto item1:*serviceGroupList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["serviceGroupList"] = boost::any(temp1);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("escalationPlanType") != m.end() && !m["escalationPlanType"].empty()) {
      escalationPlanType = make_shared<string>(boost::any_cast<string>(m["escalationPlanType"]));
    }
    if (m.find("noticeChannels") != m.end() && !m["noticeChannels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["noticeChannels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["noticeChannels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      noticeChannels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("noticeObjectList") != m.end() && !m["noticeObjectList"].empty()) {
      if (typeid(vector<boost::any>) == m["noticeObjectList"].type()) {
        vector<ListIncidentDetailEscalationPlansResponseBodyDataUnFinishEscalationPlanNoticeObjectList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["noticeObjectList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIncidentDetailEscalationPlansResponseBodyDataUnFinishEscalationPlanNoticeObjectList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        noticeObjectList = make_shared<vector<ListIncidentDetailEscalationPlansResponseBodyDataUnFinishEscalationPlanNoticeObjectList>>(expect1);
      }
    }
    if (m.find("noticeTime") != m.end() && !m["noticeTime"].empty()) {
      noticeTime = make_shared<long>(boost::any_cast<long>(m["noticeTime"]));
    }
    if (m.find("serviceGroupList") != m.end() && !m["serviceGroupList"].empty()) {
      if (typeid(vector<boost::any>) == m["serviceGroupList"].type()) {
        vector<ListIncidentDetailEscalationPlansResponseBodyDataUnFinishEscalationPlanServiceGroupList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["serviceGroupList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIncidentDetailEscalationPlansResponseBodyDataUnFinishEscalationPlanServiceGroupList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceGroupList = make_shared<vector<ListIncidentDetailEscalationPlansResponseBodyDataUnFinishEscalationPlanServiceGroupList>>(expect1);
      }
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~ListIncidentDetailEscalationPlansResponseBodyDataUnFinishEscalationPlan() = default;
};
class ListIncidentDetailEscalationPlansResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListIncidentDetailEscalationPlansResponseBodyDataConvergenceEscalationPlan>> convergenceEscalationPlan{};
  shared_ptr<long> escalationPlanId{};
  shared_ptr<string> escalationPlanName{};
  shared_ptr<vector<ListIncidentDetailEscalationPlansResponseBodyDataNuAcknowledgeEscalationPlan>> nuAcknowledgeEscalationPlan{};
  shared_ptr<vector<ListIncidentDetailEscalationPlansResponseBodyDataUnFinishEscalationPlan>> unFinishEscalationPlan{};

  ListIncidentDetailEscalationPlansResponseBodyData() {}

  explicit ListIncidentDetailEscalationPlansResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (convergenceEscalationPlan) {
      vector<boost::any> temp1;
      for(auto item1:*convergenceEscalationPlan){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["convergenceEscalationPlan"] = boost::any(temp1);
    }
    if (escalationPlanId) {
      res["escalationPlanId"] = boost::any(*escalationPlanId);
    }
    if (escalationPlanName) {
      res["escalationPlanName"] = boost::any(*escalationPlanName);
    }
    if (nuAcknowledgeEscalationPlan) {
      vector<boost::any> temp1;
      for(auto item1:*nuAcknowledgeEscalationPlan){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["nuAcknowledgeEscalationPlan"] = boost::any(temp1);
    }
    if (unFinishEscalationPlan) {
      vector<boost::any> temp1;
      for(auto item1:*unFinishEscalationPlan){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["unFinishEscalationPlan"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("convergenceEscalationPlan") != m.end() && !m["convergenceEscalationPlan"].empty()) {
      if (typeid(vector<boost::any>) == m["convergenceEscalationPlan"].type()) {
        vector<ListIncidentDetailEscalationPlansResponseBodyDataConvergenceEscalationPlan> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["convergenceEscalationPlan"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIncidentDetailEscalationPlansResponseBodyDataConvergenceEscalationPlan model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        convergenceEscalationPlan = make_shared<vector<ListIncidentDetailEscalationPlansResponseBodyDataConvergenceEscalationPlan>>(expect1);
      }
    }
    if (m.find("escalationPlanId") != m.end() && !m["escalationPlanId"].empty()) {
      escalationPlanId = make_shared<long>(boost::any_cast<long>(m["escalationPlanId"]));
    }
    if (m.find("escalationPlanName") != m.end() && !m["escalationPlanName"].empty()) {
      escalationPlanName = make_shared<string>(boost::any_cast<string>(m["escalationPlanName"]));
    }
    if (m.find("nuAcknowledgeEscalationPlan") != m.end() && !m["nuAcknowledgeEscalationPlan"].empty()) {
      if (typeid(vector<boost::any>) == m["nuAcknowledgeEscalationPlan"].type()) {
        vector<ListIncidentDetailEscalationPlansResponseBodyDataNuAcknowledgeEscalationPlan> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["nuAcknowledgeEscalationPlan"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIncidentDetailEscalationPlansResponseBodyDataNuAcknowledgeEscalationPlan model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nuAcknowledgeEscalationPlan = make_shared<vector<ListIncidentDetailEscalationPlansResponseBodyDataNuAcknowledgeEscalationPlan>>(expect1);
      }
    }
    if (m.find("unFinishEscalationPlan") != m.end() && !m["unFinishEscalationPlan"].empty()) {
      if (typeid(vector<boost::any>) == m["unFinishEscalationPlan"].type()) {
        vector<ListIncidentDetailEscalationPlansResponseBodyDataUnFinishEscalationPlan> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["unFinishEscalationPlan"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIncidentDetailEscalationPlansResponseBodyDataUnFinishEscalationPlan model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        unFinishEscalationPlan = make_shared<vector<ListIncidentDetailEscalationPlansResponseBodyDataUnFinishEscalationPlan>>(expect1);
      }
    }
  }


  virtual ~ListIncidentDetailEscalationPlansResponseBodyData() = default;
};
class ListIncidentDetailEscalationPlansResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListIncidentDetailEscalationPlansResponseBodyData> data{};
  shared_ptr<string> requestId{};

  ListIncidentDetailEscalationPlansResponseBody() {}

  explicit ListIncidentDetailEscalationPlansResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        ListIncidentDetailEscalationPlansResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<ListIncidentDetailEscalationPlansResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListIncidentDetailEscalationPlansResponseBody() = default;
};
class ListIncidentDetailEscalationPlansResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIncidentDetailEscalationPlansResponseBody> body{};

  ListIncidentDetailEscalationPlansResponse() {}

  explicit ListIncidentDetailEscalationPlansResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIncidentDetailEscalationPlansResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIncidentDetailEscalationPlansResponseBody>(model1);
      }
    }
  }


  virtual ~ListIncidentDetailEscalationPlansResponse() = default;
};
class ListIncidentDetailTimelinesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> idSort{};
  shared_ptr<long> incidentId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListIncidentDetailTimelinesRequest() {}

  explicit ListIncidentDetailTimelinesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (idSort) {
      res["idSort"] = boost::any(*idSort);
    }
    if (incidentId) {
      res["incidentId"] = boost::any(*incidentId);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("idSort") != m.end() && !m["idSort"].empty()) {
      idSort = make_shared<string>(boost::any_cast<string>(m["idSort"]));
    }
    if (m.find("incidentId") != m.end() && !m["incidentId"].empty()) {
      incidentId = make_shared<long>(boost::any_cast<long>(m["incidentId"]));
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
  }


  virtual ~ListIncidentDetailTimelinesRequest() = default;
};
class ListIncidentDetailTimelinesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<long> incidentId{};
  shared_ptr<long> relRouteRuleDeleteType{};
  shared_ptr<string> relatedServiceName{};
  shared_ptr<string> remark{};
  shared_ptr<string> snapshotData{};
  shared_ptr<string> title{};

  ListIncidentDetailTimelinesResponseBodyData() {}

  explicit ListIncidentDetailTimelinesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["action"] = boost::any(*action);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (incidentId) {
      res["incidentId"] = boost::any(*incidentId);
    }
    if (relRouteRuleDeleteType) {
      res["relRouteRuleDeleteType"] = boost::any(*relRouteRuleDeleteType);
    }
    if (relatedServiceName) {
      res["relatedServiceName"] = boost::any(*relatedServiceName);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (snapshotData) {
      res["snapshotData"] = boost::any(*snapshotData);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("action") != m.end() && !m["action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["action"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("incidentId") != m.end() && !m["incidentId"].empty()) {
      incidentId = make_shared<long>(boost::any_cast<long>(m["incidentId"]));
    }
    if (m.find("relRouteRuleDeleteType") != m.end() && !m["relRouteRuleDeleteType"].empty()) {
      relRouteRuleDeleteType = make_shared<long>(boost::any_cast<long>(m["relRouteRuleDeleteType"]));
    }
    if (m.find("relatedServiceName") != m.end() && !m["relatedServiceName"].empty()) {
      relatedServiceName = make_shared<string>(boost::any_cast<string>(m["relatedServiceName"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("snapshotData") != m.end() && !m["snapshotData"].empty()) {
      snapshotData = make_shared<string>(boost::any_cast<string>(m["snapshotData"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~ListIncidentDetailTimelinesResponseBodyData() = default;
};
class ListIncidentDetailTimelinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListIncidentDetailTimelinesResponseBodyData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListIncidentDetailTimelinesResponseBody() {}

  explicit ListIncidentDetailTimelinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListIncidentDetailTimelinesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIncidentDetailTimelinesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListIncidentDetailTimelinesResponseBodyData>>(expect1);
      }
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ListIncidentDetailTimelinesResponseBody() = default;
};
class ListIncidentDetailTimelinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIncidentDetailTimelinesResponseBody> body{};

  ListIncidentDetailTimelinesResponse() {}

  explicit ListIncidentDetailTimelinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIncidentDetailTimelinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIncidentDetailTimelinesResponseBody>(model1);
      }
    }
  }


  virtual ~ListIncidentDetailTimelinesResponse() = default;
};
class ListIncidentSubtotalsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> incidentId{};

  ListIncidentSubtotalsRequest() {}

  explicit ListIncidentSubtotalsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (incidentId) {
      res["incidentId"] = boost::any(*incidentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("incidentId") != m.end() && !m["incidentId"].empty()) {
      incidentId = make_shared<long>(boost::any_cast<long>(m["incidentId"]));
    }
  }


  virtual ~ListIncidentSubtotalsRequest() = default;
};
class ListIncidentSubtotalsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> createUserId{};
  shared_ptr<string> createUserName{};
  shared_ptr<string> createUserPhone{};
  shared_ptr<string> description{};

  ListIncidentSubtotalsResponseBodyData() {}

  explicit ListIncidentSubtotalsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (createUserId) {
      res["createUserId"] = boost::any(*createUserId);
    }
    if (createUserName) {
      res["createUserName"] = boost::any(*createUserName);
    }
    if (createUserPhone) {
      res["createUserPhone"] = boost::any(*createUserPhone);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("createUserId") != m.end() && !m["createUserId"].empty()) {
      createUserId = make_shared<long>(boost::any_cast<long>(m["createUserId"]));
    }
    if (m.find("createUserName") != m.end() && !m["createUserName"].empty()) {
      createUserName = make_shared<string>(boost::any_cast<string>(m["createUserName"]));
    }
    if (m.find("createUserPhone") != m.end() && !m["createUserPhone"].empty()) {
      createUserPhone = make_shared<string>(boost::any_cast<string>(m["createUserPhone"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
  }


  virtual ~ListIncidentSubtotalsResponseBodyData() = default;
};
class ListIncidentSubtotalsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListIncidentSubtotalsResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  ListIncidentSubtotalsResponseBody() {}

  explicit ListIncidentSubtotalsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListIncidentSubtotalsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIncidentSubtotalsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListIncidentSubtotalsResponseBodyData>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListIncidentSubtotalsResponseBody() = default;
};
class ListIncidentSubtotalsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIncidentSubtotalsResponseBody> body{};

  ListIncidentSubtotalsResponse() {}

  explicit ListIncidentSubtotalsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIncidentSubtotalsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIncidentSubtotalsResponseBody>(model1);
      }
    }
  }


  virtual ~ListIncidentSubtotalsResponse() = default;
};
class ListIncidentTimelinesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListIncidentTimelinesRequest() {}

  explicit ListIncidentTimelinesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
  }


  virtual ~ListIncidentTimelinesRequest() = default;
};
class ListIncidentTimelinesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> createTime{};
  shared_ptr<long> description{};
  shared_ptr<long> incidentId{};
  shared_ptr<string> incidentNumber{};
  shared_ptr<string> incidentTitle{};
  shared_ptr<long> relRouteRuleDeleteType{};
  shared_ptr<string> relatedServiceName{};
  shared_ptr<string> remark{};
  shared_ptr<string> snapshotData{};
  shared_ptr<string> title{};

  ListIncidentTimelinesResponseBodyData() {}

  explicit ListIncidentTimelinesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["action"] = boost::any(*action);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (incidentId) {
      res["incidentId"] = boost::any(*incidentId);
    }
    if (incidentNumber) {
      res["incidentNumber"] = boost::any(*incidentNumber);
    }
    if (incidentTitle) {
      res["incidentTitle"] = boost::any(*incidentTitle);
    }
    if (relRouteRuleDeleteType) {
      res["relRouteRuleDeleteType"] = boost::any(*relRouteRuleDeleteType);
    }
    if (relatedServiceName) {
      res["relatedServiceName"] = boost::any(*relatedServiceName);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (snapshotData) {
      res["snapshotData"] = boost::any(*snapshotData);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("action") != m.end() && !m["action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["action"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<long>(boost::any_cast<long>(m["description"]));
    }
    if (m.find("incidentId") != m.end() && !m["incidentId"].empty()) {
      incidentId = make_shared<long>(boost::any_cast<long>(m["incidentId"]));
    }
    if (m.find("incidentNumber") != m.end() && !m["incidentNumber"].empty()) {
      incidentNumber = make_shared<string>(boost::any_cast<string>(m["incidentNumber"]));
    }
    if (m.find("incidentTitle") != m.end() && !m["incidentTitle"].empty()) {
      incidentTitle = make_shared<string>(boost::any_cast<string>(m["incidentTitle"]));
    }
    if (m.find("relRouteRuleDeleteType") != m.end() && !m["relRouteRuleDeleteType"].empty()) {
      relRouteRuleDeleteType = make_shared<long>(boost::any_cast<long>(m["relRouteRuleDeleteType"]));
    }
    if (m.find("relatedServiceName") != m.end() && !m["relatedServiceName"].empty()) {
      relatedServiceName = make_shared<string>(boost::any_cast<string>(m["relatedServiceName"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("snapshotData") != m.end() && !m["snapshotData"].empty()) {
      snapshotData = make_shared<string>(boost::any_cast<string>(m["snapshotData"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~ListIncidentTimelinesResponseBodyData() = default;
};
class ListIncidentTimelinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListIncidentTimelinesResponseBodyData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListIncidentTimelinesResponseBody() {}

  explicit ListIncidentTimelinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListIncidentTimelinesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIncidentTimelinesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListIncidentTimelinesResponseBodyData>>(expect1);
      }
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ListIncidentTimelinesResponseBody() = default;
};
class ListIncidentTimelinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIncidentTimelinesResponseBody> body{};

  ListIncidentTimelinesResponse() {}

  explicit ListIncidentTimelinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIncidentTimelinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIncidentTimelinesResponseBody>(model1);
      }
    }
  }


  virtual ~ListIncidentTimelinesResponse() = default;
};
class ListIncidentsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> createEndTime{};
  shared_ptr<string> createStartTime{};
  shared_ptr<string> effect{};
  shared_ptr<string> incidentLevel{};
  shared_ptr<string> incidentStatus{};
  shared_ptr<long> me{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> relationServiceId{};
  shared_ptr<string> ruleName{};

  ListIncidentsRequest() {}

  explicit ListIncidentsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (createEndTime) {
      res["createEndTime"] = boost::any(*createEndTime);
    }
    if (createStartTime) {
      res["createStartTime"] = boost::any(*createStartTime);
    }
    if (effect) {
      res["effect"] = boost::any(*effect);
    }
    if (incidentLevel) {
      res["incidentLevel"] = boost::any(*incidentLevel);
    }
    if (incidentStatus) {
      res["incidentStatus"] = boost::any(*incidentStatus);
    }
    if (me) {
      res["me"] = boost::any(*me);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (relationServiceId) {
      res["relationServiceId"] = boost::any(*relationServiceId);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("createEndTime") != m.end() && !m["createEndTime"].empty()) {
      createEndTime = make_shared<string>(boost::any_cast<string>(m["createEndTime"]));
    }
    if (m.find("createStartTime") != m.end() && !m["createStartTime"].empty()) {
      createStartTime = make_shared<string>(boost::any_cast<string>(m["createStartTime"]));
    }
    if (m.find("effect") != m.end() && !m["effect"].empty()) {
      effect = make_shared<string>(boost::any_cast<string>(m["effect"]));
    }
    if (m.find("incidentLevel") != m.end() && !m["incidentLevel"].empty()) {
      incidentLevel = make_shared<string>(boost::any_cast<string>(m["incidentLevel"]));
    }
    if (m.find("incidentStatus") != m.end() && !m["incidentStatus"].empty()) {
      incidentStatus = make_shared<string>(boost::any_cast<string>(m["incidentStatus"]));
    }
    if (m.find("me") != m.end() && !m["me"].empty()) {
      me = make_shared<long>(boost::any_cast<long>(m["me"]));
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("relationServiceId") != m.end() && !m["relationServiceId"].empty()) {
      relationServiceId = make_shared<long>(boost::any_cast<long>(m["relationServiceId"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
  }


  virtual ~ListIncidentsRequest() = default;
};
class ListIncidentsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> assignToWhoIsValid{};
  shared_ptr<long> assignUserId{};
  shared_ptr<string> assignUserName{};
  shared_ptr<string> assignUserPhone{};
  shared_ptr<string> createTime{};
  shared_ptr<string> effect{};
  shared_ptr<long> incidentId{};
  shared_ptr<string> incidentLevel{};
  shared_ptr<string> incidentNumber{};
  shared_ptr<string> incidentStatus{};
  shared_ptr<string> incidentTitle{};
  shared_ptr<bool> isManual{};
  shared_ptr<long> relRouteRuleDeleteType{};
  shared_ptr<long> relServiceDeleteType{};
  shared_ptr<long> relatedServiceId{};
  shared_ptr<string> relatedServiceName{};
  shared_ptr<long> routeRuleId{};
  shared_ptr<string> routeRuleName{};

  ListIncidentsResponseBodyData() {}

  explicit ListIncidentsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignToWhoIsValid) {
      res["assignToWhoIsValid"] = boost::any(*assignToWhoIsValid);
    }
    if (assignUserId) {
      res["assignUserId"] = boost::any(*assignUserId);
    }
    if (assignUserName) {
      res["assignUserName"] = boost::any(*assignUserName);
    }
    if (assignUserPhone) {
      res["assignUserPhone"] = boost::any(*assignUserPhone);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (effect) {
      res["effect"] = boost::any(*effect);
    }
    if (incidentId) {
      res["incidentId"] = boost::any(*incidentId);
    }
    if (incidentLevel) {
      res["incidentLevel"] = boost::any(*incidentLevel);
    }
    if (incidentNumber) {
      res["incidentNumber"] = boost::any(*incidentNumber);
    }
    if (incidentStatus) {
      res["incidentStatus"] = boost::any(*incidentStatus);
    }
    if (incidentTitle) {
      res["incidentTitle"] = boost::any(*incidentTitle);
    }
    if (isManual) {
      res["isManual"] = boost::any(*isManual);
    }
    if (relRouteRuleDeleteType) {
      res["relRouteRuleDeleteType"] = boost::any(*relRouteRuleDeleteType);
    }
    if (relServiceDeleteType) {
      res["relServiceDeleteType"] = boost::any(*relServiceDeleteType);
    }
    if (relatedServiceId) {
      res["relatedServiceId"] = boost::any(*relatedServiceId);
    }
    if (relatedServiceName) {
      res["relatedServiceName"] = boost::any(*relatedServiceName);
    }
    if (routeRuleId) {
      res["routeRuleId"] = boost::any(*routeRuleId);
    }
    if (routeRuleName) {
      res["routeRuleName"] = boost::any(*routeRuleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignToWhoIsValid") != m.end() && !m["assignToWhoIsValid"].empty()) {
      assignToWhoIsValid = make_shared<long>(boost::any_cast<long>(m["assignToWhoIsValid"]));
    }
    if (m.find("assignUserId") != m.end() && !m["assignUserId"].empty()) {
      assignUserId = make_shared<long>(boost::any_cast<long>(m["assignUserId"]));
    }
    if (m.find("assignUserName") != m.end() && !m["assignUserName"].empty()) {
      assignUserName = make_shared<string>(boost::any_cast<string>(m["assignUserName"]));
    }
    if (m.find("assignUserPhone") != m.end() && !m["assignUserPhone"].empty()) {
      assignUserPhone = make_shared<string>(boost::any_cast<string>(m["assignUserPhone"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("effect") != m.end() && !m["effect"].empty()) {
      effect = make_shared<string>(boost::any_cast<string>(m["effect"]));
    }
    if (m.find("incidentId") != m.end() && !m["incidentId"].empty()) {
      incidentId = make_shared<long>(boost::any_cast<long>(m["incidentId"]));
    }
    if (m.find("incidentLevel") != m.end() && !m["incidentLevel"].empty()) {
      incidentLevel = make_shared<string>(boost::any_cast<string>(m["incidentLevel"]));
    }
    if (m.find("incidentNumber") != m.end() && !m["incidentNumber"].empty()) {
      incidentNumber = make_shared<string>(boost::any_cast<string>(m["incidentNumber"]));
    }
    if (m.find("incidentStatus") != m.end() && !m["incidentStatus"].empty()) {
      incidentStatus = make_shared<string>(boost::any_cast<string>(m["incidentStatus"]));
    }
    if (m.find("incidentTitle") != m.end() && !m["incidentTitle"].empty()) {
      incidentTitle = make_shared<string>(boost::any_cast<string>(m["incidentTitle"]));
    }
    if (m.find("isManual") != m.end() && !m["isManual"].empty()) {
      isManual = make_shared<bool>(boost::any_cast<bool>(m["isManual"]));
    }
    if (m.find("relRouteRuleDeleteType") != m.end() && !m["relRouteRuleDeleteType"].empty()) {
      relRouteRuleDeleteType = make_shared<long>(boost::any_cast<long>(m["relRouteRuleDeleteType"]));
    }
    if (m.find("relServiceDeleteType") != m.end() && !m["relServiceDeleteType"].empty()) {
      relServiceDeleteType = make_shared<long>(boost::any_cast<long>(m["relServiceDeleteType"]));
    }
    if (m.find("relatedServiceId") != m.end() && !m["relatedServiceId"].empty()) {
      relatedServiceId = make_shared<long>(boost::any_cast<long>(m["relatedServiceId"]));
    }
    if (m.find("relatedServiceName") != m.end() && !m["relatedServiceName"].empty()) {
      relatedServiceName = make_shared<string>(boost::any_cast<string>(m["relatedServiceName"]));
    }
    if (m.find("routeRuleId") != m.end() && !m["routeRuleId"].empty()) {
      routeRuleId = make_shared<long>(boost::any_cast<long>(m["routeRuleId"]));
    }
    if (m.find("routeRuleName") != m.end() && !m["routeRuleName"].empty()) {
      routeRuleName = make_shared<string>(boost::any_cast<string>(m["routeRuleName"]));
    }
  }


  virtual ~ListIncidentsResponseBodyData() = default;
};
class ListIncidentsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListIncidentsResponseBodyData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListIncidentsResponseBody() {}

  explicit ListIncidentsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListIncidentsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIncidentsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListIncidentsResponseBodyData>>(expect1);
      }
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ListIncidentsResponseBody() = default;
};
class ListIncidentsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIncidentsResponseBody> body{};

  ListIncidentsResponse() {}

  explicit ListIncidentsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIncidentsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIncidentsResponseBody>(model1);
      }
    }
  }


  virtual ~ListIncidentsResponse() = default;
};
class ListIntegrationConfigTimelinesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> integrationConfigId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListIntegrationConfigTimelinesRequest() {}

  explicit ListIntegrationConfigTimelinesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (integrationConfigId) {
      res["integrationConfigId"] = boost::any(*integrationConfigId);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("integrationConfigId") != m.end() && !m["integrationConfigId"].empty()) {
      integrationConfigId = make_shared<long>(boost::any_cast<long>(m["integrationConfigId"]));
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
  }


  virtual ~ListIntegrationConfigTimelinesRequest() = default;
};
class ListIntegrationConfigTimelinesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> title{};

  ListIntegrationConfigTimelinesResponseBodyData() {}

  explicit ListIntegrationConfigTimelinesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~ListIntegrationConfigTimelinesResponseBodyData() = default;
};
class ListIntegrationConfigTimelinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListIntegrationConfigTimelinesResponseBodyData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListIntegrationConfigTimelinesResponseBody() {}

  explicit ListIntegrationConfigTimelinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListIntegrationConfigTimelinesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIntegrationConfigTimelinesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListIntegrationConfigTimelinesResponseBodyData>>(expect1);
      }
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ListIntegrationConfigTimelinesResponseBody() = default;
};
class ListIntegrationConfigTimelinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIntegrationConfigTimelinesResponseBody> body{};

  ListIntegrationConfigTimelinesResponse() {}

  explicit ListIntegrationConfigTimelinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIntegrationConfigTimelinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIntegrationConfigTimelinesResponseBody>(model1);
      }
    }
  }


  virtual ~ListIntegrationConfigTimelinesResponse() = default;
};
class ListIntegrationConfigsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> monitorSourceName{};

  ListIntegrationConfigsRequest() {}

  explicit ListIntegrationConfigsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (monitorSourceName) {
      res["monitorSourceName"] = boost::any(*monitorSourceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("monitorSourceName") != m.end() && !m["monitorSourceName"].empty()) {
      monitorSourceName = make_shared<string>(boost::any_cast<string>(m["monitorSourceName"]));
    }
  }


  virtual ~ListIntegrationConfigsRequest() = default;
};
class ListIntegrationConfigsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> integrationConfigId{};
  shared_ptr<bool> isReceivedEvent{};
  shared_ptr<long> monitorSourceId{};
  shared_ptr<string> monitorSourceName{};
  shared_ptr<string> monitorSourceShortName{};
  shared_ptr<string> status{};

  ListIntegrationConfigsResponseBodyData() {}

  explicit ListIntegrationConfigsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (integrationConfigId) {
      res["integrationConfigId"] = boost::any(*integrationConfigId);
    }
    if (isReceivedEvent) {
      res["isReceivedEvent"] = boost::any(*isReceivedEvent);
    }
    if (monitorSourceId) {
      res["monitorSourceId"] = boost::any(*monitorSourceId);
    }
    if (monitorSourceName) {
      res["monitorSourceName"] = boost::any(*monitorSourceName);
    }
    if (monitorSourceShortName) {
      res["monitorSourceShortName"] = boost::any(*monitorSourceShortName);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("integrationConfigId") != m.end() && !m["integrationConfigId"].empty()) {
      integrationConfigId = make_shared<long>(boost::any_cast<long>(m["integrationConfigId"]));
    }
    if (m.find("isReceivedEvent") != m.end() && !m["isReceivedEvent"].empty()) {
      isReceivedEvent = make_shared<bool>(boost::any_cast<bool>(m["isReceivedEvent"]));
    }
    if (m.find("monitorSourceId") != m.end() && !m["monitorSourceId"].empty()) {
      monitorSourceId = make_shared<long>(boost::any_cast<long>(m["monitorSourceId"]));
    }
    if (m.find("monitorSourceName") != m.end() && !m["monitorSourceName"].empty()) {
      monitorSourceName = make_shared<string>(boost::any_cast<string>(m["monitorSourceName"]));
    }
    if (m.find("monitorSourceShortName") != m.end() && !m["monitorSourceShortName"].empty()) {
      monitorSourceShortName = make_shared<string>(boost::any_cast<string>(m["monitorSourceShortName"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~ListIntegrationConfigsResponseBodyData() = default;
};
class ListIntegrationConfigsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListIntegrationConfigsResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  ListIntegrationConfigsResponseBody() {}

  explicit ListIntegrationConfigsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListIntegrationConfigsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIntegrationConfigsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListIntegrationConfigsResponseBodyData>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListIntegrationConfigsResponseBody() = default;
};
class ListIntegrationConfigsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIntegrationConfigsResponseBody> body{};

  ListIntegrationConfigsResponse() {}

  explicit ListIntegrationConfigsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIntegrationConfigsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIntegrationConfigsResponseBody>(model1);
      }
    }
  }


  virtual ~ListIntegrationConfigsResponse() = default;
};
class ListMonitorSourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};

  ListMonitorSourcesRequest() {}

  explicit ListMonitorSourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~ListMonitorSourcesRequest() = default;
};
class ListMonitorSourcesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fieldKeys{};
  shared_ptr<long> monitorSourceId{};
  shared_ptr<string> monitorSourceName{};

  ListMonitorSourcesResponseBodyData() {}

  explicit ListMonitorSourcesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fieldKeys) {
      res["fieldKeys"] = boost::any(*fieldKeys);
    }
    if (monitorSourceId) {
      res["monitorSourceId"] = boost::any(*monitorSourceId);
    }
    if (monitorSourceName) {
      res["monitorSourceName"] = boost::any(*monitorSourceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fieldKeys") != m.end() && !m["fieldKeys"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["fieldKeys"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["fieldKeys"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fieldKeys = make_shared<vector<string>>(toVec1);
    }
    if (m.find("monitorSourceId") != m.end() && !m["monitorSourceId"].empty()) {
      monitorSourceId = make_shared<long>(boost::any_cast<long>(m["monitorSourceId"]));
    }
    if (m.find("monitorSourceName") != m.end() && !m["monitorSourceName"].empty()) {
      monitorSourceName = make_shared<string>(boost::any_cast<string>(m["monitorSourceName"]));
    }
  }


  virtual ~ListMonitorSourcesResponseBodyData() = default;
};
class ListMonitorSourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListMonitorSourcesResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  ListMonitorSourcesResponseBody() {}

  explicit ListMonitorSourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListMonitorSourcesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListMonitorSourcesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListMonitorSourcesResponseBodyData>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListMonitorSourcesResponseBody() = default;
};
class ListMonitorSourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListMonitorSourcesResponseBody> body{};

  ListMonitorSourcesResponse() {}

  explicit ListMonitorSourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListMonitorSourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListMonitorSourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListMonitorSourcesResponse() = default;
};
class ListProblemDetailOperationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> createTimeSort{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> problemId{};

  ListProblemDetailOperationsRequest() {}

  explicit ListProblemDetailOperationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (createTimeSort) {
      res["createTimeSort"] = boost::any(*createTimeSort);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("createTimeSort") != m.end() && !m["createTimeSort"].empty()) {
      createTimeSort = make_shared<string>(boost::any_cast<string>(m["createTimeSort"]));
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
  }


  virtual ~ListProblemDetailOperationsRequest() = default;
};
class ListProblemDetailOperationsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> relatedServiceName{};
  shared_ptr<string> remark{};
  shared_ptr<string> snapshotData{};
  shared_ptr<string> title{};

  ListProblemDetailOperationsResponseBodyData() {}

  explicit ListProblemDetailOperationsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["action"] = boost::any(*action);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (relatedServiceName) {
      res["relatedServiceName"] = boost::any(*relatedServiceName);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (snapshotData) {
      res["snapshotData"] = boost::any(*snapshotData);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("action") != m.end() && !m["action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["action"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("relatedServiceName") != m.end() && !m["relatedServiceName"].empty()) {
      relatedServiceName = make_shared<string>(boost::any_cast<string>(m["relatedServiceName"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("snapshotData") != m.end() && !m["snapshotData"].empty()) {
      snapshotData = make_shared<string>(boost::any_cast<string>(m["snapshotData"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~ListProblemDetailOperationsResponseBodyData() = default;
};
class ListProblemDetailOperationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListProblemDetailOperationsResponseBodyData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListProblemDetailOperationsResponseBody() {}

  explicit ListProblemDetailOperationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListProblemDetailOperationsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProblemDetailOperationsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListProblemDetailOperationsResponseBodyData>>(expect1);
      }
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ListProblemDetailOperationsResponseBody() = default;
};
class ListProblemDetailOperationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListProblemDetailOperationsResponseBody> body{};

  ListProblemDetailOperationsResponse() {}

  explicit ListProblemDetailOperationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProblemDetailOperationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProblemDetailOperationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListProblemDetailOperationsResponse() = default;
};
class ListProblemOperationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  ListProblemOperationsRequest() {}

  explicit ListProblemOperationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
  }


  virtual ~ListProblemOperationsRequest() = default;
};
class ListProblemOperationsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<long> problemId{};
  shared_ptr<string> problemName{};
  shared_ptr<string> problemNumber{};
  shared_ptr<string> relatedServiceName{};
  shared_ptr<string> snapshotData{};
  shared_ptr<string> title{};

  ListProblemOperationsResponseBodyData() {}

  explicit ListProblemOperationsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["action"] = boost::any(*action);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    if (problemName) {
      res["problemName"] = boost::any(*problemName);
    }
    if (problemNumber) {
      res["problemNumber"] = boost::any(*problemNumber);
    }
    if (relatedServiceName) {
      res["relatedServiceName"] = boost::any(*relatedServiceName);
    }
    if (snapshotData) {
      res["snapshotData"] = boost::any(*snapshotData);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("action") != m.end() && !m["action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["action"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
    if (m.find("problemName") != m.end() && !m["problemName"].empty()) {
      problemName = make_shared<string>(boost::any_cast<string>(m["problemName"]));
    }
    if (m.find("problemNumber") != m.end() && !m["problemNumber"].empty()) {
      problemNumber = make_shared<string>(boost::any_cast<string>(m["problemNumber"]));
    }
    if (m.find("relatedServiceName") != m.end() && !m["relatedServiceName"].empty()) {
      relatedServiceName = make_shared<string>(boost::any_cast<string>(m["relatedServiceName"]));
    }
    if (m.find("snapshotData") != m.end() && !m["snapshotData"].empty()) {
      snapshotData = make_shared<string>(boost::any_cast<string>(m["snapshotData"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~ListProblemOperationsResponseBodyData() = default;
};
class ListProblemOperationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListProblemOperationsResponseBodyData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListProblemOperationsResponseBody() {}

  explicit ListProblemOperationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListProblemOperationsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProblemOperationsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListProblemOperationsResponseBodyData>>(expect1);
      }
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ListProblemOperationsResponseBody() = default;
};
class ListProblemOperationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListProblemOperationsResponseBody> body{};

  ListProblemOperationsResponse() {}

  explicit ListProblemOperationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProblemOperationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProblemOperationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListProblemOperationsResponse() = default;
};
class ListProblemSubtotalsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> problemId{};

  ListProblemSubtotalsRequest() {}

  explicit ListProblemSubtotalsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
  }


  virtual ~ListProblemSubtotalsRequest() = default;
};
class ListProblemSubtotalsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> createRamName{};
  shared_ptr<string> createTime{};
  shared_ptr<long> createUserId{};
  shared_ptr<string> createUserPhone{};
  shared_ptr<string> description{};

  ListProblemSubtotalsResponseBodyData() {}

  explicit ListProblemSubtotalsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createRamName) {
      res["createRamName"] = boost::any(*createRamName);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (createUserId) {
      res["createUserId"] = boost::any(*createUserId);
    }
    if (createUserPhone) {
      res["createUserPhone"] = boost::any(*createUserPhone);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createRamName") != m.end() && !m["createRamName"].empty()) {
      createRamName = make_shared<string>(boost::any_cast<string>(m["createRamName"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("createUserId") != m.end() && !m["createUserId"].empty()) {
      createUserId = make_shared<long>(boost::any_cast<long>(m["createUserId"]));
    }
    if (m.find("createUserPhone") != m.end() && !m["createUserPhone"].empty()) {
      createUserPhone = make_shared<string>(boost::any_cast<string>(m["createUserPhone"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
  }


  virtual ~ListProblemSubtotalsResponseBodyData() = default;
};
class ListProblemSubtotalsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListProblemSubtotalsResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  ListProblemSubtotalsResponseBody() {}

  explicit ListProblemSubtotalsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListProblemSubtotalsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProblemSubtotalsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListProblemSubtotalsResponseBodyData>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListProblemSubtotalsResponseBody() = default;
};
class ListProblemSubtotalsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListProblemSubtotalsResponseBody> body{};

  ListProblemSubtotalsResponse() {}

  explicit ListProblemSubtotalsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProblemSubtotalsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProblemSubtotalsResponseBody>(model1);
      }
    }
  }


  virtual ~ListProblemSubtotalsResponse() = default;
};
class ListProblemTimeLinesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> problemId{};

  ListProblemTimeLinesRequest() {}

  explicit ListProblemTimeLinesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
  }


  virtual ~ListProblemTimeLinesRequest() = default;
};
class ListProblemTimeLinesResponseBodyDataUsersInContent : public Darabonba::Model {
public:
  shared_ptr<long> isValid{};
  shared_ptr<long> userId{};
  shared_ptr<string> username{};

  ListProblemTimeLinesResponseBodyDataUsersInContent() {}

  explicit ListProblemTimeLinesResponseBodyDataUsersInContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isValid) {
      res["isValid"] = boost::any(*isValid);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("isValid") != m.end() && !m["isValid"].empty()) {
      isValid = make_shared<long>(boost::any_cast<long>(m["isValid"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~ListProblemTimeLinesResponseBodyDataUsersInContent() = default;
};
class ListProblemTimeLinesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> createTime{};
  shared_ptr<bool> isKey{};
  shared_ptr<string> keyNode{};
  shared_ptr<long> problemTimelineId{};
  shared_ptr<string> time{};
  shared_ptr<string> updateTime{};
  shared_ptr<vector<ListProblemTimeLinesResponseBodyDataUsersInContent>> usersInContent{};

  ListProblemTimeLinesResponseBodyData() {}

  explicit ListProblemTimeLinesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (isKey) {
      res["isKey"] = boost::any(*isKey);
    }
    if (keyNode) {
      res["keyNode"] = boost::any(*keyNode);
    }
    if (problemTimelineId) {
      res["problemTimelineId"] = boost::any(*problemTimelineId);
    }
    if (time) {
      res["time"] = boost::any(*time);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    if (usersInContent) {
      vector<boost::any> temp1;
      for(auto item1:*usersInContent){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["usersInContent"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("isKey") != m.end() && !m["isKey"].empty()) {
      isKey = make_shared<bool>(boost::any_cast<bool>(m["isKey"]));
    }
    if (m.find("keyNode") != m.end() && !m["keyNode"].empty()) {
      keyNode = make_shared<string>(boost::any_cast<string>(m["keyNode"]));
    }
    if (m.find("problemTimelineId") != m.end() && !m["problemTimelineId"].empty()) {
      problemTimelineId = make_shared<long>(boost::any_cast<long>(m["problemTimelineId"]));
    }
    if (m.find("time") != m.end() && !m["time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["time"]));
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["updateTime"]));
    }
    if (m.find("usersInContent") != m.end() && !m["usersInContent"].empty()) {
      if (typeid(vector<boost::any>) == m["usersInContent"].type()) {
        vector<ListProblemTimeLinesResponseBodyDataUsersInContent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["usersInContent"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProblemTimeLinesResponseBodyDataUsersInContent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        usersInContent = make_shared<vector<ListProblemTimeLinesResponseBodyDataUsersInContent>>(expect1);
      }
    }
  }


  virtual ~ListProblemTimeLinesResponseBodyData() = default;
};
class ListProblemTimeLinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListProblemTimeLinesResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  ListProblemTimeLinesResponseBody() {}

  explicit ListProblemTimeLinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListProblemTimeLinesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProblemTimeLinesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListProblemTimeLinesResponseBodyData>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListProblemTimeLinesResponseBody() = default;
};
class ListProblemTimeLinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListProblemTimeLinesResponseBody> body{};

  ListProblemTimeLinesResponse() {}

  explicit ListProblemTimeLinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProblemTimeLinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProblemTimeLinesResponseBody>(model1);
      }
    }
  }


  virtual ~ListProblemTimeLinesResponse() = default;
};
class ListProblemsRequest : public Darabonba::Model {
public:
  shared_ptr<long> affectServiceId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> discoveryEndTime{};
  shared_ptr<string> discoveryStartTime{};
  shared_ptr<long> mainHandlerId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> problemLevel{};
  shared_ptr<string> problemStatus{};
  shared_ptr<string> queryType{};
  shared_ptr<long> repeaterId{};
  shared_ptr<string> restoreEndTime{};
  shared_ptr<string> restoreStartTime{};
  shared_ptr<long> serviceGroupId{};

  ListProblemsRequest() {}

  explicit ListProblemsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (affectServiceId) {
      res["affectServiceId"] = boost::any(*affectServiceId);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (discoveryEndTime) {
      res["discoveryEndTime"] = boost::any(*discoveryEndTime);
    }
    if (discoveryStartTime) {
      res["discoveryStartTime"] = boost::any(*discoveryStartTime);
    }
    if (mainHandlerId) {
      res["mainHandlerId"] = boost::any(*mainHandlerId);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (problemLevel) {
      res["problemLevel"] = boost::any(*problemLevel);
    }
    if (problemStatus) {
      res["problemStatus"] = boost::any(*problemStatus);
    }
    if (queryType) {
      res["queryType"] = boost::any(*queryType);
    }
    if (repeaterId) {
      res["repeaterId"] = boost::any(*repeaterId);
    }
    if (restoreEndTime) {
      res["restoreEndTime"] = boost::any(*restoreEndTime);
    }
    if (restoreStartTime) {
      res["restoreStartTime"] = boost::any(*restoreStartTime);
    }
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("affectServiceId") != m.end() && !m["affectServiceId"].empty()) {
      affectServiceId = make_shared<long>(boost::any_cast<long>(m["affectServiceId"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("discoveryEndTime") != m.end() && !m["discoveryEndTime"].empty()) {
      discoveryEndTime = make_shared<string>(boost::any_cast<string>(m["discoveryEndTime"]));
    }
    if (m.find("discoveryStartTime") != m.end() && !m["discoveryStartTime"].empty()) {
      discoveryStartTime = make_shared<string>(boost::any_cast<string>(m["discoveryStartTime"]));
    }
    if (m.find("mainHandlerId") != m.end() && !m["mainHandlerId"].empty()) {
      mainHandlerId = make_shared<long>(boost::any_cast<long>(m["mainHandlerId"]));
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("problemLevel") != m.end() && !m["problemLevel"].empty()) {
      problemLevel = make_shared<string>(boost::any_cast<string>(m["problemLevel"]));
    }
    if (m.find("problemStatus") != m.end() && !m["problemStatus"].empty()) {
      problemStatus = make_shared<string>(boost::any_cast<string>(m["problemStatus"]));
    }
    if (m.find("queryType") != m.end() && !m["queryType"].empty()) {
      queryType = make_shared<string>(boost::any_cast<string>(m["queryType"]));
    }
    if (m.find("repeaterId") != m.end() && !m["repeaterId"].empty()) {
      repeaterId = make_shared<long>(boost::any_cast<long>(m["repeaterId"]));
    }
    if (m.find("restoreEndTime") != m.end() && !m["restoreEndTime"].empty()) {
      restoreEndTime = make_shared<string>(boost::any_cast<string>(m["restoreEndTime"]));
    }
    if (m.find("restoreStartTime") != m.end() && !m["restoreStartTime"].empty()) {
      restoreStartTime = make_shared<string>(boost::any_cast<string>(m["restoreStartTime"]));
    }
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
  }


  virtual ~ListProblemsRequest() = default;
};
class ListProblemsResponseBodyDataAffectServices : public Darabonba::Model {
public:
  shared_ptr<string> serviceDescription{};
  shared_ptr<long> serviceId{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> updateTime{};

  ListProblemsResponseBodyDataAffectServices() {}

  explicit ListProblemsResponseBodyDataAffectServices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceDescription) {
      res["serviceDescription"] = boost::any(*serviceDescription);
    }
    if (serviceId) {
      res["serviceId"] = boost::any(*serviceId);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("serviceDescription") != m.end() && !m["serviceDescription"].empty()) {
      serviceDescription = make_shared<string>(boost::any_cast<string>(m["serviceDescription"]));
    }
    if (m.find("serviceId") != m.end() && !m["serviceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["serviceId"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["updateTime"]));
    }
  }


  virtual ~ListProblemsResponseBodyDataAffectServices() = default;
};
class ListProblemsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<ListProblemsResponseBodyDataAffectServices>> affectServices{};
  shared_ptr<string> cancelTime{};
  shared_ptr<string> createTime{};
  shared_ptr<string> discoverTime{};
  shared_ptr<string> finishTime{};
  shared_ptr<long> incidentId{};
  shared_ptr<bool> isManual{};
  shared_ptr<bool> isUpgrade{};
  shared_ptr<long> mainHandlerId{};
  shared_ptr<long> mainHandlerIsValid{};
  shared_ptr<string> mainHandlerName{};
  shared_ptr<long> problemId{};
  shared_ptr<string> problemLevel{};
  shared_ptr<string> problemName{};
  shared_ptr<string> problemNumber{};
  shared_ptr<string> problemStatus{};
  shared_ptr<string> recoveryTime{};
  shared_ptr<string> relatedServiceId{};
  shared_ptr<string> replayTime{};
  shared_ptr<long> serviceDeletedType{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> updateTime{};

  ListProblemsResponseBodyData() {}

  explicit ListProblemsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (affectServices) {
      vector<boost::any> temp1;
      for(auto item1:*affectServices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["affectServices"] = boost::any(temp1);
    }
    if (cancelTime) {
      res["cancelTime"] = boost::any(*cancelTime);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (discoverTime) {
      res["discoverTime"] = boost::any(*discoverTime);
    }
    if (finishTime) {
      res["finishTime"] = boost::any(*finishTime);
    }
    if (incidentId) {
      res["incidentId"] = boost::any(*incidentId);
    }
    if (isManual) {
      res["isManual"] = boost::any(*isManual);
    }
    if (isUpgrade) {
      res["isUpgrade"] = boost::any(*isUpgrade);
    }
    if (mainHandlerId) {
      res["mainHandlerId"] = boost::any(*mainHandlerId);
    }
    if (mainHandlerIsValid) {
      res["mainHandlerIsValid"] = boost::any(*mainHandlerIsValid);
    }
    if (mainHandlerName) {
      res["mainHandlerName"] = boost::any(*mainHandlerName);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    if (problemLevel) {
      res["problemLevel"] = boost::any(*problemLevel);
    }
    if (problemName) {
      res["problemName"] = boost::any(*problemName);
    }
    if (problemNumber) {
      res["problemNumber"] = boost::any(*problemNumber);
    }
    if (problemStatus) {
      res["problemStatus"] = boost::any(*problemStatus);
    }
    if (recoveryTime) {
      res["recoveryTime"] = boost::any(*recoveryTime);
    }
    if (relatedServiceId) {
      res["relatedServiceId"] = boost::any(*relatedServiceId);
    }
    if (replayTime) {
      res["replayTime"] = boost::any(*replayTime);
    }
    if (serviceDeletedType) {
      res["serviceDeletedType"] = boost::any(*serviceDeletedType);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("affectServices") != m.end() && !m["affectServices"].empty()) {
      if (typeid(vector<boost::any>) == m["affectServices"].type()) {
        vector<ListProblemsResponseBodyDataAffectServices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["affectServices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProblemsResponseBodyDataAffectServices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        affectServices = make_shared<vector<ListProblemsResponseBodyDataAffectServices>>(expect1);
      }
    }
    if (m.find("cancelTime") != m.end() && !m["cancelTime"].empty()) {
      cancelTime = make_shared<string>(boost::any_cast<string>(m["cancelTime"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("discoverTime") != m.end() && !m["discoverTime"].empty()) {
      discoverTime = make_shared<string>(boost::any_cast<string>(m["discoverTime"]));
    }
    if (m.find("finishTime") != m.end() && !m["finishTime"].empty()) {
      finishTime = make_shared<string>(boost::any_cast<string>(m["finishTime"]));
    }
    if (m.find("incidentId") != m.end() && !m["incidentId"].empty()) {
      incidentId = make_shared<long>(boost::any_cast<long>(m["incidentId"]));
    }
    if (m.find("isManual") != m.end() && !m["isManual"].empty()) {
      isManual = make_shared<bool>(boost::any_cast<bool>(m["isManual"]));
    }
    if (m.find("isUpgrade") != m.end() && !m["isUpgrade"].empty()) {
      isUpgrade = make_shared<bool>(boost::any_cast<bool>(m["isUpgrade"]));
    }
    if (m.find("mainHandlerId") != m.end() && !m["mainHandlerId"].empty()) {
      mainHandlerId = make_shared<long>(boost::any_cast<long>(m["mainHandlerId"]));
    }
    if (m.find("mainHandlerIsValid") != m.end() && !m["mainHandlerIsValid"].empty()) {
      mainHandlerIsValid = make_shared<long>(boost::any_cast<long>(m["mainHandlerIsValid"]));
    }
    if (m.find("mainHandlerName") != m.end() && !m["mainHandlerName"].empty()) {
      mainHandlerName = make_shared<string>(boost::any_cast<string>(m["mainHandlerName"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
    if (m.find("problemLevel") != m.end() && !m["problemLevel"].empty()) {
      problemLevel = make_shared<string>(boost::any_cast<string>(m["problemLevel"]));
    }
    if (m.find("problemName") != m.end() && !m["problemName"].empty()) {
      problemName = make_shared<string>(boost::any_cast<string>(m["problemName"]));
    }
    if (m.find("problemNumber") != m.end() && !m["problemNumber"].empty()) {
      problemNumber = make_shared<string>(boost::any_cast<string>(m["problemNumber"]));
    }
    if (m.find("problemStatus") != m.end() && !m["problemStatus"].empty()) {
      problemStatus = make_shared<string>(boost::any_cast<string>(m["problemStatus"]));
    }
    if (m.find("recoveryTime") != m.end() && !m["recoveryTime"].empty()) {
      recoveryTime = make_shared<string>(boost::any_cast<string>(m["recoveryTime"]));
    }
    if (m.find("relatedServiceId") != m.end() && !m["relatedServiceId"].empty()) {
      relatedServiceId = make_shared<string>(boost::any_cast<string>(m["relatedServiceId"]));
    }
    if (m.find("replayTime") != m.end() && !m["replayTime"].empty()) {
      replayTime = make_shared<string>(boost::any_cast<string>(m["replayTime"]));
    }
    if (m.find("serviceDeletedType") != m.end() && !m["serviceDeletedType"].empty()) {
      serviceDeletedType = make_shared<long>(boost::any_cast<long>(m["serviceDeletedType"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["updateTime"]));
    }
  }


  virtual ~ListProblemsResponseBodyData() = default;
};
class ListProblemsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListProblemsResponseBodyData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListProblemsResponseBody() {}

  explicit ListProblemsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListProblemsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProblemsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListProblemsResponseBodyData>>(expect1);
      }
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ListProblemsResponseBody() = default;
};
class ListProblemsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListProblemsResponseBody> body{};

  ListProblemsResponse() {}

  explicit ListProblemsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProblemsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProblemsResponseBody>(model1);
      }
    }
  }


  virtual ~ListProblemsResponse() = default;
};
class ListRouteRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> notFilterRouteRuleDeleted{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> routeType{};
  shared_ptr<vector<uint8_t>> ruleName{};
  shared_ptr<vector<uint8_t>> serviceName{};

  ListRouteRulesRequest() {}

  explicit ListRouteRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (notFilterRouteRuleDeleted) {
      res["notFilterRouteRuleDeleted"] = boost::any(*notFilterRouteRuleDeleted);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (routeType) {
      res["routeType"] = boost::any(*routeType);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("notFilterRouteRuleDeleted") != m.end() && !m["notFilterRouteRuleDeleted"].empty()) {
      notFilterRouteRuleDeleted = make_shared<bool>(boost::any_cast<bool>(m["notFilterRouteRuleDeleted"]));
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("routeType") != m.end() && !m["routeType"].empty()) {
      routeType = make_shared<long>(boost::any_cast<long>(m["routeType"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<vector<uint8_t>>(boost::any_cast<vector<uint8_t>>(m["ruleName"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<vector<uint8_t>>(boost::any_cast<vector<uint8_t>>(m["serviceName"]));
    }
  }


  virtual ~ListRouteRulesRequest() = default;
};
class ListRouteRulesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> assignObjectId{};
  shared_ptr<string> assignObjectType{};
  shared_ptr<string> createTime{};
  shared_ptr<string> effection{};
  shared_ptr<string> enableStatus{};
  shared_ptr<string> incidentLevel{};
  shared_ptr<long> isValid{};
  shared_ptr<long> matchCount{};
  shared_ptr<string> monitorSourceNames{};
  shared_ptr<long> relServiceDeleteType{};
  shared_ptr<long> relatedServiceId{};
  shared_ptr<string> relatedServiceName{};
  shared_ptr<long> routeRuleId{};
  shared_ptr<string> routeType{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> tenantRamId{};
  shared_ptr<long> timeWindow{};
  shared_ptr<long> timeWindowUnit{};
  shared_ptr<string> updateTime{};

  ListRouteRulesResponseBodyData() {}

  explicit ListRouteRulesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignObjectId) {
      res["assignObjectId"] = boost::any(*assignObjectId);
    }
    if (assignObjectType) {
      res["assignObjectType"] = boost::any(*assignObjectType);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (effection) {
      res["effection"] = boost::any(*effection);
    }
    if (enableStatus) {
      res["enableStatus"] = boost::any(*enableStatus);
    }
    if (incidentLevel) {
      res["incidentLevel"] = boost::any(*incidentLevel);
    }
    if (isValid) {
      res["isValid"] = boost::any(*isValid);
    }
    if (matchCount) {
      res["matchCount"] = boost::any(*matchCount);
    }
    if (monitorSourceNames) {
      res["monitorSourceNames"] = boost::any(*monitorSourceNames);
    }
    if (relServiceDeleteType) {
      res["relServiceDeleteType"] = boost::any(*relServiceDeleteType);
    }
    if (relatedServiceId) {
      res["relatedServiceId"] = boost::any(*relatedServiceId);
    }
    if (relatedServiceName) {
      res["relatedServiceName"] = boost::any(*relatedServiceName);
    }
    if (routeRuleId) {
      res["routeRuleId"] = boost::any(*routeRuleId);
    }
    if (routeType) {
      res["routeType"] = boost::any(*routeType);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    if (tenantRamId) {
      res["tenantRamId"] = boost::any(*tenantRamId);
    }
    if (timeWindow) {
      res["timeWindow"] = boost::any(*timeWindow);
    }
    if (timeWindowUnit) {
      res["timeWindowUnit"] = boost::any(*timeWindowUnit);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignObjectId") != m.end() && !m["assignObjectId"].empty()) {
      assignObjectId = make_shared<long>(boost::any_cast<long>(m["assignObjectId"]));
    }
    if (m.find("assignObjectType") != m.end() && !m["assignObjectType"].empty()) {
      assignObjectType = make_shared<string>(boost::any_cast<string>(m["assignObjectType"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("effection") != m.end() && !m["effection"].empty()) {
      effection = make_shared<string>(boost::any_cast<string>(m["effection"]));
    }
    if (m.find("enableStatus") != m.end() && !m["enableStatus"].empty()) {
      enableStatus = make_shared<string>(boost::any_cast<string>(m["enableStatus"]));
    }
    if (m.find("incidentLevel") != m.end() && !m["incidentLevel"].empty()) {
      incidentLevel = make_shared<string>(boost::any_cast<string>(m["incidentLevel"]));
    }
    if (m.find("isValid") != m.end() && !m["isValid"].empty()) {
      isValid = make_shared<long>(boost::any_cast<long>(m["isValid"]));
    }
    if (m.find("matchCount") != m.end() && !m["matchCount"].empty()) {
      matchCount = make_shared<long>(boost::any_cast<long>(m["matchCount"]));
    }
    if (m.find("monitorSourceNames") != m.end() && !m["monitorSourceNames"].empty()) {
      monitorSourceNames = make_shared<string>(boost::any_cast<string>(m["monitorSourceNames"]));
    }
    if (m.find("relServiceDeleteType") != m.end() && !m["relServiceDeleteType"].empty()) {
      relServiceDeleteType = make_shared<long>(boost::any_cast<long>(m["relServiceDeleteType"]));
    }
    if (m.find("relatedServiceId") != m.end() && !m["relatedServiceId"].empty()) {
      relatedServiceId = make_shared<long>(boost::any_cast<long>(m["relatedServiceId"]));
    }
    if (m.find("relatedServiceName") != m.end() && !m["relatedServiceName"].empty()) {
      relatedServiceName = make_shared<string>(boost::any_cast<string>(m["relatedServiceName"]));
    }
    if (m.find("routeRuleId") != m.end() && !m["routeRuleId"].empty()) {
      routeRuleId = make_shared<long>(boost::any_cast<long>(m["routeRuleId"]));
    }
    if (m.find("routeType") != m.end() && !m["routeType"].empty()) {
      routeType = make_shared<string>(boost::any_cast<string>(m["routeType"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
    if (m.find("tenantRamId") != m.end() && !m["tenantRamId"].empty()) {
      tenantRamId = make_shared<long>(boost::any_cast<long>(m["tenantRamId"]));
    }
    if (m.find("timeWindow") != m.end() && !m["timeWindow"].empty()) {
      timeWindow = make_shared<long>(boost::any_cast<long>(m["timeWindow"]));
    }
    if (m.find("timeWindowUnit") != m.end() && !m["timeWindowUnit"].empty()) {
      timeWindowUnit = make_shared<long>(boost::any_cast<long>(m["timeWindowUnit"]));
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["updateTime"]));
    }
  }


  virtual ~ListRouteRulesResponseBodyData() = default;
};
class ListRouteRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListRouteRulesResponseBodyData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListRouteRulesResponseBody() {}

  explicit ListRouteRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListRouteRulesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRouteRulesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListRouteRulesResponseBodyData>>(expect1);
      }
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ListRouteRulesResponseBody() = default;
};
class ListRouteRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRouteRulesResponseBody> body{};

  ListRouteRulesResponse() {}

  explicit ListRouteRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRouteRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRouteRulesResponseBody>(model1);
      }
    }
  }


  virtual ~ListRouteRulesResponse() = default;
};
class ListRouteRulesByAssignWhoIdRequest : public Darabonba::Model {
public:
  shared_ptr<long> assignWhoId{};
  shared_ptr<long> assignWhoType{};

  ListRouteRulesByAssignWhoIdRequest() {}

  explicit ListRouteRulesByAssignWhoIdRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignWhoId) {
      res["assignWhoId"] = boost::any(*assignWhoId);
    }
    if (assignWhoType) {
      res["assignWhoType"] = boost::any(*assignWhoType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignWhoId") != m.end() && !m["assignWhoId"].empty()) {
      assignWhoId = make_shared<long>(boost::any_cast<long>(m["assignWhoId"]));
    }
    if (m.find("assignWhoType") != m.end() && !m["assignWhoType"].empty()) {
      assignWhoType = make_shared<long>(boost::any_cast<long>(m["assignWhoType"]));
    }
  }


  virtual ~ListRouteRulesByAssignWhoIdRequest() = default;
};
class ListRouteRulesByAssignWhoIdResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> tenantRamId{};

  ListRouteRulesByAssignWhoIdResponseBodyData() {}

  explicit ListRouteRulesByAssignWhoIdResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    if (tenantRamId) {
      res["tenantRamId"] = boost::any(*tenantRamId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
    if (m.find("tenantRamId") != m.end() && !m["tenantRamId"].empty()) {
      tenantRamId = make_shared<long>(boost::any_cast<long>(m["tenantRamId"]));
    }
  }


  virtual ~ListRouteRulesByAssignWhoIdResponseBodyData() = default;
};
class ListRouteRulesByAssignWhoIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListRouteRulesByAssignWhoIdResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  ListRouteRulesByAssignWhoIdResponseBody() {}

  explicit ListRouteRulesByAssignWhoIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListRouteRulesByAssignWhoIdResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRouteRulesByAssignWhoIdResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListRouteRulesByAssignWhoIdResponseBodyData>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListRouteRulesByAssignWhoIdResponseBody() = default;
};
class ListRouteRulesByAssignWhoIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRouteRulesByAssignWhoIdResponseBody> body{};

  ListRouteRulesByAssignWhoIdResponse() {}

  explicit ListRouteRulesByAssignWhoIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRouteRulesByAssignWhoIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRouteRulesByAssignWhoIdResponseBody>(model1);
      }
    }
  }


  virtual ~ListRouteRulesByAssignWhoIdResponse() = default;
};
class ListRouteRulesByServiceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> ruleName{};

  ListRouteRulesByServiceResponseBodyData() {}

  explicit ListRouteRulesByServiceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
  }


  virtual ~ListRouteRulesByServiceResponseBodyData() = default;
};
class ListRouteRulesByServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListRouteRulesByServiceResponseBodyData>> data{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListRouteRulesByServiceResponseBody() {}

  explicit ListRouteRulesByServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListRouteRulesByServiceResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListRouteRulesByServiceResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListRouteRulesByServiceResponseBodyData>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ListRouteRulesByServiceResponseBody() = default;
};
class ListRouteRulesByServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRouteRulesByServiceResponseBody> body{};

  ListRouteRulesByServiceResponse() {}

  explicit ListRouteRulesByServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRouteRulesByServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRouteRulesByServiceResponseBody>(model1);
      }
    }
  }


  virtual ~ListRouteRulesByServiceResponse() = default;
};
class ListServiceGroupMonitorSourceTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> serviceGroupId{};

  ListServiceGroupMonitorSourceTemplatesRequest() {}

  explicit ListServiceGroupMonitorSourceTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
  }


  virtual ~ListServiceGroupMonitorSourceTemplatesRequest() = default;
};
class ListServiceGroupMonitorSourceTemplatesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fields{};
  shared_ptr<long> monitorSourceId{};
  shared_ptr<string> monitorSourceName{};
  shared_ptr<string> templateContent{};
  shared_ptr<long> templateId{};

  ListServiceGroupMonitorSourceTemplatesResponseBodyData() {}

  explicit ListServiceGroupMonitorSourceTemplatesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fields) {
      res["fields"] = boost::any(*fields);
    }
    if (monitorSourceId) {
      res["monitorSourceId"] = boost::any(*monitorSourceId);
    }
    if (monitorSourceName) {
      res["monitorSourceName"] = boost::any(*monitorSourceName);
    }
    if (templateContent) {
      res["templateContent"] = boost::any(*templateContent);
    }
    if (templateId) {
      res["templateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fields") != m.end() && !m["fields"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["fields"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["fields"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fields = make_shared<vector<string>>(toVec1);
    }
    if (m.find("monitorSourceId") != m.end() && !m["monitorSourceId"].empty()) {
      monitorSourceId = make_shared<long>(boost::any_cast<long>(m["monitorSourceId"]));
    }
    if (m.find("monitorSourceName") != m.end() && !m["monitorSourceName"].empty()) {
      monitorSourceName = make_shared<string>(boost::any_cast<string>(m["monitorSourceName"]));
    }
    if (m.find("templateContent") != m.end() && !m["templateContent"].empty()) {
      templateContent = make_shared<string>(boost::any_cast<string>(m["templateContent"]));
    }
    if (m.find("templateId") != m.end() && !m["templateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["templateId"]));
    }
  }


  virtual ~ListServiceGroupMonitorSourceTemplatesResponseBodyData() = default;
};
class ListServiceGroupMonitorSourceTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListServiceGroupMonitorSourceTemplatesResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  ListServiceGroupMonitorSourceTemplatesResponseBody() {}

  explicit ListServiceGroupMonitorSourceTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListServiceGroupMonitorSourceTemplatesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListServiceGroupMonitorSourceTemplatesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListServiceGroupMonitorSourceTemplatesResponseBodyData>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListServiceGroupMonitorSourceTemplatesResponseBody() = default;
};
class ListServiceGroupMonitorSourceTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListServiceGroupMonitorSourceTemplatesResponseBody> body{};

  ListServiceGroupMonitorSourceTemplatesResponse() {}

  explicit ListServiceGroupMonitorSourceTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListServiceGroupMonitorSourceTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListServiceGroupMonitorSourceTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListServiceGroupMonitorSourceTemplatesResponse() = default;
};
class ListServiceGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> isScheduled{};
  shared_ptr<bool> orderByScheduleStatus{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> queryName{};
  shared_ptr<string> queryType{};
  shared_ptr<long> userId{};

  ListServiceGroupsRequest() {}

  explicit ListServiceGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (isScheduled) {
      res["isScheduled"] = boost::any(*isScheduled);
    }
    if (orderByScheduleStatus) {
      res["orderByScheduleStatus"] = boost::any(*orderByScheduleStatus);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (queryName) {
      res["queryName"] = boost::any(*queryName);
    }
    if (queryType) {
      res["queryType"] = boost::any(*queryType);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("isScheduled") != m.end() && !m["isScheduled"].empty()) {
      isScheduled = make_shared<bool>(boost::any_cast<bool>(m["isScheduled"]));
    }
    if (m.find("orderByScheduleStatus") != m.end() && !m["orderByScheduleStatus"].empty()) {
      orderByScheduleStatus = make_shared<bool>(boost::any_cast<bool>(m["orderByScheduleStatus"]));
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("queryName") != m.end() && !m["queryName"].empty()) {
      queryName = make_shared<string>(boost::any_cast<string>(m["queryName"]));
    }
    if (m.find("queryType") != m.end() && !m["queryType"].empty()) {
      queryType = make_shared<string>(boost::any_cast<string>(m["queryType"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
  }


  virtual ~ListServiceGroupsRequest() = default;
};
class ListServiceGroupsResponseBodyDataUsers : public Darabonba::Model {
public:
  shared_ptr<string> email{};
  shared_ptr<long> isRelated{};
  shared_ptr<string> phone{};
  shared_ptr<long> serviceGroupId{};
  shared_ptr<long> userId{};
  shared_ptr<string> userName{};

  ListServiceGroupsResponseBodyDataUsers() {}

  explicit ListServiceGroupsResponseBodyDataUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (isRelated) {
      res["isRelated"] = boost::any(*isRelated);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    if (userName) {
      res["userName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("isRelated") != m.end() && !m["isRelated"].empty()) {
      isRelated = make_shared<long>(boost::any_cast<long>(m["isRelated"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
    if (m.find("userName") != m.end() && !m["userName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["userName"]));
    }
  }


  virtual ~ListServiceGroupsResponseBodyDataUsers() = default;
};
class ListServiceGroupsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> enableWebhook{};
  shared_ptr<bool> isScheduled{};
  shared_ptr<string> serviceGroupDescription{};
  shared_ptr<long> serviceGroupId{};
  shared_ptr<string> serviceGroupName{};
  shared_ptr<string> updateTime{};
  shared_ptr<vector<ListServiceGroupsResponseBodyDataUsers>> users{};
  shared_ptr<string> webhookLink{};
  shared_ptr<string> webhookType{};

  ListServiceGroupsResponseBodyData() {}

  explicit ListServiceGroupsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableWebhook) {
      res["enableWebhook"] = boost::any(*enableWebhook);
    }
    if (isScheduled) {
      res["isScheduled"] = boost::any(*isScheduled);
    }
    if (serviceGroupDescription) {
      res["serviceGroupDescription"] = boost::any(*serviceGroupDescription);
    }
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    if (serviceGroupName) {
      res["serviceGroupName"] = boost::any(*serviceGroupName);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    if (users) {
      vector<boost::any> temp1;
      for(auto item1:*users){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["users"] = boost::any(temp1);
    }
    if (webhookLink) {
      res["webhookLink"] = boost::any(*webhookLink);
    }
    if (webhookType) {
      res["webhookType"] = boost::any(*webhookType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enableWebhook") != m.end() && !m["enableWebhook"].empty()) {
      enableWebhook = make_shared<string>(boost::any_cast<string>(m["enableWebhook"]));
    }
    if (m.find("isScheduled") != m.end() && !m["isScheduled"].empty()) {
      isScheduled = make_shared<bool>(boost::any_cast<bool>(m["isScheduled"]));
    }
    if (m.find("serviceGroupDescription") != m.end() && !m["serviceGroupDescription"].empty()) {
      serviceGroupDescription = make_shared<string>(boost::any_cast<string>(m["serviceGroupDescription"]));
    }
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
    if (m.find("serviceGroupName") != m.end() && !m["serviceGroupName"].empty()) {
      serviceGroupName = make_shared<string>(boost::any_cast<string>(m["serviceGroupName"]));
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["updateTime"]));
    }
    if (m.find("users") != m.end() && !m["users"].empty()) {
      if (typeid(vector<boost::any>) == m["users"].type()) {
        vector<ListServiceGroupsResponseBodyDataUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["users"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListServiceGroupsResponseBodyDataUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        users = make_shared<vector<ListServiceGroupsResponseBodyDataUsers>>(expect1);
      }
    }
    if (m.find("webhookLink") != m.end() && !m["webhookLink"].empty()) {
      webhookLink = make_shared<string>(boost::any_cast<string>(m["webhookLink"]));
    }
    if (m.find("webhookType") != m.end() && !m["webhookType"].empty()) {
      webhookType = make_shared<string>(boost::any_cast<string>(m["webhookType"]));
    }
  }


  virtual ~ListServiceGroupsResponseBodyData() = default;
};
class ListServiceGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListServiceGroupsResponseBodyData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListServiceGroupsResponseBody() {}

  explicit ListServiceGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListServiceGroupsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListServiceGroupsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListServiceGroupsResponseBodyData>>(expect1);
      }
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ListServiceGroupsResponseBody() = default;
};
class ListServiceGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListServiceGroupsResponseBody> body{};

  ListServiceGroupsResponse() {}

  explicit ListServiceGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListServiceGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListServiceGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListServiceGroupsResponse() = default;
};
class ListServiceGroupsByUserIdResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<bool> isScheduled{};
  shared_ptr<long> serviceGroupId{};
  shared_ptr<string> serviceGroupName{};

  ListServiceGroupsByUserIdResponseBodyData() {}

  explicit ListServiceGroupsByUserIdResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isScheduled) {
      res["isScheduled"] = boost::any(*isScheduled);
    }
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    if (serviceGroupName) {
      res["serviceGroupName"] = boost::any(*serviceGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("isScheduled") != m.end() && !m["isScheduled"].empty()) {
      isScheduled = make_shared<bool>(boost::any_cast<bool>(m["isScheduled"]));
    }
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
    if (m.find("serviceGroupName") != m.end() && !m["serviceGroupName"].empty()) {
      serviceGroupName = make_shared<string>(boost::any_cast<string>(m["serviceGroupName"]));
    }
  }


  virtual ~ListServiceGroupsByUserIdResponseBodyData() = default;
};
class ListServiceGroupsByUserIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListServiceGroupsByUserIdResponseBodyData> data{};
  shared_ptr<string> requestId{};

  ListServiceGroupsByUserIdResponseBody() {}

  explicit ListServiceGroupsByUserIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        ListServiceGroupsByUserIdResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<ListServiceGroupsByUserIdResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListServiceGroupsByUserIdResponseBody() = default;
};
class ListServiceGroupsByUserIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListServiceGroupsByUserIdResponseBody> body{};

  ListServiceGroupsByUserIdResponse() {}

  explicit ListServiceGroupsByUserIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListServiceGroupsByUserIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListServiceGroupsByUserIdResponseBody>(model1);
      }
    }
  }


  virtual ~ListServiceGroupsByUserIdResponse() = default;
};
class ListServicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> serviceName{};

  ListServicesRequest() {}

  explicit ListServicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
  }


  virtual ~ListServicesRequest() = default;
};
class ListServicesResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> isValid{};
  shared_ptr<string> serviceDescription{};
  shared_ptr<long> serviceId{};
  shared_ptr<string> serviceName{};
  shared_ptr<string> updateTime{};

  ListServicesResponseBodyData() {}

  explicit ListServicesResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isValid) {
      res["isValid"] = boost::any(*isValid);
    }
    if (serviceDescription) {
      res["serviceDescription"] = boost::any(*serviceDescription);
    }
    if (serviceId) {
      res["serviceId"] = boost::any(*serviceId);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("isValid") != m.end() && !m["isValid"].empty()) {
      isValid = make_shared<long>(boost::any_cast<long>(m["isValid"]));
    }
    if (m.find("serviceDescription") != m.end() && !m["serviceDescription"].empty()) {
      serviceDescription = make_shared<string>(boost::any_cast<string>(m["serviceDescription"]));
    }
    if (m.find("serviceId") != m.end() && !m["serviceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["serviceId"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["updateTime"]));
    }
  }


  virtual ~ListServicesResponseBodyData() = default;
};
class ListServicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListServicesResponseBodyData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListServicesResponseBody() {}

  explicit ListServicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListServicesResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListServicesResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListServicesResponseBodyData>>(expect1);
      }
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ListServicesResponseBody() = default;
};
class ListServicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListServicesResponseBody> body{};

  ListServicesResponse() {}

  explicit ListServicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListServicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListServicesResponseBody>(model1);
      }
    }
  }


  virtual ~ListServicesResponse() = default;
};
class ListSourceEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> endTime{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> startRowKey{};
  shared_ptr<string> startTime{};
  shared_ptr<string> stopRowKey{};

  ListSourceEventsRequest() {}

  explicit ListSourceEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["instanceType"] = boost::any(*instanceType);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (startRowKey) {
      res["startRowKey"] = boost::any(*startRowKey);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (stopRowKey) {
      res["stopRowKey"] = boost::any(*stopRowKey);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["instanceId"]));
    }
    if (m.find("instanceType") != m.end() && !m["instanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["instanceType"]));
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("startRowKey") != m.end() && !m["startRowKey"].empty()) {
      startRowKey = make_shared<string>(boost::any_cast<string>(m["startRowKey"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
    if (m.find("stopRowKey") != m.end() && !m["stopRowKey"].empty()) {
      stopRowKey = make_shared<string>(boost::any_cast<string>(m["stopRowKey"]));
    }
  }


  virtual ~ListSourceEventsRequest() = default;
};
class ListSourceEventsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> eventJson{};
  shared_ptr<string> eventTime{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<long> monitorSourceId{};
  shared_ptr<string> monitorSourceName{};
  shared_ptr<long> routeRuleId{};
  shared_ptr<long> tenantRamId{};

  ListSourceEventsResponseBodyData() {}

  explicit ListSourceEventsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventJson) {
      res["eventJson"] = boost::any(*eventJson);
    }
    if (eventTime) {
      res["eventTime"] = boost::any(*eventTime);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["instanceType"] = boost::any(*instanceType);
    }
    if (monitorSourceId) {
      res["monitorSourceId"] = boost::any(*monitorSourceId);
    }
    if (monitorSourceName) {
      res["monitorSourceName"] = boost::any(*monitorSourceName);
    }
    if (routeRuleId) {
      res["routeRuleId"] = boost::any(*routeRuleId);
    }
    if (tenantRamId) {
      res["tenantRamId"] = boost::any(*tenantRamId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("eventJson") != m.end() && !m["eventJson"].empty()) {
      eventJson = make_shared<string>(boost::any_cast<string>(m["eventJson"]));
    }
    if (m.find("eventTime") != m.end() && !m["eventTime"].empty()) {
      eventTime = make_shared<string>(boost::any_cast<string>(m["eventTime"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["instanceId"]));
    }
    if (m.find("instanceType") != m.end() && !m["instanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["instanceType"]));
    }
    if (m.find("monitorSourceId") != m.end() && !m["monitorSourceId"].empty()) {
      monitorSourceId = make_shared<long>(boost::any_cast<long>(m["monitorSourceId"]));
    }
    if (m.find("monitorSourceName") != m.end() && !m["monitorSourceName"].empty()) {
      monitorSourceName = make_shared<string>(boost::any_cast<string>(m["monitorSourceName"]));
    }
    if (m.find("routeRuleId") != m.end() && !m["routeRuleId"].empty()) {
      routeRuleId = make_shared<long>(boost::any_cast<long>(m["routeRuleId"]));
    }
    if (m.find("tenantRamId") != m.end() && !m["tenantRamId"].empty()) {
      tenantRamId = make_shared<long>(boost::any_cast<long>(m["tenantRamId"]));
    }
  }


  virtual ~ListSourceEventsResponseBodyData() = default;
};
class ListSourceEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListSourceEventsResponseBodyData>> data{};
  shared_ptr<string> firstRowKey{};
  shared_ptr<string> lastRowKey{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListSourceEventsResponseBody() {}

  explicit ListSourceEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (firstRowKey) {
      res["firstRowKey"] = boost::any(*firstRowKey);
    }
    if (lastRowKey) {
      res["lastRowKey"] = boost::any(*lastRowKey);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListSourceEventsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSourceEventsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListSourceEventsResponseBodyData>>(expect1);
      }
    }
    if (m.find("firstRowKey") != m.end() && !m["firstRowKey"].empty()) {
      firstRowKey = make_shared<string>(boost::any_cast<string>(m["firstRowKey"]));
    }
    if (m.find("lastRowKey") != m.end() && !m["lastRowKey"].empty()) {
      lastRowKey = make_shared<string>(boost::any_cast<string>(m["lastRowKey"]));
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ListSourceEventsResponseBody() = default;
};
class ListSourceEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSourceEventsResponseBody> body{};

  ListSourceEventsResponse() {}

  explicit ListSourceEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSourceEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSourceEventsResponseBody>(model1);
      }
    }
  }


  virtual ~ListSourceEventsResponse() = default;
};
class ListSourceEventsForMonitorSourceRequest : public Darabonba::Model {
public:
  shared_ptr<long> monitorSourceId{};

  ListSourceEventsForMonitorSourceRequest() {}

  explicit ListSourceEventsForMonitorSourceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorSourceId) {
      res["monitorSourceId"] = boost::any(*monitorSourceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("monitorSourceId") != m.end() && !m["monitorSourceId"].empty()) {
      monitorSourceId = make_shared<long>(boost::any_cast<long>(m["monitorSourceId"]));
    }
  }


  virtual ~ListSourceEventsForMonitorSourceRequest() = default;
};
class ListSourceEventsForMonitorSourceResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> eventJson{};
  shared_ptr<string> eventTime{};
  shared_ptr<bool> monitorSourceId{};
  shared_ptr<string> monitorSourceName{};

  ListSourceEventsForMonitorSourceResponseBodyData() {}

  explicit ListSourceEventsForMonitorSourceResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventJson) {
      res["eventJson"] = boost::any(*eventJson);
    }
    if (eventTime) {
      res["eventTime"] = boost::any(*eventTime);
    }
    if (monitorSourceId) {
      res["monitorSourceId"] = boost::any(*monitorSourceId);
    }
    if (monitorSourceName) {
      res["monitorSourceName"] = boost::any(*monitorSourceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("eventJson") != m.end() && !m["eventJson"].empty()) {
      eventJson = make_shared<string>(boost::any_cast<string>(m["eventJson"]));
    }
    if (m.find("eventTime") != m.end() && !m["eventTime"].empty()) {
      eventTime = make_shared<string>(boost::any_cast<string>(m["eventTime"]));
    }
    if (m.find("monitorSourceId") != m.end() && !m["monitorSourceId"].empty()) {
      monitorSourceId = make_shared<bool>(boost::any_cast<bool>(m["monitorSourceId"]));
    }
    if (m.find("monitorSourceName") != m.end() && !m["monitorSourceName"].empty()) {
      monitorSourceName = make_shared<string>(boost::any_cast<string>(m["monitorSourceName"]));
    }
  }


  virtual ~ListSourceEventsForMonitorSourceResponseBodyData() = default;
};
class ListSourceEventsForMonitorSourceResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListSourceEventsForMonitorSourceResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  ListSourceEventsForMonitorSourceResponseBody() {}

  explicit ListSourceEventsForMonitorSourceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListSourceEventsForMonitorSourceResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSourceEventsForMonitorSourceResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListSourceEventsForMonitorSourceResponseBodyData>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListSourceEventsForMonitorSourceResponseBody() = default;
};
class ListSourceEventsForMonitorSourceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSourceEventsForMonitorSourceResponseBody> body{};

  ListSourceEventsForMonitorSourceResponse() {}

  explicit ListSourceEventsForMonitorSourceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSourceEventsForMonitorSourceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSourceEventsForMonitorSourceResponseBody>(model1);
      }
    }
  }


  virtual ~ListSourceEventsForMonitorSourceResponse() = default;
};
class ListSubscriptionServiceGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<vector<long>> serviceIds{};

  ListSubscriptionServiceGroupsRequest() {}

  explicit ListSubscriptionServiceGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (serviceIds) {
      res["serviceIds"] = boost::any(*serviceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("serviceIds") != m.end() && !m["serviceIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["serviceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["serviceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      serviceIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~ListSubscriptionServiceGroupsRequest() = default;
};
class ListSubscriptionServiceGroupsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> serviceGroupDescription{};
  shared_ptr<long> serviceId{};
  shared_ptr<string> serviceName{};

  ListSubscriptionServiceGroupsResponseBodyData() {}

  explicit ListSubscriptionServiceGroupsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceGroupDescription) {
      res["serviceGroupDescription"] = boost::any(*serviceGroupDescription);
    }
    if (serviceId) {
      res["serviceId"] = boost::any(*serviceId);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("serviceGroupDescription") != m.end() && !m["serviceGroupDescription"].empty()) {
      serviceGroupDescription = make_shared<string>(boost::any_cast<string>(m["serviceGroupDescription"]));
    }
    if (m.find("serviceId") != m.end() && !m["serviceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["serviceId"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
  }


  virtual ~ListSubscriptionServiceGroupsResponseBodyData() = default;
};
class ListSubscriptionServiceGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListSubscriptionServiceGroupsResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  ListSubscriptionServiceGroupsResponseBody() {}

  explicit ListSubscriptionServiceGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListSubscriptionServiceGroupsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSubscriptionServiceGroupsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListSubscriptionServiceGroupsResponseBodyData>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListSubscriptionServiceGroupsResponseBody() = default;
};
class ListSubscriptionServiceGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSubscriptionServiceGroupsResponseBody> body{};

  ListSubscriptionServiceGroupsResponse() {}

  explicit ListSubscriptionServiceGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSubscriptionServiceGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSubscriptionServiceGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListSubscriptionServiceGroupsResponse() = default;
};
class ListSubscriptionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> notFilterScopeObjectDeleted{};
  shared_ptr<string> notifyObject{};
  shared_ptr<string> notifyObjectType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> scope{};
  shared_ptr<string> scopeObject{};
  shared_ptr<string> subscriptionTitle{};

  ListSubscriptionsRequest() {}

  explicit ListSubscriptionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (notFilterScopeObjectDeleted) {
      res["notFilterScopeObjectDeleted"] = boost::any(*notFilterScopeObjectDeleted);
    }
    if (notifyObject) {
      res["notifyObject"] = boost::any(*notifyObject);
    }
    if (notifyObjectType) {
      res["notifyObjectType"] = boost::any(*notifyObjectType);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (scopeObject) {
      res["scopeObject"] = boost::any(*scopeObject);
    }
    if (subscriptionTitle) {
      res["subscriptionTitle"] = boost::any(*subscriptionTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("notFilterScopeObjectDeleted") != m.end() && !m["notFilterScopeObjectDeleted"].empty()) {
      notFilterScopeObjectDeleted = make_shared<bool>(boost::any_cast<bool>(m["notFilterScopeObjectDeleted"]));
    }
    if (m.find("notifyObject") != m.end() && !m["notifyObject"].empty()) {
      notifyObject = make_shared<string>(boost::any_cast<string>(m["notifyObject"]));
    }
    if (m.find("notifyObjectType") != m.end() && !m["notifyObjectType"].empty()) {
      notifyObjectType = make_shared<string>(boost::any_cast<string>(m["notifyObjectType"]));
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
    if (m.find("scopeObject") != m.end() && !m["scopeObject"].empty()) {
      scopeObject = make_shared<string>(boost::any_cast<string>(m["scopeObject"]));
    }
    if (m.find("subscriptionTitle") != m.end() && !m["subscriptionTitle"].empty()) {
      subscriptionTitle = make_shared<string>(boost::any_cast<string>(m["subscriptionTitle"]));
    }
  }


  virtual ~ListSubscriptionsRequest() = default;
};
class ListSubscriptionsResponseBodyDataNotifyObjectList : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> isValid{};
  shared_ptr<string> name{};
  shared_ptr<long> notifyObjectId{};
  shared_ptr<long> notifyObjectType{};

  ListSubscriptionsResponseBodyDataNotifyObjectList() {}

  explicit ListSubscriptionsResponseBodyDataNotifyObjectList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isValid) {
      res["isValid"] = boost::any(*isValid);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (notifyObjectId) {
      res["notifyObjectId"] = boost::any(*notifyObjectId);
    }
    if (notifyObjectType) {
      res["notifyObjectType"] = boost::any(*notifyObjectType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("isValid") != m.end() && !m["isValid"].empty()) {
      isValid = make_shared<long>(boost::any_cast<long>(m["isValid"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("notifyObjectId") != m.end() && !m["notifyObjectId"].empty()) {
      notifyObjectId = make_shared<long>(boost::any_cast<long>(m["notifyObjectId"]));
    }
    if (m.find("notifyObjectType") != m.end() && !m["notifyObjectType"].empty()) {
      notifyObjectType = make_shared<long>(boost::any_cast<long>(m["notifyObjectType"]));
    }
  }


  virtual ~ListSubscriptionsResponseBodyDataNotifyObjectList() = default;
};
class ListSubscriptionsResponseBodyDataScopeObjectList : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> isValid{};
  shared_ptr<long> scope{};
  shared_ptr<string> scopeObject{};
  shared_ptr<long> scopeObjectId{};

  ListSubscriptionsResponseBodyDataScopeObjectList() {}

  explicit ListSubscriptionsResponseBodyDataScopeObjectList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (isValid) {
      res["isValid"] = boost::any(*isValid);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (scopeObject) {
      res["scopeObject"] = boost::any(*scopeObject);
    }
    if (scopeObjectId) {
      res["scopeObjectId"] = boost::any(*scopeObjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("isValid") != m.end() && !m["isValid"].empty()) {
      isValid = make_shared<long>(boost::any_cast<long>(m["isValid"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<long>(boost::any_cast<long>(m["scope"]));
    }
    if (m.find("scopeObject") != m.end() && !m["scopeObject"].empty()) {
      scopeObject = make_shared<string>(boost::any_cast<string>(m["scopeObject"]));
    }
    if (m.find("scopeObjectId") != m.end() && !m["scopeObjectId"].empty()) {
      scopeObjectId = make_shared<long>(boost::any_cast<long>(m["scopeObjectId"]));
    }
  }


  virtual ~ListSubscriptionsResponseBodyDataScopeObjectList() = default;
};
class ListSubscriptionsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> expiredType{};
  shared_ptr<vector<ListSubscriptionsResponseBodyDataNotifyObjectList>> notifyObjectList{};
  shared_ptr<long> notifyObjectType{};
  shared_ptr<long> scope{};
  shared_ptr<vector<ListSubscriptionsResponseBodyDataScopeObjectList>> scopeObjectList{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<long> subscriptionId{};
  shared_ptr<string> subscriptionTitle{};

  ListSubscriptionsResponseBodyData() {}

  explicit ListSubscriptionsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (expiredType) {
      res["expiredType"] = boost::any(*expiredType);
    }
    if (notifyObjectList) {
      vector<boost::any> temp1;
      for(auto item1:*notifyObjectList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["notifyObjectList"] = boost::any(temp1);
    }
    if (notifyObjectType) {
      res["notifyObjectType"] = boost::any(*notifyObjectType);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (scopeObjectList) {
      vector<boost::any> temp1;
      for(auto item1:*scopeObjectList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["scopeObjectList"] = boost::any(temp1);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (subscriptionId) {
      res["subscriptionId"] = boost::any(*subscriptionId);
    }
    if (subscriptionTitle) {
      res["subscriptionTitle"] = boost::any(*subscriptionTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("expiredType") != m.end() && !m["expiredType"].empty()) {
      expiredType = make_shared<string>(boost::any_cast<string>(m["expiredType"]));
    }
    if (m.find("notifyObjectList") != m.end() && !m["notifyObjectList"].empty()) {
      if (typeid(vector<boost::any>) == m["notifyObjectList"].type()) {
        vector<ListSubscriptionsResponseBodyDataNotifyObjectList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["notifyObjectList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSubscriptionsResponseBodyDataNotifyObjectList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifyObjectList = make_shared<vector<ListSubscriptionsResponseBodyDataNotifyObjectList>>(expect1);
      }
    }
    if (m.find("notifyObjectType") != m.end() && !m["notifyObjectType"].empty()) {
      notifyObjectType = make_shared<long>(boost::any_cast<long>(m["notifyObjectType"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<long>(boost::any_cast<long>(m["scope"]));
    }
    if (m.find("scopeObjectList") != m.end() && !m["scopeObjectList"].empty()) {
      if (typeid(vector<boost::any>) == m["scopeObjectList"].type()) {
        vector<ListSubscriptionsResponseBodyDataScopeObjectList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["scopeObjectList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSubscriptionsResponseBodyDataScopeObjectList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scopeObjectList = make_shared<vector<ListSubscriptionsResponseBodyDataScopeObjectList>>(expect1);
      }
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("subscriptionId") != m.end() && !m["subscriptionId"].empty()) {
      subscriptionId = make_shared<long>(boost::any_cast<long>(m["subscriptionId"]));
    }
    if (m.find("subscriptionTitle") != m.end() && !m["subscriptionTitle"].empty()) {
      subscriptionTitle = make_shared<string>(boost::any_cast<string>(m["subscriptionTitle"]));
    }
  }


  virtual ~ListSubscriptionsResponseBodyData() = default;
};
class ListSubscriptionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListSubscriptionsResponseBodyData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListSubscriptionsResponseBody() {}

  explicit ListSubscriptionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListSubscriptionsResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSubscriptionsResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListSubscriptionsResponseBodyData>>(expect1);
      }
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ListSubscriptionsResponseBody() = default;
};
class ListSubscriptionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSubscriptionsResponseBody> body{};

  ListSubscriptionsResponse() {}

  explicit ListSubscriptionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSubscriptionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSubscriptionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListSubscriptionsResponse() = default;
};
class ListTrendForSourceEventRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<long> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<long> timeUnit{};

  ListTrendForSourceEventRequest() {}

  explicit ListTrendForSourceEventRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["instanceType"] = boost::any(*instanceType);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (timeUnit) {
      res["timeUnit"] = boost::any(*timeUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["instanceId"]));
    }
    if (m.find("instanceType") != m.end() && !m["instanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["instanceType"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
    if (m.find("timeUnit") != m.end() && !m["timeUnit"].empty()) {
      timeUnit = make_shared<long>(boost::any_cast<long>(m["timeUnit"]));
    }
  }


  virtual ~ListTrendForSourceEventRequest() = default;
};
class ListTrendForSourceEventResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> convergenceRate{};
  shared_ptr<long> maxSustainTime{};
  shared_ptr<bool> skipDay{};
  shared_ptr<map<string, boost::any>> sourceEventsStatMap{};
  shared_ptr<string> unit{};

  ListTrendForSourceEventResponseBodyData() {}

  explicit ListTrendForSourceEventResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (convergenceRate) {
      res["convergenceRate"] = boost::any(*convergenceRate);
    }
    if (maxSustainTime) {
      res["maxSustainTime"] = boost::any(*maxSustainTime);
    }
    if (skipDay) {
      res["skipDay"] = boost::any(*skipDay);
    }
    if (sourceEventsStatMap) {
      res["sourceEventsStatMap"] = boost::any(*sourceEventsStatMap);
    }
    if (unit) {
      res["unit"] = boost::any(*unit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("convergenceRate") != m.end() && !m["convergenceRate"].empty()) {
      convergenceRate = make_shared<string>(boost::any_cast<string>(m["convergenceRate"]));
    }
    if (m.find("maxSustainTime") != m.end() && !m["maxSustainTime"].empty()) {
      maxSustainTime = make_shared<long>(boost::any_cast<long>(m["maxSustainTime"]));
    }
    if (m.find("skipDay") != m.end() && !m["skipDay"].empty()) {
      skipDay = make_shared<bool>(boost::any_cast<bool>(m["skipDay"]));
    }
    if (m.find("sourceEventsStatMap") != m.end() && !m["sourceEventsStatMap"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["sourceEventsStatMap"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      sourceEventsStatMap = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("unit") != m.end() && !m["unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["unit"]));
    }
  }


  virtual ~ListTrendForSourceEventResponseBodyData() = default;
};
class ListTrendForSourceEventResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListTrendForSourceEventResponseBodyData>> data{};
  shared_ptr<string> requestId{};

  ListTrendForSourceEventResponseBody() {}

  explicit ListTrendForSourceEventResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListTrendForSourceEventResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTrendForSourceEventResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListTrendForSourceEventResponseBodyData>>(expect1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListTrendForSourceEventResponseBody() = default;
};
class ListTrendForSourceEventResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTrendForSourceEventResponseBody> body{};

  ListTrendForSourceEventResponse() {}

  explicit ListTrendForSourceEventResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTrendForSourceEventResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTrendForSourceEventResponseBody>(model1);
      }
    }
  }


  virtual ~ListTrendForSourceEventResponse() = default;
};
class ListUserSerivceGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> userId{};

  ListUserSerivceGroupsRequest() {}

  explicit ListUserSerivceGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
  }


  virtual ~ListUserSerivceGroupsRequest() = default;
};
class ListUserSerivceGroupsResponseBodyDataServiceGroups : public Darabonba::Model {
public:
  shared_ptr<string> serviceGroupDescription{};
  shared_ptr<long> serviceGroupId{};
  shared_ptr<string> serviceGroupName{};

  ListUserSerivceGroupsResponseBodyDataServiceGroups() {}

  explicit ListUserSerivceGroupsResponseBodyDataServiceGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceGroupDescription) {
      res["serviceGroupDescription"] = boost::any(*serviceGroupDescription);
    }
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    if (serviceGroupName) {
      res["serviceGroupName"] = boost::any(*serviceGroupName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("serviceGroupDescription") != m.end() && !m["serviceGroupDescription"].empty()) {
      serviceGroupDescription = make_shared<string>(boost::any_cast<string>(m["serviceGroupDescription"]));
    }
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
    if (m.find("serviceGroupName") != m.end() && !m["serviceGroupName"].empty()) {
      serviceGroupName = make_shared<string>(boost::any_cast<string>(m["serviceGroupName"]));
    }
  }


  virtual ~ListUserSerivceGroupsResponseBodyDataServiceGroups() = default;
};
class ListUserSerivceGroupsResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> email{};
  shared_ptr<string> phone{};
  shared_ptr<long> ramId{};
  shared_ptr<vector<ListUserSerivceGroupsResponseBodyDataServiceGroups>> serviceGroups{};
  shared_ptr<long> userId{};
  shared_ptr<string> username{};

  ListUserSerivceGroupsResponseBodyData() {}

  explicit ListUserSerivceGroupsResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (ramId) {
      res["ramId"] = boost::any(*ramId);
    }
    if (serviceGroups) {
      vector<boost::any> temp1;
      for(auto item1:*serviceGroups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["serviceGroups"] = boost::any(temp1);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("ramId") != m.end() && !m["ramId"].empty()) {
      ramId = make_shared<long>(boost::any_cast<long>(m["ramId"]));
    }
    if (m.find("serviceGroups") != m.end() && !m["serviceGroups"].empty()) {
      if (typeid(vector<boost::any>) == m["serviceGroups"].type()) {
        vector<ListUserSerivceGroupsResponseBodyDataServiceGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["serviceGroups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUserSerivceGroupsResponseBodyDataServiceGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        serviceGroups = make_shared<vector<ListUserSerivceGroupsResponseBodyDataServiceGroups>>(expect1);
      }
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~ListUserSerivceGroupsResponseBodyData() = default;
};
class ListUserSerivceGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListUserSerivceGroupsResponseBodyData> data{};
  shared_ptr<string> requestId{};

  ListUserSerivceGroupsResponseBody() {}

  explicit ListUserSerivceGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        ListUserSerivceGroupsResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<ListUserSerivceGroupsResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ListUserSerivceGroupsResponseBody() = default;
};
class ListUserSerivceGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUserSerivceGroupsResponseBody> body{};

  ListUserSerivceGroupsResponse() {}

  explicit ListUserSerivceGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUserSerivceGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUserSerivceGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListUserSerivceGroupsResponse() = default;
};
class ListUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> phone{};
  shared_ptr<string> ramId{};
  shared_ptr<long> scene{};
  shared_ptr<string> synergyChannel{};
  shared_ptr<string> username{};

  ListUsersRequest() {}

  explicit ListUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (ramId) {
      res["ramId"] = boost::any(*ramId);
    }
    if (scene) {
      res["scene"] = boost::any(*scene);
    }
    if (synergyChannel) {
      res["synergyChannel"] = boost::any(*synergyChannel);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("ramId") != m.end() && !m["ramId"].empty()) {
      ramId = make_shared<string>(boost::any_cast<string>(m["ramId"]));
    }
    if (m.find("scene") != m.end() && !m["scene"].empty()) {
      scene = make_shared<long>(boost::any_cast<long>(m["scene"]));
    }
    if (m.find("synergyChannel") != m.end() && !m["synergyChannel"].empty()) {
      synergyChannel = make_shared<string>(boost::any_cast<string>(m["synergyChannel"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~ListUsersRequest() = default;
};
class ListUsersResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> accountType{};
  shared_ptr<string> appAccount{};
  shared_ptr<string> email{};
  shared_ptr<long> isEditableUser{};
  shared_ptr<long> isOperation{};
  shared_ptr<long> isRam{};
  shared_ptr<string> isRelated{};
  shared_ptr<string> phone{};
  shared_ptr<long> ramId{};
  shared_ptr<string> synergyChannel{};
  shared_ptr<long> userId{};
  shared_ptr<string> username{};

  ListUsersResponseBodyData() {}

  explicit ListUsersResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accountType) {
      res["accountType"] = boost::any(*accountType);
    }
    if (appAccount) {
      res["appAccount"] = boost::any(*appAccount);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (isEditableUser) {
      res["isEditableUser"] = boost::any(*isEditableUser);
    }
    if (isOperation) {
      res["isOperation"] = boost::any(*isOperation);
    }
    if (isRam) {
      res["isRam"] = boost::any(*isRam);
    }
    if (isRelated) {
      res["isRelated"] = boost::any(*isRelated);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (ramId) {
      res["ramId"] = boost::any(*ramId);
    }
    if (synergyChannel) {
      res["synergyChannel"] = boost::any(*synergyChannel);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accountType") != m.end() && !m["accountType"].empty()) {
      accountType = make_shared<long>(boost::any_cast<long>(m["accountType"]));
    }
    if (m.find("appAccount") != m.end() && !m["appAccount"].empty()) {
      appAccount = make_shared<string>(boost::any_cast<string>(m["appAccount"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("isEditableUser") != m.end() && !m["isEditableUser"].empty()) {
      isEditableUser = make_shared<long>(boost::any_cast<long>(m["isEditableUser"]));
    }
    if (m.find("isOperation") != m.end() && !m["isOperation"].empty()) {
      isOperation = make_shared<long>(boost::any_cast<long>(m["isOperation"]));
    }
    if (m.find("isRam") != m.end() && !m["isRam"].empty()) {
      isRam = make_shared<long>(boost::any_cast<long>(m["isRam"]));
    }
    if (m.find("isRelated") != m.end() && !m["isRelated"].empty()) {
      isRelated = make_shared<string>(boost::any_cast<string>(m["isRelated"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("ramId") != m.end() && !m["ramId"].empty()) {
      ramId = make_shared<long>(boost::any_cast<long>(m["ramId"]));
    }
    if (m.find("synergyChannel") != m.end() && !m["synergyChannel"].empty()) {
      synergyChannel = make_shared<string>(boost::any_cast<string>(m["synergyChannel"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~ListUsersResponseBodyData() = default;
};
class ListUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListUsersResponseBodyData>> data{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  ListUsersResponseBody() {}

  explicit ListUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      vector<boost::any> temp1;
      for(auto item1:*data){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["data"] = boost::any(temp1);
    }
    if (pageNumber) {
      res["pageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(vector<boost::any>) == m["data"].type()) {
        vector<ListUsersResponseBodyData> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["data"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListUsersResponseBodyData model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        data = make_shared<vector<ListUsersResponseBodyData>>(expect1);
      }
    }
    if (m.find("pageNumber") != m.end() && !m["pageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["pageNumber"]));
    }
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
  }


  virtual ~ListUsersResponseBody() = default;
};
class ListUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListUsersResponseBody> body{};

  ListUsersResponse() {}

  explicit ListUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListUsersResponseBody>(model1);
      }
    }
  }


  virtual ~ListUsersResponse() = default;
};
class PushMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};

  PushMonitorRequest() {}

  explicit PushMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~PushMonitorRequest() = default;
};
class PushMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<boost::any> data{};
  shared_ptr<string> requestId{};

  PushMonitorResponseBody() {}

  explicit PushMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<boost::any>(boost::any_cast<boost::any>(m["data"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~PushMonitorResponseBody() = default;
};
class PushMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PushMonitorResponseBody> body{};

  PushMonitorResponse() {}

  explicit PushMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PushMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PushMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~PushMonitorResponse() = default;
};
class RecoverProblemRequest : public Darabonba::Model {
public:
  shared_ptr<long> problemId{};
  shared_ptr<string> problemNotifyType{};
  shared_ptr<string> recoveryTime{};

  RecoverProblemRequest() {}

  explicit RecoverProblemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    if (problemNotifyType) {
      res["problemNotifyType"] = boost::any(*problemNotifyType);
    }
    if (recoveryTime) {
      res["recoveryTime"] = boost::any(*recoveryTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
    if (m.find("problemNotifyType") != m.end() && !m["problemNotifyType"].empty()) {
      problemNotifyType = make_shared<string>(boost::any_cast<string>(m["problemNotifyType"]));
    }
    if (m.find("recoveryTime") != m.end() && !m["recoveryTime"].empty()) {
      recoveryTime = make_shared<string>(boost::any_cast<string>(m["recoveryTime"]));
    }
  }


  virtual ~RecoverProblemRequest() = default;
};
class RecoverProblemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RecoverProblemResponseBody() {}

  explicit RecoverProblemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~RecoverProblemResponseBody() = default;
};
class RecoverProblemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RecoverProblemResponseBody> body{};

  RecoverProblemResponse() {}

  explicit RecoverProblemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RecoverProblemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RecoverProblemResponseBody>(model1);
      }
    }
  }


  virtual ~RecoverProblemResponse() = default;
};
class RefreshIntegrationConfigKeyRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> integrationConfigId{};

  RefreshIntegrationConfigKeyRequest() {}

  explicit RefreshIntegrationConfigKeyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (integrationConfigId) {
      res["integrationConfigId"] = boost::any(*integrationConfigId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("integrationConfigId") != m.end() && !m["integrationConfigId"].empty()) {
      integrationConfigId = make_shared<long>(boost::any_cast<long>(m["integrationConfigId"]));
    }
  }


  virtual ~RefreshIntegrationConfigKeyRequest() = default;
};
class RefreshIntegrationConfigKeyResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<string> key{};

  RefreshIntegrationConfigKeyResponseBodyData() {}

  explicit RefreshIntegrationConfigKeyResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
  }


  virtual ~RefreshIntegrationConfigKeyResponseBodyData() = default;
};
class RefreshIntegrationConfigKeyResponseBody : public Darabonba::Model {
public:
  shared_ptr<RefreshIntegrationConfigKeyResponseBodyData> data{};
  shared_ptr<string> requestId{};

  RefreshIntegrationConfigKeyResponseBody() {}

  explicit RefreshIntegrationConfigKeyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        RefreshIntegrationConfigKeyResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<RefreshIntegrationConfigKeyResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~RefreshIntegrationConfigKeyResponseBody() = default;
};
class RefreshIntegrationConfigKeyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RefreshIntegrationConfigKeyResponseBody> body{};

  RefreshIntegrationConfigKeyResponse() {}

  explicit RefreshIntegrationConfigKeyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefreshIntegrationConfigKeyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefreshIntegrationConfigKeyResponseBody>(model1);
      }
    }
  }


  virtual ~RefreshIntegrationConfigKeyResponse() = default;
};
class RemoveIntegrationConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> integrationConfigId{};

  RemoveIntegrationConfigRequest() {}

  explicit RemoveIntegrationConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (integrationConfigId) {
      res["integrationConfigId"] = boost::any(*integrationConfigId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("integrationConfigId") != m.end() && !m["integrationConfigId"].empty()) {
      integrationConfigId = make_shared<long>(boost::any_cast<long>(m["integrationConfigId"]));
    }
  }


  virtual ~RemoveIntegrationConfigRequest() = default;
};
class RemoveIntegrationConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveIntegrationConfigResponseBody() {}

  explicit RemoveIntegrationConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~RemoveIntegrationConfigResponseBody() = default;
};
class RemoveIntegrationConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveIntegrationConfigResponseBody> body{};

  RemoveIntegrationConfigResponse() {}

  explicit RemoveIntegrationConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveIntegrationConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveIntegrationConfigResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveIntegrationConfigResponse() = default;
};
class RemoveProblemServiceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> problemId{};
  shared_ptr<vector<long>> serviceGroupIds{};

  RemoveProblemServiceGroupRequest() {}

  explicit RemoveProblemServiceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    if (serviceGroupIds) {
      res["serviceGroupIds"] = boost::any(*serviceGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
    if (m.find("serviceGroupIds") != m.end() && !m["serviceGroupIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["serviceGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["serviceGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      serviceGroupIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~RemoveProblemServiceGroupRequest() = default;
};
class RemoveProblemServiceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveProblemServiceGroupResponseBody() {}

  explicit RemoveProblemServiceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~RemoveProblemServiceGroupResponseBody() = default;
};
class RemoveProblemServiceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveProblemServiceGroupResponseBody> body{};

  RemoveProblemServiceGroupResponse() {}

  explicit RemoveProblemServiceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveProblemServiceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveProblemServiceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveProblemServiceGroupResponse() = default;
};
class ReplayProblemRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> problemId{};
  shared_ptr<long> replayDutyUserId{};

  ReplayProblemRequest() {}

  explicit ReplayProblemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    if (replayDutyUserId) {
      res["replayDutyUserId"] = boost::any(*replayDutyUserId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
    if (m.find("replayDutyUserId") != m.end() && !m["replayDutyUserId"].empty()) {
      replayDutyUserId = make_shared<long>(boost::any_cast<long>(m["replayDutyUserId"]));
    }
  }


  virtual ~ReplayProblemRequest() = default;
};
class ReplayProblemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ReplayProblemResponseBody() {}

  explicit ReplayProblemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~ReplayProblemResponseBody() = default;
};
class ReplayProblemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReplayProblemResponseBody> body{};

  ReplayProblemResponse() {}

  explicit ReplayProblemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReplayProblemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReplayProblemResponseBody>(model1);
      }
    }
  }


  virtual ~ReplayProblemResponse() = default;
};
class RespondIncidentRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<vector<long>> incidentIds{};

  RespondIncidentRequest() {}

  explicit RespondIncidentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (incidentIds) {
      res["incidentIds"] = boost::any(*incidentIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("incidentIds") != m.end() && !m["incidentIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["incidentIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["incidentIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      incidentIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~RespondIncidentRequest() = default;
};
class RespondIncidentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RespondIncidentResponseBody() {}

  explicit RespondIncidentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~RespondIncidentResponseBody() = default;
};
class RespondIncidentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RespondIncidentResponseBody> body{};

  RespondIncidentResponse() {}

  explicit RespondIncidentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RespondIncidentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RespondIncidentResponseBody>(model1);
      }
    }
  }


  virtual ~RespondIncidentResponse() = default;
};
class RevokeProblemRecoveryRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> problemId{};
  shared_ptr<string> problemNotifyType{};

  RevokeProblemRecoveryRequest() {}

  explicit RevokeProblemRecoveryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    if (problemNotifyType) {
      res["problemNotifyType"] = boost::any(*problemNotifyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
    if (m.find("problemNotifyType") != m.end() && !m["problemNotifyType"].empty()) {
      problemNotifyType = make_shared<string>(boost::any_cast<string>(m["problemNotifyType"]));
    }
  }


  virtual ~RevokeProblemRecoveryRequest() = default;
};
class RevokeProblemRecoveryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RevokeProblemRecoveryResponseBody() {}

  explicit RevokeProblemRecoveryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~RevokeProblemRecoveryResponseBody() = default;
};
class RevokeProblemRecoveryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RevokeProblemRecoveryResponseBody> body{};

  RevokeProblemRecoveryResponse() {}

  explicit RevokeProblemRecoveryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokeProblemRecoveryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokeProblemRecoveryResponseBody>(model1);
      }
    }
  }


  virtual ~RevokeProblemRecoveryResponse() = default;
};
class UnbindUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnbindUserResponseBody() {}

  explicit UnbindUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UnbindUserResponseBody() = default;
};
class UnbindUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UnbindUserResponseBody> body{};

  UnbindUserResponse() {}

  explicit UnbindUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindUserResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindUserResponse() = default;
};
class UpdateEscalationPlanRequestEscalationPlanRulesEscalationPlanConditions : public Darabonba::Model {
public:
  shared_ptr<string> effection{};
  shared_ptr<string> level{};

  UpdateEscalationPlanRequestEscalationPlanRulesEscalationPlanConditions() {}

  explicit UpdateEscalationPlanRequestEscalationPlanRulesEscalationPlanConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (effection) {
      res["effection"] = boost::any(*effection);
    }
    if (level) {
      res["level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("effection") != m.end() && !m["effection"].empty()) {
      effection = make_shared<string>(boost::any_cast<string>(m["effection"]));
    }
    if (m.find("level") != m.end() && !m["level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["level"]));
    }
  }


  virtual ~UpdateEscalationPlanRequestEscalationPlanRulesEscalationPlanConditions() = default;
};
class UpdateEscalationPlanRequestEscalationPlanRulesEscalationPlanStrategies : public Darabonba::Model {
public:
  shared_ptr<bool> enableWebhook{};
  shared_ptr<vector<string>> noticeChannels{};
  shared_ptr<vector<long>> noticeObjects{};
  shared_ptr<long> noticeTime{};
  shared_ptr<vector<long>> serviceGroupIds{};

  UpdateEscalationPlanRequestEscalationPlanRulesEscalationPlanStrategies() {}

  explicit UpdateEscalationPlanRequestEscalationPlanRulesEscalationPlanStrategies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enableWebhook) {
      res["enableWebhook"] = boost::any(*enableWebhook);
    }
    if (noticeChannels) {
      res["noticeChannels"] = boost::any(*noticeChannels);
    }
    if (noticeObjects) {
      res["noticeObjects"] = boost::any(*noticeObjects);
    }
    if (noticeTime) {
      res["noticeTime"] = boost::any(*noticeTime);
    }
    if (serviceGroupIds) {
      res["serviceGroupIds"] = boost::any(*serviceGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enableWebhook") != m.end() && !m["enableWebhook"].empty()) {
      enableWebhook = make_shared<bool>(boost::any_cast<bool>(m["enableWebhook"]));
    }
    if (m.find("noticeChannels") != m.end() && !m["noticeChannels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["noticeChannels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["noticeChannels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      noticeChannels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("noticeObjects") != m.end() && !m["noticeObjects"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["noticeObjects"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["noticeObjects"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      noticeObjects = make_shared<vector<long>>(toVec1);
    }
    if (m.find("noticeTime") != m.end() && !m["noticeTime"].empty()) {
      noticeTime = make_shared<long>(boost::any_cast<long>(m["noticeTime"]));
    }
    if (m.find("serviceGroupIds") != m.end() && !m["serviceGroupIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["serviceGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["serviceGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      serviceGroupIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~UpdateEscalationPlanRequestEscalationPlanRulesEscalationPlanStrategies() = default;
};
class UpdateEscalationPlanRequestEscalationPlanRules : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateEscalationPlanRequestEscalationPlanRulesEscalationPlanConditions>> escalationPlanConditions{};
  shared_ptr<vector<UpdateEscalationPlanRequestEscalationPlanRulesEscalationPlanStrategies>> escalationPlanStrategies{};
  shared_ptr<string> escalationPlanType{};
  shared_ptr<long> id{};

  UpdateEscalationPlanRequestEscalationPlanRules() {}

  explicit UpdateEscalationPlanRequestEscalationPlanRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalationPlanConditions) {
      vector<boost::any> temp1;
      for(auto item1:*escalationPlanConditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["escalationPlanConditions"] = boost::any(temp1);
    }
    if (escalationPlanStrategies) {
      vector<boost::any> temp1;
      for(auto item1:*escalationPlanStrategies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["escalationPlanStrategies"] = boost::any(temp1);
    }
    if (escalationPlanType) {
      res["escalationPlanType"] = boost::any(*escalationPlanType);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("escalationPlanConditions") != m.end() && !m["escalationPlanConditions"].empty()) {
      if (typeid(vector<boost::any>) == m["escalationPlanConditions"].type()) {
        vector<UpdateEscalationPlanRequestEscalationPlanRulesEscalationPlanConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["escalationPlanConditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateEscalationPlanRequestEscalationPlanRulesEscalationPlanConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        escalationPlanConditions = make_shared<vector<UpdateEscalationPlanRequestEscalationPlanRulesEscalationPlanConditions>>(expect1);
      }
    }
    if (m.find("escalationPlanStrategies") != m.end() && !m["escalationPlanStrategies"].empty()) {
      if (typeid(vector<boost::any>) == m["escalationPlanStrategies"].type()) {
        vector<UpdateEscalationPlanRequestEscalationPlanRulesEscalationPlanStrategies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["escalationPlanStrategies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateEscalationPlanRequestEscalationPlanRulesEscalationPlanStrategies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        escalationPlanStrategies = make_shared<vector<UpdateEscalationPlanRequestEscalationPlanRulesEscalationPlanStrategies>>(expect1);
      }
    }
    if (m.find("escalationPlanType") != m.end() && !m["escalationPlanType"].empty()) {
      escalationPlanType = make_shared<string>(boost::any_cast<string>(m["escalationPlanType"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
  }


  virtual ~UpdateEscalationPlanRequestEscalationPlanRules() = default;
};
class UpdateEscalationPlanRequestEscalationPlanScopeObjects : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<string> scope{};
  shared_ptr<long> scopeObjectId{};

  UpdateEscalationPlanRequestEscalationPlanScopeObjects() {}

  explicit UpdateEscalationPlanRequestEscalationPlanScopeObjects(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (scopeObjectId) {
      res["scopeObjectId"] = boost::any(*scopeObjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
    if (m.find("scopeObjectId") != m.end() && !m["scopeObjectId"].empty()) {
      scopeObjectId = make_shared<long>(boost::any_cast<long>(m["scopeObjectId"]));
    }
  }


  virtual ~UpdateEscalationPlanRequestEscalationPlanScopeObjects() = default;
};
class UpdateEscalationPlanRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> escalationPlanDescription{};
  shared_ptr<long> escalationPlanId{};
  shared_ptr<string> escalationPlanName{};
  shared_ptr<vector<UpdateEscalationPlanRequestEscalationPlanRules>> escalationPlanRules{};
  shared_ptr<vector<UpdateEscalationPlanRequestEscalationPlanScopeObjects>> escalationPlanScopeObjects{};

  UpdateEscalationPlanRequest() {}

  explicit UpdateEscalationPlanRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (escalationPlanDescription) {
      res["escalationPlanDescription"] = boost::any(*escalationPlanDescription);
    }
    if (escalationPlanId) {
      res["escalationPlanId"] = boost::any(*escalationPlanId);
    }
    if (escalationPlanName) {
      res["escalationPlanName"] = boost::any(*escalationPlanName);
    }
    if (escalationPlanRules) {
      vector<boost::any> temp1;
      for(auto item1:*escalationPlanRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["escalationPlanRules"] = boost::any(temp1);
    }
    if (escalationPlanScopeObjects) {
      vector<boost::any> temp1;
      for(auto item1:*escalationPlanScopeObjects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["escalationPlanScopeObjects"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("escalationPlanDescription") != m.end() && !m["escalationPlanDescription"].empty()) {
      escalationPlanDescription = make_shared<string>(boost::any_cast<string>(m["escalationPlanDescription"]));
    }
    if (m.find("escalationPlanId") != m.end() && !m["escalationPlanId"].empty()) {
      escalationPlanId = make_shared<long>(boost::any_cast<long>(m["escalationPlanId"]));
    }
    if (m.find("escalationPlanName") != m.end() && !m["escalationPlanName"].empty()) {
      escalationPlanName = make_shared<string>(boost::any_cast<string>(m["escalationPlanName"]));
    }
    if (m.find("escalationPlanRules") != m.end() && !m["escalationPlanRules"].empty()) {
      if (typeid(vector<boost::any>) == m["escalationPlanRules"].type()) {
        vector<UpdateEscalationPlanRequestEscalationPlanRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["escalationPlanRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateEscalationPlanRequestEscalationPlanRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        escalationPlanRules = make_shared<vector<UpdateEscalationPlanRequestEscalationPlanRules>>(expect1);
      }
    }
    if (m.find("escalationPlanScopeObjects") != m.end() && !m["escalationPlanScopeObjects"].empty()) {
      if (typeid(vector<boost::any>) == m["escalationPlanScopeObjects"].type()) {
        vector<UpdateEscalationPlanRequestEscalationPlanScopeObjects> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["escalationPlanScopeObjects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateEscalationPlanRequestEscalationPlanScopeObjects model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        escalationPlanScopeObjects = make_shared<vector<UpdateEscalationPlanRequestEscalationPlanScopeObjects>>(expect1);
      }
    }
  }


  virtual ~UpdateEscalationPlanRequest() = default;
};
class UpdateEscalationPlanResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateEscalationPlanResponseBody() {}

  explicit UpdateEscalationPlanResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateEscalationPlanResponseBody() = default;
};
class UpdateEscalationPlanResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateEscalationPlanResponseBody> body{};

  UpdateEscalationPlanResponse() {}

  explicit UpdateEscalationPlanResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEscalationPlanResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEscalationPlanResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEscalationPlanResponse() = default;
};
class UpdateIncidentRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> effect{};
  shared_ptr<long> incidentId{};
  shared_ptr<string> incidentLevel{};
  shared_ptr<string> incidentTitle{};

  UpdateIncidentRequest() {}

  explicit UpdateIncidentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (effect) {
      res["effect"] = boost::any(*effect);
    }
    if (incidentId) {
      res["incidentId"] = boost::any(*incidentId);
    }
    if (incidentLevel) {
      res["incidentLevel"] = boost::any(*incidentLevel);
    }
    if (incidentTitle) {
      res["incidentTitle"] = boost::any(*incidentTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("effect") != m.end() && !m["effect"].empty()) {
      effect = make_shared<string>(boost::any_cast<string>(m["effect"]));
    }
    if (m.find("incidentId") != m.end() && !m["incidentId"].empty()) {
      incidentId = make_shared<long>(boost::any_cast<long>(m["incidentId"]));
    }
    if (m.find("incidentLevel") != m.end() && !m["incidentLevel"].empty()) {
      incidentLevel = make_shared<string>(boost::any_cast<string>(m["incidentLevel"]));
    }
    if (m.find("incidentTitle") != m.end() && !m["incidentTitle"].empty()) {
      incidentTitle = make_shared<string>(boost::any_cast<string>(m["incidentTitle"]));
    }
  }


  virtual ~UpdateIncidentRequest() = default;
};
class UpdateIncidentResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> incidentId{};

  UpdateIncidentResponseBodyData() {}

  explicit UpdateIncidentResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (incidentId) {
      res["incidentId"] = boost::any(*incidentId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("incidentId") != m.end() && !m["incidentId"].empty()) {
      incidentId = make_shared<long>(boost::any_cast<long>(m["incidentId"]));
    }
  }


  virtual ~UpdateIncidentResponseBodyData() = default;
};
class UpdateIncidentResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdateIncidentResponseBodyData> data{};
  shared_ptr<string> requestId{};

  UpdateIncidentResponseBody() {}

  explicit UpdateIncidentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        UpdateIncidentResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<UpdateIncidentResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateIncidentResponseBody() = default;
};
class UpdateIncidentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateIncidentResponseBody> body{};

  UpdateIncidentResponse() {}

  explicit UpdateIncidentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateIncidentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateIncidentResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateIncidentResponse() = default;
};
class UpdateIntegrationConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessKey{};
  shared_ptr<string> clientToken{};
  shared_ptr<long> integrationConfigId{};

  UpdateIntegrationConfigRequest() {}

  explicit UpdateIntegrationConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessKey) {
      res["accessKey"] = boost::any(*accessKey);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (integrationConfigId) {
      res["integrationConfigId"] = boost::any(*integrationConfigId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("accessKey") != m.end() && !m["accessKey"].empty()) {
      accessKey = make_shared<string>(boost::any_cast<string>(m["accessKey"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("integrationConfigId") != m.end() && !m["integrationConfigId"].empty()) {
      integrationConfigId = make_shared<long>(boost::any_cast<long>(m["integrationConfigId"]));
    }
  }


  virtual ~UpdateIntegrationConfigRequest() = default;
};
class UpdateIntegrationConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateIntegrationConfigResponseBody() {}

  explicit UpdateIntegrationConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateIntegrationConfigResponseBody() = default;
};
class UpdateIntegrationConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateIntegrationConfigResponseBody> body{};

  UpdateIntegrationConfigResponse() {}

  explicit UpdateIntegrationConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateIntegrationConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateIntegrationConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateIntegrationConfigResponse() = default;
};
class UpdateProblemRequest : public Darabonba::Model {
public:
  shared_ptr<string> feedback{};
  shared_ptr<string> level{};
  shared_ptr<long> mainHandlerId{};
  shared_ptr<string> preliminaryReason{};
  shared_ptr<long> problemId{};
  shared_ptr<string> problemName{};
  shared_ptr<string> progressSummary{};
  shared_ptr<long> progressSummaryRichTextId{};
  shared_ptr<long> relatedServiceId{};
  shared_ptr<vector<long>> serviceGroupIds{};

  UpdateProblemRequest() {}

  explicit UpdateProblemRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feedback) {
      res["feedback"] = boost::any(*feedback);
    }
    if (level) {
      res["level"] = boost::any(*level);
    }
    if (mainHandlerId) {
      res["mainHandlerId"] = boost::any(*mainHandlerId);
    }
    if (preliminaryReason) {
      res["preliminaryReason"] = boost::any(*preliminaryReason);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    if (problemName) {
      res["problemName"] = boost::any(*problemName);
    }
    if (progressSummary) {
      res["progressSummary"] = boost::any(*progressSummary);
    }
    if (progressSummaryRichTextId) {
      res["progressSummaryRichTextId"] = boost::any(*progressSummaryRichTextId);
    }
    if (relatedServiceId) {
      res["relatedServiceId"] = boost::any(*relatedServiceId);
    }
    if (serviceGroupIds) {
      res["serviceGroupIds"] = boost::any(*serviceGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("feedback") != m.end() && !m["feedback"].empty()) {
      feedback = make_shared<string>(boost::any_cast<string>(m["feedback"]));
    }
    if (m.find("level") != m.end() && !m["level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["level"]));
    }
    if (m.find("mainHandlerId") != m.end() && !m["mainHandlerId"].empty()) {
      mainHandlerId = make_shared<long>(boost::any_cast<long>(m["mainHandlerId"]));
    }
    if (m.find("preliminaryReason") != m.end() && !m["preliminaryReason"].empty()) {
      preliminaryReason = make_shared<string>(boost::any_cast<string>(m["preliminaryReason"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
    if (m.find("problemName") != m.end() && !m["problemName"].empty()) {
      problemName = make_shared<string>(boost::any_cast<string>(m["problemName"]));
    }
    if (m.find("progressSummary") != m.end() && !m["progressSummary"].empty()) {
      progressSummary = make_shared<string>(boost::any_cast<string>(m["progressSummary"]));
    }
    if (m.find("progressSummaryRichTextId") != m.end() && !m["progressSummaryRichTextId"].empty()) {
      progressSummaryRichTextId = make_shared<long>(boost::any_cast<long>(m["progressSummaryRichTextId"]));
    }
    if (m.find("relatedServiceId") != m.end() && !m["relatedServiceId"].empty()) {
      relatedServiceId = make_shared<long>(boost::any_cast<long>(m["relatedServiceId"]));
    }
    if (m.find("serviceGroupIds") != m.end() && !m["serviceGroupIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["serviceGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["serviceGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      serviceGroupIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~UpdateProblemRequest() = default;
};
class UpdateProblemResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateProblemResponseBody() {}

  explicit UpdateProblemResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateProblemResponseBody() = default;
};
class UpdateProblemResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateProblemResponseBody> body{};

  UpdateProblemResponse() {}

  explicit UpdateProblemResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateProblemResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateProblemResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateProblemResponse() = default;
};
class UpdateProblemEffectionServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> description{};
  shared_ptr<long> effectionServiceId{};
  shared_ptr<string> level{};
  shared_ptr<vector<string>> picUrl{};
  shared_ptr<long> problemId{};
  shared_ptr<long> serviceId{};
  shared_ptr<string> status{};

  UpdateProblemEffectionServiceRequest() {}

  explicit UpdateProblemEffectionServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (effectionServiceId) {
      res["effectionServiceId"] = boost::any(*effectionServiceId);
    }
    if (level) {
      res["level"] = boost::any(*level);
    }
    if (picUrl) {
      res["picUrl"] = boost::any(*picUrl);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    if (serviceId) {
      res["serviceId"] = boost::any(*serviceId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("effectionServiceId") != m.end() && !m["effectionServiceId"].empty()) {
      effectionServiceId = make_shared<long>(boost::any_cast<long>(m["effectionServiceId"]));
    }
    if (m.find("level") != m.end() && !m["level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["level"]));
    }
    if (m.find("picUrl") != m.end() && !m["picUrl"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["picUrl"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["picUrl"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      picUrl = make_shared<vector<string>>(toVec1);
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
    if (m.find("serviceId") != m.end() && !m["serviceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["serviceId"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~UpdateProblemEffectionServiceRequest() = default;
};
class UpdateProblemEffectionServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateProblemEffectionServiceResponseBody() {}

  explicit UpdateProblemEffectionServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateProblemEffectionServiceResponseBody() = default;
};
class UpdateProblemEffectionServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateProblemEffectionServiceResponseBody> body{};

  UpdateProblemEffectionServiceResponse() {}

  explicit UpdateProblemEffectionServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateProblemEffectionServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateProblemEffectionServiceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateProblemEffectionServiceResponse() = default;
};
class UpdateProblemImprovementRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> customProblemReason{};
  shared_ptr<long> discoverSource{};
  shared_ptr<long> dutyDepartmentId{};
  shared_ptr<string> dutyDepartmentName{};
  shared_ptr<long> dutyUserId{};
  shared_ptr<string> injectionMode{};
  shared_ptr<string> monitorSourceName{};
  shared_ptr<long> problemId{};
  shared_ptr<string> problemReason{};
  shared_ptr<string> recentActivity{};
  shared_ptr<string> recoveryMode{};
  shared_ptr<string> relationChanges{};
  shared_ptr<string> remark{};
  shared_ptr<long> replayDutyUserId{};
  shared_ptr<long> userReport{};

  UpdateProblemImprovementRequest() {}

  explicit UpdateProblemImprovementRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (customProblemReason) {
      res["customProblemReason"] = boost::any(*customProblemReason);
    }
    if (discoverSource) {
      res["discoverSource"] = boost::any(*discoverSource);
    }
    if (dutyDepartmentId) {
      res["dutyDepartmentId"] = boost::any(*dutyDepartmentId);
    }
    if (dutyDepartmentName) {
      res["dutyDepartmentName"] = boost::any(*dutyDepartmentName);
    }
    if (dutyUserId) {
      res["dutyUserId"] = boost::any(*dutyUserId);
    }
    if (injectionMode) {
      res["injectionMode"] = boost::any(*injectionMode);
    }
    if (monitorSourceName) {
      res["monitorSourceName"] = boost::any(*monitorSourceName);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    if (problemReason) {
      res["problemReason"] = boost::any(*problemReason);
    }
    if (recentActivity) {
      res["recentActivity"] = boost::any(*recentActivity);
    }
    if (recoveryMode) {
      res["recoveryMode"] = boost::any(*recoveryMode);
    }
    if (relationChanges) {
      res["relationChanges"] = boost::any(*relationChanges);
    }
    if (remark) {
      res["remark"] = boost::any(*remark);
    }
    if (replayDutyUserId) {
      res["replayDutyUserId"] = boost::any(*replayDutyUserId);
    }
    if (userReport) {
      res["userReport"] = boost::any(*userReport);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("customProblemReason") != m.end() && !m["customProblemReason"].empty()) {
      customProblemReason = make_shared<string>(boost::any_cast<string>(m["customProblemReason"]));
    }
    if (m.find("discoverSource") != m.end() && !m["discoverSource"].empty()) {
      discoverSource = make_shared<long>(boost::any_cast<long>(m["discoverSource"]));
    }
    if (m.find("dutyDepartmentId") != m.end() && !m["dutyDepartmentId"].empty()) {
      dutyDepartmentId = make_shared<long>(boost::any_cast<long>(m["dutyDepartmentId"]));
    }
    if (m.find("dutyDepartmentName") != m.end() && !m["dutyDepartmentName"].empty()) {
      dutyDepartmentName = make_shared<string>(boost::any_cast<string>(m["dutyDepartmentName"]));
    }
    if (m.find("dutyUserId") != m.end() && !m["dutyUserId"].empty()) {
      dutyUserId = make_shared<long>(boost::any_cast<long>(m["dutyUserId"]));
    }
    if (m.find("injectionMode") != m.end() && !m["injectionMode"].empty()) {
      injectionMode = make_shared<string>(boost::any_cast<string>(m["injectionMode"]));
    }
    if (m.find("monitorSourceName") != m.end() && !m["monitorSourceName"].empty()) {
      monitorSourceName = make_shared<string>(boost::any_cast<string>(m["monitorSourceName"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
    if (m.find("problemReason") != m.end() && !m["problemReason"].empty()) {
      problemReason = make_shared<string>(boost::any_cast<string>(m["problemReason"]));
    }
    if (m.find("recentActivity") != m.end() && !m["recentActivity"].empty()) {
      recentActivity = make_shared<string>(boost::any_cast<string>(m["recentActivity"]));
    }
    if (m.find("recoveryMode") != m.end() && !m["recoveryMode"].empty()) {
      recoveryMode = make_shared<string>(boost::any_cast<string>(m["recoveryMode"]));
    }
    if (m.find("relationChanges") != m.end() && !m["relationChanges"].empty()) {
      relationChanges = make_shared<string>(boost::any_cast<string>(m["relationChanges"]));
    }
    if (m.find("remark") != m.end() && !m["remark"].empty()) {
      remark = make_shared<string>(boost::any_cast<string>(m["remark"]));
    }
    if (m.find("replayDutyUserId") != m.end() && !m["replayDutyUserId"].empty()) {
      replayDutyUserId = make_shared<long>(boost::any_cast<long>(m["replayDutyUserId"]));
    }
    if (m.find("userReport") != m.end() && !m["userReport"].empty()) {
      userReport = make_shared<long>(boost::any_cast<long>(m["userReport"]));
    }
  }


  virtual ~UpdateProblemImprovementRequest() = default;
};
class UpdateProblemImprovementResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateProblemImprovementResponseBody() {}

  explicit UpdateProblemImprovementResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateProblemImprovementResponseBody() = default;
};
class UpdateProblemImprovementResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateProblemImprovementResponseBody> body{};

  UpdateProblemImprovementResponse() {}

  explicit UpdateProblemImprovementResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateProblemImprovementResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateProblemImprovementResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateProblemImprovementResponse() = default;
};
class UpdateProblemMeasureRequest : public Darabonba::Model {
public:
  shared_ptr<string> checkStandard{};
  shared_ptr<long> checkUserId{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> content{};
  shared_ptr<long> directorId{};
  shared_ptr<long> measureId{};
  shared_ptr<string> planFinishTime{};
  shared_ptr<long> problemId{};
  shared_ptr<long> stalkerId{};
  shared_ptr<string> status{};
  shared_ptr<long> type{};

  UpdateProblemMeasureRequest() {}

  explicit UpdateProblemMeasureRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (checkStandard) {
      res["checkStandard"] = boost::any(*checkStandard);
    }
    if (checkUserId) {
      res["checkUserId"] = boost::any(*checkUserId);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (directorId) {
      res["directorId"] = boost::any(*directorId);
    }
    if (measureId) {
      res["measureId"] = boost::any(*measureId);
    }
    if (planFinishTime) {
      res["planFinishTime"] = boost::any(*planFinishTime);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    if (stalkerId) {
      res["stalkerId"] = boost::any(*stalkerId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("checkStandard") != m.end() && !m["checkStandard"].empty()) {
      checkStandard = make_shared<string>(boost::any_cast<string>(m["checkStandard"]));
    }
    if (m.find("checkUserId") != m.end() && !m["checkUserId"].empty()) {
      checkUserId = make_shared<long>(boost::any_cast<long>(m["checkUserId"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("directorId") != m.end() && !m["directorId"].empty()) {
      directorId = make_shared<long>(boost::any_cast<long>(m["directorId"]));
    }
    if (m.find("measureId") != m.end() && !m["measureId"].empty()) {
      measureId = make_shared<long>(boost::any_cast<long>(m["measureId"]));
    }
    if (m.find("planFinishTime") != m.end() && !m["planFinishTime"].empty()) {
      planFinishTime = make_shared<string>(boost::any_cast<string>(m["planFinishTime"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
    if (m.find("stalkerId") != m.end() && !m["stalkerId"].empty()) {
      stalkerId = make_shared<long>(boost::any_cast<long>(m["stalkerId"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["type"]));
    }
  }


  virtual ~UpdateProblemMeasureRequest() = default;
};
class UpdateProblemMeasureResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateProblemMeasureResponseBody() {}

  explicit UpdateProblemMeasureResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateProblemMeasureResponseBody() = default;
};
class UpdateProblemMeasureResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateProblemMeasureResponseBody> body{};

  UpdateProblemMeasureResponse() {}

  explicit UpdateProblemMeasureResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateProblemMeasureResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateProblemMeasureResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateProblemMeasureResponse() = default;
};
class UpdateProblemNoticeRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<long> problemId{};
  shared_ptr<string> problemNotifyType{};

  UpdateProblemNoticeRequest() {}

  explicit UpdateProblemNoticeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    if (problemNotifyType) {
      res["problemNotifyType"] = boost::any(*problemNotifyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
    if (m.find("problemNotifyType") != m.end() && !m["problemNotifyType"].empty()) {
      problemNotifyType = make_shared<string>(boost::any_cast<string>(m["problemNotifyType"]));
    }
  }


  virtual ~UpdateProblemNoticeRequest() = default;
};
class UpdateProblemNoticeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateProblemNoticeResponseBody() {}

  explicit UpdateProblemNoticeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateProblemNoticeResponseBody() = default;
};
class UpdateProblemNoticeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateProblemNoticeResponseBody> body{};

  UpdateProblemNoticeResponse() {}

  explicit UpdateProblemNoticeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateProblemNoticeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateProblemNoticeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateProblemNoticeResponse() = default;
};
class UpdateProblemTimelineRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> content{};
  shared_ptr<string> keyNode{};
  shared_ptr<long> problemId{};
  shared_ptr<long> problemTimelineId{};
  shared_ptr<string> time{};

  UpdateProblemTimelineRequest() {}

  explicit UpdateProblemTimelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (keyNode) {
      res["keyNode"] = boost::any(*keyNode);
    }
    if (problemId) {
      res["problemId"] = boost::any(*problemId);
    }
    if (problemTimelineId) {
      res["problemTimelineId"] = boost::any(*problemTimelineId);
    }
    if (time) {
      res["time"] = boost::any(*time);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("keyNode") != m.end() && !m["keyNode"].empty()) {
      keyNode = make_shared<string>(boost::any_cast<string>(m["keyNode"]));
    }
    if (m.find("problemId") != m.end() && !m["problemId"].empty()) {
      problemId = make_shared<long>(boost::any_cast<long>(m["problemId"]));
    }
    if (m.find("problemTimelineId") != m.end() && !m["problemTimelineId"].empty()) {
      problemTimelineId = make_shared<long>(boost::any_cast<long>(m["problemTimelineId"]));
    }
    if (m.find("time") != m.end() && !m["time"].empty()) {
      time = make_shared<string>(boost::any_cast<string>(m["time"]));
    }
  }


  virtual ~UpdateProblemTimelineRequest() = default;
};
class UpdateProblemTimelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateProblemTimelineResponseBody() {}

  explicit UpdateProblemTimelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateProblemTimelineResponseBody() = default;
};
class UpdateProblemTimelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateProblemTimelineResponseBody> body{};

  UpdateProblemTimelineResponse() {}

  explicit UpdateProblemTimelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateProblemTimelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateProblemTimelineResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateProblemTimelineResponse() = default;
};
class UpdateRichTextRequest : public Darabonba::Model {
public:
  shared_ptr<long> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> richText{};
  shared_ptr<long> richTextId{};

  UpdateRichTextRequest() {}

  explicit UpdateRichTextRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["instanceType"] = boost::any(*instanceType);
    }
    if (richText) {
      res["richText"] = boost::any(*richText);
    }
    if (richTextId) {
      res["richTextId"] = boost::any(*richTextId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<long>(boost::any_cast<long>(m["instanceId"]));
    }
    if (m.find("instanceType") != m.end() && !m["instanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["instanceType"]));
    }
    if (m.find("richText") != m.end() && !m["richText"].empty()) {
      richText = make_shared<string>(boost::any_cast<string>(m["richText"]));
    }
    if (m.find("richTextId") != m.end() && !m["richTextId"].empty()) {
      richTextId = make_shared<long>(boost::any_cast<long>(m["richTextId"]));
    }
  }


  virtual ~UpdateRichTextRequest() = default;
};
class UpdateRichTextResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<long> id{};

  UpdateRichTextResponseBodyData() {}

  explicit UpdateRichTextResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
  }


  virtual ~UpdateRichTextResponseBodyData() = default;
};
class UpdateRichTextResponseBody : public Darabonba::Model {
public:
  shared_ptr<UpdateRichTextResponseBodyData> data{};
  shared_ptr<string> requestId{};

  UpdateRichTextResponseBody() {}

  explicit UpdateRichTextResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        UpdateRichTextResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<UpdateRichTextResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateRichTextResponseBody() = default;
};
class UpdateRichTextResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateRichTextResponseBody> body{};

  UpdateRichTextResponse() {}

  explicit UpdateRichTextResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateRichTextResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateRichTextResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateRichTextResponse() = default;
};
class UpdateRouteRuleRequestRouteChildRulesConditions : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> operationSymbol{};
  shared_ptr<string> value{};

  UpdateRouteRuleRequestRouteChildRulesConditions() {}

  explicit UpdateRouteRuleRequestRouteChildRulesConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (operationSymbol) {
      res["operationSymbol"] = boost::any(*operationSymbol);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("operationSymbol") != m.end() && !m["operationSymbol"].empty()) {
      operationSymbol = make_shared<string>(boost::any_cast<string>(m["operationSymbol"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~UpdateRouteRuleRequestRouteChildRulesConditions() = default;
};
class UpdateRouteRuleRequestRouteChildRules : public Darabonba::Model {
public:
  shared_ptr<long> childConditionRelation{};
  shared_ptr<long> childRouteRuleId{};
  shared_ptr<vector<UpdateRouteRuleRequestRouteChildRulesConditions>> conditions{};
  shared_ptr<bool> isValidChildRule{};
  shared_ptr<long> monitorSourceId{};
  shared_ptr<string> problemLevel{};

  UpdateRouteRuleRequestRouteChildRules() {}

  explicit UpdateRouteRuleRequestRouteChildRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (childConditionRelation) {
      res["childConditionRelation"] = boost::any(*childConditionRelation);
    }
    if (childRouteRuleId) {
      res["childRouteRuleId"] = boost::any(*childRouteRuleId);
    }
    if (conditions) {
      vector<boost::any> temp1;
      for(auto item1:*conditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["conditions"] = boost::any(temp1);
    }
    if (isValidChildRule) {
      res["isValidChildRule"] = boost::any(*isValidChildRule);
    }
    if (monitorSourceId) {
      res["monitorSourceId"] = boost::any(*monitorSourceId);
    }
    if (problemLevel) {
      res["problemLevel"] = boost::any(*problemLevel);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("childConditionRelation") != m.end() && !m["childConditionRelation"].empty()) {
      childConditionRelation = make_shared<long>(boost::any_cast<long>(m["childConditionRelation"]));
    }
    if (m.find("childRouteRuleId") != m.end() && !m["childRouteRuleId"].empty()) {
      childRouteRuleId = make_shared<long>(boost::any_cast<long>(m["childRouteRuleId"]));
    }
    if (m.find("conditions") != m.end() && !m["conditions"].empty()) {
      if (typeid(vector<boost::any>) == m["conditions"].type()) {
        vector<UpdateRouteRuleRequestRouteChildRulesConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["conditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateRouteRuleRequestRouteChildRulesConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditions = make_shared<vector<UpdateRouteRuleRequestRouteChildRulesConditions>>(expect1);
      }
    }
    if (m.find("isValidChildRule") != m.end() && !m["isValidChildRule"].empty()) {
      isValidChildRule = make_shared<bool>(boost::any_cast<bool>(m["isValidChildRule"]));
    }
    if (m.find("monitorSourceId") != m.end() && !m["monitorSourceId"].empty()) {
      monitorSourceId = make_shared<long>(boost::any_cast<long>(m["monitorSourceId"]));
    }
    if (m.find("problemLevel") != m.end() && !m["problemLevel"].empty()) {
      problemLevel = make_shared<string>(boost::any_cast<string>(m["problemLevel"]));
    }
  }


  virtual ~UpdateRouteRuleRequestRouteChildRules() = default;
};
class UpdateRouteRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> assignObjectId{};
  shared_ptr<string> assignObjectType{};
  shared_ptr<string> childRuleRelation{};
  shared_ptr<string> clientToken{};
  shared_ptr<vector<string>> convergenceFields{};
  shared_ptr<long> convergenceType{};
  shared_ptr<vector<string>> coverageProblemLevels{};
  shared_ptr<string> effection{};
  shared_ptr<string> incidentLevel{};
  shared_ptr<long> matchCount{};
  shared_ptr<vector<string>> notifyChannels{};
  shared_ptr<vector<long>> problemEffectionServices{};
  shared_ptr<map<string, ProblemLevelGroupValue>> problemLevelGroup{};
  shared_ptr<long> relatedServiceId{};
  shared_ptr<vector<UpdateRouteRuleRequestRouteChildRules>> routeChildRules{};
  shared_ptr<long> routeRuleId{};
  shared_ptr<string> routeType{};
  shared_ptr<string> ruleName{};
  shared_ptr<long> timeWindow{};
  shared_ptr<string> timeWindowUnit{};

  UpdateRouteRuleRequest() {}

  explicit UpdateRouteRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assignObjectId) {
      res["assignObjectId"] = boost::any(*assignObjectId);
    }
    if (assignObjectType) {
      res["assignObjectType"] = boost::any(*assignObjectType);
    }
    if (childRuleRelation) {
      res["childRuleRelation"] = boost::any(*childRuleRelation);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (convergenceFields) {
      res["convergenceFields"] = boost::any(*convergenceFields);
    }
    if (convergenceType) {
      res["convergenceType"] = boost::any(*convergenceType);
    }
    if (coverageProblemLevels) {
      res["coverageProblemLevels"] = boost::any(*coverageProblemLevels);
    }
    if (effection) {
      res["effection"] = boost::any(*effection);
    }
    if (incidentLevel) {
      res["incidentLevel"] = boost::any(*incidentLevel);
    }
    if (matchCount) {
      res["matchCount"] = boost::any(*matchCount);
    }
    if (notifyChannels) {
      res["notifyChannels"] = boost::any(*notifyChannels);
    }
    if (problemEffectionServices) {
      res["problemEffectionServices"] = boost::any(*problemEffectionServices);
    }
    if (problemLevelGroup) {
      map<string, boost::any> temp1;
      for(auto item1:*problemLevelGroup){
        temp1[item1.first] = boost::any(item1.second.toMap());
      }
      res["problemLevelGroup"] = boost::any(temp1);
    }
    if (relatedServiceId) {
      res["relatedServiceId"] = boost::any(*relatedServiceId);
    }
    if (routeChildRules) {
      vector<boost::any> temp1;
      for(auto item1:*routeChildRules){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["routeChildRules"] = boost::any(temp1);
    }
    if (routeRuleId) {
      res["routeRuleId"] = boost::any(*routeRuleId);
    }
    if (routeType) {
      res["routeType"] = boost::any(*routeType);
    }
    if (ruleName) {
      res["ruleName"] = boost::any(*ruleName);
    }
    if (timeWindow) {
      res["timeWindow"] = boost::any(*timeWindow);
    }
    if (timeWindowUnit) {
      res["timeWindowUnit"] = boost::any(*timeWindowUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("assignObjectId") != m.end() && !m["assignObjectId"].empty()) {
      assignObjectId = make_shared<long>(boost::any_cast<long>(m["assignObjectId"]));
    }
    if (m.find("assignObjectType") != m.end() && !m["assignObjectType"].empty()) {
      assignObjectType = make_shared<string>(boost::any_cast<string>(m["assignObjectType"]));
    }
    if (m.find("childRuleRelation") != m.end() && !m["childRuleRelation"].empty()) {
      childRuleRelation = make_shared<string>(boost::any_cast<string>(m["childRuleRelation"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("convergenceFields") != m.end() && !m["convergenceFields"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["convergenceFields"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["convergenceFields"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      convergenceFields = make_shared<vector<string>>(toVec1);
    }
    if (m.find("convergenceType") != m.end() && !m["convergenceType"].empty()) {
      convergenceType = make_shared<long>(boost::any_cast<long>(m["convergenceType"]));
    }
    if (m.find("coverageProblemLevels") != m.end() && !m["coverageProblemLevels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["coverageProblemLevels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["coverageProblemLevels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      coverageProblemLevels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("effection") != m.end() && !m["effection"].empty()) {
      effection = make_shared<string>(boost::any_cast<string>(m["effection"]));
    }
    if (m.find("incidentLevel") != m.end() && !m["incidentLevel"].empty()) {
      incidentLevel = make_shared<string>(boost::any_cast<string>(m["incidentLevel"]));
    }
    if (m.find("matchCount") != m.end() && !m["matchCount"].empty()) {
      matchCount = make_shared<long>(boost::any_cast<long>(m["matchCount"]));
    }
    if (m.find("notifyChannels") != m.end() && !m["notifyChannels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["notifyChannels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["notifyChannels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      notifyChannels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("problemEffectionServices") != m.end() && !m["problemEffectionServices"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["problemEffectionServices"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["problemEffectionServices"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      problemEffectionServices = make_shared<vector<long>>(toVec1);
    }
    if (m.find("problemLevelGroup") != m.end() && !m["problemLevelGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["problemLevelGroup"].type()) {
        map<string, ProblemLevelGroupValue> expect1;
        for(auto item1:boost::any_cast<map<string, boost::any>>(m["problemLevelGroup"])){
          if (typeid(map<string, boost::any>) == item1.second.type()) {
            ProblemLevelGroupValue model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1.second));
            expect1[item1.first] = model2;
          }
        }
        problemLevelGroup = make_shared<map<string, ProblemLevelGroupValue>>(expect1);
      }
    }
    if (m.find("relatedServiceId") != m.end() && !m["relatedServiceId"].empty()) {
      relatedServiceId = make_shared<long>(boost::any_cast<long>(m["relatedServiceId"]));
    }
    if (m.find("routeChildRules") != m.end() && !m["routeChildRules"].empty()) {
      if (typeid(vector<boost::any>) == m["routeChildRules"].type()) {
        vector<UpdateRouteRuleRequestRouteChildRules> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["routeChildRules"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateRouteRuleRequestRouteChildRules model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routeChildRules = make_shared<vector<UpdateRouteRuleRequestRouteChildRules>>(expect1);
      }
    }
    if (m.find("routeRuleId") != m.end() && !m["routeRuleId"].empty()) {
      routeRuleId = make_shared<long>(boost::any_cast<long>(m["routeRuleId"]));
    }
    if (m.find("routeType") != m.end() && !m["routeType"].empty()) {
      routeType = make_shared<string>(boost::any_cast<string>(m["routeType"]));
    }
    if (m.find("ruleName") != m.end() && !m["ruleName"].empty()) {
      ruleName = make_shared<string>(boost::any_cast<string>(m["ruleName"]));
    }
    if (m.find("timeWindow") != m.end() && !m["timeWindow"].empty()) {
      timeWindow = make_shared<long>(boost::any_cast<long>(m["timeWindow"]));
    }
    if (m.find("timeWindowUnit") != m.end() && !m["timeWindowUnit"].empty()) {
      timeWindowUnit = make_shared<string>(boost::any_cast<string>(m["timeWindowUnit"]));
    }
  }


  virtual ~UpdateRouteRuleRequest() = default;
};
class UpdateRouteRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> data{};
  shared_ptr<string> requestId{};

  UpdateRouteRuleResponseBody() {}

  explicit UpdateRouteRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["data"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateRouteRuleResponseBody() = default;
};
class UpdateRouteRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateRouteRuleResponseBody> body{};

  UpdateRouteRuleResponse() {}

  explicit UpdateRouteRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateRouteRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateRouteRuleResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateRouteRuleResponse() = default;
};
class UpdateServiceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> serviceDescription{};
  shared_ptr<long> serviceId{};
  shared_ptr<string> serviceName{};

  UpdateServiceRequest() {}

  explicit UpdateServiceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (serviceDescription) {
      res["serviceDescription"] = boost::any(*serviceDescription);
    }
    if (serviceId) {
      res["serviceId"] = boost::any(*serviceId);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("serviceDescription") != m.end() && !m["serviceDescription"].empty()) {
      serviceDescription = make_shared<string>(boost::any_cast<string>(m["serviceDescription"]));
    }
    if (m.find("serviceId") != m.end() && !m["serviceId"].empty()) {
      serviceId = make_shared<long>(boost::any_cast<long>(m["serviceId"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
  }


  virtual ~UpdateServiceRequest() = default;
};
class UpdateServiceResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> data{};
  shared_ptr<string> requestId{};

  UpdateServiceResponseBody() {}

  explicit UpdateServiceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = boost::any(*data);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      data = make_shared<long>(boost::any_cast<long>(m["data"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateServiceResponseBody() = default;
};
class UpdateServiceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateServiceResponseBody> body{};

  UpdateServiceResponse() {}

  explicit UpdateServiceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateServiceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateServiceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateServiceResponse() = default;
};
class UpdateServiceGroupRequestMonitorSourceTemplates : public Darabonba::Model {
public:
  shared_ptr<long> monitorSourceId{};
  shared_ptr<string> monitorSourceName{};
  shared_ptr<string> templateContent{};
  shared_ptr<long> templateId{};

  UpdateServiceGroupRequestMonitorSourceTemplates() {}

  explicit UpdateServiceGroupRequestMonitorSourceTemplates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (monitorSourceId) {
      res["monitorSourceId"] = boost::any(*monitorSourceId);
    }
    if (monitorSourceName) {
      res["monitorSourceName"] = boost::any(*monitorSourceName);
    }
    if (templateContent) {
      res["templateContent"] = boost::any(*templateContent);
    }
    if (templateId) {
      res["templateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("monitorSourceId") != m.end() && !m["monitorSourceId"].empty()) {
      monitorSourceId = make_shared<long>(boost::any_cast<long>(m["monitorSourceId"]));
    }
    if (m.find("monitorSourceName") != m.end() && !m["monitorSourceName"].empty()) {
      monitorSourceName = make_shared<string>(boost::any_cast<string>(m["monitorSourceName"]));
    }
    if (m.find("templateContent") != m.end() && !m["templateContent"].empty()) {
      templateContent = make_shared<string>(boost::any_cast<string>(m["templateContent"]));
    }
    if (m.find("templateId") != m.end() && !m["templateId"].empty()) {
      templateId = make_shared<long>(boost::any_cast<long>(m["templateId"]));
    }
  }


  virtual ~UpdateServiceGroupRequestMonitorSourceTemplates() = default;
};
class UpdateServiceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> enableWebhook{};
  shared_ptr<vector<UpdateServiceGroupRequestMonitorSourceTemplates>> monitorSourceTemplates{};
  shared_ptr<string> serviceGroupDescription{};
  shared_ptr<long> serviceGroupId{};
  shared_ptr<string> serviceGroupName{};
  shared_ptr<vector<long>> userIds{};
  shared_ptr<string> webhookLink{};
  shared_ptr<string> webhookType{};

  UpdateServiceGroupRequest() {}

  explicit UpdateServiceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (enableWebhook) {
      res["enableWebhook"] = boost::any(*enableWebhook);
    }
    if (monitorSourceTemplates) {
      vector<boost::any> temp1;
      for(auto item1:*monitorSourceTemplates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["monitorSourceTemplates"] = boost::any(temp1);
    }
    if (serviceGroupDescription) {
      res["serviceGroupDescription"] = boost::any(*serviceGroupDescription);
    }
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    if (serviceGroupName) {
      res["serviceGroupName"] = boost::any(*serviceGroupName);
    }
    if (userIds) {
      res["userIds"] = boost::any(*userIds);
    }
    if (webhookLink) {
      res["webhookLink"] = boost::any(*webhookLink);
    }
    if (webhookType) {
      res["webhookType"] = boost::any(*webhookType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("enableWebhook") != m.end() && !m["enableWebhook"].empty()) {
      enableWebhook = make_shared<string>(boost::any_cast<string>(m["enableWebhook"]));
    }
    if (m.find("monitorSourceTemplates") != m.end() && !m["monitorSourceTemplates"].empty()) {
      if (typeid(vector<boost::any>) == m["monitorSourceTemplates"].type()) {
        vector<UpdateServiceGroupRequestMonitorSourceTemplates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["monitorSourceTemplates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateServiceGroupRequestMonitorSourceTemplates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        monitorSourceTemplates = make_shared<vector<UpdateServiceGroupRequestMonitorSourceTemplates>>(expect1);
      }
    }
    if (m.find("serviceGroupDescription") != m.end() && !m["serviceGroupDescription"].empty()) {
      serviceGroupDescription = make_shared<string>(boost::any_cast<string>(m["serviceGroupDescription"]));
    }
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
    if (m.find("serviceGroupName") != m.end() && !m["serviceGroupName"].empty()) {
      serviceGroupName = make_shared<string>(boost::any_cast<string>(m["serviceGroupName"]));
    }
    if (m.find("userIds") != m.end() && !m["userIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["userIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["userIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      userIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("webhookLink") != m.end() && !m["webhookLink"].empty()) {
      webhookLink = make_shared<string>(boost::any_cast<string>(m["webhookLink"]));
    }
    if (m.find("webhookType") != m.end() && !m["webhookType"].empty()) {
      webhookType = make_shared<string>(boost::any_cast<string>(m["webhookType"]));
    }
  }


  virtual ~UpdateServiceGroupRequest() = default;
};
class UpdateServiceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateServiceGroupResponseBody() {}

  explicit UpdateServiceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateServiceGroupResponseBody() = default;
};
class UpdateServiceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateServiceGroupResponseBody> body{};

  UpdateServiceGroupResponse() {}

  explicit UpdateServiceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateServiceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateServiceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateServiceGroupResponse() = default;
};
class UpdateServiceGroupSchedulingRequestFastSchedulingSchedulingUsers : public Darabonba::Model {
public:
  shared_ptr<string> schedulingObjectType{};
  shared_ptr<long> schedulingOrder{};
  shared_ptr<long> schedulingUserId{};
  shared_ptr<vector<long>> schedulingUserIdList{};

  UpdateServiceGroupSchedulingRequestFastSchedulingSchedulingUsers() {}

  explicit UpdateServiceGroupSchedulingRequestFastSchedulingSchedulingUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (schedulingObjectType) {
      res["schedulingObjectType"] = boost::any(*schedulingObjectType);
    }
    if (schedulingOrder) {
      res["schedulingOrder"] = boost::any(*schedulingOrder);
    }
    if (schedulingUserId) {
      res["schedulingUserId"] = boost::any(*schedulingUserId);
    }
    if (schedulingUserIdList) {
      res["schedulingUserIdList"] = boost::any(*schedulingUserIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("schedulingObjectType") != m.end() && !m["schedulingObjectType"].empty()) {
      schedulingObjectType = make_shared<string>(boost::any_cast<string>(m["schedulingObjectType"]));
    }
    if (m.find("schedulingOrder") != m.end() && !m["schedulingOrder"].empty()) {
      schedulingOrder = make_shared<long>(boost::any_cast<long>(m["schedulingOrder"]));
    }
    if (m.find("schedulingUserId") != m.end() && !m["schedulingUserId"].empty()) {
      schedulingUserId = make_shared<long>(boost::any_cast<long>(m["schedulingUserId"]));
    }
    if (m.find("schedulingUserIdList") != m.end() && !m["schedulingUserIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["schedulingUserIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["schedulingUserIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      schedulingUserIdList = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~UpdateServiceGroupSchedulingRequestFastSchedulingSchedulingUsers() = default;
};
class UpdateServiceGroupSchedulingRequestFastScheduling : public Darabonba::Model {
public:
  shared_ptr<string> dutyPlan{};
  shared_ptr<long> id{};
  shared_ptr<vector<UpdateServiceGroupSchedulingRequestFastSchedulingSchedulingUsers>> schedulingUsers{};
  shared_ptr<long> singleDuration{};
  shared_ptr<string> singleDurationUnit{};

  UpdateServiceGroupSchedulingRequestFastScheduling() {}

  explicit UpdateServiceGroupSchedulingRequestFastScheduling(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dutyPlan) {
      res["dutyPlan"] = boost::any(*dutyPlan);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (schedulingUsers) {
      vector<boost::any> temp1;
      for(auto item1:*schedulingUsers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["schedulingUsers"] = boost::any(temp1);
    }
    if (singleDuration) {
      res["singleDuration"] = boost::any(*singleDuration);
    }
    if (singleDurationUnit) {
      res["singleDurationUnit"] = boost::any(*singleDurationUnit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dutyPlan") != m.end() && !m["dutyPlan"].empty()) {
      dutyPlan = make_shared<string>(boost::any_cast<string>(m["dutyPlan"]));
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("schedulingUsers") != m.end() && !m["schedulingUsers"].empty()) {
      if (typeid(vector<boost::any>) == m["schedulingUsers"].type()) {
        vector<UpdateServiceGroupSchedulingRequestFastSchedulingSchedulingUsers> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["schedulingUsers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateServiceGroupSchedulingRequestFastSchedulingSchedulingUsers model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        schedulingUsers = make_shared<vector<UpdateServiceGroupSchedulingRequestFastSchedulingSchedulingUsers>>(expect1);
      }
    }
    if (m.find("singleDuration") != m.end() && !m["singleDuration"].empty()) {
      singleDuration = make_shared<long>(boost::any_cast<long>(m["singleDuration"]));
    }
    if (m.find("singleDurationUnit") != m.end() && !m["singleDurationUnit"].empty()) {
      singleDurationUnit = make_shared<string>(boost::any_cast<string>(m["singleDurationUnit"]));
    }
  }


  virtual ~UpdateServiceGroupSchedulingRequestFastScheduling() = default;
};
class UpdateServiceGroupSchedulingRequestFineSchedulingSchedulingFineShifts : public Darabonba::Model {
public:
  shared_ptr<long> cycleOrder{};
  shared_ptr<string> schedulingEndTime{};
  shared_ptr<string> schedulingObjectType{};
  shared_ptr<long> schedulingOrder{};
  shared_ptr<string> schedulingStartTime{};
  shared_ptr<long> schedulingUserId{};
  shared_ptr<vector<long>> schedulingUserIdList{};
  shared_ptr<string> shiftName{};
  shared_ptr<bool> skipOneDay{};

  UpdateServiceGroupSchedulingRequestFineSchedulingSchedulingFineShifts() {}

  explicit UpdateServiceGroupSchedulingRequestFineSchedulingSchedulingFineShifts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cycleOrder) {
      res["cycleOrder"] = boost::any(*cycleOrder);
    }
    if (schedulingEndTime) {
      res["schedulingEndTime"] = boost::any(*schedulingEndTime);
    }
    if (schedulingObjectType) {
      res["schedulingObjectType"] = boost::any(*schedulingObjectType);
    }
    if (schedulingOrder) {
      res["schedulingOrder"] = boost::any(*schedulingOrder);
    }
    if (schedulingStartTime) {
      res["schedulingStartTime"] = boost::any(*schedulingStartTime);
    }
    if (schedulingUserId) {
      res["schedulingUserId"] = boost::any(*schedulingUserId);
    }
    if (schedulingUserIdList) {
      res["schedulingUserIdList"] = boost::any(*schedulingUserIdList);
    }
    if (shiftName) {
      res["shiftName"] = boost::any(*shiftName);
    }
    if (skipOneDay) {
      res["skipOneDay"] = boost::any(*skipOneDay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cycleOrder") != m.end() && !m["cycleOrder"].empty()) {
      cycleOrder = make_shared<long>(boost::any_cast<long>(m["cycleOrder"]));
    }
    if (m.find("schedulingEndTime") != m.end() && !m["schedulingEndTime"].empty()) {
      schedulingEndTime = make_shared<string>(boost::any_cast<string>(m["schedulingEndTime"]));
    }
    if (m.find("schedulingObjectType") != m.end() && !m["schedulingObjectType"].empty()) {
      schedulingObjectType = make_shared<string>(boost::any_cast<string>(m["schedulingObjectType"]));
    }
    if (m.find("schedulingOrder") != m.end() && !m["schedulingOrder"].empty()) {
      schedulingOrder = make_shared<long>(boost::any_cast<long>(m["schedulingOrder"]));
    }
    if (m.find("schedulingStartTime") != m.end() && !m["schedulingStartTime"].empty()) {
      schedulingStartTime = make_shared<string>(boost::any_cast<string>(m["schedulingStartTime"]));
    }
    if (m.find("schedulingUserId") != m.end() && !m["schedulingUserId"].empty()) {
      schedulingUserId = make_shared<long>(boost::any_cast<long>(m["schedulingUserId"]));
    }
    if (m.find("schedulingUserIdList") != m.end() && !m["schedulingUserIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["schedulingUserIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["schedulingUserIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      schedulingUserIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("shiftName") != m.end() && !m["shiftName"].empty()) {
      shiftName = make_shared<string>(boost::any_cast<string>(m["shiftName"]));
    }
    if (m.find("skipOneDay") != m.end() && !m["skipOneDay"].empty()) {
      skipOneDay = make_shared<bool>(boost::any_cast<bool>(m["skipOneDay"]));
    }
  }


  virtual ~UpdateServiceGroupSchedulingRequestFineSchedulingSchedulingFineShifts() = default;
};
class UpdateServiceGroupSchedulingRequestFineSchedulingSchedulingTemplateFineShifts : public Darabonba::Model {
public:
  shared_ptr<string> schedulingEndTime{};
  shared_ptr<string> schedulingObjectType{};
  shared_ptr<long> schedulingOrder{};
  shared_ptr<string> schedulingStartTime{};
  shared_ptr<long> schedulingUserId{};
  shared_ptr<vector<long>> schedulingUserIdList{};
  shared_ptr<string> shiftName{};
  shared_ptr<bool> skipOneDay{};

  UpdateServiceGroupSchedulingRequestFineSchedulingSchedulingTemplateFineShifts() {}

  explicit UpdateServiceGroupSchedulingRequestFineSchedulingSchedulingTemplateFineShifts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (schedulingEndTime) {
      res["schedulingEndTime"] = boost::any(*schedulingEndTime);
    }
    if (schedulingObjectType) {
      res["schedulingObjectType"] = boost::any(*schedulingObjectType);
    }
    if (schedulingOrder) {
      res["schedulingOrder"] = boost::any(*schedulingOrder);
    }
    if (schedulingStartTime) {
      res["schedulingStartTime"] = boost::any(*schedulingStartTime);
    }
    if (schedulingUserId) {
      res["schedulingUserId"] = boost::any(*schedulingUserId);
    }
    if (schedulingUserIdList) {
      res["schedulingUserIdList"] = boost::any(*schedulingUserIdList);
    }
    if (shiftName) {
      res["shiftName"] = boost::any(*shiftName);
    }
    if (skipOneDay) {
      res["skipOneDay"] = boost::any(*skipOneDay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("schedulingEndTime") != m.end() && !m["schedulingEndTime"].empty()) {
      schedulingEndTime = make_shared<string>(boost::any_cast<string>(m["schedulingEndTime"]));
    }
    if (m.find("schedulingObjectType") != m.end() && !m["schedulingObjectType"].empty()) {
      schedulingObjectType = make_shared<string>(boost::any_cast<string>(m["schedulingObjectType"]));
    }
    if (m.find("schedulingOrder") != m.end() && !m["schedulingOrder"].empty()) {
      schedulingOrder = make_shared<long>(boost::any_cast<long>(m["schedulingOrder"]));
    }
    if (m.find("schedulingStartTime") != m.end() && !m["schedulingStartTime"].empty()) {
      schedulingStartTime = make_shared<string>(boost::any_cast<string>(m["schedulingStartTime"]));
    }
    if (m.find("schedulingUserId") != m.end() && !m["schedulingUserId"].empty()) {
      schedulingUserId = make_shared<long>(boost::any_cast<long>(m["schedulingUserId"]));
    }
    if (m.find("schedulingUserIdList") != m.end() && !m["schedulingUserIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["schedulingUserIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["schedulingUserIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      schedulingUserIdList = make_shared<vector<long>>(toVec1);
    }
    if (m.find("shiftName") != m.end() && !m["shiftName"].empty()) {
      shiftName = make_shared<string>(boost::any_cast<string>(m["shiftName"]));
    }
    if (m.find("skipOneDay") != m.end() && !m["skipOneDay"].empty()) {
      skipOneDay = make_shared<bool>(boost::any_cast<bool>(m["skipOneDay"]));
    }
  }


  virtual ~UpdateServiceGroupSchedulingRequestFineSchedulingSchedulingTemplateFineShifts() = default;
};
class UpdateServiceGroupSchedulingRequestFineScheduling : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> period{};
  shared_ptr<string> periodUnit{};
  shared_ptr<vector<UpdateServiceGroupSchedulingRequestFineSchedulingSchedulingFineShifts>> schedulingFineShifts{};
  shared_ptr<vector<UpdateServiceGroupSchedulingRequestFineSchedulingSchedulingTemplateFineShifts>> schedulingTemplateFineShifts{};
  shared_ptr<string> shiftType{};

  UpdateServiceGroupSchedulingRequestFineScheduling() {}

  explicit UpdateServiceGroupSchedulingRequestFineScheduling(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (period) {
      res["period"] = boost::any(*period);
    }
    if (periodUnit) {
      res["periodUnit"] = boost::any(*periodUnit);
    }
    if (schedulingFineShifts) {
      vector<boost::any> temp1;
      for(auto item1:*schedulingFineShifts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["schedulingFineShifts"] = boost::any(temp1);
    }
    if (schedulingTemplateFineShifts) {
      vector<boost::any> temp1;
      for(auto item1:*schedulingTemplateFineShifts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["schedulingTemplateFineShifts"] = boost::any(temp1);
    }
    if (shiftType) {
      res["shiftType"] = boost::any(*shiftType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("period") != m.end() && !m["period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["period"]));
    }
    if (m.find("periodUnit") != m.end() && !m["periodUnit"].empty()) {
      periodUnit = make_shared<string>(boost::any_cast<string>(m["periodUnit"]));
    }
    if (m.find("schedulingFineShifts") != m.end() && !m["schedulingFineShifts"].empty()) {
      if (typeid(vector<boost::any>) == m["schedulingFineShifts"].type()) {
        vector<UpdateServiceGroupSchedulingRequestFineSchedulingSchedulingFineShifts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["schedulingFineShifts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateServiceGroupSchedulingRequestFineSchedulingSchedulingFineShifts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        schedulingFineShifts = make_shared<vector<UpdateServiceGroupSchedulingRequestFineSchedulingSchedulingFineShifts>>(expect1);
      }
    }
    if (m.find("schedulingTemplateFineShifts") != m.end() && !m["schedulingTemplateFineShifts"].empty()) {
      if (typeid(vector<boost::any>) == m["schedulingTemplateFineShifts"].type()) {
        vector<UpdateServiceGroupSchedulingRequestFineSchedulingSchedulingTemplateFineShifts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["schedulingTemplateFineShifts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateServiceGroupSchedulingRequestFineSchedulingSchedulingTemplateFineShifts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        schedulingTemplateFineShifts = make_shared<vector<UpdateServiceGroupSchedulingRequestFineSchedulingSchedulingTemplateFineShifts>>(expect1);
      }
    }
    if (m.find("shiftType") != m.end() && !m["shiftType"].empty()) {
      shiftType = make_shared<string>(boost::any_cast<string>(m["shiftType"]));
    }
  }


  virtual ~UpdateServiceGroupSchedulingRequestFineScheduling() = default;
};
class UpdateServiceGroupSchedulingRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<UpdateServiceGroupSchedulingRequestFastScheduling> fastScheduling{};
  shared_ptr<UpdateServiceGroupSchedulingRequestFineScheduling> fineScheduling{};
  shared_ptr<string> schedulingWay{};
  shared_ptr<long> serviceGroupId{};

  UpdateServiceGroupSchedulingRequest() {}

  explicit UpdateServiceGroupSchedulingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (fastScheduling) {
      res["fastScheduling"] = fastScheduling ? boost::any(fastScheduling->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (fineScheduling) {
      res["fineScheduling"] = fineScheduling ? boost::any(fineScheduling->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (schedulingWay) {
      res["schedulingWay"] = boost::any(*schedulingWay);
    }
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("fastScheduling") != m.end() && !m["fastScheduling"].empty()) {
      if (typeid(map<string, boost::any>) == m["fastScheduling"].type()) {
        UpdateServiceGroupSchedulingRequestFastScheduling model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["fastScheduling"]));
        fastScheduling = make_shared<UpdateServiceGroupSchedulingRequestFastScheduling>(model1);
      }
    }
    if (m.find("fineScheduling") != m.end() && !m["fineScheduling"].empty()) {
      if (typeid(map<string, boost::any>) == m["fineScheduling"].type()) {
        UpdateServiceGroupSchedulingRequestFineScheduling model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["fineScheduling"]));
        fineScheduling = make_shared<UpdateServiceGroupSchedulingRequestFineScheduling>(model1);
      }
    }
    if (m.find("schedulingWay") != m.end() && !m["schedulingWay"].empty()) {
      schedulingWay = make_shared<string>(boost::any_cast<string>(m["schedulingWay"]));
    }
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
  }


  virtual ~UpdateServiceGroupSchedulingRequest() = default;
};
class UpdateServiceGroupSchedulingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateServiceGroupSchedulingResponseBody() {}

  explicit UpdateServiceGroupSchedulingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateServiceGroupSchedulingResponseBody() = default;
};
class UpdateServiceGroupSchedulingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateServiceGroupSchedulingResponseBody> body{};

  UpdateServiceGroupSchedulingResponse() {}

  explicit UpdateServiceGroupSchedulingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateServiceGroupSchedulingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateServiceGroupSchedulingResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateServiceGroupSchedulingResponse() = default;
};
class UpdateServiceGroupSpecialDaySchedulingRequestSchedulingSpecialDays : public Darabonba::Model {
public:
  shared_ptr<string> schedulingEndTime{};
  shared_ptr<string> schedulingObjectType{};
  shared_ptr<long> schedulingOrder{};
  shared_ptr<string> schedulingStartTime{};
  shared_ptr<long> schedulingUserId{};
  shared_ptr<vector<long>> schedulingUserIdList{};

  UpdateServiceGroupSpecialDaySchedulingRequestSchedulingSpecialDays() {}

  explicit UpdateServiceGroupSpecialDaySchedulingRequestSchedulingSpecialDays(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (schedulingEndTime) {
      res["schedulingEndTime"] = boost::any(*schedulingEndTime);
    }
    if (schedulingObjectType) {
      res["schedulingObjectType"] = boost::any(*schedulingObjectType);
    }
    if (schedulingOrder) {
      res["schedulingOrder"] = boost::any(*schedulingOrder);
    }
    if (schedulingStartTime) {
      res["schedulingStartTime"] = boost::any(*schedulingStartTime);
    }
    if (schedulingUserId) {
      res["schedulingUserId"] = boost::any(*schedulingUserId);
    }
    if (schedulingUserIdList) {
      res["schedulingUserIdList"] = boost::any(*schedulingUserIdList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("schedulingEndTime") != m.end() && !m["schedulingEndTime"].empty()) {
      schedulingEndTime = make_shared<string>(boost::any_cast<string>(m["schedulingEndTime"]));
    }
    if (m.find("schedulingObjectType") != m.end() && !m["schedulingObjectType"].empty()) {
      schedulingObjectType = make_shared<string>(boost::any_cast<string>(m["schedulingObjectType"]));
    }
    if (m.find("schedulingOrder") != m.end() && !m["schedulingOrder"].empty()) {
      schedulingOrder = make_shared<long>(boost::any_cast<long>(m["schedulingOrder"]));
    }
    if (m.find("schedulingStartTime") != m.end() && !m["schedulingStartTime"].empty()) {
      schedulingStartTime = make_shared<string>(boost::any_cast<string>(m["schedulingStartTime"]));
    }
    if (m.find("schedulingUserId") != m.end() && !m["schedulingUserId"].empty()) {
      schedulingUserId = make_shared<long>(boost::any_cast<long>(m["schedulingUserId"]));
    }
    if (m.find("schedulingUserIdList") != m.end() && !m["schedulingUserIdList"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["schedulingUserIdList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["schedulingUserIdList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      schedulingUserIdList = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~UpdateServiceGroupSpecialDaySchedulingRequestSchedulingSpecialDays() = default;
};
class UpdateServiceGroupSpecialDaySchedulingRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> schedulingDate{};
  shared_ptr<vector<UpdateServiceGroupSpecialDaySchedulingRequestSchedulingSpecialDays>> schedulingSpecialDays{};
  shared_ptr<long> serviceGroupId{};

  UpdateServiceGroupSpecialDaySchedulingRequest() {}

  explicit UpdateServiceGroupSpecialDaySchedulingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (schedulingDate) {
      res["schedulingDate"] = boost::any(*schedulingDate);
    }
    if (schedulingSpecialDays) {
      vector<boost::any> temp1;
      for(auto item1:*schedulingSpecialDays){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["schedulingSpecialDays"] = boost::any(temp1);
    }
    if (serviceGroupId) {
      res["serviceGroupId"] = boost::any(*serviceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("schedulingDate") != m.end() && !m["schedulingDate"].empty()) {
      schedulingDate = make_shared<string>(boost::any_cast<string>(m["schedulingDate"]));
    }
    if (m.find("schedulingSpecialDays") != m.end() && !m["schedulingSpecialDays"].empty()) {
      if (typeid(vector<boost::any>) == m["schedulingSpecialDays"].type()) {
        vector<UpdateServiceGroupSpecialDaySchedulingRequestSchedulingSpecialDays> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["schedulingSpecialDays"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateServiceGroupSpecialDaySchedulingRequestSchedulingSpecialDays model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        schedulingSpecialDays = make_shared<vector<UpdateServiceGroupSpecialDaySchedulingRequestSchedulingSpecialDays>>(expect1);
      }
    }
    if (m.find("serviceGroupId") != m.end() && !m["serviceGroupId"].empty()) {
      serviceGroupId = make_shared<long>(boost::any_cast<long>(m["serviceGroupId"]));
    }
  }


  virtual ~UpdateServiceGroupSpecialDaySchedulingRequest() = default;
};
class UpdateServiceGroupSpecialDaySchedulingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateServiceGroupSpecialDaySchedulingResponseBody() {}

  explicit UpdateServiceGroupSpecialDaySchedulingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateServiceGroupSpecialDaySchedulingResponseBody() = default;
};
class UpdateServiceGroupSpecialDaySchedulingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateServiceGroupSpecialDaySchedulingResponseBody> body{};

  UpdateServiceGroupSpecialDaySchedulingResponse() {}

  explicit UpdateServiceGroupSpecialDaySchedulingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateServiceGroupSpecialDaySchedulingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateServiceGroupSpecialDaySchedulingResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateServiceGroupSpecialDaySchedulingResponse() = default;
};
class UpdateSubscriptionRequestNotifyObjectList : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> notifyObjectId{};

  UpdateSubscriptionRequestNotifyObjectList() {}

  explicit UpdateSubscriptionRequestNotifyObjectList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (notifyObjectId) {
      res["notifyObjectId"] = boost::any(*notifyObjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("notifyObjectId") != m.end() && !m["notifyObjectId"].empty()) {
      notifyObjectId = make_shared<long>(boost::any_cast<long>(m["notifyObjectId"]));
    }
  }


  virtual ~UpdateSubscriptionRequestNotifyObjectList() = default;
};
class UpdateSubscriptionRequestNotifyStrategyListStrategiesConditions : public Darabonba::Model {
public:
  shared_ptr<string> action{};
  shared_ptr<string> effection{};
  shared_ptr<string> level{};
  shared_ptr<string> problemNotifyType{};

  UpdateSubscriptionRequestNotifyStrategyListStrategiesConditions() {}

  explicit UpdateSubscriptionRequestNotifyStrategyListStrategiesConditions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["action"] = boost::any(*action);
    }
    if (effection) {
      res["effection"] = boost::any(*effection);
    }
    if (level) {
      res["level"] = boost::any(*level);
    }
    if (problemNotifyType) {
      res["problemNotifyType"] = boost::any(*problemNotifyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("action") != m.end() && !m["action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["action"]));
    }
    if (m.find("effection") != m.end() && !m["effection"].empty()) {
      effection = make_shared<string>(boost::any_cast<string>(m["effection"]));
    }
    if (m.find("level") != m.end() && !m["level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["level"]));
    }
    if (m.find("problemNotifyType") != m.end() && !m["problemNotifyType"].empty()) {
      problemNotifyType = make_shared<string>(boost::any_cast<string>(m["problemNotifyType"]));
    }
  }


  virtual ~UpdateSubscriptionRequestNotifyStrategyListStrategiesConditions() = default;
};
class UpdateSubscriptionRequestNotifyStrategyListStrategiesPeriodChannel : public Darabonba::Model {
public:
  shared_ptr<string> nonWorkday{};
  shared_ptr<string> workday{};

  UpdateSubscriptionRequestNotifyStrategyListStrategiesPeriodChannel() {}

  explicit UpdateSubscriptionRequestNotifyStrategyListStrategiesPeriodChannel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nonWorkday) {
      res["nonWorkday"] = boost::any(*nonWorkday);
    }
    if (workday) {
      res["workday"] = boost::any(*workday);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("nonWorkday") != m.end() && !m["nonWorkday"].empty()) {
      nonWorkday = make_shared<string>(boost::any_cast<string>(m["nonWorkday"]));
    }
    if (m.find("workday") != m.end() && !m["workday"].empty()) {
      workday = make_shared<string>(boost::any_cast<string>(m["workday"]));
    }
  }


  virtual ~UpdateSubscriptionRequestNotifyStrategyListStrategiesPeriodChannel() = default;
};
class UpdateSubscriptionRequestNotifyStrategyListStrategies : public Darabonba::Model {
public:
  shared_ptr<string> channels{};
  shared_ptr<vector<UpdateSubscriptionRequestNotifyStrategyListStrategiesConditions>> conditions{};
  shared_ptr<string> id{};
  shared_ptr<UpdateSubscriptionRequestNotifyStrategyListStrategiesPeriodChannel> periodChannel{};

  UpdateSubscriptionRequestNotifyStrategyListStrategies() {}

  explicit UpdateSubscriptionRequestNotifyStrategyListStrategies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["channels"] = boost::any(*channels);
    }
    if (conditions) {
      vector<boost::any> temp1;
      for(auto item1:*conditions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["conditions"] = boost::any(temp1);
    }
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (periodChannel) {
      res["periodChannel"] = periodChannel ? boost::any(periodChannel->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("channels") != m.end() && !m["channels"].empty()) {
      channels = make_shared<string>(boost::any_cast<string>(m["channels"]));
    }
    if (m.find("conditions") != m.end() && !m["conditions"].empty()) {
      if (typeid(vector<boost::any>) == m["conditions"].type()) {
        vector<UpdateSubscriptionRequestNotifyStrategyListStrategiesConditions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["conditions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSubscriptionRequestNotifyStrategyListStrategiesConditions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        conditions = make_shared<vector<UpdateSubscriptionRequestNotifyStrategyListStrategiesConditions>>(expect1);
      }
    }
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["id"]));
    }
    if (m.find("periodChannel") != m.end() && !m["periodChannel"].empty()) {
      if (typeid(map<string, boost::any>) == m["periodChannel"].type()) {
        UpdateSubscriptionRequestNotifyStrategyListStrategiesPeriodChannel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["periodChannel"]));
        periodChannel = make_shared<UpdateSubscriptionRequestNotifyStrategyListStrategiesPeriodChannel>(model1);
      }
    }
  }


  virtual ~UpdateSubscriptionRequestNotifyStrategyListStrategies() = default;
};
class UpdateSubscriptionRequestNotifyStrategyList : public Darabonba::Model {
public:
  shared_ptr<long> instanceType{};
  shared_ptr<vector<UpdateSubscriptionRequestNotifyStrategyListStrategies>> strategies{};

  UpdateSubscriptionRequestNotifyStrategyList() {}

  explicit UpdateSubscriptionRequestNotifyStrategyList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceType) {
      res["instanceType"] = boost::any(*instanceType);
    }
    if (strategies) {
      vector<boost::any> temp1;
      for(auto item1:*strategies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["strategies"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instanceType") != m.end() && !m["instanceType"].empty()) {
      instanceType = make_shared<long>(boost::any_cast<long>(m["instanceType"]));
    }
    if (m.find("strategies") != m.end() && !m["strategies"].empty()) {
      if (typeid(vector<boost::any>) == m["strategies"].type()) {
        vector<UpdateSubscriptionRequestNotifyStrategyListStrategies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["strategies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSubscriptionRequestNotifyStrategyListStrategies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        strategies = make_shared<vector<UpdateSubscriptionRequestNotifyStrategyListStrategies>>(expect1);
      }
    }
  }


  virtual ~UpdateSubscriptionRequestNotifyStrategyList() = default;
};
class UpdateSubscriptionRequestScopeObjectList : public Darabonba::Model {
public:
  shared_ptr<long> id{};
  shared_ptr<long> scopeObjectId{};

  UpdateSubscriptionRequestScopeObjectList() {}

  explicit UpdateSubscriptionRequestScopeObjectList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["id"] = boost::any(*id);
    }
    if (scopeObjectId) {
      res["scopeObjectId"] = boost::any(*scopeObjectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("id") != m.end() && !m["id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["id"]));
    }
    if (m.find("scopeObjectId") != m.end() && !m["scopeObjectId"].empty()) {
      scopeObjectId = make_shared<long>(boost::any_cast<long>(m["scopeObjectId"]));
    }
  }


  virtual ~UpdateSubscriptionRequestScopeObjectList() = default;
};
class UpdateSubscriptionRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTime{};
  shared_ptr<string> expiredType{};
  shared_ptr<vector<UpdateSubscriptionRequestNotifyObjectList>> notifyObjectList{};
  shared_ptr<string> notifyObjectType{};
  shared_ptr<vector<UpdateSubscriptionRequestNotifyStrategyList>> notifyStrategyList{};
  shared_ptr<string> period{};
  shared_ptr<string> scope{};
  shared_ptr<vector<UpdateSubscriptionRequestScopeObjectList>> scopeObjectList{};
  shared_ptr<string> startTime{};
  shared_ptr<long> subscriptionId{};
  shared_ptr<string> subscriptionTitle{};

  UpdateSubscriptionRequest() {}

  explicit UpdateSubscriptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (expiredType) {
      res["expiredType"] = boost::any(*expiredType);
    }
    if (notifyObjectList) {
      vector<boost::any> temp1;
      for(auto item1:*notifyObjectList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["notifyObjectList"] = boost::any(temp1);
    }
    if (notifyObjectType) {
      res["notifyObjectType"] = boost::any(*notifyObjectType);
    }
    if (notifyStrategyList) {
      vector<boost::any> temp1;
      for(auto item1:*notifyStrategyList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["notifyStrategyList"] = boost::any(temp1);
    }
    if (period) {
      res["period"] = boost::any(*period);
    }
    if (scope) {
      res["scope"] = boost::any(*scope);
    }
    if (scopeObjectList) {
      vector<boost::any> temp1;
      for(auto item1:*scopeObjectList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["scopeObjectList"] = boost::any(temp1);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (subscriptionId) {
      res["subscriptionId"] = boost::any(*subscriptionId);
    }
    if (subscriptionTitle) {
      res["subscriptionTitle"] = boost::any(*subscriptionTitle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["endTime"]));
    }
    if (m.find("expiredType") != m.end() && !m["expiredType"].empty()) {
      expiredType = make_shared<string>(boost::any_cast<string>(m["expiredType"]));
    }
    if (m.find("notifyObjectList") != m.end() && !m["notifyObjectList"].empty()) {
      if (typeid(vector<boost::any>) == m["notifyObjectList"].type()) {
        vector<UpdateSubscriptionRequestNotifyObjectList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["notifyObjectList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSubscriptionRequestNotifyObjectList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifyObjectList = make_shared<vector<UpdateSubscriptionRequestNotifyObjectList>>(expect1);
      }
    }
    if (m.find("notifyObjectType") != m.end() && !m["notifyObjectType"].empty()) {
      notifyObjectType = make_shared<string>(boost::any_cast<string>(m["notifyObjectType"]));
    }
    if (m.find("notifyStrategyList") != m.end() && !m["notifyStrategyList"].empty()) {
      if (typeid(vector<boost::any>) == m["notifyStrategyList"].type()) {
        vector<UpdateSubscriptionRequestNotifyStrategyList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["notifyStrategyList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSubscriptionRequestNotifyStrategyList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifyStrategyList = make_shared<vector<UpdateSubscriptionRequestNotifyStrategyList>>(expect1);
      }
    }
    if (m.find("period") != m.end() && !m["period"].empty()) {
      period = make_shared<string>(boost::any_cast<string>(m["period"]));
    }
    if (m.find("scope") != m.end() && !m["scope"].empty()) {
      scope = make_shared<string>(boost::any_cast<string>(m["scope"]));
    }
    if (m.find("scopeObjectList") != m.end() && !m["scopeObjectList"].empty()) {
      if (typeid(vector<boost::any>) == m["scopeObjectList"].type()) {
        vector<UpdateSubscriptionRequestScopeObjectList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["scopeObjectList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSubscriptionRequestScopeObjectList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        scopeObjectList = make_shared<vector<UpdateSubscriptionRequestScopeObjectList>>(expect1);
      }
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["startTime"]));
    }
    if (m.find("subscriptionId") != m.end() && !m["subscriptionId"].empty()) {
      subscriptionId = make_shared<long>(boost::any_cast<long>(m["subscriptionId"]));
    }
    if (m.find("subscriptionTitle") != m.end() && !m["subscriptionTitle"].empty()) {
      subscriptionTitle = make_shared<string>(boost::any_cast<string>(m["subscriptionTitle"]));
    }
  }


  virtual ~UpdateSubscriptionRequest() = default;
};
class UpdateSubscriptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateSubscriptionResponseBody() {}

  explicit UpdateSubscriptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateSubscriptionResponseBody() = default;
};
class UpdateSubscriptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSubscriptionResponseBody> body{};

  UpdateSubscriptionResponse() {}

  explicit UpdateSubscriptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSubscriptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSubscriptionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSubscriptionResponse() = default;
};
class UpdateUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> email{};
  shared_ptr<string> phone{};
  shared_ptr<long> ramId{};
  shared_ptr<long> userId{};
  shared_ptr<string> username{};

  UpdateUserRequest() {}

  explicit UpdateUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (email) {
      res["email"] = boost::any(*email);
    }
    if (phone) {
      res["phone"] = boost::any(*phone);
    }
    if (ramId) {
      res["ramId"] = boost::any(*ramId);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("email") != m.end() && !m["email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["email"]));
    }
    if (m.find("phone") != m.end() && !m["phone"].empty()) {
      phone = make_shared<string>(boost::any_cast<string>(m["phone"]));
    }
    if (m.find("ramId") != m.end() && !m["ramId"].empty()) {
      ramId = make_shared<long>(boost::any_cast<long>(m["ramId"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<long>(boost::any_cast<long>(m["userId"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
  }


  virtual ~UpdateUserRequest() = default;
};
class UpdateUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateUserResponseBody() {}

  explicit UpdateUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateUserResponseBody() = default;
};
class UpdateUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateUserResponseBody> body{};

  UpdateUserResponse() {}

  explicit UpdateUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateUserResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateUserResponse() = default;
};
class UpdateUserGuideStatusRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> guideAction{};

  UpdateUserGuideStatusRequest() {}

  explicit UpdateUserGuideStatusRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (guideAction) {
      res["guideAction"] = boost::any(*guideAction);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("guideAction") != m.end() && !m["guideAction"].empty()) {
      guideAction = make_shared<string>(boost::any_cast<string>(m["guideAction"]));
    }
  }


  virtual ~UpdateUserGuideStatusRequest() = default;
};
class UpdateUserGuideStatusResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateUserGuideStatusResponseBody() {}

  explicit UpdateUserGuideStatusResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateUserGuideStatusResponseBody() = default;
};
class UpdateUserGuideStatusResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateUserGuideStatusResponseBody> body{};

  UpdateUserGuideStatusResponse() {}

  explicit UpdateUserGuideStatusResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateUserGuideStatusResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateUserGuideStatusResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateUserGuideStatusResponse() = default;
};
class VerifyRouteRuleRequestTestSourceEvents : public Darabonba::Model {
public:
  shared_ptr<string> eventJson{};
  shared_ptr<string> eventTime{};
  shared_ptr<long> monitorSourceId{};
  shared_ptr<string> monitorSourceName{};

  VerifyRouteRuleRequestTestSourceEvents() {}

  explicit VerifyRouteRuleRequestTestSourceEvents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventJson) {
      res["eventJson"] = boost::any(*eventJson);
    }
    if (eventTime) {
      res["eventTime"] = boost::any(*eventTime);
    }
    if (monitorSourceId) {
      res["monitorSourceId"] = boost::any(*monitorSourceId);
    }
    if (monitorSourceName) {
      res["monitorSourceName"] = boost::any(*monitorSourceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("eventJson") != m.end() && !m["eventJson"].empty()) {
      eventJson = make_shared<string>(boost::any_cast<string>(m["eventJson"]));
    }
    if (m.find("eventTime") != m.end() && !m["eventTime"].empty()) {
      eventTime = make_shared<string>(boost::any_cast<string>(m["eventTime"]));
    }
    if (m.find("monitorSourceId") != m.end() && !m["monitorSourceId"].empty()) {
      monitorSourceId = make_shared<long>(boost::any_cast<long>(m["monitorSourceId"]));
    }
    if (m.find("monitorSourceName") != m.end() && !m["monitorSourceName"].empty()) {
      monitorSourceName = make_shared<string>(boost::any_cast<string>(m["monitorSourceName"]));
    }
  }


  virtual ~VerifyRouteRuleRequestTestSourceEvents() = default;
};
class VerifyRouteRuleRequest : public Darabonba::Model {
public:
  shared_ptr<long> routeRuleId{};
  shared_ptr<vector<VerifyRouteRuleRequestTestSourceEvents>> testSourceEvents{};

  VerifyRouteRuleRequest() {}

  explicit VerifyRouteRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routeRuleId) {
      res["routeRuleId"] = boost::any(*routeRuleId);
    }
    if (testSourceEvents) {
      vector<boost::any> temp1;
      for(auto item1:*testSourceEvents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["testSourceEvents"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("routeRuleId") != m.end() && !m["routeRuleId"].empty()) {
      routeRuleId = make_shared<long>(boost::any_cast<long>(m["routeRuleId"]));
    }
    if (m.find("testSourceEvents") != m.end() && !m["testSourceEvents"].empty()) {
      if (typeid(vector<boost::any>) == m["testSourceEvents"].type()) {
        vector<VerifyRouteRuleRequestTestSourceEvents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["testSourceEvents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            VerifyRouteRuleRequestTestSourceEvents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        testSourceEvents = make_shared<vector<VerifyRouteRuleRequestTestSourceEvents>>(expect1);
      }
    }
  }


  virtual ~VerifyRouteRuleRequest() = default;
};
class VerifyRouteRuleResponseBodyDataEscalationPlans : public Darabonba::Model {
public:
  shared_ptr<long> escalationPlanId{};
  shared_ptr<string> escalationPlanName{};

  VerifyRouteRuleResponseBodyDataEscalationPlans() {}

  explicit VerifyRouteRuleResponseBodyDataEscalationPlans(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalationPlanId) {
      res["escalationPlanId"] = boost::any(*escalationPlanId);
    }
    if (escalationPlanName) {
      res["escalationPlanName"] = boost::any(*escalationPlanName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("escalationPlanId") != m.end() && !m["escalationPlanId"].empty()) {
      escalationPlanId = make_shared<long>(boost::any_cast<long>(m["escalationPlanId"]));
    }
    if (m.find("escalationPlanName") != m.end() && !m["escalationPlanName"].empty()) {
      escalationPlanName = make_shared<string>(boost::any_cast<string>(m["escalationPlanName"]));
    }
  }


  virtual ~VerifyRouteRuleResponseBodyDataEscalationPlans() = default;
};
class VerifyRouteRuleResponseBodyDataNotifySubscriptionNames : public Darabonba::Model {
public:
  shared_ptr<long> subscriptionId{};
  shared_ptr<string> title{};

  VerifyRouteRuleResponseBodyDataNotifySubscriptionNames() {}

  explicit VerifyRouteRuleResponseBodyDataNotifySubscriptionNames(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (subscriptionId) {
      res["subscriptionId"] = boost::any(*subscriptionId);
    }
    if (title) {
      res["title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("subscriptionId") != m.end() && !m["subscriptionId"].empty()) {
      subscriptionId = make_shared<long>(boost::any_cast<long>(m["subscriptionId"]));
    }
    if (m.find("title") != m.end() && !m["title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["title"]));
    }
  }


  virtual ~VerifyRouteRuleResponseBodyDataNotifySubscriptionNames() = default;
};
class VerifyRouteRuleResponseBodyData : public Darabonba::Model {
public:
  shared_ptr<vector<VerifyRouteRuleResponseBodyDataEscalationPlans>> escalationPlans{};
  shared_ptr<bool> isValidRule{};
  shared_ptr<vector<long>> monitorSourceIds{};
  shared_ptr<vector<VerifyRouteRuleResponseBodyDataNotifySubscriptionNames>> notifySubscriptionNames{};
  shared_ptr<vector<string>> routeRuleFailReason{};
  shared_ptr<string> routeType{};

  VerifyRouteRuleResponseBodyData() {}

  explicit VerifyRouteRuleResponseBodyData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (escalationPlans) {
      vector<boost::any> temp1;
      for(auto item1:*escalationPlans){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["escalationPlans"] = boost::any(temp1);
    }
    if (isValidRule) {
      res["isValidRule"] = boost::any(*isValidRule);
    }
    if (monitorSourceIds) {
      res["monitorSourceIds"] = boost::any(*monitorSourceIds);
    }
    if (notifySubscriptionNames) {
      vector<boost::any> temp1;
      for(auto item1:*notifySubscriptionNames){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["notifySubscriptionNames"] = boost::any(temp1);
    }
    if (routeRuleFailReason) {
      res["routeRuleFailReason"] = boost::any(*routeRuleFailReason);
    }
    if (routeType) {
      res["routeType"] = boost::any(*routeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("escalationPlans") != m.end() && !m["escalationPlans"].empty()) {
      if (typeid(vector<boost::any>) == m["escalationPlans"].type()) {
        vector<VerifyRouteRuleResponseBodyDataEscalationPlans> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["escalationPlans"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            VerifyRouteRuleResponseBodyDataEscalationPlans model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        escalationPlans = make_shared<vector<VerifyRouteRuleResponseBodyDataEscalationPlans>>(expect1);
      }
    }
    if (m.find("isValidRule") != m.end() && !m["isValidRule"].empty()) {
      isValidRule = make_shared<bool>(boost::any_cast<bool>(m["isValidRule"]));
    }
    if (m.find("monitorSourceIds") != m.end() && !m["monitorSourceIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["monitorSourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["monitorSourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      monitorSourceIds = make_shared<vector<long>>(toVec1);
    }
    if (m.find("notifySubscriptionNames") != m.end() && !m["notifySubscriptionNames"].empty()) {
      if (typeid(vector<boost::any>) == m["notifySubscriptionNames"].type()) {
        vector<VerifyRouteRuleResponseBodyDataNotifySubscriptionNames> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["notifySubscriptionNames"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            VerifyRouteRuleResponseBodyDataNotifySubscriptionNames model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        notifySubscriptionNames = make_shared<vector<VerifyRouteRuleResponseBodyDataNotifySubscriptionNames>>(expect1);
      }
    }
    if (m.find("routeRuleFailReason") != m.end() && !m["routeRuleFailReason"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["routeRuleFailReason"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["routeRuleFailReason"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      routeRuleFailReason = make_shared<vector<string>>(toVec1);
    }
    if (m.find("routeType") != m.end() && !m["routeType"].empty()) {
      routeType = make_shared<string>(boost::any_cast<string>(m["routeType"]));
    }
  }


  virtual ~VerifyRouteRuleResponseBodyData() = default;
};
class VerifyRouteRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<VerifyRouteRuleResponseBodyData> data{};
  shared_ptr<string> requestId{};

  VerifyRouteRuleResponseBody() {}

  explicit VerifyRouteRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (data) {
      res["data"] = data ? boost::any(data->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("data") != m.end() && !m["data"].empty()) {
      if (typeid(map<string, boost::any>) == m["data"].type()) {
        VerifyRouteRuleResponseBodyData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["data"]));
        data = make_shared<VerifyRouteRuleResponseBodyData>(model1);
      }
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~VerifyRouteRuleResponseBody() = default;
};
class VerifyRouteRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<VerifyRouteRuleResponseBody> body{};

  VerifyRouteRuleResponse() {}

  explicit VerifyRouteRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        VerifyRouteRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<VerifyRouteRuleResponseBody>(model1);
      }
    }
  }


  virtual ~VerifyRouteRuleResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddProblemServiceGroupResponse addProblemServiceGroupWithOptions(shared_ptr<AddProblemServiceGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddProblemServiceGroupResponse addProblemServiceGroup(shared_ptr<AddProblemServiceGroupRequest> request);
  BillingStatisticsResponse billingStatisticsWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BillingStatisticsResponse billingStatistics();
  CancelProblemResponse cancelProblemWithOptions(shared_ptr<CancelProblemRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelProblemResponse cancelProblem(shared_ptr<CancelProblemRequest> request);
  CheckWebhookResponse checkWebhookWithOptions(shared_ptr<CheckWebhookRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CheckWebhookResponse checkWebhook(shared_ptr<CheckWebhookRequest> request);
  ConfirmIntegrationConfigResponse confirmIntegrationConfigWithOptions(shared_ptr<ConfirmIntegrationConfigRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ConfirmIntegrationConfigResponse confirmIntegrationConfig(shared_ptr<ConfirmIntegrationConfigRequest> request);
  CreateEscalationPlanResponse createEscalationPlanWithOptions(shared_ptr<CreateEscalationPlanRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEscalationPlanResponse createEscalationPlan(shared_ptr<CreateEscalationPlanRequest> request);
  CreateIncidentResponse createIncidentWithOptions(shared_ptr<CreateIncidentRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateIncidentResponse createIncident(shared_ptr<CreateIncidentRequest> request);
  CreateIncidentSubtotalResponse createIncidentSubtotalWithOptions(shared_ptr<CreateIncidentSubtotalRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateIncidentSubtotalResponse createIncidentSubtotal(shared_ptr<CreateIncidentSubtotalRequest> request);
  CreateIntegrationConfigResponse createIntegrationConfigWithOptions(shared_ptr<CreateIntegrationConfigRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateIntegrationConfigResponse createIntegrationConfig(shared_ptr<CreateIntegrationConfigRequest> request);
  CreateProblemResponse createProblemWithOptions(shared_ptr<CreateProblemRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProblemResponse createProblem(shared_ptr<CreateProblemRequest> request);
  CreateProblemEffectionServiceResponse createProblemEffectionServiceWithOptions(shared_ptr<CreateProblemEffectionServiceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProblemEffectionServiceResponse createProblemEffectionService(shared_ptr<CreateProblemEffectionServiceRequest> request);
  CreateProblemMeasureResponse createProblemMeasureWithOptions(shared_ptr<CreateProblemMeasureRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProblemMeasureResponse createProblemMeasure(shared_ptr<CreateProblemMeasureRequest> request);
  CreateProblemSubtotalResponse createProblemSubtotalWithOptions(shared_ptr<CreateProblemSubtotalRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProblemSubtotalResponse createProblemSubtotal(shared_ptr<CreateProblemSubtotalRequest> request);
  CreateProblemTimelineResponse createProblemTimelineWithOptions(shared_ptr<CreateProblemTimelineRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProblemTimelineResponse createProblemTimeline(shared_ptr<CreateProblemTimelineRequest> request);
  CreateProblemTimelinesResponse createProblemTimelinesWithOptions(shared_ptr<CreateProblemTimelinesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProblemTimelinesResponse createProblemTimelines(shared_ptr<CreateProblemTimelinesRequest> request);
  CreateRichTextResponse createRichTextWithOptions(shared_ptr<CreateRichTextRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRichTextResponse createRichText(shared_ptr<CreateRichTextRequest> request);
  CreateRouteRuleResponse createRouteRuleWithOptions(shared_ptr<CreateRouteRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateRouteRuleResponse createRouteRule(shared_ptr<CreateRouteRuleRequest> request);
  CreateServiceResponse createServiceWithOptions(shared_ptr<CreateServiceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateServiceResponse createService(shared_ptr<CreateServiceRequest> request);
  CreateServiceGroupResponse createServiceGroupWithOptions(shared_ptr<CreateServiceGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateServiceGroupResponse createServiceGroup(shared_ptr<CreateServiceGroupRequest> request);
  CreateServiceGroupSchedulingResponse createServiceGroupSchedulingWithOptions(shared_ptr<CreateServiceGroupSchedulingRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateServiceGroupSchedulingResponse createServiceGroupScheduling(shared_ptr<CreateServiceGroupSchedulingRequest> request);
  CreateSubscriptionResponse createSubscriptionWithOptions(shared_ptr<CreateSubscriptionRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSubscriptionResponse createSubscription(shared_ptr<CreateSubscriptionRequest> request);
  CreateTenantApplicationResponse createTenantApplicationWithOptions(shared_ptr<CreateTenantApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTenantApplicationResponse createTenantApplication(shared_ptr<CreateTenantApplicationRequest> request);
  CreateUserResponse createUserWithOptions(shared_ptr<CreateUserRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateUserResponse createUser(shared_ptr<CreateUserRequest> request);
  DeleteEscalationPlanResponse deleteEscalationPlanWithOptions(shared_ptr<DeleteEscalationPlanRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEscalationPlanResponse deleteEscalationPlan(shared_ptr<DeleteEscalationPlanRequest> request);
  DeleteIncidentResponse deleteIncidentWithOptions(shared_ptr<DeleteIncidentRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteIncidentResponse deleteIncident(shared_ptr<DeleteIncidentRequest> request);
  DeleteIntegrationConfigResponse deleteIntegrationConfigWithOptions(shared_ptr<DeleteIntegrationConfigRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteIntegrationConfigResponse deleteIntegrationConfig(shared_ptr<DeleteIntegrationConfigRequest> request);
  DeleteProblemResponse deleteProblemWithOptions(shared_ptr<DeleteProblemRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteProblemResponse deleteProblem(shared_ptr<DeleteProblemRequest> request);
  DeleteProblemEffectionServiceResponse deleteProblemEffectionServiceWithOptions(shared_ptr<DeleteProblemEffectionServiceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteProblemEffectionServiceResponse deleteProblemEffectionService(shared_ptr<DeleteProblemEffectionServiceRequest> request);
  DeleteProblemMeasureResponse deleteProblemMeasureWithOptions(shared_ptr<DeleteProblemMeasureRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteProblemMeasureResponse deleteProblemMeasure(shared_ptr<DeleteProblemMeasureRequest> request);
  DeleteProblemTimelineResponse deleteProblemTimelineWithOptions(shared_ptr<DeleteProblemTimelineRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteProblemTimelineResponse deleteProblemTimeline(shared_ptr<DeleteProblemTimelineRequest> request);
  DeleteRouteRuleResponse deleteRouteRuleWithOptions(shared_ptr<DeleteRouteRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRouteRuleResponse deleteRouteRule(shared_ptr<DeleteRouteRuleRequest> request);
  DeleteServiceResponse deleteServiceWithOptions(shared_ptr<DeleteServiceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteServiceResponse deleteService(shared_ptr<DeleteServiceRequest> request);
  DeleteServiceGroupResponse deleteServiceGroupWithOptions(shared_ptr<DeleteServiceGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteServiceGroupResponse deleteServiceGroup(shared_ptr<DeleteServiceGroupRequest> request);
  DeleteServiceGroupSchedulingResponse deleteServiceGroupSchedulingWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteServiceGroupSchedulingResponse deleteServiceGroupScheduling();
  DeleteServiceGroupUserResponse deleteServiceGroupUserWithOptions(shared_ptr<DeleteServiceGroupUserRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteServiceGroupUserResponse deleteServiceGroupUser(shared_ptr<DeleteServiceGroupUserRequest> request);
  DeleteSubscriptionResponse deleteSubscriptionWithOptions(shared_ptr<DeleteSubscriptionRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSubscriptionResponse deleteSubscription(shared_ptr<DeleteSubscriptionRequest> request);
  DeleteUserResponse deleteUserWithOptions(shared_ptr<DeleteUserRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteUserResponse deleteUser(shared_ptr<DeleteUserRequest> request);
  DeliverIncidentResponse deliverIncidentWithOptions(shared_ptr<DeliverIncidentRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeliverIncidentResponse deliverIncident(shared_ptr<DeliverIncidentRequest> request);
  DisableEscalationPlanResponse disableEscalationPlanWithOptions(shared_ptr<DisableEscalationPlanRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableEscalationPlanResponse disableEscalationPlan(shared_ptr<DisableEscalationPlanRequest> request);
  DisableIntegrationConfigResponse disableIntegrationConfigWithOptions(shared_ptr<DisableIntegrationConfigRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableIntegrationConfigResponse disableIntegrationConfig(shared_ptr<DisableIntegrationConfigRequest> request);
  DisableRouteRuleResponse disableRouteRuleWithOptions(shared_ptr<DisableRouteRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableRouteRuleResponse disableRouteRule(shared_ptr<DisableRouteRuleRequest> request);
  DisableServiceGroupWebhookResponse disableServiceGroupWebhookWithOptions(shared_ptr<DisableServiceGroupWebhookRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableServiceGroupWebhookResponse disableServiceGroupWebhook(shared_ptr<DisableServiceGroupWebhookRequest> request);
  DisableSubscriptionResponse disableSubscriptionWithOptions(shared_ptr<DisableSubscriptionRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableSubscriptionResponse disableSubscription(shared_ptr<DisableSubscriptionRequest> request);
  EnableEscalationPlanResponse enableEscalationPlanWithOptions(shared_ptr<EnableEscalationPlanRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableEscalationPlanResponse enableEscalationPlan(shared_ptr<EnableEscalationPlanRequest> request);
  EnableIntegrationConfigResponse enableIntegrationConfigWithOptions(shared_ptr<EnableIntegrationConfigRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableIntegrationConfigResponse enableIntegrationConfig(shared_ptr<EnableIntegrationConfigRequest> request);
  EnableRouteRuleResponse enableRouteRuleWithOptions(shared_ptr<EnableRouteRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableRouteRuleResponse enableRouteRule(shared_ptr<EnableRouteRuleRequest> request);
  EnableServiceGroupWebhookResponse enableServiceGroupWebhookWithOptions(shared_ptr<EnableServiceGroupWebhookRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableServiceGroupWebhookResponse enableServiceGroupWebhook(shared_ptr<EnableServiceGroupWebhookRequest> request);
  EnableSubscriptionResponse enableSubscriptionWithOptions(shared_ptr<EnableSubscriptionRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableSubscriptionResponse enableSubscription(shared_ptr<EnableSubscriptionRequest> request);
  FinishIncidentResponse finishIncidentWithOptions(shared_ptr<FinishIncidentRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FinishIncidentResponse finishIncident(shared_ptr<FinishIncidentRequest> request);
  FinishProblemResponse finishProblemWithOptions(shared_ptr<FinishProblemRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FinishProblemResponse finishProblem(shared_ptr<FinishProblemRequest> request);
  GeneratePictureLinkResponse generatePictureLinkWithOptions(shared_ptr<GeneratePictureLinkRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GeneratePictureLinkResponse generatePictureLink(shared_ptr<GeneratePictureLinkRequest> request);
  GeneratePictureUploadSignResponse generatePictureUploadSignWithOptions(shared_ptr<GeneratePictureUploadSignRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GeneratePictureUploadSignResponse generatePictureUploadSign(shared_ptr<GeneratePictureUploadSignRequest> request);
  GenerateProblemPictureLinkResponse generateProblemPictureLinkWithOptions(shared_ptr<GenerateProblemPictureLinkRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateProblemPictureLinkResponse generateProblemPictureLink(shared_ptr<GenerateProblemPictureLinkRequest> request);
  GenerateProblemPictureUploadSignResponse generateProblemPictureUploadSignWithOptions(shared_ptr<GenerateProblemPictureUploadSignRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateProblemPictureUploadSignResponse generateProblemPictureUploadSign(shared_ptr<GenerateProblemPictureUploadSignRequest> request);
  GetEscalationPlanResponse getEscalationPlanWithOptions(shared_ptr<GetEscalationPlanRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEscalationPlanResponse getEscalationPlan(shared_ptr<GetEscalationPlanRequest> request);
  GetEventResponse getEventWithOptions(shared_ptr<GetEventRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEventResponse getEvent(shared_ptr<GetEventRequest> request);
  GetHomePageGuidanceResponse getHomePageGuidanceWithOptions(shared_ptr<GetHomePageGuidanceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetHomePageGuidanceResponse getHomePageGuidance(shared_ptr<GetHomePageGuidanceRequest> request);
  GetIncidentResponse getIncidentWithOptions(shared_ptr<GetIncidentRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetIncidentResponse getIncident(shared_ptr<GetIncidentRequest> request);
  GetIncidentListByIdListResponse getIncidentListByIdListWithOptions(shared_ptr<GetIncidentListByIdListRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetIncidentListByIdListResponse getIncidentListByIdList(shared_ptr<GetIncidentListByIdListRequest> request);
  GetIncidentStatisticsResponse getIncidentStatisticsWithOptions(shared_ptr<GetIncidentStatisticsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetIncidentStatisticsResponse getIncidentStatistics(shared_ptr<GetIncidentStatisticsRequest> request);
  GetIncidentSubtotalCountResponse getIncidentSubtotalCountWithOptions(shared_ptr<GetIncidentSubtotalCountRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetIncidentSubtotalCountResponse getIncidentSubtotalCount(shared_ptr<GetIncidentSubtotalCountRequest> request);
  GetIntegrationConfigResponse getIntegrationConfigWithOptions(shared_ptr<GetIntegrationConfigRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetIntegrationConfigResponse getIntegrationConfig(shared_ptr<GetIntegrationConfigRequest> request);
  GetProblemResponse getProblemWithOptions(shared_ptr<GetProblemRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetProblemResponse getProblem(shared_ptr<GetProblemRequest> request);
  GetProblemEffectionServiceResponse getProblemEffectionServiceWithOptions(shared_ptr<GetProblemEffectionServiceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetProblemEffectionServiceResponse getProblemEffectionService(shared_ptr<GetProblemEffectionServiceRequest> request);
  GetProblemImprovementResponse getProblemImprovementWithOptions(shared_ptr<GetProblemImprovementRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetProblemImprovementResponse getProblemImprovement(shared_ptr<GetProblemImprovementRequest> request);
  GetProblemPreviewResponse getProblemPreviewWithOptions(shared_ptr<GetProblemPreviewRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetProblemPreviewResponse getProblemPreview(shared_ptr<GetProblemPreviewRequest> request);
  GetResourceStatisticsResponse getResourceStatisticsWithOptions(shared_ptr<GetResourceStatisticsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetResourceStatisticsResponse getResourceStatistics(shared_ptr<GetResourceStatisticsRequest> request);
  GetRichTextResponse getRichTextWithOptions(shared_ptr<GetRichTextRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRichTextResponse getRichText(shared_ptr<GetRichTextRequest> request);
  GetRouteRuleResponse getRouteRuleWithOptions(shared_ptr<GetRouteRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRouteRuleResponse getRouteRule(shared_ptr<GetRouteRuleRequest> request);
  GetServiceResponse getServiceWithOptions(shared_ptr<GetServiceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetServiceResponse getService(shared_ptr<GetServiceRequest> request);
  GetServiceGroupResponse getServiceGroupWithOptions(shared_ptr<GetServiceGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetServiceGroupResponse getServiceGroup(shared_ptr<GetServiceGroupRequest> request);
  GetServiceGroupPersonSchedulingResponse getServiceGroupPersonSchedulingWithOptions(shared_ptr<GetServiceGroupPersonSchedulingRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetServiceGroupPersonSchedulingResponse getServiceGroupPersonScheduling(shared_ptr<GetServiceGroupPersonSchedulingRequest> request);
  GetServiceGroupSchedulingResponse getServiceGroupSchedulingWithOptions(shared_ptr<GetServiceGroupSchedulingRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetServiceGroupSchedulingResponse getServiceGroupScheduling(shared_ptr<GetServiceGroupSchedulingRequest> request);
  GetServiceGroupSchedulingPreviewResponse getServiceGroupSchedulingPreviewWithOptions(shared_ptr<GetServiceGroupSchedulingPreviewRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetServiceGroupSchedulingPreviewResponse getServiceGroupSchedulingPreview(shared_ptr<GetServiceGroupSchedulingPreviewRequest> request);
  GetServiceGroupSpecialPersonSchedulingResponse getServiceGroupSpecialPersonSchedulingWithOptions(shared_ptr<GetServiceGroupSpecialPersonSchedulingRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetServiceGroupSpecialPersonSchedulingResponse getServiceGroupSpecialPersonScheduling(shared_ptr<GetServiceGroupSpecialPersonSchedulingRequest> request);
  GetSimilarIncidentStatisticsResponse getSimilarIncidentStatisticsWithOptions(shared_ptr<GetSimilarIncidentStatisticsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSimilarIncidentStatisticsResponse getSimilarIncidentStatistics(shared_ptr<GetSimilarIncidentStatisticsRequest> request);
  GetSubscriptionResponse getSubscriptionWithOptions(shared_ptr<GetSubscriptionRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSubscriptionResponse getSubscription(shared_ptr<GetSubscriptionRequest> request);
  GetTenantApplicationResponse getTenantApplicationWithOptions(shared_ptr<GetTenantApplicationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTenantApplicationResponse getTenantApplication(shared_ptr<GetTenantApplicationRequest> request);
  GetTenantStatusResponse getTenantStatusWithOptions(shared_ptr<GetTenantStatusRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTenantStatusResponse getTenantStatus(shared_ptr<GetTenantStatusRequest> request);
  GetUserResponse getUserWithOptions(shared_ptr<GetUserRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUserResponse getUser(shared_ptr<GetUserRequest> request);
  GetUserGuideStatusResponse getUserGuideStatusWithOptions(shared_ptr<GetUserGuideStatusRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetUserGuideStatusResponse getUserGuideStatus(shared_ptr<GetUserGuideStatusRequest> request);
  ListAlertsResponse listAlertsWithOptions(shared_ptr<ListAlertsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAlertsResponse listAlerts(shared_ptr<ListAlertsRequest> request);
  ListByMonitorSourceIdResponse listByMonitorSourceIdWithOptions(shared_ptr<ListByMonitorSourceIdRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListByMonitorSourceIdResponse listByMonitorSourceId(shared_ptr<ListByMonitorSourceIdRequest> request);
  ListChartDataForServiceGroupResponse listChartDataForServiceGroupWithOptions(shared_ptr<ListChartDataForServiceGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListChartDataForServiceGroupResponse listChartDataForServiceGroup(shared_ptr<ListChartDataForServiceGroupRequest> request);
  ListChartDataForUserResponse listChartDataForUserWithOptions(shared_ptr<ListChartDataForUserRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListChartDataForUserResponse listChartDataForUser(shared_ptr<ListChartDataForUserRequest> request);
  ListConfigsResponse listConfigsWithOptions(shared_ptr<ListConfigsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListConfigsResponse listConfigs(shared_ptr<ListConfigsRequest> request);
  ListDataReportForServiceGroupResponse listDataReportForServiceGroupWithOptions(shared_ptr<ListDataReportForServiceGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataReportForServiceGroupResponse listDataReportForServiceGroup(shared_ptr<ListDataReportForServiceGroupRequest> request);
  ListDataReportForUserResponse listDataReportForUserWithOptions(shared_ptr<ListDataReportForUserRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataReportForUserResponse listDataReportForUser(shared_ptr<ListDataReportForUserRequest> request);
  ListDictionariesResponse listDictionariesWithOptions(shared_ptr<ListDictionariesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDictionariesResponse listDictionaries(shared_ptr<ListDictionariesRequest> request);
  ListEscalationPlanServicesResponse listEscalationPlanServicesWithOptions(shared_ptr<ListEscalationPlanServicesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEscalationPlanServicesResponse listEscalationPlanServices(shared_ptr<ListEscalationPlanServicesRequest> request);
  ListEscalationPlansResponse listEscalationPlansWithOptions(shared_ptr<ListEscalationPlansRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEscalationPlansResponse listEscalationPlans(shared_ptr<ListEscalationPlansRequest> request);
  ListEscalationPlansByNoticeObjectResponse listEscalationPlansByNoticeObjectWithOptions(shared_ptr<ListEscalationPlansByNoticeObjectRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEscalationPlansByNoticeObjectResponse listEscalationPlansByNoticeObject(shared_ptr<ListEscalationPlansByNoticeObjectRequest> request);
  ListIncidentDetailEscalationPlansResponse listIncidentDetailEscalationPlansWithOptions(shared_ptr<ListIncidentDetailEscalationPlansRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIncidentDetailEscalationPlansResponse listIncidentDetailEscalationPlans(shared_ptr<ListIncidentDetailEscalationPlansRequest> request);
  ListIncidentDetailTimelinesResponse listIncidentDetailTimelinesWithOptions(shared_ptr<ListIncidentDetailTimelinesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIncidentDetailTimelinesResponse listIncidentDetailTimelines(shared_ptr<ListIncidentDetailTimelinesRequest> request);
  ListIncidentSubtotalsResponse listIncidentSubtotalsWithOptions(shared_ptr<ListIncidentSubtotalsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIncidentSubtotalsResponse listIncidentSubtotals(shared_ptr<ListIncidentSubtotalsRequest> request);
  ListIncidentTimelinesResponse listIncidentTimelinesWithOptions(shared_ptr<ListIncidentTimelinesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIncidentTimelinesResponse listIncidentTimelines(shared_ptr<ListIncidentTimelinesRequest> request);
  ListIncidentsResponse listIncidentsWithOptions(shared_ptr<ListIncidentsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIncidentsResponse listIncidents(shared_ptr<ListIncidentsRequest> request);
  ListIntegrationConfigTimelinesResponse listIntegrationConfigTimelinesWithOptions(shared_ptr<ListIntegrationConfigTimelinesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIntegrationConfigTimelinesResponse listIntegrationConfigTimelines(shared_ptr<ListIntegrationConfigTimelinesRequest> request);
  ListIntegrationConfigsResponse listIntegrationConfigsWithOptions(shared_ptr<ListIntegrationConfigsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIntegrationConfigsResponse listIntegrationConfigs(shared_ptr<ListIntegrationConfigsRequest> request);
  ListMonitorSourcesResponse listMonitorSourcesWithOptions(shared_ptr<ListMonitorSourcesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListMonitorSourcesResponse listMonitorSources(shared_ptr<ListMonitorSourcesRequest> request);
  ListProblemDetailOperationsResponse listProblemDetailOperationsWithOptions(shared_ptr<ListProblemDetailOperationsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProblemDetailOperationsResponse listProblemDetailOperations(shared_ptr<ListProblemDetailOperationsRequest> request);
  ListProblemOperationsResponse listProblemOperationsWithOptions(shared_ptr<ListProblemOperationsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProblemOperationsResponse listProblemOperations(shared_ptr<ListProblemOperationsRequest> request);
  ListProblemSubtotalsResponse listProblemSubtotalsWithOptions(shared_ptr<ListProblemSubtotalsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProblemSubtotalsResponse listProblemSubtotals(shared_ptr<ListProblemSubtotalsRequest> request);
  ListProblemTimeLinesResponse listProblemTimeLinesWithOptions(shared_ptr<ListProblemTimeLinesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProblemTimeLinesResponse listProblemTimeLines(shared_ptr<ListProblemTimeLinesRequest> request);
  ListProblemsResponse listProblemsWithOptions(shared_ptr<ListProblemsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProblemsResponse listProblems(shared_ptr<ListProblemsRequest> request);
  ListRouteRulesResponse listRouteRulesWithOptions(shared_ptr<ListRouteRulesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRouteRulesResponse listRouteRules(shared_ptr<ListRouteRulesRequest> request);
  ListRouteRulesByAssignWhoIdResponse listRouteRulesByAssignWhoIdWithOptions(shared_ptr<ListRouteRulesByAssignWhoIdRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRouteRulesByAssignWhoIdResponse listRouteRulesByAssignWhoId(shared_ptr<ListRouteRulesByAssignWhoIdRequest> request);
  ListRouteRulesByServiceResponse listRouteRulesByServiceWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRouteRulesByServiceResponse listRouteRulesByService();
  ListServiceGroupMonitorSourceTemplatesResponse listServiceGroupMonitorSourceTemplatesWithOptions(shared_ptr<ListServiceGroupMonitorSourceTemplatesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListServiceGroupMonitorSourceTemplatesResponse listServiceGroupMonitorSourceTemplates(shared_ptr<ListServiceGroupMonitorSourceTemplatesRequest> request);
  ListServiceGroupsResponse listServiceGroupsWithOptions(shared_ptr<ListServiceGroupsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListServiceGroupsResponse listServiceGroups(shared_ptr<ListServiceGroupsRequest> request);
  ListServiceGroupsByUserIdResponse listServiceGroupsByUserIdWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListServiceGroupsByUserIdResponse listServiceGroupsByUserId();
  ListServicesResponse listServicesWithOptions(shared_ptr<ListServicesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListServicesResponse listServices(shared_ptr<ListServicesRequest> request);
  ListSourceEventsResponse listSourceEventsWithOptions(shared_ptr<ListSourceEventsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSourceEventsResponse listSourceEvents(shared_ptr<ListSourceEventsRequest> request);
  ListSourceEventsForMonitorSourceResponse listSourceEventsForMonitorSourceWithOptions(shared_ptr<ListSourceEventsForMonitorSourceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSourceEventsForMonitorSourceResponse listSourceEventsForMonitorSource(shared_ptr<ListSourceEventsForMonitorSourceRequest> request);
  ListSubscriptionServiceGroupsResponse listSubscriptionServiceGroupsWithOptions(shared_ptr<ListSubscriptionServiceGroupsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSubscriptionServiceGroupsResponse listSubscriptionServiceGroups(shared_ptr<ListSubscriptionServiceGroupsRequest> request);
  ListSubscriptionsResponse listSubscriptionsWithOptions(shared_ptr<ListSubscriptionsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSubscriptionsResponse listSubscriptions(shared_ptr<ListSubscriptionsRequest> request);
  ListTrendForSourceEventResponse listTrendForSourceEventWithOptions(shared_ptr<ListTrendForSourceEventRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTrendForSourceEventResponse listTrendForSourceEvent(shared_ptr<ListTrendForSourceEventRequest> request);
  ListUserSerivceGroupsResponse listUserSerivceGroupsWithOptions(shared_ptr<ListUserSerivceGroupsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUserSerivceGroupsResponse listUserSerivceGroups(shared_ptr<ListUserSerivceGroupsRequest> request);
  ListUsersResponse listUsersWithOptions(shared_ptr<ListUsersRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListUsersResponse listUsers(shared_ptr<ListUsersRequest> request);
  PushMonitorResponse pushMonitorWithOptions(shared_ptr<string> apiKey,
                                             shared_ptr<PushMonitorRequest> request,
                                             shared_ptr<map<string, string>> headers,
                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PushMonitorResponse pushMonitor(shared_ptr<string> apiKey, shared_ptr<PushMonitorRequest> request);
  RecoverProblemResponse recoverProblemWithOptions(shared_ptr<RecoverProblemRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RecoverProblemResponse recoverProblem(shared_ptr<RecoverProblemRequest> request);
  RefreshIntegrationConfigKeyResponse refreshIntegrationConfigKeyWithOptions(shared_ptr<RefreshIntegrationConfigKeyRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefreshIntegrationConfigKeyResponse refreshIntegrationConfigKey(shared_ptr<RefreshIntegrationConfigKeyRequest> request);
  RemoveIntegrationConfigResponse removeIntegrationConfigWithOptions(shared_ptr<RemoveIntegrationConfigRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveIntegrationConfigResponse removeIntegrationConfig(shared_ptr<RemoveIntegrationConfigRequest> request);
  RemoveProblemServiceGroupResponse removeProblemServiceGroupWithOptions(shared_ptr<RemoveProblemServiceGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveProblemServiceGroupResponse removeProblemServiceGroup(shared_ptr<RemoveProblemServiceGroupRequest> request);
  ReplayProblemResponse replayProblemWithOptions(shared_ptr<ReplayProblemRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReplayProblemResponse replayProblem(shared_ptr<ReplayProblemRequest> request);
  RespondIncidentResponse respondIncidentWithOptions(shared_ptr<RespondIncidentRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RespondIncidentResponse respondIncident(shared_ptr<RespondIncidentRequest> request);
  RevokeProblemRecoveryResponse revokeProblemRecoveryWithOptions(shared_ptr<RevokeProblemRecoveryRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeProblemRecoveryResponse revokeProblemRecovery(shared_ptr<RevokeProblemRecoveryRequest> request);
  UnbindUserResponse unbindUserWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindUserResponse unbindUser();
  UpdateEscalationPlanResponse updateEscalationPlanWithOptions(shared_ptr<UpdateEscalationPlanRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEscalationPlanResponse updateEscalationPlan(shared_ptr<UpdateEscalationPlanRequest> request);
  UpdateIncidentResponse updateIncidentWithOptions(shared_ptr<UpdateIncidentRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateIncidentResponse updateIncident(shared_ptr<UpdateIncidentRequest> request);
  UpdateIntegrationConfigResponse updateIntegrationConfigWithOptions(shared_ptr<UpdateIntegrationConfigRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateIntegrationConfigResponse updateIntegrationConfig(shared_ptr<UpdateIntegrationConfigRequest> request);
  UpdateProblemResponse updateProblemWithOptions(shared_ptr<UpdateProblemRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProblemResponse updateProblem(shared_ptr<UpdateProblemRequest> request);
  UpdateProblemEffectionServiceResponse updateProblemEffectionServiceWithOptions(shared_ptr<UpdateProblemEffectionServiceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProblemEffectionServiceResponse updateProblemEffectionService(shared_ptr<UpdateProblemEffectionServiceRequest> request);
  UpdateProblemImprovementResponse updateProblemImprovementWithOptions(shared_ptr<UpdateProblemImprovementRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProblemImprovementResponse updateProblemImprovement(shared_ptr<UpdateProblemImprovementRequest> request);
  UpdateProblemMeasureResponse updateProblemMeasureWithOptions(shared_ptr<UpdateProblemMeasureRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProblemMeasureResponse updateProblemMeasure(shared_ptr<UpdateProblemMeasureRequest> request);
  UpdateProblemNoticeResponse updateProblemNoticeWithOptions(shared_ptr<UpdateProblemNoticeRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProblemNoticeResponse updateProblemNotice(shared_ptr<UpdateProblemNoticeRequest> request);
  UpdateProblemTimelineResponse updateProblemTimelineWithOptions(shared_ptr<UpdateProblemTimelineRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProblemTimelineResponse updateProblemTimeline(shared_ptr<UpdateProblemTimelineRequest> request);
  UpdateRichTextResponse updateRichTextWithOptions(shared_ptr<UpdateRichTextRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRichTextResponse updateRichText(shared_ptr<UpdateRichTextRequest> request);
  UpdateRouteRuleResponse updateRouteRuleWithOptions(shared_ptr<UpdateRouteRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateRouteRuleResponse updateRouteRule(shared_ptr<UpdateRouteRuleRequest> request);
  UpdateServiceResponse updateServiceWithOptions(shared_ptr<UpdateServiceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateServiceResponse updateService(shared_ptr<UpdateServiceRequest> request);
  UpdateServiceGroupResponse updateServiceGroupWithOptions(shared_ptr<UpdateServiceGroupRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateServiceGroupResponse updateServiceGroup(shared_ptr<UpdateServiceGroupRequest> request);
  UpdateServiceGroupSchedulingResponse updateServiceGroupSchedulingWithOptions(shared_ptr<UpdateServiceGroupSchedulingRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateServiceGroupSchedulingResponse updateServiceGroupScheduling(shared_ptr<UpdateServiceGroupSchedulingRequest> request);
  UpdateServiceGroupSpecialDaySchedulingResponse updateServiceGroupSpecialDaySchedulingWithOptions(shared_ptr<UpdateServiceGroupSpecialDaySchedulingRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateServiceGroupSpecialDaySchedulingResponse updateServiceGroupSpecialDayScheduling(shared_ptr<UpdateServiceGroupSpecialDaySchedulingRequest> request);
  UpdateSubscriptionResponse updateSubscriptionWithOptions(shared_ptr<UpdateSubscriptionRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSubscriptionResponse updateSubscription(shared_ptr<UpdateSubscriptionRequest> request);
  UpdateUserResponse updateUserWithOptions(shared_ptr<UpdateUserRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateUserResponse updateUser(shared_ptr<UpdateUserRequest> request);
  UpdateUserGuideStatusResponse updateUserGuideStatusWithOptions(shared_ptr<UpdateUserGuideStatusRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateUserGuideStatusResponse updateUserGuideStatus(shared_ptr<UpdateUserGuideStatusRequest> request);
  VerifyRouteRuleResponse verifyRouteRuleWithOptions(shared_ptr<VerifyRouteRuleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  VerifyRouteRuleResponse verifyRouteRule(shared_ptr<VerifyRouteRuleRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_GEMP20210413

#endif
