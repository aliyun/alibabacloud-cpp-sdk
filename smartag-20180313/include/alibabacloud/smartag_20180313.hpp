// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_SMARTAG20180313_H_
#define ALIBABACLOUD_SMARTAG20180313_H_

#include <alibabacloud/open_api.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Smartag20180313 {
class GrantSagInstanceToVbrRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> vbrUid{};
  shared_ptr<string> vbrInstanceId{};
  shared_ptr<string> vbrRegionId{};
  shared_ptr<string> smartAGId{};

  GrantSagInstanceToVbrRequest() {}

  explicit GrantSagInstanceToVbrRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vbrUid) {
      res["VbrUid"] = boost::any(*vbrUid);
    }
    if (vbrInstanceId) {
      res["VbrInstanceId"] = boost::any(*vbrInstanceId);
    }
    if (vbrRegionId) {
      res["VbrRegionId"] = boost::any(*vbrRegionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VbrUid") != m.end() && !m["VbrUid"].empty()) {
      vbrUid = make_shared<long>(boost::any_cast<long>(m["VbrUid"]));
    }
    if (m.find("VbrInstanceId") != m.end() && !m["VbrInstanceId"].empty()) {
      vbrInstanceId = make_shared<string>(boost::any_cast<string>(m["VbrInstanceId"]));
    }
    if (m.find("VbrRegionId") != m.end() && !m["VbrRegionId"].empty()) {
      vbrRegionId = make_shared<string>(boost::any_cast<string>(m["VbrRegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
  }


  virtual ~GrantSagInstanceToVbrRequest() = default;
};
class GrantSagInstanceToVbrResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> instanceId{};

  GrantSagInstanceToVbrResponseBody() {}

  explicit GrantSagInstanceToVbrResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GrantSagInstanceToVbrResponseBody() = default;
};
class GrantSagInstanceToVbrResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GrantSagInstanceToVbrResponseBody> body{};

  GrantSagInstanceToVbrResponse() {}

  explicit GrantSagInstanceToVbrResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GrantSagInstanceToVbrResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GrantSagInstanceToVbrResponseBody>(model1);
      }
    }
  }


  virtual ~GrantSagInstanceToVbrResponse() = default;
};
class DescribeSagTrafficTopNRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> size{};

  DescribeSagTrafficTopNRequest() {}

  explicit DescribeSagTrafficTopNRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~DescribeSagTrafficTopNRequest() = default;
};
class DescribeSagTrafficTopNResponseBodyTrafficTopN : public Darabonba::Model {
public:
  shared_ptr<string> trafficRate{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};

  DescribeSagTrafficTopNResponseBodyTrafficTopN() {}

  explicit DescribeSagTrafficTopNResponseBodyTrafficTopN(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (trafficRate) {
      res["TrafficRate"] = boost::any(*trafficRate);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TrafficRate") != m.end() && !m["TrafficRate"].empty()) {
      trafficRate = make_shared<string>(boost::any_cast<string>(m["TrafficRate"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeSagTrafficTopNResponseBodyTrafficTopN() = default;
};
class DescribeSagTrafficTopNResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSagTrafficTopNResponseBodyTrafficTopN>> trafficTopN{};

  DescribeSagTrafficTopNResponseBody() {}

  explicit DescribeSagTrafficTopNResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (trafficTopN) {
      vector<boost::any> temp1;
      for(auto item1:*trafficTopN){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TrafficTopN"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TrafficTopN") != m.end() && !m["TrafficTopN"].empty()) {
      if (typeid(vector<boost::any>) == m["TrafficTopN"].type()) {
        vector<DescribeSagTrafficTopNResponseBodyTrafficTopN> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TrafficTopN"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSagTrafficTopNResponseBodyTrafficTopN model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        trafficTopN = make_shared<vector<DescribeSagTrafficTopNResponseBodyTrafficTopN>>(expect1);
      }
    }
  }


  virtual ~DescribeSagTrafficTopNResponseBody() = default;
};
class DescribeSagTrafficTopNResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSagTrafficTopNResponseBody> body{};

  DescribeSagTrafficTopNResponse() {}

  explicit DescribeSagTrafficTopNResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSagTrafficTopNResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSagTrafficTopNResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSagTrafficTopNResponse() = default;
};
class DescribeGrantSagVbrRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> vbrInstanceId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeGrantSagVbrRulesRequest() {}

  explicit DescribeGrantSagVbrRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (vbrInstanceId) {
      res["VbrInstanceId"] = boost::any(*vbrInstanceId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("VbrInstanceId") != m.end() && !m["VbrInstanceId"].empty()) {
      vbrInstanceId = make_shared<string>(boost::any_cast<string>(m["VbrInstanceId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeGrantSagVbrRulesRequest() = default;
};
class DescribeGrantSagVbrRulesResponseBodyGrantRulesGrantRule : public Darabonba::Model {
public:
  shared_ptr<string> vbrInstanceId{};
  shared_ptr<long> vbrUid{};
  shared_ptr<string> vbrRegionId{};
  shared_ptr<long> createTime{};
  shared_ptr<string> smartAGId{};
  shared_ptr<bool> bound{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> smartAGUid{};

  DescribeGrantSagVbrRulesResponseBodyGrantRulesGrantRule() {}

  explicit DescribeGrantSagVbrRulesResponseBodyGrantRulesGrantRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vbrInstanceId) {
      res["VbrInstanceId"] = boost::any(*vbrInstanceId);
    }
    if (vbrUid) {
      res["VbrUid"] = boost::any(*vbrUid);
    }
    if (vbrRegionId) {
      res["VbrRegionId"] = boost::any(*vbrRegionId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (bound) {
      res["Bound"] = boost::any(*bound);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (smartAGUid) {
      res["SmartAGUid"] = boost::any(*smartAGUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VbrInstanceId") != m.end() && !m["VbrInstanceId"].empty()) {
      vbrInstanceId = make_shared<string>(boost::any_cast<string>(m["VbrInstanceId"]));
    }
    if (m.find("VbrUid") != m.end() && !m["VbrUid"].empty()) {
      vbrUid = make_shared<long>(boost::any_cast<long>(m["VbrUid"]));
    }
    if (m.find("VbrRegionId") != m.end() && !m["VbrRegionId"].empty()) {
      vbrRegionId = make_shared<string>(boost::any_cast<string>(m["VbrRegionId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("Bound") != m.end() && !m["Bound"].empty()) {
      bound = make_shared<bool>(boost::any_cast<bool>(m["Bound"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SmartAGUid") != m.end() && !m["SmartAGUid"].empty()) {
      smartAGUid = make_shared<long>(boost::any_cast<long>(m["SmartAGUid"]));
    }
  }


  virtual ~DescribeGrantSagVbrRulesResponseBodyGrantRulesGrantRule() = default;
};
class DescribeGrantSagVbrRulesResponseBodyGrantRules : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGrantSagVbrRulesResponseBodyGrantRulesGrantRule>> grantRule{};

  DescribeGrantSagVbrRulesResponseBodyGrantRules() {}

  explicit DescribeGrantSagVbrRulesResponseBodyGrantRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (grantRule) {
      vector<boost::any> temp1;
      for(auto item1:*grantRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GrantRule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GrantRule") != m.end() && !m["GrantRule"].empty()) {
      if (typeid(vector<boost::any>) == m["GrantRule"].type()) {
        vector<DescribeGrantSagVbrRulesResponseBodyGrantRulesGrantRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GrantRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGrantSagVbrRulesResponseBodyGrantRulesGrantRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        grantRule = make_shared<vector<DescribeGrantSagVbrRulesResponseBodyGrantRulesGrantRule>>(expect1);
      }
    }
  }


  virtual ~DescribeGrantSagVbrRulesResponseBodyGrantRules() = default;
};
class DescribeGrantSagVbrRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<DescribeGrantSagVbrRulesResponseBodyGrantRules> grantRules{};

  DescribeGrantSagVbrRulesResponseBody() {}

  explicit DescribeGrantSagVbrRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (grantRules) {
      res["GrantRules"] = grantRules ? boost::any(grantRules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("GrantRules") != m.end() && !m["GrantRules"].empty()) {
      if (typeid(map<string, boost::any>) == m["GrantRules"].type()) {
        DescribeGrantSagVbrRulesResponseBodyGrantRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GrantRules"]));
        grantRules = make_shared<DescribeGrantSagVbrRulesResponseBodyGrantRules>(model1);
      }
    }
  }


  virtual ~DescribeGrantSagVbrRulesResponseBody() = default;
};
class DescribeGrantSagVbrRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeGrantSagVbrRulesResponseBody> body{};

  DescribeGrantSagVbrRulesResponse() {}

  explicit DescribeGrantSagVbrRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGrantSagVbrRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGrantSagVbrRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGrantSagVbrRulesResponse() = default;
};
class DescribeSagStaticRouteListRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};

  DescribeSagStaticRouteListRequest() {}

  explicit DescribeSagStaticRouteListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
  }


  virtual ~DescribeSagStaticRouteListRequest() = default;
};
class DescribeSagStaticRouteListResponseBodyStaticRoutes : public Darabonba::Model {
public:
  shared_ptr<string> nextHop{};
  shared_ptr<string> destinationCidr{};
  shared_ptr<string> portName{};
  shared_ptr<string> vlan{};

  DescribeSagStaticRouteListResponseBodyStaticRoutes() {}

  explicit DescribeSagStaticRouteListResponseBodyStaticRoutes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextHop) {
      res["NextHop"] = boost::any(*nextHop);
    }
    if (destinationCidr) {
      res["DestinationCidr"] = boost::any(*destinationCidr);
    }
    if (portName) {
      res["PortName"] = boost::any(*portName);
    }
    if (vlan) {
      res["Vlan"] = boost::any(*vlan);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      nextHop = make_shared<string>(boost::any_cast<string>(m["NextHop"]));
    }
    if (m.find("DestinationCidr") != m.end() && !m["DestinationCidr"].empty()) {
      destinationCidr = make_shared<string>(boost::any_cast<string>(m["DestinationCidr"]));
    }
    if (m.find("PortName") != m.end() && !m["PortName"].empty()) {
      portName = make_shared<string>(boost::any_cast<string>(m["PortName"]));
    }
    if (m.find("Vlan") != m.end() && !m["Vlan"].empty()) {
      vlan = make_shared<string>(boost::any_cast<string>(m["Vlan"]));
    }
  }


  virtual ~DescribeSagStaticRouteListResponseBodyStaticRoutes() = default;
};
class DescribeSagStaticRouteListResponseBodyTaskStates : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> state{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> createTime{};

  DescribeSagStaticRouteListResponseBodyTaskStates() {}

  explicit DescribeSagStaticRouteListResponseBodyTaskStates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
  }


  virtual ~DescribeSagStaticRouteListResponseBodyTaskStates() = default;
};
class DescribeSagStaticRouteListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSagStaticRouteListResponseBodyStaticRoutes>> staticRoutes{};
  shared_ptr<vector<DescribeSagStaticRouteListResponseBodyTaskStates>> taskStates{};

  DescribeSagStaticRouteListResponseBody() {}

  explicit DescribeSagStaticRouteListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (staticRoutes) {
      vector<boost::any> temp1;
      for(auto item1:*staticRoutes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StaticRoutes"] = boost::any(temp1);
    }
    if (taskStates) {
      vector<boost::any> temp1;
      for(auto item1:*taskStates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskStates"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StaticRoutes") != m.end() && !m["StaticRoutes"].empty()) {
      if (typeid(vector<boost::any>) == m["StaticRoutes"].type()) {
        vector<DescribeSagStaticRouteListResponseBodyStaticRoutes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StaticRoutes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSagStaticRouteListResponseBodyStaticRoutes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        staticRoutes = make_shared<vector<DescribeSagStaticRouteListResponseBodyStaticRoutes>>(expect1);
      }
    }
    if (m.find("TaskStates") != m.end() && !m["TaskStates"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskStates"].type()) {
        vector<DescribeSagStaticRouteListResponseBodyTaskStates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskStates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSagStaticRouteListResponseBodyTaskStates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskStates = make_shared<vector<DescribeSagStaticRouteListResponseBodyTaskStates>>(expect1);
      }
    }
  }


  virtual ~DescribeSagStaticRouteListResponseBody() = default;
};
class DescribeSagStaticRouteListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSagStaticRouteListResponseBody> body{};

  DescribeSagStaticRouteListResponse() {}

  explicit DescribeSagStaticRouteListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSagStaticRouteListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSagStaticRouteListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSagStaticRouteListResponse() = default;
};
class DescribeSagRouteListRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};

  DescribeSagRouteListRequest() {}

  explicit DescribeSagRouteListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
  }


  virtual ~DescribeSagRouteListRequest() = default;
};
class DescribeSagRouteListResponseBodyRoutes : public Darabonba::Model {
public:
  shared_ptr<string> nextHop{};
  shared_ptr<string> destinationCidr{};
  shared_ptr<string> cost{};
  shared_ptr<string> portName{};
  shared_ptr<vector<string>> conflictCidrs{};
  shared_ptr<string> routeProtocol{};

  DescribeSagRouteListResponseBodyRoutes() {}

  explicit DescribeSagRouteListResponseBodyRoutes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextHop) {
      res["NextHop"] = boost::any(*nextHop);
    }
    if (destinationCidr) {
      res["DestinationCidr"] = boost::any(*destinationCidr);
    }
    if (cost) {
      res["Cost"] = boost::any(*cost);
    }
    if (portName) {
      res["PortName"] = boost::any(*portName);
    }
    if (conflictCidrs) {
      res["ConflictCidrs"] = boost::any(*conflictCidrs);
    }
    if (routeProtocol) {
      res["RouteProtocol"] = boost::any(*routeProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      nextHop = make_shared<string>(boost::any_cast<string>(m["NextHop"]));
    }
    if (m.find("DestinationCidr") != m.end() && !m["DestinationCidr"].empty()) {
      destinationCidr = make_shared<string>(boost::any_cast<string>(m["DestinationCidr"]));
    }
    if (m.find("Cost") != m.end() && !m["Cost"].empty()) {
      cost = make_shared<string>(boost::any_cast<string>(m["Cost"]));
    }
    if (m.find("PortName") != m.end() && !m["PortName"].empty()) {
      portName = make_shared<string>(boost::any_cast<string>(m["PortName"]));
    }
    if (m.find("ConflictCidrs") != m.end() && !m["ConflictCidrs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ConflictCidrs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ConflictCidrs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      conflictCidrs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RouteProtocol") != m.end() && !m["RouteProtocol"].empty()) {
      routeProtocol = make_shared<string>(boost::any_cast<string>(m["RouteProtocol"]));
    }
  }


  virtual ~DescribeSagRouteListResponseBodyRoutes() = default;
};
class DescribeSagRouteListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSagRouteListResponseBodyRoutes>> routes{};

  DescribeSagRouteListResponseBody() {}

  explicit DescribeSagRouteListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (routes) {
      vector<boost::any> temp1;
      for(auto item1:*routes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Routes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Routes") != m.end() && !m["Routes"].empty()) {
      if (typeid(vector<boost::any>) == m["Routes"].type()) {
        vector<DescribeSagRouteListResponseBodyRoutes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Routes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSagRouteListResponseBodyRoutes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        routes = make_shared<vector<DescribeSagRouteListResponseBodyRoutes>>(expect1);
      }
    }
  }


  virtual ~DescribeSagRouteListResponseBody() = default;
};
class DescribeSagRouteListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSagRouteListResponseBody> body{};

  DescribeSagRouteListResponse() {}

  explicit DescribeSagRouteListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSagRouteListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSagRouteListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSagRouteListResponse() = default;
};
class ProbeAccessPointNetworkQualityRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<vector<long>> accessPointIds{};

  ProbeAccessPointNetworkQualityRequest() {}

  explicit ProbeAccessPointNetworkQualityRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (accessPointIds) {
      res["AccessPointIds"] = boost::any(*accessPointIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("AccessPointIds") != m.end() && !m["AccessPointIds"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["AccessPointIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AccessPointIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      accessPointIds = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~ProbeAccessPointNetworkQualityRequest() = default;
};
class ProbeAccessPointNetworkQualityResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ProbeAccessPointNetworkQualityResponseBody() {}

  explicit ProbeAccessPointNetworkQualityResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ProbeAccessPointNetworkQualityResponseBody() = default;
};
class ProbeAccessPointNetworkQualityResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ProbeAccessPointNetworkQualityResponseBody> body{};

  ProbeAccessPointNetworkQualityResponse() {}

  explicit ProbeAccessPointNetworkQualityResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ProbeAccessPointNetworkQualityResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ProbeAccessPointNetworkQualityResponseBody>(model1);
      }
    }
  }


  virtual ~ProbeAccessPointNetworkQualityResponse() = default;
};
class ModifySagGlobalRouteProtocolRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};
  shared_ptr<string> routeProtocol{};

  ModifySagGlobalRouteProtocolRequest() {}

  explicit ModifySagGlobalRouteProtocolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    if (routeProtocol) {
      res["RouteProtocol"] = boost::any(*routeProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
    if (m.find("RouteProtocol") != m.end() && !m["RouteProtocol"].empty()) {
      routeProtocol = make_shared<string>(boost::any_cast<string>(m["RouteProtocol"]));
    }
  }


  virtual ~ModifySagGlobalRouteProtocolRequest() = default;
};
class ModifySagGlobalRouteProtocolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySagGlobalRouteProtocolResponseBody() {}

  explicit ModifySagGlobalRouteProtocolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySagGlobalRouteProtocolResponseBody() = default;
};
class ModifySagGlobalRouteProtocolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySagGlobalRouteProtocolResponseBody> body{};

  ModifySagGlobalRouteProtocolResponse() {}

  explicit ModifySagGlobalRouteProtocolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySagGlobalRouteProtocolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySagGlobalRouteProtocolResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySagGlobalRouteProtocolResponse() = default;
};
class DeleteRouteDistributionStrategyRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> destCidrBlock{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> routeSource{};

  DeleteRouteDistributionStrategyRequest() {}

  explicit DeleteRouteDistributionStrategyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (destCidrBlock) {
      res["DestCidrBlock"] = boost::any(*destCidrBlock);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (routeSource) {
      res["RouteSource"] = boost::any(*routeSource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("DestCidrBlock") != m.end() && !m["DestCidrBlock"].empty()) {
      destCidrBlock = make_shared<string>(boost::any_cast<string>(m["DestCidrBlock"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("RouteSource") != m.end() && !m["RouteSource"].empty()) {
      routeSource = make_shared<string>(boost::any_cast<string>(m["RouteSource"]));
    }
  }


  virtual ~DeleteRouteDistributionStrategyRequest() = default;
};
class DeleteRouteDistributionStrategyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteRouteDistributionStrategyResponseBody() {}

  explicit DeleteRouteDistributionStrategyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteRouteDistributionStrategyResponseBody() = default;
};
class DeleteRouteDistributionStrategyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteRouteDistributionStrategyResponseBody> body{};

  DeleteRouteDistributionStrategyResponse() {}

  explicit DeleteRouteDistributionStrategyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteRouteDistributionStrategyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteRouteDistributionStrategyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteRouteDistributionStrategyResponse() = default;
};
class CreateQosCarRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> description{};
  shared_ptr<string> regionId{};
  shared_ptr<string> qosId{};
  shared_ptr<long> priority{};
  shared_ptr<string> limitType{};
  shared_ptr<long> minBandwidthAbs{};
  shared_ptr<long> maxBandwidthAbs{};
  shared_ptr<long> minBandwidthPercent{};
  shared_ptr<long> maxBandwidthPercent{};
  shared_ptr<string> percentSourceType{};
  shared_ptr<string> name{};

  CreateQosCarRequest() {}

  explicit CreateQosCarRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (limitType) {
      res["LimitType"] = boost::any(*limitType);
    }
    if (minBandwidthAbs) {
      res["MinBandwidthAbs"] = boost::any(*minBandwidthAbs);
    }
    if (maxBandwidthAbs) {
      res["MaxBandwidthAbs"] = boost::any(*maxBandwidthAbs);
    }
    if (minBandwidthPercent) {
      res["MinBandwidthPercent"] = boost::any(*minBandwidthPercent);
    }
    if (maxBandwidthPercent) {
      res["MaxBandwidthPercent"] = boost::any(*maxBandwidthPercent);
    }
    if (percentSourceType) {
      res["PercentSourceType"] = boost::any(*percentSourceType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("LimitType") != m.end() && !m["LimitType"].empty()) {
      limitType = make_shared<string>(boost::any_cast<string>(m["LimitType"]));
    }
    if (m.find("MinBandwidthAbs") != m.end() && !m["MinBandwidthAbs"].empty()) {
      minBandwidthAbs = make_shared<long>(boost::any_cast<long>(m["MinBandwidthAbs"]));
    }
    if (m.find("MaxBandwidthAbs") != m.end() && !m["MaxBandwidthAbs"].empty()) {
      maxBandwidthAbs = make_shared<long>(boost::any_cast<long>(m["MaxBandwidthAbs"]));
    }
    if (m.find("MinBandwidthPercent") != m.end() && !m["MinBandwidthPercent"].empty()) {
      minBandwidthPercent = make_shared<long>(boost::any_cast<long>(m["MinBandwidthPercent"]));
    }
    if (m.find("MaxBandwidthPercent") != m.end() && !m["MaxBandwidthPercent"].empty()) {
      maxBandwidthPercent = make_shared<long>(boost::any_cast<long>(m["MaxBandwidthPercent"]));
    }
    if (m.find("PercentSourceType") != m.end() && !m["PercentSourceType"].empty()) {
      percentSourceType = make_shared<string>(boost::any_cast<string>(m["PercentSourceType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreateQosCarRequest() = default;
};
class CreateQosCarResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> minBandwidthAbs{};
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<string> qosCarId{};
  shared_ptr<long> maxBandwidthAbs{};
  shared_ptr<long> maxBandwidthPercent{};
  shared_ptr<long> priority{};
  shared_ptr<string> qosId{};
  shared_ptr<string> percentSourceType{};
  shared_ptr<long> minBandwidthPercent{};
  shared_ptr<string> limitType{};

  CreateQosCarResponseBody() {}

  explicit CreateQosCarResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (minBandwidthAbs) {
      res["MinBandwidthAbs"] = boost::any(*minBandwidthAbs);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (qosCarId) {
      res["QosCarId"] = boost::any(*qosCarId);
    }
    if (maxBandwidthAbs) {
      res["MaxBandwidthAbs"] = boost::any(*maxBandwidthAbs);
    }
    if (maxBandwidthPercent) {
      res["MaxBandwidthPercent"] = boost::any(*maxBandwidthPercent);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (percentSourceType) {
      res["PercentSourceType"] = boost::any(*percentSourceType);
    }
    if (minBandwidthPercent) {
      res["MinBandwidthPercent"] = boost::any(*minBandwidthPercent);
    }
    if (limitType) {
      res["LimitType"] = boost::any(*limitType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MinBandwidthAbs") != m.end() && !m["MinBandwidthAbs"].empty()) {
      minBandwidthAbs = make_shared<long>(boost::any_cast<long>(m["MinBandwidthAbs"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("QosCarId") != m.end() && !m["QosCarId"].empty()) {
      qosCarId = make_shared<string>(boost::any_cast<string>(m["QosCarId"]));
    }
    if (m.find("MaxBandwidthAbs") != m.end() && !m["MaxBandwidthAbs"].empty()) {
      maxBandwidthAbs = make_shared<long>(boost::any_cast<long>(m["MaxBandwidthAbs"]));
    }
    if (m.find("MaxBandwidthPercent") != m.end() && !m["MaxBandwidthPercent"].empty()) {
      maxBandwidthPercent = make_shared<long>(boost::any_cast<long>(m["MaxBandwidthPercent"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("PercentSourceType") != m.end() && !m["PercentSourceType"].empty()) {
      percentSourceType = make_shared<string>(boost::any_cast<string>(m["PercentSourceType"]));
    }
    if (m.find("MinBandwidthPercent") != m.end() && !m["MinBandwidthPercent"].empty()) {
      minBandwidthPercent = make_shared<long>(boost::any_cast<long>(m["MinBandwidthPercent"]));
    }
    if (m.find("LimitType") != m.end() && !m["LimitType"].empty()) {
      limitType = make_shared<string>(boost::any_cast<string>(m["LimitType"]));
    }
  }


  virtual ~CreateQosCarResponseBody() = default;
};
class CreateQosCarResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateQosCarResponseBody> body{};

  CreateQosCarResponse() {}

  explicit CreateQosCarResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateQosCarResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateQosCarResponseBody>(model1);
      }
    }
  }


  virtual ~CreateQosCarResponse() = default;
};
class UpdateSmartAGDpiAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<bool> dpiEnabled{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};

  UpdateSmartAGDpiAttributeRequest() {}

  explicit UpdateSmartAGDpiAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (dpiEnabled) {
      res["DpiEnabled"] = boost::any(*dpiEnabled);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("DpiEnabled") != m.end() && !m["DpiEnabled"].empty()) {
      dpiEnabled = make_shared<bool>(boost::any_cast<bool>(m["DpiEnabled"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
  }


  virtual ~UpdateSmartAGDpiAttributeRequest() = default;
};
class UpdateSmartAGDpiAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateSmartAGDpiAttributeResponseBody() {}

  explicit UpdateSmartAGDpiAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateSmartAGDpiAttributeResponseBody() = default;
};
class UpdateSmartAGDpiAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateSmartAGDpiAttributeResponseBody> body{};

  UpdateSmartAGDpiAttributeResponse() {}

  explicit UpdateSmartAGDpiAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSmartAGDpiAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSmartAGDpiAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSmartAGDpiAttributeResponse() = default;
};
class ClearSagRouteableAddressRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> sagId{};

  ClearSagRouteableAddressRequest() {}

  explicit ClearSagRouteableAddressRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (sagId) {
      res["SagId"] = boost::any(*sagId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("SagId") != m.end() && !m["SagId"].empty()) {
      sagId = make_shared<string>(boost::any_cast<string>(m["SagId"]));
    }
  }


  virtual ~ClearSagRouteableAddressRequest() = default;
};
class ClearSagRouteableAddressResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ClearSagRouteableAddressResponseBody() {}

  explicit ClearSagRouteableAddressResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ClearSagRouteableAddressResponseBody() = default;
};
class ClearSagRouteableAddressResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ClearSagRouteableAddressResponseBody> body{};

  ClearSagRouteableAddressResponse() {}

  explicit ClearSagRouteableAddressResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ClearSagRouteableAddressResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ClearSagRouteableAddressResponseBody>(model1);
      }
    }
  }


  virtual ~ClearSagRouteableAddressResponse() = default;
};
class AssociateQosRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> qosId{};
  shared_ptr<string> smartAGId{};

  AssociateQosRequest() {}

  explicit AssociateQosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
  }


  virtual ~AssociateQosRequest() = default;
};
class AssociateQosResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AssociateQosResponseBody() {}

  explicit AssociateQosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AssociateQosResponseBody() = default;
};
class AssociateQosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AssociateQosResponseBody> body{};

  AssociateQosResponse() {}

  explicit AssociateQosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssociateQosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssociateQosResponseBody>(model1);
      }
    }
  }


  virtual ~AssociateQosResponse() = default;
};
class ModifySAGAdminPasswordRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};
  shared_ptr<string> password{};

  ModifySAGAdminPasswordRequest() {}

  explicit ModifySAGAdminPasswordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
  }


  virtual ~ModifySAGAdminPasswordRequest() = default;
};
class ModifySAGAdminPasswordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySAGAdminPasswordResponseBody() {}

  explicit ModifySAGAdminPasswordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySAGAdminPasswordResponseBody() = default;
};
class ModifySAGAdminPasswordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySAGAdminPasswordResponseBody> body{};

  ModifySAGAdminPasswordResponse() {}

  explicit ModifySAGAdminPasswordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySAGAdminPasswordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySAGAdminPasswordResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySAGAdminPasswordResponse() = default;
};
class DowngradeSmartAccessGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> bandWidthSpec{};
  shared_ptr<bool> autoPay{};

  DowngradeSmartAccessGatewayRequest() {}

  explicit DowngradeSmartAccessGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (bandWidthSpec) {
      res["BandWidthSpec"] = boost::any(*bandWidthSpec);
    }
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("BandWidthSpec") != m.end() && !m["BandWidthSpec"].empty()) {
      bandWidthSpec = make_shared<long>(boost::any_cast<long>(m["BandWidthSpec"]));
    }
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
  }


  virtual ~DowngradeSmartAccessGatewayRequest() = default;
};
class DowngradeSmartAccessGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> orderId{};

  DowngradeSmartAccessGatewayResponseBody() {}

  explicit DowngradeSmartAccessGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
  }


  virtual ~DowngradeSmartAccessGatewayResponseBody() = default;
};
class DowngradeSmartAccessGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DowngradeSmartAccessGatewayResponseBody> body{};

  DowngradeSmartAccessGatewayResponse() {}

  explicit DowngradeSmartAccessGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DowngradeSmartAccessGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DowngradeSmartAccessGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~DowngradeSmartAccessGatewayResponse() = default;
};
class DescribeSagPortRouteProtocolListRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};

  DescribeSagPortRouteProtocolListRequest() {}

  explicit DescribeSagPortRouteProtocolListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
  }


  virtual ~DescribeSagPortRouteProtocolListRequest() = default;
};
class DescribeSagPortRouteProtocolListResponseBodyPorts : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> remoteIp{};
  shared_ptr<string> portName{};
  shared_ptr<string> neighborIp{};
  shared_ptr<string> routeProtocol{};
  shared_ptr<string> remoteAs{};
  shared_ptr<string> vlan{};

  DescribeSagPortRouteProtocolListResponseBodyPorts() {}

  explicit DescribeSagPortRouteProtocolListResponseBodyPorts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (remoteIp) {
      res["RemoteIp"] = boost::any(*remoteIp);
    }
    if (portName) {
      res["PortName"] = boost::any(*portName);
    }
    if (neighborIp) {
      res["NeighborIp"] = boost::any(*neighborIp);
    }
    if (routeProtocol) {
      res["RouteProtocol"] = boost::any(*routeProtocol);
    }
    if (remoteAs) {
      res["RemoteAs"] = boost::any(*remoteAs);
    }
    if (vlan) {
      res["Vlan"] = boost::any(*vlan);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("RemoteIp") != m.end() && !m["RemoteIp"].empty()) {
      remoteIp = make_shared<string>(boost::any_cast<string>(m["RemoteIp"]));
    }
    if (m.find("PortName") != m.end() && !m["PortName"].empty()) {
      portName = make_shared<string>(boost::any_cast<string>(m["PortName"]));
    }
    if (m.find("NeighborIp") != m.end() && !m["NeighborIp"].empty()) {
      neighborIp = make_shared<string>(boost::any_cast<string>(m["NeighborIp"]));
    }
    if (m.find("RouteProtocol") != m.end() && !m["RouteProtocol"].empty()) {
      routeProtocol = make_shared<string>(boost::any_cast<string>(m["RouteProtocol"]));
    }
    if (m.find("RemoteAs") != m.end() && !m["RemoteAs"].empty()) {
      remoteAs = make_shared<string>(boost::any_cast<string>(m["RemoteAs"]));
    }
    if (m.find("Vlan") != m.end() && !m["Vlan"].empty()) {
      vlan = make_shared<string>(boost::any_cast<string>(m["Vlan"]));
    }
  }


  virtual ~DescribeSagPortRouteProtocolListResponseBodyPorts() = default;
};
class DescribeSagPortRouteProtocolListResponseBodyTaskStates : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> state{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> createTime{};

  DescribeSagPortRouteProtocolListResponseBodyTaskStates() {}

  explicit DescribeSagPortRouteProtocolListResponseBodyTaskStates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
  }


  virtual ~DescribeSagPortRouteProtocolListResponseBodyTaskStates() = default;
};
class DescribeSagPortRouteProtocolListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSagPortRouteProtocolListResponseBodyPorts>> ports{};
  shared_ptr<vector<DescribeSagPortRouteProtocolListResponseBodyTaskStates>> taskStates{};

  DescribeSagPortRouteProtocolListResponseBody() {}

  explicit DescribeSagPortRouteProtocolListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ports) {
      vector<boost::any> temp1;
      for(auto item1:*ports){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ports"] = boost::any(temp1);
    }
    if (taskStates) {
      vector<boost::any> temp1;
      for(auto item1:*taskStates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskStates"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Ports") != m.end() && !m["Ports"].empty()) {
      if (typeid(vector<boost::any>) == m["Ports"].type()) {
        vector<DescribeSagPortRouteProtocolListResponseBodyPorts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ports"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSagPortRouteProtocolListResponseBodyPorts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ports = make_shared<vector<DescribeSagPortRouteProtocolListResponseBodyPorts>>(expect1);
      }
    }
    if (m.find("TaskStates") != m.end() && !m["TaskStates"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskStates"].type()) {
        vector<DescribeSagPortRouteProtocolListResponseBodyTaskStates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskStates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSagPortRouteProtocolListResponseBodyTaskStates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskStates = make_shared<vector<DescribeSagPortRouteProtocolListResponseBodyTaskStates>>(expect1);
      }
    }
  }


  virtual ~DescribeSagPortRouteProtocolListResponseBody() = default;
};
class DescribeSagPortRouteProtocolListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSagPortRouteProtocolListResponseBody> body{};

  DescribeSagPortRouteProtocolListResponse() {}

  explicit DescribeSagPortRouteProtocolListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSagPortRouteProtocolListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSagPortRouteProtocolListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSagPortRouteProtocolListResponse() = default;
};
class DescribeSagWanSnatRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};

  DescribeSagWanSnatRequest() {}

  explicit DescribeSagWanSnatRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
  }


  virtual ~DescribeSagWanSnatRequest() = default;
};
class DescribeSagWanSnatResponseBodyTaskStates : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> state{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> createTime{};

  DescribeSagWanSnatResponseBodyTaskStates() {}

  explicit DescribeSagWanSnatResponseBodyTaskStates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
  }


  virtual ~DescribeSagWanSnatResponseBodyTaskStates() = default;
};
class DescribeSagWanSnatResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> snat{};
  shared_ptr<vector<DescribeSagWanSnatResponseBodyTaskStates>> taskStates{};

  DescribeSagWanSnatResponseBody() {}

  explicit DescribeSagWanSnatResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snat) {
      res["Snat"] = boost::any(*snat);
    }
    if (taskStates) {
      vector<boost::any> temp1;
      for(auto item1:*taskStates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskStates"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Snat") != m.end() && !m["Snat"].empty()) {
      snat = make_shared<string>(boost::any_cast<string>(m["Snat"]));
    }
    if (m.find("TaskStates") != m.end() && !m["TaskStates"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskStates"].type()) {
        vector<DescribeSagWanSnatResponseBodyTaskStates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskStates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSagWanSnatResponseBodyTaskStates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskStates = make_shared<vector<DescribeSagWanSnatResponseBodyTaskStates>>(expect1);
      }
    }
  }


  virtual ~DescribeSagWanSnatResponseBody() = default;
};
class DescribeSagWanSnatResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSagWanSnatResponseBody> body{};

  DescribeSagWanSnatResponse() {}

  explicit DescribeSagWanSnatResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSagWanSnatResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSagWanSnatResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSagWanSnatResponse() = default;
};
class DescribeSagUserDnsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};

  DescribeSagUserDnsRequest() {}

  explicit DescribeSagUserDnsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
  }


  virtual ~DescribeSagUserDnsRequest() = default;
};
class DescribeSagUserDnsResponseBodyTaskStates : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> state{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> createTime{};

  DescribeSagUserDnsResponseBodyTaskStates() {}

  explicit DescribeSagUserDnsResponseBodyTaskStates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
  }


  virtual ~DescribeSagUserDnsResponseBodyTaskStates() = default;
};
class DescribeSagUserDnsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> slaveDns{};
  shared_ptr<vector<DescribeSagUserDnsResponseBodyTaskStates>> taskStates{};
  shared_ptr<string> masterDns{};

  DescribeSagUserDnsResponseBody() {}

  explicit DescribeSagUserDnsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (slaveDns) {
      res["SlaveDns"] = boost::any(*slaveDns);
    }
    if (taskStates) {
      vector<boost::any> temp1;
      for(auto item1:*taskStates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskStates"] = boost::any(temp1);
    }
    if (masterDns) {
      res["MasterDns"] = boost::any(*masterDns);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SlaveDns") != m.end() && !m["SlaveDns"].empty()) {
      slaveDns = make_shared<string>(boost::any_cast<string>(m["SlaveDns"]));
    }
    if (m.find("TaskStates") != m.end() && !m["TaskStates"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskStates"].type()) {
        vector<DescribeSagUserDnsResponseBodyTaskStates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskStates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSagUserDnsResponseBodyTaskStates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskStates = make_shared<vector<DescribeSagUserDnsResponseBodyTaskStates>>(expect1);
      }
    }
    if (m.find("MasterDns") != m.end() && !m["MasterDns"].empty()) {
      masterDns = make_shared<string>(boost::any_cast<string>(m["MasterDns"]));
    }
  }


  virtual ~DescribeSagUserDnsResponseBody() = default;
};
class DescribeSagUserDnsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSagUserDnsResponseBody> body{};

  DescribeSagUserDnsResponse() {}

  explicit DescribeSagUserDnsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSagUserDnsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSagUserDnsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSagUserDnsResponse() = default;
};
class ListAccessPointNetworkQualitiesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};

  ListAccessPointNetworkQualitiesRequest() {}

  explicit ListAccessPointNetworkQualitiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
  }


  virtual ~ListAccessPointNetworkQualitiesRequest() = default;
};
class ListAccessPointNetworkQualitiesResponseBodyAccessPointNetworkQualities : public Darabonba::Model {
public:
  shared_ptr<string> loss{};
  shared_ptr<string> rtt{};
  shared_ptr<long> id{};

  ListAccessPointNetworkQualitiesResponseBodyAccessPointNetworkQualities() {}

  explicit ListAccessPointNetworkQualitiesResponseBodyAccessPointNetworkQualities(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (loss) {
      res["Loss"] = boost::any(*loss);
    }
    if (rtt) {
      res["Rtt"] = boost::any(*rtt);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Loss") != m.end() && !m["Loss"].empty()) {
      loss = make_shared<string>(boost::any_cast<string>(m["Loss"]));
    }
    if (m.find("Rtt") != m.end() && !m["Rtt"].empty()) {
      rtt = make_shared<string>(boost::any_cast<string>(m["Rtt"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<long>(boost::any_cast<long>(m["Id"]));
    }
  }


  virtual ~ListAccessPointNetworkQualitiesResponseBodyAccessPointNetworkQualities() = default;
};
class ListAccessPointNetworkQualitiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListAccessPointNetworkQualitiesResponseBodyAccessPointNetworkQualities>> accessPointNetworkQualities{};
  shared_ptr<string> requestId{};

  ListAccessPointNetworkQualitiesResponseBody() {}

  explicit ListAccessPointNetworkQualitiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessPointNetworkQualities) {
      vector<boost::any> temp1;
      for(auto item1:*accessPointNetworkQualities){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AccessPointNetworkQualities"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessPointNetworkQualities") != m.end() && !m["AccessPointNetworkQualities"].empty()) {
      if (typeid(vector<boost::any>) == m["AccessPointNetworkQualities"].type()) {
        vector<ListAccessPointNetworkQualitiesResponseBodyAccessPointNetworkQualities> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AccessPointNetworkQualities"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAccessPointNetworkQualitiesResponseBodyAccessPointNetworkQualities model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accessPointNetworkQualities = make_shared<vector<ListAccessPointNetworkQualitiesResponseBodyAccessPointNetworkQualities>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAccessPointNetworkQualitiesResponseBody() = default;
};
class ListAccessPointNetworkQualitiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListAccessPointNetworkQualitiesResponseBody> body{};

  ListAccessPointNetworkQualitiesResponse() {}

  explicit ListAccessPointNetworkQualitiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAccessPointNetworkQualitiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAccessPointNetworkQualitiesResponseBody>(model1);
      }
    }
  }


  virtual ~ListAccessPointNetworkQualitiesResponse() = default;
};
class ModifyFlowLogAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<long> activeAging{};
  shared_ptr<long> inactiveAging{};
  shared_ptr<string> outputType{};
  shared_ptr<string> slsRegionId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> logstoreName{};
  shared_ptr<string> netflowServerIp{};
  shared_ptr<long> netflowServerPort{};
  shared_ptr<string> netflowVersion{};
  shared_ptr<string> flowLogId{};

  ModifyFlowLogAttributeRequest() {}

  explicit ModifyFlowLogAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (activeAging) {
      res["ActiveAging"] = boost::any(*activeAging);
    }
    if (inactiveAging) {
      res["InactiveAging"] = boost::any(*inactiveAging);
    }
    if (outputType) {
      res["OutputType"] = boost::any(*outputType);
    }
    if (slsRegionId) {
      res["SlsRegionId"] = boost::any(*slsRegionId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (logstoreName) {
      res["LogstoreName"] = boost::any(*logstoreName);
    }
    if (netflowServerIp) {
      res["NetflowServerIp"] = boost::any(*netflowServerIp);
    }
    if (netflowServerPort) {
      res["NetflowServerPort"] = boost::any(*netflowServerPort);
    }
    if (netflowVersion) {
      res["NetflowVersion"] = boost::any(*netflowVersion);
    }
    if (flowLogId) {
      res["FlowLogId"] = boost::any(*flowLogId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ActiveAging") != m.end() && !m["ActiveAging"].empty()) {
      activeAging = make_shared<long>(boost::any_cast<long>(m["ActiveAging"]));
    }
    if (m.find("InactiveAging") != m.end() && !m["InactiveAging"].empty()) {
      inactiveAging = make_shared<long>(boost::any_cast<long>(m["InactiveAging"]));
    }
    if (m.find("OutputType") != m.end() && !m["OutputType"].empty()) {
      outputType = make_shared<string>(boost::any_cast<string>(m["OutputType"]));
    }
    if (m.find("SlsRegionId") != m.end() && !m["SlsRegionId"].empty()) {
      slsRegionId = make_shared<string>(boost::any_cast<string>(m["SlsRegionId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("LogstoreName") != m.end() && !m["LogstoreName"].empty()) {
      logstoreName = make_shared<string>(boost::any_cast<string>(m["LogstoreName"]));
    }
    if (m.find("NetflowServerIp") != m.end() && !m["NetflowServerIp"].empty()) {
      netflowServerIp = make_shared<string>(boost::any_cast<string>(m["NetflowServerIp"]));
    }
    if (m.find("NetflowServerPort") != m.end() && !m["NetflowServerPort"].empty()) {
      netflowServerPort = make_shared<long>(boost::any_cast<long>(m["NetflowServerPort"]));
    }
    if (m.find("NetflowVersion") != m.end() && !m["NetflowVersion"].empty()) {
      netflowVersion = make_shared<string>(boost::any_cast<string>(m["NetflowVersion"]));
    }
    if (m.find("FlowLogId") != m.end() && !m["FlowLogId"].empty()) {
      flowLogId = make_shared<string>(boost::any_cast<string>(m["FlowLogId"]));
    }
  }


  virtual ~ModifyFlowLogAttributeRequest() = default;
};
class ModifyFlowLogAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyFlowLogAttributeResponseBody() {}

  explicit ModifyFlowLogAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyFlowLogAttributeResponseBody() = default;
};
class ModifyFlowLogAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyFlowLogAttributeResponseBody> body{};

  ModifyFlowLogAttributeResponse() {}

  explicit ModifyFlowLogAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyFlowLogAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyFlowLogAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyFlowLogAttributeResponse() = default;
};
class DescribeQosPoliciesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> qosId{};
  shared_ptr<string> qosPolicyId{};
  shared_ptr<string> description{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> priority{};

  DescribeQosPoliciesRequest() {}

  explicit DescribeQosPoliciesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (qosPolicyId) {
      res["QosPolicyId"] = boost::any(*qosPolicyId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("QosPolicyId") != m.end() && !m["QosPolicyId"].empty()) {
      qosPolicyId = make_shared<string>(boost::any_cast<string>(m["QosPolicyId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
  }


  virtual ~DescribeQosPoliciesRequest() = default;
};
class DescribeQosPoliciesResponseBodyQosPoliciesQosPolicyDpiSignatureIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dpiSignatureId{};

  DescribeQosPoliciesResponseBodyQosPoliciesQosPolicyDpiSignatureIds() {}

  explicit DescribeQosPoliciesResponseBodyQosPoliciesQosPolicyDpiSignatureIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dpiSignatureId) {
      res["DpiSignatureId"] = boost::any(*dpiSignatureId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DpiSignatureId") != m.end() && !m["DpiSignatureId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DpiSignatureId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DpiSignatureId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dpiSignatureId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeQosPoliciesResponseBodyQosPoliciesQosPolicyDpiSignatureIds() = default;
};
class DescribeQosPoliciesResponseBodyQosPoliciesQosPolicyDpiGroupIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dpiGroupId{};

  DescribeQosPoliciesResponseBodyQosPoliciesQosPolicyDpiGroupIds() {}

  explicit DescribeQosPoliciesResponseBodyQosPoliciesQosPolicyDpiGroupIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dpiGroupId) {
      res["DpiGroupId"] = boost::any(*dpiGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DpiGroupId") != m.end() && !m["DpiGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DpiGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DpiGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dpiGroupId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeQosPoliciesResponseBodyQosPoliciesQosPolicyDpiGroupIds() = default;
};
class DescribeQosPoliciesResponseBodyQosPoliciesQosPolicy : public Darabonba::Model {
public:
  shared_ptr<DescribeQosPoliciesResponseBodyQosPoliciesQosPolicyDpiSignatureIds> dpiSignatureIds{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> qosId{};
  shared_ptr<long> priority{};
  shared_ptr<string> endTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> description{};
  shared_ptr<string> destCidr{};
  shared_ptr<string> destPortRange{};
  shared_ptr<string> qosPolicyId{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceCidr{};
  shared_ptr<string> sourcePortRange{};
  shared_ptr<DescribeQosPoliciesResponseBodyQosPoliciesQosPolicyDpiGroupIds> dpiGroupIds{};

  DescribeQosPoliciesResponseBodyQosPoliciesQosPolicy() {}

  explicit DescribeQosPoliciesResponseBodyQosPoliciesQosPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dpiSignatureIds) {
      res["DpiSignatureIds"] = dpiSignatureIds ? boost::any(dpiSignatureIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (destCidr) {
      res["DestCidr"] = boost::any(*destCidr);
    }
    if (destPortRange) {
      res["DestPortRange"] = boost::any(*destPortRange);
    }
    if (qosPolicyId) {
      res["QosPolicyId"] = boost::any(*qosPolicyId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (sourceCidr) {
      res["SourceCidr"] = boost::any(*sourceCidr);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    if (dpiGroupIds) {
      res["DpiGroupIds"] = dpiGroupIds ? boost::any(dpiGroupIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DpiSignatureIds") != m.end() && !m["DpiSignatureIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["DpiSignatureIds"].type()) {
        DescribeQosPoliciesResponseBodyQosPoliciesQosPolicyDpiSignatureIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DpiSignatureIds"]));
        dpiSignatureIds = make_shared<DescribeQosPoliciesResponseBodyQosPoliciesQosPolicyDpiSignatureIds>(model1);
      }
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("DestCidr") != m.end() && !m["DestCidr"].empty()) {
      destCidr = make_shared<string>(boost::any_cast<string>(m["DestCidr"]));
    }
    if (m.find("DestPortRange") != m.end() && !m["DestPortRange"].empty()) {
      destPortRange = make_shared<string>(boost::any_cast<string>(m["DestPortRange"]));
    }
    if (m.find("QosPolicyId") != m.end() && !m["QosPolicyId"].empty()) {
      qosPolicyId = make_shared<string>(boost::any_cast<string>(m["QosPolicyId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SourceCidr") != m.end() && !m["SourceCidr"].empty()) {
      sourceCidr = make_shared<string>(boost::any_cast<string>(m["SourceCidr"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
    if (m.find("DpiGroupIds") != m.end() && !m["DpiGroupIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["DpiGroupIds"].type()) {
        DescribeQosPoliciesResponseBodyQosPoliciesQosPolicyDpiGroupIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DpiGroupIds"]));
        dpiGroupIds = make_shared<DescribeQosPoliciesResponseBodyQosPoliciesQosPolicyDpiGroupIds>(model1);
      }
    }
  }


  virtual ~DescribeQosPoliciesResponseBodyQosPoliciesQosPolicy() = default;
};
class DescribeQosPoliciesResponseBodyQosPolicies : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeQosPoliciesResponseBodyQosPoliciesQosPolicy>> qosPolicy{};

  DescribeQosPoliciesResponseBodyQosPolicies() {}

  explicit DescribeQosPoliciesResponseBodyQosPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qosPolicy) {
      vector<boost::any> temp1;
      for(auto item1:*qosPolicy){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QosPolicy"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QosPolicy") != m.end() && !m["QosPolicy"].empty()) {
      if (typeid(vector<boost::any>) == m["QosPolicy"].type()) {
        vector<DescribeQosPoliciesResponseBodyQosPoliciesQosPolicy> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QosPolicy"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeQosPoliciesResponseBodyQosPoliciesQosPolicy model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        qosPolicy = make_shared<vector<DescribeQosPoliciesResponseBodyQosPoliciesQosPolicy>>(expect1);
      }
    }
  }


  virtual ~DescribeQosPoliciesResponseBodyQosPolicies() = default;
};
class DescribeQosPoliciesResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeQosPoliciesResponseBodyQosPolicies> qosPolicies{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};

  DescribeQosPoliciesResponseBody() {}

  explicit DescribeQosPoliciesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qosPolicies) {
      res["QosPolicies"] = qosPolicies ? boost::any(qosPolicies->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QosPolicies") != m.end() && !m["QosPolicies"].empty()) {
      if (typeid(map<string, boost::any>) == m["QosPolicies"].type()) {
        DescribeQosPoliciesResponseBodyQosPolicies model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QosPolicies"]));
        qosPolicies = make_shared<DescribeQosPoliciesResponseBodyQosPolicies>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~DescribeQosPoliciesResponseBody() = default;
};
class DescribeQosPoliciesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeQosPoliciesResponseBody> body{};

  DescribeQosPoliciesResponse() {}

  explicit DescribeQosPoliciesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeQosPoliciesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeQosPoliciesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeQosPoliciesResponse() = default;
};
class CreateQosRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> qosName{};
  shared_ptr<string> qosDescription{};

  CreateQosRequest() {}

  explicit CreateQosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (qosName) {
      res["QosName"] = boost::any(*qosName);
    }
    if (qosDescription) {
      res["QosDescription"] = boost::any(*qosDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("QosName") != m.end() && !m["QosName"].empty()) {
      qosName = make_shared<string>(boost::any_cast<string>(m["QosName"]));
    }
    if (m.find("QosDescription") != m.end() && !m["QosDescription"].empty()) {
      qosDescription = make_shared<string>(boost::any_cast<string>(m["QosDescription"]));
    }
  }


  virtual ~CreateQosRequest() = default;
};
class CreateQosResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> qosId{};
  shared_ptr<string> resourceGroupId{};

  CreateQosResponseBody() {}

  explicit CreateQosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~CreateQosResponseBody() = default;
};
class CreateQosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateQosResponseBody> body{};

  CreateQosResponse() {}

  explicit CreateQosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateQosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateQosResponseBody>(model1);
      }
    }
  }


  virtual ~CreateQosResponse() = default;
};
class DiscribeSmartAccessGatewayDiagnosisReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};
  shared_ptr<string> regionId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DiscribeSmartAccessGatewayDiagnosisReportRequest() {}

  explicit DiscribeSmartAccessGatewayDiagnosisReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DiscribeSmartAccessGatewayDiagnosisReportRequest() = default;
};
class DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsItemsCN : public Darabonba::Model {
public:
  shared_ptr<vector<string>> advice{};
  shared_ptr<string> itemName{};
  shared_ptr<string> itemLevel{};
  shared_ptr<string> itemType{};
  shared_ptr<vector<string>> details{};

  DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsItemsCN() {}

  explicit DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsItemsCN(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (itemLevel) {
      res["ItemLevel"] = boost::any(*itemLevel);
    }
    if (itemType) {
      res["ItemType"] = boost::any(*itemType);
    }
    if (details) {
      res["Details"] = boost::any(*details);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Advice"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Advice"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      advice = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("ItemLevel") != m.end() && !m["ItemLevel"].empty()) {
      itemLevel = make_shared<string>(boost::any_cast<string>(m["ItemLevel"]));
    }
    if (m.find("ItemType") != m.end() && !m["ItemType"].empty()) {
      itemType = make_shared<string>(boost::any_cast<string>(m["ItemType"]));
    }
    if (m.find("Details") != m.end() && !m["Details"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Details"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Details"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      details = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsItemsCN() = default;
};
class DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsItemsEN : public Darabonba::Model {
public:
  shared_ptr<vector<string>> advice{};
  shared_ptr<string> itemName{};
  shared_ptr<string> itemLevel{};
  shared_ptr<string> itemType{};
  shared_ptr<vector<string>> details{};

  DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsItemsEN() {}

  explicit DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsItemsEN(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advice) {
      res["Advice"] = boost::any(*advice);
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (itemLevel) {
      res["ItemLevel"] = boost::any(*itemLevel);
    }
    if (itemType) {
      res["ItemType"] = boost::any(*itemType);
    }
    if (details) {
      res["Details"] = boost::any(*details);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Advice") != m.end() && !m["Advice"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Advice"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Advice"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      advice = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("ItemLevel") != m.end() && !m["ItemLevel"].empty()) {
      itemLevel = make_shared<string>(boost::any_cast<string>(m["ItemLevel"]));
    }
    if (m.find("ItemType") != m.end() && !m["ItemType"].empty()) {
      itemType = make_shared<string>(boost::any_cast<string>(m["ItemType"]));
    }
    if (m.find("Details") != m.end() && !m["Details"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Details"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Details"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      details = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsItemsEN() = default;
};
class DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsItems : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};
  shared_ptr<DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsItemsCN> CN{};
  shared_ptr<string> itemName{};
  shared_ptr<DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsItemsEN> EN{};
  shared_ptr<string> level{};

  DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsItems() {}

  explicit DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (CN) {
      res["CN"] = CN ? boost::any(CN->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (itemName) {
      res["ItemName"] = boost::any(*itemName);
    }
    if (EN) {
      res["EN"] = EN ? boost::any(EN->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("CN") != m.end() && !m["CN"].empty()) {
      if (typeid(map<string, boost::any>) == m["CN"].type()) {
        DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsItemsCN model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CN"]));
        CN = make_shared<DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsItemsCN>(model1);
      }
    }
    if (m.find("ItemName") != m.end() && !m["ItemName"].empty()) {
      itemName = make_shared<string>(boost::any_cast<string>(m["ItemName"]));
    }
    if (m.find("EN") != m.end() && !m["EN"].empty()) {
      if (typeid(map<string, boost::any>) == m["EN"].type()) {
        DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsItemsEN model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EN"]));
        EN = make_shared<DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsItemsEN>(model1);
      }
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["Level"]));
    }
  }


  virtual ~DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsItems() = default;
};
class DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsStatistics : public Darabonba::Model {
public:
  shared_ptr<long> warning{};
  shared_ptr<long> error{};
  shared_ptr<long> total{};
  shared_ptr<long> info{};

  DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsStatistics() {}

  explicit DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (warning) {
      res["Warning"] = boost::any(*warning);
    }
    if (error) {
      res["Error"] = boost::any(*error);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (info) {
      res["Info"] = boost::any(*info);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Warning") != m.end() && !m["Warning"].empty()) {
      warning = make_shared<long>(boost::any_cast<long>(m["Warning"]));
    }
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      error = make_shared<long>(boost::any_cast<long>(m["Error"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      info = make_shared<long>(boost::any_cast<long>(m["Info"]));
    }
  }


  virtual ~DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsStatistics() = default;
};
class DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetails : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<vector<DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsItems>> items{};
  shared_ptr<DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsStatistics> statistics{};

  DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetails() {}

  explicit DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetails(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (items) {
      vector<boost::any> temp1;
      for(auto item1:*items){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Items"] = boost::any(temp1);
    }
    if (statistics) {
      res["Statistics"] = statistics ? boost::any(statistics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Items") != m.end() && !m["Items"].empty()) {
      if (typeid(vector<boost::any>) == m["Items"].type()) {
        vector<DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Items"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        items = make_shared<vector<DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsItems>>(expect1);
      }
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Statistics"].type()) {
        DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsStatistics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Statistics"]));
        statistics = make_shared<DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetailsStatistics>(model1);
      }
    }
  }


  virtual ~DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetails() = default;
};
class DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultLevel : public Darabonba::Model {
public:
  shared_ptr<string> configuration{};
  shared_ptr<string> total{};
  shared_ptr<string> biz{};

  DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultLevel() {}

  explicit DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultLevel(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configuration) {
      res["Configuration"] = boost::any(*configuration);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (biz) {
      res["Biz"] = boost::any(*biz);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Configuration") != m.end() && !m["Configuration"].empty()) {
      configuration = make_shared<string>(boost::any_cast<string>(m["Configuration"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<string>(boost::any_cast<string>(m["Total"]));
    }
    if (m.find("Biz") != m.end() && !m["Biz"].empty()) {
      biz = make_shared<string>(boost::any_cast<string>(m["Biz"]));
    }
  }


  virtual ~DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultLevel() = default;
};
class DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultStatistics : public Darabonba::Model {
public:
  shared_ptr<long> warning{};
  shared_ptr<long> error{};
  shared_ptr<long> total{};
  shared_ptr<long> info{};

  DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultStatistics() {}

  explicit DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (warning) {
      res["Warning"] = boost::any(*warning);
    }
    if (error) {
      res["Error"] = boost::any(*error);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (info) {
      res["Info"] = boost::any(*info);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Warning") != m.end() && !m["Warning"].empty()) {
      warning = make_shared<long>(boost::any_cast<long>(m["Warning"]));
    }
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      error = make_shared<long>(boost::any_cast<long>(m["Error"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("Info") != m.end() && !m["Info"].empty()) {
      info = make_shared<long>(boost::any_cast<long>(m["Info"]));
    }
  }


  virtual ~DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultStatistics() = default;
};
class DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResult : public Darabonba::Model {
public:
  shared_ptr<long> percent{};
  shared_ptr<string> SN{};
  shared_ptr<string> diagnoseId{};
  shared_ptr<string> state{};
  shared_ptr<string> userLevel{};
  shared_ptr<string> boxVersion{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> boxType{};
  shared_ptr<string> monitorVersion{};
  shared_ptr<long> finishedNumber{};
  shared_ptr<vector<DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetails>> details{};
  shared_ptr<string> UId{};
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};
  shared_ptr<string> parameters{};
  shared_ptr<string> storeType{};
  shared_ptr<long> reportSLSSuccess{};
  shared_ptr<long> totalNumber{};
  shared_ptr<DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultLevel> level{};
  shared_ptr<DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultStatistics> statistics{};

  DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResult() {}

  explicit DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (percent) {
      res["Percent"] = boost::any(*percent);
    }
    if (SN) {
      res["SN"] = boost::any(*SN);
    }
    if (diagnoseId) {
      res["DiagnoseId"] = boost::any(*diagnoseId);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (userLevel) {
      res["UserLevel"] = boost::any(*userLevel);
    }
    if (boxVersion) {
      res["BoxVersion"] = boost::any(*boxVersion);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (boxType) {
      res["BoxType"] = boost::any(*boxType);
    }
    if (monitorVersion) {
      res["MonitorVersion"] = boost::any(*monitorVersion);
    }
    if (finishedNumber) {
      res["FinishedNumber"] = boost::any(*finishedNumber);
    }
    if (details) {
      vector<boost::any> temp1;
      for(auto item1:*details){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Details"] = boost::any(temp1);
    }
    if (UId) {
      res["UId"] = boost::any(*UId);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    if (storeType) {
      res["StoreType"] = boost::any(*storeType);
    }
    if (reportSLSSuccess) {
      res["ReportSLSSuccess"] = boost::any(*reportSLSSuccess);
    }
    if (totalNumber) {
      res["TotalNumber"] = boost::any(*totalNumber);
    }
    if (level) {
      res["Level"] = level ? boost::any(level->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (statistics) {
      res["Statistics"] = statistics ? boost::any(statistics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Percent") != m.end() && !m["Percent"].empty()) {
      percent = make_shared<long>(boost::any_cast<long>(m["Percent"]));
    }
    if (m.find("SN") != m.end() && !m["SN"].empty()) {
      SN = make_shared<string>(boost::any_cast<string>(m["SN"]));
    }
    if (m.find("DiagnoseId") != m.end() && !m["DiagnoseId"].empty()) {
      diagnoseId = make_shared<string>(boost::any_cast<string>(m["DiagnoseId"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("UserLevel") != m.end() && !m["UserLevel"].empty()) {
      userLevel = make_shared<string>(boost::any_cast<string>(m["UserLevel"]));
    }
    if (m.find("BoxVersion") != m.end() && !m["BoxVersion"].empty()) {
      boxVersion = make_shared<string>(boost::any_cast<string>(m["BoxVersion"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("BoxType") != m.end() && !m["BoxType"].empty()) {
      boxType = make_shared<string>(boost::any_cast<string>(m["BoxType"]));
    }
    if (m.find("MonitorVersion") != m.end() && !m["MonitorVersion"].empty()) {
      monitorVersion = make_shared<string>(boost::any_cast<string>(m["MonitorVersion"]));
    }
    if (m.find("FinishedNumber") != m.end() && !m["FinishedNumber"].empty()) {
      finishedNumber = make_shared<long>(boost::any_cast<long>(m["FinishedNumber"]));
    }
    if (m.find("Details") != m.end() && !m["Details"].empty()) {
      if (typeid(vector<boost::any>) == m["Details"].type()) {
        vector<DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetails> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Details"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetails model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        details = make_shared<vector<DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultDetails>>(expect1);
      }
    }
    if (m.find("UId") != m.end() && !m["UId"].empty()) {
      UId = make_shared<string>(boost::any_cast<string>(m["UId"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      parameters = make_shared<string>(boost::any_cast<string>(m["Parameters"]));
    }
    if (m.find("StoreType") != m.end() && !m["StoreType"].empty()) {
      storeType = make_shared<string>(boost::any_cast<string>(m["StoreType"]));
    }
    if (m.find("ReportSLSSuccess") != m.end() && !m["ReportSLSSuccess"].empty()) {
      reportSLSSuccess = make_shared<long>(boost::any_cast<long>(m["ReportSLSSuccess"]));
    }
    if (m.find("TotalNumber") != m.end() && !m["TotalNumber"].empty()) {
      totalNumber = make_shared<long>(boost::any_cast<long>(m["TotalNumber"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      if (typeid(map<string, boost::any>) == m["Level"].type()) {
        DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultLevel model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Level"]));
        level = make_shared<DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultLevel>(model1);
      }
    }
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      if (typeid(map<string, boost::any>) == m["Statistics"].type()) {
        DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultStatistics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Statistics"]));
        statistics = make_shared<DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResultStatistics>(model1);
      }
    }
  }


  virtual ~DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResult() = default;
};
class DiscribeSmartAccessGatewayDiagnosisReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResult> diagnoseResult{};

  DiscribeSmartAccessGatewayDiagnosisReportResponseBody() {}

  explicit DiscribeSmartAccessGatewayDiagnosisReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (diagnoseResult) {
      res["DiagnoseResult"] = diagnoseResult ? boost::any(diagnoseResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DiagnoseResult") != m.end() && !m["DiagnoseResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["DiagnoseResult"].type()) {
        DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DiagnoseResult"]));
        diagnoseResult = make_shared<DiscribeSmartAccessGatewayDiagnosisReportResponseBodyDiagnoseResult>(model1);
      }
    }
  }


  virtual ~DiscribeSmartAccessGatewayDiagnosisReportResponseBody() = default;
};
class DiscribeSmartAccessGatewayDiagnosisReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DiscribeSmartAccessGatewayDiagnosisReportResponseBody> body{};

  DiscribeSmartAccessGatewayDiagnosisReportResponse() {}

  explicit DiscribeSmartAccessGatewayDiagnosisReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DiscribeSmartAccessGatewayDiagnosisReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DiscribeSmartAccessGatewayDiagnosisReportResponseBody>(model1);
      }
    }
  }


  virtual ~DiscribeSmartAccessGatewayDiagnosisReportResponse() = default;
};
class RoamClientUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> originSmartAGId{};
  shared_ptr<string> targetSmartAGId{};
  shared_ptr<string> originRegionId{};
  shared_ptr<string> userName{};

  RoamClientUserRequest() {}

  explicit RoamClientUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (originSmartAGId) {
      res["OriginSmartAGId"] = boost::any(*originSmartAGId);
    }
    if (targetSmartAGId) {
      res["TargetSmartAGId"] = boost::any(*targetSmartAGId);
    }
    if (originRegionId) {
      res["OriginRegionId"] = boost::any(*originRegionId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("OriginSmartAGId") != m.end() && !m["OriginSmartAGId"].empty()) {
      originSmartAGId = make_shared<string>(boost::any_cast<string>(m["OriginSmartAGId"]));
    }
    if (m.find("TargetSmartAGId") != m.end() && !m["TargetSmartAGId"].empty()) {
      targetSmartAGId = make_shared<string>(boost::any_cast<string>(m["TargetSmartAGId"]));
    }
    if (m.find("OriginRegionId") != m.end() && !m["OriginRegionId"].empty()) {
      originRegionId = make_shared<string>(boost::any_cast<string>(m["OriginRegionId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~RoamClientUserRequest() = default;
};
class RoamClientUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RoamClientUserResponseBody() {}

  explicit RoamClientUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RoamClientUserResponseBody() = default;
};
class RoamClientUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RoamClientUserResponseBody> body{};

  RoamClientUserResponse() {}

  explicit RoamClientUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RoamClientUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RoamClientUserResponseBody>(model1);
      }
    }
  }


  virtual ~RoamClientUserResponse() = default;
};
class CreateSagStaticRouteRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};
  shared_ptr<string> portName{};
  shared_ptr<string> destinationCidr{};
  shared_ptr<string> nextHop{};
  shared_ptr<string> vlan{};

  CreateSagStaticRouteRequest() {}

  explicit CreateSagStaticRouteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    if (portName) {
      res["PortName"] = boost::any(*portName);
    }
    if (destinationCidr) {
      res["DestinationCidr"] = boost::any(*destinationCidr);
    }
    if (nextHop) {
      res["NextHop"] = boost::any(*nextHop);
    }
    if (vlan) {
      res["Vlan"] = boost::any(*vlan);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
    if (m.find("PortName") != m.end() && !m["PortName"].empty()) {
      portName = make_shared<string>(boost::any_cast<string>(m["PortName"]));
    }
    if (m.find("DestinationCidr") != m.end() && !m["DestinationCidr"].empty()) {
      destinationCidr = make_shared<string>(boost::any_cast<string>(m["DestinationCidr"]));
    }
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      nextHop = make_shared<string>(boost::any_cast<string>(m["NextHop"]));
    }
    if (m.find("Vlan") != m.end() && !m["Vlan"].empty()) {
      vlan = make_shared<string>(boost::any_cast<string>(m["Vlan"]));
    }
  }


  virtual ~CreateSagStaticRouteRequest() = default;
};
class CreateSagStaticRouteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateSagStaticRouteResponseBody() {}

  explicit CreateSagStaticRouteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateSagStaticRouteResponseBody() = default;
};
class CreateSagStaticRouteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateSagStaticRouteResponseBody> body{};

  CreateSagStaticRouteResponse() {}

  explicit CreateSagStaticRouteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSagStaticRouteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSagStaticRouteResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSagStaticRouteResponse() = default;
};
class DescribeSmartAccessGatewayAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};

  DescribeSmartAccessGatewayAttributeRequest() {}

  explicit DescribeSmartAccessGatewayAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
  }


  virtual ~DescribeSmartAccessGatewayAttributeRequest() = default;
};
class DescribeSmartAccessGatewayAttributeResponseBodyQosIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> qosId{};

  DescribeSmartAccessGatewayAttributeResponseBodyQosIds() {}

  explicit DescribeSmartAccessGatewayAttributeResponseBodyQosIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["QosId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["QosId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      qosId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSmartAccessGatewayAttributeResponseBodyQosIds() = default;
};
class DescribeSmartAccessGatewayAttributeResponseBodyDevicesDevice : public Darabonba::Model {
public:
  shared_ptr<string> serialNumber{};
  shared_ptr<string> haState{};
  shared_ptr<string> secretKey{};
  shared_ptr<string> dpiSignatureDbVersion{};
  shared_ptr<string> softwareVersion{};
  shared_ptr<long> distributeSkStatus{};
  shared_ptr<string> monitorVersion{};
  shared_ptr<string> hcState{};

  DescribeSmartAccessGatewayAttributeResponseBodyDevicesDevice() {}

  explicit DescribeSmartAccessGatewayAttributeResponseBodyDevicesDevice(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (haState) {
      res["HaState"] = boost::any(*haState);
    }
    if (secretKey) {
      res["SecretKey"] = boost::any(*secretKey);
    }
    if (dpiSignatureDbVersion) {
      res["DpiSignatureDbVersion"] = boost::any(*dpiSignatureDbVersion);
    }
    if (softwareVersion) {
      res["SoftwareVersion"] = boost::any(*softwareVersion);
    }
    if (distributeSkStatus) {
      res["DistributeSkStatus"] = boost::any(*distributeSkStatus);
    }
    if (monitorVersion) {
      res["MonitorVersion"] = boost::any(*monitorVersion);
    }
    if (hcState) {
      res["HcState"] = boost::any(*hcState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("HaState") != m.end() && !m["HaState"].empty()) {
      haState = make_shared<string>(boost::any_cast<string>(m["HaState"]));
    }
    if (m.find("SecretKey") != m.end() && !m["SecretKey"].empty()) {
      secretKey = make_shared<string>(boost::any_cast<string>(m["SecretKey"]));
    }
    if (m.find("DpiSignatureDbVersion") != m.end() && !m["DpiSignatureDbVersion"].empty()) {
      dpiSignatureDbVersion = make_shared<string>(boost::any_cast<string>(m["DpiSignatureDbVersion"]));
    }
    if (m.find("SoftwareVersion") != m.end() && !m["SoftwareVersion"].empty()) {
      softwareVersion = make_shared<string>(boost::any_cast<string>(m["SoftwareVersion"]));
    }
    if (m.find("DistributeSkStatus") != m.end() && !m["DistributeSkStatus"].empty()) {
      distributeSkStatus = make_shared<long>(boost::any_cast<long>(m["DistributeSkStatus"]));
    }
    if (m.find("MonitorVersion") != m.end() && !m["MonitorVersion"].empty()) {
      monitorVersion = make_shared<string>(boost::any_cast<string>(m["MonitorVersion"]));
    }
    if (m.find("HcState") != m.end() && !m["HcState"].empty()) {
      hcState = make_shared<string>(boost::any_cast<string>(m["HcState"]));
    }
  }


  virtual ~DescribeSmartAccessGatewayAttributeResponseBodyDevicesDevice() = default;
};
class DescribeSmartAccessGatewayAttributeResponseBodyDevices : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSmartAccessGatewayAttributeResponseBodyDevicesDevice>> device{};

  DescribeSmartAccessGatewayAttributeResponseBodyDevices() {}

  explicit DescribeSmartAccessGatewayAttributeResponseBodyDevices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (device) {
      vector<boost::any> temp1;
      for(auto item1:*device){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Device"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Device") != m.end() && !m["Device"].empty()) {
      if (typeid(vector<boost::any>) == m["Device"].type()) {
        vector<DescribeSmartAccessGatewayAttributeResponseBodyDevicesDevice> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Device"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSmartAccessGatewayAttributeResponseBodyDevicesDevice model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        device = make_shared<vector<DescribeSmartAccessGatewayAttributeResponseBodyDevicesDevice>>(expect1);
      }
    }
  }


  virtual ~DescribeSmartAccessGatewayAttributeResponseBodyDevices() = default;
};
class DescribeSmartAccessGatewayAttributeResponseBodyFlowLogIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> flowLogId{};

  DescribeSmartAccessGatewayAttributeResponseBodyFlowLogIds() {}

  explicit DescribeSmartAccessGatewayAttributeResponseBodyFlowLogIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowLogId) {
      res["FlowLogId"] = boost::any(*flowLogId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowLogId") != m.end() && !m["FlowLogId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FlowLogId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FlowLogId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      flowLogId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSmartAccessGatewayAttributeResponseBodyFlowLogIds() = default;
};
class DescribeSmartAccessGatewayAttributeResponseBodyLinksLink : public Darabonba::Model {
public:
  shared_ptr<string> healthCheckTargetIp{};
  shared_ptr<long> endTime{};
  shared_ptr<string> status{};
  shared_ptr<string> type{};
  shared_ptr<string> bandwidth{};
  shared_ptr<string> relateInstanceRegionId{};
  shared_ptr<string> relateInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> commodityType{};

  DescribeSmartAccessGatewayAttributeResponseBodyLinksLink() {}

  explicit DescribeSmartAccessGatewayAttributeResponseBodyLinksLink(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (healthCheckTargetIp) {
      res["HealthCheckTargetIp"] = boost::any(*healthCheckTargetIp);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (relateInstanceRegionId) {
      res["RelateInstanceRegionId"] = boost::any(*relateInstanceRegionId);
    }
    if (relateInstanceId) {
      res["RelateInstanceId"] = boost::any(*relateInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (commodityType) {
      res["CommodityType"] = boost::any(*commodityType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HealthCheckTargetIp") != m.end() && !m["HealthCheckTargetIp"].empty()) {
      healthCheckTargetIp = make_shared<string>(boost::any_cast<string>(m["HealthCheckTargetIp"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<string>(boost::any_cast<string>(m["Bandwidth"]));
    }
    if (m.find("RelateInstanceRegionId") != m.end() && !m["RelateInstanceRegionId"].empty()) {
      relateInstanceRegionId = make_shared<string>(boost::any_cast<string>(m["RelateInstanceRegionId"]));
    }
    if (m.find("RelateInstanceId") != m.end() && !m["RelateInstanceId"].empty()) {
      relateInstanceId = make_shared<string>(boost::any_cast<string>(m["RelateInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("CommodityType") != m.end() && !m["CommodityType"].empty()) {
      commodityType = make_shared<string>(boost::any_cast<string>(m["CommodityType"]));
    }
  }


  virtual ~DescribeSmartAccessGatewayAttributeResponseBodyLinksLink() = default;
};
class DescribeSmartAccessGatewayAttributeResponseBodyLinks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSmartAccessGatewayAttributeResponseBodyLinksLink>> link{};

  DescribeSmartAccessGatewayAttributeResponseBodyLinks() {}

  explicit DescribeSmartAccessGatewayAttributeResponseBodyLinks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (link) {
      vector<boost::any> temp1;
      for(auto item1:*link){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Link"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Link") != m.end() && !m["Link"].empty()) {
      if (typeid(vector<boost::any>) == m["Link"].type()) {
        vector<DescribeSmartAccessGatewayAttributeResponseBodyLinksLink> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Link"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSmartAccessGatewayAttributeResponseBodyLinksLink model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        link = make_shared<vector<DescribeSmartAccessGatewayAttributeResponseBodyLinksLink>>(expect1);
      }
    }
  }


  virtual ~DescribeSmartAccessGatewayAttributeResponseBodyLinks() = default;
};
class DescribeSmartAccessGatewayAttributeResponseBodyAclIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> aclId{};

  DescribeSmartAccessGatewayAttributeResponseBodyAclIds() {}

  explicit DescribeSmartAccessGatewayAttributeResponseBodyAclIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AclId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AclId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      aclId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSmartAccessGatewayAttributeResponseBodyAclIds() = default;
};
class DescribeSmartAccessGatewayAttributeResponseBodyApplicationBandwidthPackageOperationLocks : public Darabonba::Model {
public:
  shared_ptr<string> lockType{};
  shared_ptr<string> lockReason{};

  DescribeSmartAccessGatewayAttributeResponseBodyApplicationBandwidthPackageOperationLocks() {}

  explicit DescribeSmartAccessGatewayAttributeResponseBodyApplicationBandwidthPackageOperationLocks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lockType) {
      res["LockType"] = boost::any(*lockType);
    }
    if (lockReason) {
      res["LockReason"] = boost::any(*lockReason);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LockType") != m.end() && !m["LockType"].empty()) {
      lockType = make_shared<string>(boost::any_cast<string>(m["LockType"]));
    }
    if (m.find("LockReason") != m.end() && !m["LockReason"].empty()) {
      lockReason = make_shared<string>(boost::any_cast<string>(m["LockReason"]));
    }
  }


  virtual ~DescribeSmartAccessGatewayAttributeResponseBodyApplicationBandwidthPackageOperationLocks() = default;
};
class DescribeSmartAccessGatewayAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> upBandwidth4G{};
  shared_ptr<string> description{};
  shared_ptr<long> endTime{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> userCount{};
  shared_ptr<string> associatedCcnName{};
  shared_ptr<string> maxBandwidth{};
  shared_ptr<string> vpnStatus{};
  shared_ptr<string> boxControllerIp{};
  shared_ptr<long> upBandwidthWan{};
  shared_ptr<string> cidrBlock{};
  shared_ptr<DescribeSmartAccessGatewayAttributeResponseBodyQosIds> qosIds{};
  shared_ptr<DescribeSmartAccessGatewayAttributeResponseBodyDevices> devices{};
  shared_ptr<string> name{};
  shared_ptr<bool> optimizationType{};
  shared_ptr<string> ipsecStatus{};
  shared_ptr<string> routingStrategy{};
  shared_ptr<string> associatedCcnId{};
  shared_ptr<DescribeSmartAccessGatewayAttributeResponseBodyFlowLogIds> flowLogIds{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> resellerUid{};
  shared_ptr<long> securityLockThreshold{};
  shared_ptr<string> status{};
  shared_ptr<string> requestId{};
  shared_ptr<long> createTime{};
  shared_ptr<long> dataPlan{};
  shared_ptr<bool> enableOptimization{};
  shared_ptr<string> city{};
  shared_ptr<string> resellerInstanceId{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> backupBoxControllerIp{};
  shared_ptr<string> trafficMasterSn{};
  shared_ptr<string> accessPointId{};
  shared_ptr<DescribeSmartAccessGatewayAttributeResponseBodyLinks> links{};
  shared_ptr<DescribeSmartAccessGatewayAttributeResponseBodyAclIds> aclIds{};
  shared_ptr<string> applicationBandwidthPackageId{};
  shared_ptr<string> applicationBandwidthPackageName{};
  shared_ptr<long> accelerateBandwidth{};
  shared_ptr<string> applicationBandwidthPackageBussinessStatus{};
  shared_ptr<DescribeSmartAccessGatewayAttributeResponseBodyApplicationBandwidthPackageOperationLocks> applicationBandwidthPackageOperationLocks{};

  DescribeSmartAccessGatewayAttributeResponseBody() {}

  explicit DescribeSmartAccessGatewayAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (upBandwidth4G) {
      res["UpBandwidth4G"] = boost::any(*upBandwidth4G);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (userCount) {
      res["UserCount"] = boost::any(*userCount);
    }
    if (associatedCcnName) {
      res["AssociatedCcnName"] = boost::any(*associatedCcnName);
    }
    if (maxBandwidth) {
      res["MaxBandwidth"] = boost::any(*maxBandwidth);
    }
    if (vpnStatus) {
      res["VpnStatus"] = boost::any(*vpnStatus);
    }
    if (boxControllerIp) {
      res["BoxControllerIp"] = boost::any(*boxControllerIp);
    }
    if (upBandwidthWan) {
      res["UpBandwidthWan"] = boost::any(*upBandwidthWan);
    }
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (qosIds) {
      res["QosIds"] = qosIds ? boost::any(qosIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (devices) {
      res["Devices"] = devices ? boost::any(devices->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (optimizationType) {
      res["OptimizationType"] = boost::any(*optimizationType);
    }
    if (ipsecStatus) {
      res["IpsecStatus"] = boost::any(*ipsecStatus);
    }
    if (routingStrategy) {
      res["RoutingStrategy"] = boost::any(*routingStrategy);
    }
    if (associatedCcnId) {
      res["AssociatedCcnId"] = boost::any(*associatedCcnId);
    }
    if (flowLogIds) {
      res["FlowLogIds"] = flowLogIds ? boost::any(flowLogIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (resellerUid) {
      res["ResellerUid"] = boost::any(*resellerUid);
    }
    if (securityLockThreshold) {
      res["SecurityLockThreshold"] = boost::any(*securityLockThreshold);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (dataPlan) {
      res["DataPlan"] = boost::any(*dataPlan);
    }
    if (enableOptimization) {
      res["EnableOptimization"] = boost::any(*enableOptimization);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (resellerInstanceId) {
      res["ResellerInstanceId"] = boost::any(*resellerInstanceId);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (backupBoxControllerIp) {
      res["BackupBoxControllerIp"] = boost::any(*backupBoxControllerIp);
    }
    if (trafficMasterSn) {
      res["TrafficMasterSn"] = boost::any(*trafficMasterSn);
    }
    if (accessPointId) {
      res["AccessPointId"] = boost::any(*accessPointId);
    }
    if (links) {
      res["Links"] = links ? boost::any(links->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (aclIds) {
      res["AclIds"] = aclIds ? boost::any(aclIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (applicationBandwidthPackageId) {
      res["ApplicationBandwidthPackageId"] = boost::any(*applicationBandwidthPackageId);
    }
    if (applicationBandwidthPackageName) {
      res["ApplicationBandwidthPackageName"] = boost::any(*applicationBandwidthPackageName);
    }
    if (accelerateBandwidth) {
      res["AccelerateBandwidth"] = boost::any(*accelerateBandwidth);
    }
    if (applicationBandwidthPackageBussinessStatus) {
      res["ApplicationBandwidthPackageBussinessStatus"] = boost::any(*applicationBandwidthPackageBussinessStatus);
    }
    if (applicationBandwidthPackageOperationLocks) {
      res["ApplicationBandwidthPackageOperationLocks"] = applicationBandwidthPackageOperationLocks ? boost::any(applicationBandwidthPackageOperationLocks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UpBandwidth4G") != m.end() && !m["UpBandwidth4G"].empty()) {
      upBandwidth4G = make_shared<long>(boost::any_cast<long>(m["UpBandwidth4G"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("UserCount") != m.end() && !m["UserCount"].empty()) {
      userCount = make_shared<long>(boost::any_cast<long>(m["UserCount"]));
    }
    if (m.find("AssociatedCcnName") != m.end() && !m["AssociatedCcnName"].empty()) {
      associatedCcnName = make_shared<string>(boost::any_cast<string>(m["AssociatedCcnName"]));
    }
    if (m.find("MaxBandwidth") != m.end() && !m["MaxBandwidth"].empty()) {
      maxBandwidth = make_shared<string>(boost::any_cast<string>(m["MaxBandwidth"]));
    }
    if (m.find("VpnStatus") != m.end() && !m["VpnStatus"].empty()) {
      vpnStatus = make_shared<string>(boost::any_cast<string>(m["VpnStatus"]));
    }
    if (m.find("BoxControllerIp") != m.end() && !m["BoxControllerIp"].empty()) {
      boxControllerIp = make_shared<string>(boost::any_cast<string>(m["BoxControllerIp"]));
    }
    if (m.find("UpBandwidthWan") != m.end() && !m["UpBandwidthWan"].empty()) {
      upBandwidthWan = make_shared<long>(boost::any_cast<long>(m["UpBandwidthWan"]));
    }
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("QosIds") != m.end() && !m["QosIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["QosIds"].type()) {
        DescribeSmartAccessGatewayAttributeResponseBodyQosIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QosIds"]));
        qosIds = make_shared<DescribeSmartAccessGatewayAttributeResponseBodyQosIds>(model1);
      }
    }
    if (m.find("Devices") != m.end() && !m["Devices"].empty()) {
      if (typeid(map<string, boost::any>) == m["Devices"].type()) {
        DescribeSmartAccessGatewayAttributeResponseBodyDevices model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Devices"]));
        devices = make_shared<DescribeSmartAccessGatewayAttributeResponseBodyDevices>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OptimizationType") != m.end() && !m["OptimizationType"].empty()) {
      optimizationType = make_shared<bool>(boost::any_cast<bool>(m["OptimizationType"]));
    }
    if (m.find("IpsecStatus") != m.end() && !m["IpsecStatus"].empty()) {
      ipsecStatus = make_shared<string>(boost::any_cast<string>(m["IpsecStatus"]));
    }
    if (m.find("RoutingStrategy") != m.end() && !m["RoutingStrategy"].empty()) {
      routingStrategy = make_shared<string>(boost::any_cast<string>(m["RoutingStrategy"]));
    }
    if (m.find("AssociatedCcnId") != m.end() && !m["AssociatedCcnId"].empty()) {
      associatedCcnId = make_shared<string>(boost::any_cast<string>(m["AssociatedCcnId"]));
    }
    if (m.find("FlowLogIds") != m.end() && !m["FlowLogIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["FlowLogIds"].type()) {
        DescribeSmartAccessGatewayAttributeResponseBodyFlowLogIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FlowLogIds"]));
        flowLogIds = make_shared<DescribeSmartAccessGatewayAttributeResponseBodyFlowLogIds>(model1);
      }
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("ResellerUid") != m.end() && !m["ResellerUid"].empty()) {
      resellerUid = make_shared<string>(boost::any_cast<string>(m["ResellerUid"]));
    }
    if (m.find("SecurityLockThreshold") != m.end() && !m["SecurityLockThreshold"].empty()) {
      securityLockThreshold = make_shared<long>(boost::any_cast<long>(m["SecurityLockThreshold"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("DataPlan") != m.end() && !m["DataPlan"].empty()) {
      dataPlan = make_shared<long>(boost::any_cast<long>(m["DataPlan"]));
    }
    if (m.find("EnableOptimization") != m.end() && !m["EnableOptimization"].empty()) {
      enableOptimization = make_shared<bool>(boost::any_cast<bool>(m["EnableOptimization"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("ResellerInstanceId") != m.end() && !m["ResellerInstanceId"].empty()) {
      resellerInstanceId = make_shared<string>(boost::any_cast<string>(m["ResellerInstanceId"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("BackupBoxControllerIp") != m.end() && !m["BackupBoxControllerIp"].empty()) {
      backupBoxControllerIp = make_shared<string>(boost::any_cast<string>(m["BackupBoxControllerIp"]));
    }
    if (m.find("TrafficMasterSn") != m.end() && !m["TrafficMasterSn"].empty()) {
      trafficMasterSn = make_shared<string>(boost::any_cast<string>(m["TrafficMasterSn"]));
    }
    if (m.find("AccessPointId") != m.end() && !m["AccessPointId"].empty()) {
      accessPointId = make_shared<string>(boost::any_cast<string>(m["AccessPointId"]));
    }
    if (m.find("Links") != m.end() && !m["Links"].empty()) {
      if (typeid(map<string, boost::any>) == m["Links"].type()) {
        DescribeSmartAccessGatewayAttributeResponseBodyLinks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Links"]));
        links = make_shared<DescribeSmartAccessGatewayAttributeResponseBodyLinks>(model1);
      }
    }
    if (m.find("AclIds") != m.end() && !m["AclIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["AclIds"].type()) {
        DescribeSmartAccessGatewayAttributeResponseBodyAclIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["AclIds"]));
        aclIds = make_shared<DescribeSmartAccessGatewayAttributeResponseBodyAclIds>(model1);
      }
    }
    if (m.find("ApplicationBandwidthPackageId") != m.end() && !m["ApplicationBandwidthPackageId"].empty()) {
      applicationBandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["ApplicationBandwidthPackageId"]));
    }
    if (m.find("ApplicationBandwidthPackageName") != m.end() && !m["ApplicationBandwidthPackageName"].empty()) {
      applicationBandwidthPackageName = make_shared<string>(boost::any_cast<string>(m["ApplicationBandwidthPackageName"]));
    }
    if (m.find("AccelerateBandwidth") != m.end() && !m["AccelerateBandwidth"].empty()) {
      accelerateBandwidth = make_shared<long>(boost::any_cast<long>(m["AccelerateBandwidth"]));
    }
    if (m.find("ApplicationBandwidthPackageBussinessStatus") != m.end() && !m["ApplicationBandwidthPackageBussinessStatus"].empty()) {
      applicationBandwidthPackageBussinessStatus = make_shared<string>(boost::any_cast<string>(m["ApplicationBandwidthPackageBussinessStatus"]));
    }
    if (m.find("ApplicationBandwidthPackageOperationLocks") != m.end() && !m["ApplicationBandwidthPackageOperationLocks"].empty()) {
      if (typeid(map<string, boost::any>) == m["ApplicationBandwidthPackageOperationLocks"].type()) {
        DescribeSmartAccessGatewayAttributeResponseBodyApplicationBandwidthPackageOperationLocks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ApplicationBandwidthPackageOperationLocks"]));
        applicationBandwidthPackageOperationLocks = make_shared<DescribeSmartAccessGatewayAttributeResponseBodyApplicationBandwidthPackageOperationLocks>(model1);
      }
    }
  }


  virtual ~DescribeSmartAccessGatewayAttributeResponseBody() = default;
};
class DescribeSmartAccessGatewayAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSmartAccessGatewayAttributeResponseBody> body{};

  DescribeSmartAccessGatewayAttributeResponse() {}

  explicit DescribeSmartAccessGatewayAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSmartAccessGatewayAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSmartAccessGatewayAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSmartAccessGatewayAttributeResponse() = default;
};
class CreateCloudConnectNetworkRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> snatCidrBlock{};

  CreateCloudConnectNetworkRequest() {}

  explicit CreateCloudConnectNetworkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (snatCidrBlock) {
      res["SnatCidrBlock"] = boost::any(*snatCidrBlock);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("SnatCidrBlock") != m.end() && !m["SnatCidrBlock"].empty()) {
      snatCidrBlock = make_shared<string>(boost::any_cast<string>(m["SnatCidrBlock"]));
    }
  }


  virtual ~CreateCloudConnectNetworkRequest() = default;
};
class CreateCloudConnectNetworkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<string> ccnId{};
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> snatCidrBlock{};
  shared_ptr<string> name{};
  shared_ptr<string> resourceGroupId{};

  CreateCloudConnectNetworkResponseBody() {}

  explicit CreateCloudConnectNetworkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ccnId) {
      res["CcnId"] = boost::any(*ccnId);
    }
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (snatCidrBlock) {
      res["SnatCidrBlock"] = boost::any(*snatCidrBlock);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("CcnId") != m.end() && !m["CcnId"].empty()) {
      ccnId = make_shared<string>(boost::any_cast<string>(m["CcnId"]));
    }
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("SnatCidrBlock") != m.end() && !m["SnatCidrBlock"].empty()) {
      snatCidrBlock = make_shared<string>(boost::any_cast<string>(m["SnatCidrBlock"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~CreateCloudConnectNetworkResponseBody() = default;
};
class CreateCloudConnectNetworkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateCloudConnectNetworkResponseBody> body{};

  CreateCloudConnectNetworkResponse() {}

  explicit CreateCloudConnectNetworkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCloudConnectNetworkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCloudConnectNetworkResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCloudConnectNetworkResponse() = default;
};
class DeleteQosPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> qosId{};
  shared_ptr<string> qosPolicyId{};

  DeleteQosPolicyRequest() {}

  explicit DeleteQosPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (qosPolicyId) {
      res["QosPolicyId"] = boost::any(*qosPolicyId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("QosPolicyId") != m.end() && !m["QosPolicyId"].empty()) {
      qosPolicyId = make_shared<string>(boost::any_cast<string>(m["QosPolicyId"]));
    }
  }


  virtual ~DeleteQosPolicyRequest() = default;
};
class DeleteQosPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteQosPolicyResponseBody() {}

  explicit DeleteQosPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteQosPolicyResponseBody() = default;
};
class DeleteQosPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteQosPolicyResponseBody> body{};

  DeleteQosPolicyResponse() {}

  explicit DeleteQosPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteQosPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteQosPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteQosPolicyResponse() = default;
};
class ModifySagHaRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};
  shared_ptr<string> mode{};
  shared_ptr<string> portName{};
  shared_ptr<string> virtualIp{};

  ModifySagHaRequest() {}

  explicit ModifySagHaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (portName) {
      res["PortName"] = boost::any(*portName);
    }
    if (virtualIp) {
      res["VirtualIp"] = boost::any(*virtualIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("PortName") != m.end() && !m["PortName"].empty()) {
      portName = make_shared<string>(boost::any_cast<string>(m["PortName"]));
    }
    if (m.find("VirtualIp") != m.end() && !m["VirtualIp"].empty()) {
      virtualIp = make_shared<string>(boost::any_cast<string>(m["VirtualIp"]));
    }
  }


  virtual ~ModifySagHaRequest() = default;
};
class ModifySagHaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySagHaResponseBody() {}

  explicit ModifySagHaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySagHaResponseBody() = default;
};
class ModifySagHaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySagHaResponseBody> body{};

  ModifySagHaResponse() {}

  explicit ModifySagHaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySagHaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySagHaResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySagHaResponse() = default;
};
class DeleteHealthCheckRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> hcInstanceId{};

  DeleteHealthCheckRequest() {}

  explicit DeleteHealthCheckRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (hcInstanceId) {
      res["HcInstanceId"] = boost::any(*hcInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("HcInstanceId") != m.end() && !m["HcInstanceId"].empty()) {
      hcInstanceId = make_shared<string>(boost::any_cast<string>(m["HcInstanceId"]));
    }
  }


  virtual ~DeleteHealthCheckRequest() = default;
};
class DeleteHealthCheckResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteHealthCheckResponseBody() {}

  explicit DeleteHealthCheckResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteHealthCheckResponseBody() = default;
};
class DeleteHealthCheckResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteHealthCheckResponseBody> body{};

  DeleteHealthCheckResponse() {}

  explicit DeleteHealthCheckResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteHealthCheckResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteHealthCheckResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteHealthCheckResponse() = default;
};
class SynchronizeSmartAGWebConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};

  SynchronizeSmartAGWebConfigRequest() {}

  explicit SynchronizeSmartAGWebConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
  }


  virtual ~SynchronizeSmartAGWebConfigRequest() = default;
};
class SynchronizeSmartAGWebConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SynchronizeSmartAGWebConfigResponseBody() {}

  explicit SynchronizeSmartAGWebConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SynchronizeSmartAGWebConfigResponseBody() = default;
};
class SynchronizeSmartAGWebConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<SynchronizeSmartAGWebConfigResponseBody> body{};

  SynchronizeSmartAGWebConfigResponse() {}

  explicit SynchronizeSmartAGWebConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SynchronizeSmartAGWebConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SynchronizeSmartAGWebConfigResponseBody>(model1);
      }
    }
  }


  virtual ~SynchronizeSmartAGWebConfigResponse() = default;
};
class DeleteSnatEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> instanceId{};

  DeleteSnatEntryRequest() {}

  explicit DeleteSnatEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~DeleteSnatEntryRequest() = default;
};
class DeleteSnatEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSnatEntryResponseBody() {}

  explicit DeleteSnatEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSnatEntryResponseBody() = default;
};
class DeleteSnatEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteSnatEntryResponseBody> body{};

  DeleteSnatEntryResponse() {}

  explicit DeleteSnatEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSnatEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSnatEntryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSnatEntryResponse() = default;
};
class DeleteQosRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> qosId{};

  DeleteQosRequest() {}

  explicit DeleteQosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
  }


  virtual ~DeleteQosRequest() = default;
};
class DeleteQosResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteQosResponseBody() {}

  explicit DeleteQosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteQosResponseBody() = default;
};
class DeleteQosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteQosResponseBody> body{};

  DeleteQosResponse() {}

  explicit DeleteQosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteQosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteQosResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteQosResponse() = default;
};
class AddSagCidrRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> cidr{};
  shared_ptr<string> smartAGId{};
  shared_ptr<bool> enableBackup{};

  AddSagCidrRequest() {}

  explicit AddSagCidrRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (cidr) {
      res["Cidr"] = boost::any(*cidr);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (enableBackup) {
      res["EnableBackup"] = boost::any(*enableBackup);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Cidr") != m.end() && !m["Cidr"].empty()) {
      cidr = make_shared<string>(boost::any_cast<string>(m["Cidr"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("EnableBackup") != m.end() && !m["EnableBackup"].empty()) {
      enableBackup = make_shared<bool>(boost::any_cast<bool>(m["EnableBackup"]));
    }
  }


  virtual ~AddSagCidrRequest() = default;
};
class AddSagCidrResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddSagCidrResponseBody() {}

  explicit AddSagCidrResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddSagCidrResponseBody() = default;
};
class AddSagCidrResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddSagCidrResponseBody> body{};

  AddSagCidrResponse() {}

  explicit AddSagCidrResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddSagCidrResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddSagCidrResponseBody>(model1);
      }
    }
  }


  virtual ~AddSagCidrResponse() = default;
};
class DeleteSagStaticRouteRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};
  shared_ptr<string> portName{};
  shared_ptr<string> destinationCidr{};
  shared_ptr<string> vlan{};

  DeleteSagStaticRouteRequest() {}

  explicit DeleteSagStaticRouteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    if (portName) {
      res["PortName"] = boost::any(*portName);
    }
    if (destinationCidr) {
      res["DestinationCidr"] = boost::any(*destinationCidr);
    }
    if (vlan) {
      res["Vlan"] = boost::any(*vlan);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
    if (m.find("PortName") != m.end() && !m["PortName"].empty()) {
      portName = make_shared<string>(boost::any_cast<string>(m["PortName"]));
    }
    if (m.find("DestinationCidr") != m.end() && !m["DestinationCidr"].empty()) {
      destinationCidr = make_shared<string>(boost::any_cast<string>(m["DestinationCidr"]));
    }
    if (m.find("Vlan") != m.end() && !m["Vlan"].empty()) {
      vlan = make_shared<string>(boost::any_cast<string>(m["Vlan"]));
    }
  }


  virtual ~DeleteSagStaticRouteRequest() = default;
};
class DeleteSagStaticRouteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSagStaticRouteResponseBody() {}

  explicit DeleteSagStaticRouteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSagStaticRouteResponseBody() = default;
};
class DeleteSagStaticRouteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteSagStaticRouteResponseBody> body{};

  DeleteSagStaticRouteResponse() {}

  explicit DeleteSagStaticRouteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSagStaticRouteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSagStaticRouteResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSagStaticRouteResponse() = default;
};
class DescribeGrantSagRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeGrantSagRulesRequest() {}

  explicit DescribeGrantSagRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeGrantSagRulesRequest() = default;
};
class DescribeGrantSagRulesResponseBodyGrantRulesGrantRule : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> smartAGId{};
  shared_ptr<bool> grantTrafficService{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> ccnUid{};
  shared_ptr<string> ccnInstanceId{};

  DescribeGrantSagRulesResponseBodyGrantRulesGrantRule() {}

  explicit DescribeGrantSagRulesResponseBodyGrantRulesGrantRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (grantTrafficService) {
      res["GrantTrafficService"] = boost::any(*grantTrafficService);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (ccnUid) {
      res["CcnUid"] = boost::any(*ccnUid);
    }
    if (ccnInstanceId) {
      res["CcnInstanceId"] = boost::any(*ccnInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("GrantTrafficService") != m.end() && !m["GrantTrafficService"].empty()) {
      grantTrafficService = make_shared<bool>(boost::any_cast<bool>(m["GrantTrafficService"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("CcnUid") != m.end() && !m["CcnUid"].empty()) {
      ccnUid = make_shared<long>(boost::any_cast<long>(m["CcnUid"]));
    }
    if (m.find("CcnInstanceId") != m.end() && !m["CcnInstanceId"].empty()) {
      ccnInstanceId = make_shared<string>(boost::any_cast<string>(m["CcnInstanceId"]));
    }
  }


  virtual ~DescribeGrantSagRulesResponseBodyGrantRulesGrantRule() = default;
};
class DescribeGrantSagRulesResponseBodyGrantRules : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGrantSagRulesResponseBodyGrantRulesGrantRule>> grantRule{};

  DescribeGrantSagRulesResponseBodyGrantRules() {}

  explicit DescribeGrantSagRulesResponseBodyGrantRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (grantRule) {
      vector<boost::any> temp1;
      for(auto item1:*grantRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GrantRule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GrantRule") != m.end() && !m["GrantRule"].empty()) {
      if (typeid(vector<boost::any>) == m["GrantRule"].type()) {
        vector<DescribeGrantSagRulesResponseBodyGrantRulesGrantRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GrantRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGrantSagRulesResponseBodyGrantRulesGrantRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        grantRule = make_shared<vector<DescribeGrantSagRulesResponseBodyGrantRulesGrantRule>>(expect1);
      }
    }
  }


  virtual ~DescribeGrantSagRulesResponseBodyGrantRules() = default;
};
class DescribeGrantSagRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<DescribeGrantSagRulesResponseBodyGrantRules> grantRules{};

  DescribeGrantSagRulesResponseBody() {}

  explicit DescribeGrantSagRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (grantRules) {
      res["GrantRules"] = grantRules ? boost::any(grantRules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("GrantRules") != m.end() && !m["GrantRules"].empty()) {
      if (typeid(map<string, boost::any>) == m["GrantRules"].type()) {
        DescribeGrantSagRulesResponseBodyGrantRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GrantRules"]));
        grantRules = make_shared<DescribeGrantSagRulesResponseBodyGrantRules>(model1);
      }
    }
  }


  virtual ~DescribeGrantSagRulesResponseBody() = default;
};
class DescribeGrantSagRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeGrantSagRulesResponseBody> body{};

  DescribeGrantSagRulesResponse() {}

  explicit DescribeGrantSagRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGrantSagRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGrantSagRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGrantSagRulesResponse() = default;
};
class DescribeUserOnlineClientsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> userName{};

  DescribeUserOnlineClientsRequest() {}

  explicit DescribeUserOnlineClientsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeUserOnlineClientsRequest() = default;
};
class DescribeUserOnlineClientsResponseBodyUsersUser : public Darabonba::Model {
public:
  shared_ptr<string> clientIp{};
  shared_ptr<string> onlineTime{};

  DescribeUserOnlineClientsResponseBodyUsersUser() {}

  explicit DescribeUserOnlineClientsResponseBodyUsersUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (onlineTime) {
      res["OnlineTime"] = boost::any(*onlineTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("OnlineTime") != m.end() && !m["OnlineTime"].empty()) {
      onlineTime = make_shared<string>(boost::any_cast<string>(m["OnlineTime"]));
    }
  }


  virtual ~DescribeUserOnlineClientsResponseBodyUsersUser() = default;
};
class DescribeUserOnlineClientsResponseBodyUsers : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUserOnlineClientsResponseBodyUsersUser>> user{};

  DescribeUserOnlineClientsResponseBodyUsers() {}

  explicit DescribeUserOnlineClientsResponseBodyUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (user) {
      vector<boost::any> temp1;
      for(auto item1:*user){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["User"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("User") != m.end() && !m["User"].empty()) {
      if (typeid(vector<boost::any>) == m["User"].type()) {
        vector<DescribeUserOnlineClientsResponseBodyUsersUser> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["User"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUserOnlineClientsResponseBodyUsersUser model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        user = make_shared<vector<DescribeUserOnlineClientsResponseBodyUsersUser>>(expect1);
      }
    }
  }


  virtual ~DescribeUserOnlineClientsResponseBodyUsers() = default;
};
class DescribeUserOnlineClientsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeUserOnlineClientsResponseBodyUsers> users{};

  DescribeUserOnlineClientsResponseBody() {}

  explicit DescribeUserOnlineClientsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (users) {
      res["Users"] = users ? boost::any(users->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      if (typeid(map<string, boost::any>) == m["Users"].type()) {
        DescribeUserOnlineClientsResponseBodyUsers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Users"]));
        users = make_shared<DescribeUserOnlineClientsResponseBodyUsers>(model1);
      }
    }
  }


  virtual ~DescribeUserOnlineClientsResponseBody() = default;
};
class DescribeUserOnlineClientsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeUserOnlineClientsResponseBody> body{};

  DescribeUserOnlineClientsResponse() {}

  explicit DescribeUserOnlineClientsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserOnlineClientsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserOnlineClientsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserOnlineClientsResponse() = default;
};
class DiagnoseSmartAccessGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};
  shared_ptr<string> regionId{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> ownerAccount{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};

  DiagnoseSmartAccessGatewayRequest() {}

  explicit DiagnoseSmartAccessGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DiagnoseSmartAccessGatewayRequest() = default;
};
class DiagnoseSmartAccessGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DiagnoseSmartAccessGatewayResponseBody() {}

  explicit DiagnoseSmartAccessGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DiagnoseSmartAccessGatewayResponseBody() = default;
};
class DiagnoseSmartAccessGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DiagnoseSmartAccessGatewayResponseBody> body{};

  DiagnoseSmartAccessGatewayResponse() {}

  explicit DiagnoseSmartAccessGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DiagnoseSmartAccessGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DiagnoseSmartAccessGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~DiagnoseSmartAccessGatewayResponse() = default;
};
class DescribeSagWifiRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};

  DescribeSagWifiRequest() {}

  explicit DescribeSagWifiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
  }


  virtual ~DescribeSagWifiRequest() = default;
};
class DescribeSagWifiResponseBodyTaskStates : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> state{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> createTime{};

  DescribeSagWifiResponseBodyTaskStates() {}

  explicit DescribeSagWifiResponseBodyTaskStates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
  }


  virtual ~DescribeSagWifiResponseBodyTaskStates() = default;
};
class DescribeSagWifiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> isEnable{};
  shared_ptr<string> requestId{};
  shared_ptr<string> isAuth{};
  shared_ptr<string> bandwidth{};
  shared_ptr<string> channel{};
  shared_ptr<string> ssid{};
  shared_ptr<vector<DescribeSagWifiResponseBodyTaskStates>> taskStates{};
  shared_ptr<string> authenticationType{};
  shared_ptr<string> encryptAlgorithm{};
  shared_ptr<string> isBroadcast{};

  DescribeSagWifiResponseBody() {}

  explicit DescribeSagWifiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isEnable) {
      res["IsEnable"] = boost::any(*isEnable);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (isAuth) {
      res["IsAuth"] = boost::any(*isAuth);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (channel) {
      res["Channel"] = boost::any(*channel);
    }
    if (ssid) {
      res["Ssid"] = boost::any(*ssid);
    }
    if (taskStates) {
      vector<boost::any> temp1;
      for(auto item1:*taskStates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskStates"] = boost::any(temp1);
    }
    if (authenticationType) {
      res["AuthenticationType"] = boost::any(*authenticationType);
    }
    if (encryptAlgorithm) {
      res["EncryptAlgorithm"] = boost::any(*encryptAlgorithm);
    }
    if (isBroadcast) {
      res["IsBroadcast"] = boost::any(*isBroadcast);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsEnable") != m.end() && !m["IsEnable"].empty()) {
      isEnable = make_shared<string>(boost::any_cast<string>(m["IsEnable"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("IsAuth") != m.end() && !m["IsAuth"].empty()) {
      isAuth = make_shared<string>(boost::any_cast<string>(m["IsAuth"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<string>(boost::any_cast<string>(m["Bandwidth"]));
    }
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["Channel"]));
    }
    if (m.find("Ssid") != m.end() && !m["Ssid"].empty()) {
      ssid = make_shared<string>(boost::any_cast<string>(m["Ssid"]));
    }
    if (m.find("TaskStates") != m.end() && !m["TaskStates"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskStates"].type()) {
        vector<DescribeSagWifiResponseBodyTaskStates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskStates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSagWifiResponseBodyTaskStates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskStates = make_shared<vector<DescribeSagWifiResponseBodyTaskStates>>(expect1);
      }
    }
    if (m.find("AuthenticationType") != m.end() && !m["AuthenticationType"].empty()) {
      authenticationType = make_shared<string>(boost::any_cast<string>(m["AuthenticationType"]));
    }
    if (m.find("EncryptAlgorithm") != m.end() && !m["EncryptAlgorithm"].empty()) {
      encryptAlgorithm = make_shared<string>(boost::any_cast<string>(m["EncryptAlgorithm"]));
    }
    if (m.find("IsBroadcast") != m.end() && !m["IsBroadcast"].empty()) {
      isBroadcast = make_shared<string>(boost::any_cast<string>(m["IsBroadcast"]));
    }
  }


  virtual ~DescribeSagWifiResponseBody() = default;
};
class DescribeSagWifiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSagWifiResponseBody> body{};

  DescribeSagWifiResponse() {}

  explicit DescribeSagWifiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSagWifiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSagWifiResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSagWifiResponse() = default;
};
class UnbindSerialNumberRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> serialNumber{};

  UnbindSerialNumberRequest() {}

  explicit UnbindSerialNumberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
  }


  virtual ~UnbindSerialNumberRequest() = default;
};
class UnbindSerialNumberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnbindSerialNumberResponseBody() {}

  explicit UnbindSerialNumberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnbindSerialNumberResponseBody() = default;
};
class UnbindSerialNumberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UnbindSerialNumberResponseBody> body{};

  UnbindSerialNumberResponse() {}

  explicit UnbindSerialNumberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindSerialNumberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindSerialNumberResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindSerialNumberResponse() = default;
};
class DescribeSAGDeviceInfoRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};

  DescribeSAGDeviceInfoRequest() {}

  explicit DescribeSAGDeviceInfoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
  }


  virtual ~DescribeSAGDeviceInfoRequest() = default;
};
class DescribeSAGDeviceInfoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> serviceIP{};
  shared_ptr<string> controllerState{};
  shared_ptr<string> requestId{};
  shared_ptr<string> synStatus{};
  shared_ptr<string> smartAGType{};
  shared_ptr<string> version{};
  shared_ptr<string> vpnState{};
  shared_ptr<string> startupTime{};
  shared_ptr<string> lastConnectedControllerTime{};

  DescribeSAGDeviceInfoResponseBody() {}

  explicit DescribeSAGDeviceInfoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serviceIP) {
      res["ServiceIP"] = boost::any(*serviceIP);
    }
    if (controllerState) {
      res["ControllerState"] = boost::any(*controllerState);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (synStatus) {
      res["SynStatus"] = boost::any(*synStatus);
    }
    if (smartAGType) {
      res["SmartAGType"] = boost::any(*smartAGType);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    if (vpnState) {
      res["VpnState"] = boost::any(*vpnState);
    }
    if (startupTime) {
      res["StartupTime"] = boost::any(*startupTime);
    }
    if (lastConnectedControllerTime) {
      res["LastConnectedControllerTime"] = boost::any(*lastConnectedControllerTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ServiceIP") != m.end() && !m["ServiceIP"].empty()) {
      serviceIP = make_shared<string>(boost::any_cast<string>(m["ServiceIP"]));
    }
    if (m.find("ControllerState") != m.end() && !m["ControllerState"].empty()) {
      controllerState = make_shared<string>(boost::any_cast<string>(m["ControllerState"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SynStatus") != m.end() && !m["SynStatus"].empty()) {
      synStatus = make_shared<string>(boost::any_cast<string>(m["SynStatus"]));
    }
    if (m.find("SmartAGType") != m.end() && !m["SmartAGType"].empty()) {
      smartAGType = make_shared<string>(boost::any_cast<string>(m["SmartAGType"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
    if (m.find("VpnState") != m.end() && !m["VpnState"].empty()) {
      vpnState = make_shared<string>(boost::any_cast<string>(m["VpnState"]));
    }
    if (m.find("StartupTime") != m.end() && !m["StartupTime"].empty()) {
      startupTime = make_shared<string>(boost::any_cast<string>(m["StartupTime"]));
    }
    if (m.find("LastConnectedControllerTime") != m.end() && !m["LastConnectedControllerTime"].empty()) {
      lastConnectedControllerTime = make_shared<string>(boost::any_cast<string>(m["LastConnectedControllerTime"]));
    }
  }


  virtual ~DescribeSAGDeviceInfoResponseBody() = default;
};
class DescribeSAGDeviceInfoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSAGDeviceInfoResponseBody> body{};

  DescribeSAGDeviceInfoResponse() {}

  explicit DescribeSAGDeviceInfoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSAGDeviceInfoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSAGDeviceInfoResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSAGDeviceInfoResponse() = default;
};
class DescribeUserFlowStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> statisticsDate{};
  shared_ptr<vector<string>> userNames{};

  DescribeUserFlowStatisticsRequest() {}

  explicit DescribeUserFlowStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (statisticsDate) {
      res["StatisticsDate"] = boost::any(*statisticsDate);
    }
    if (userNames) {
      res["UserNames"] = boost::any(*userNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("StatisticsDate") != m.end() && !m["StatisticsDate"].empty()) {
      statisticsDate = make_shared<string>(boost::any_cast<string>(m["StatisticsDate"]));
    }
    if (m.find("UserNames") != m.end() && !m["UserNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeUserFlowStatisticsRequest() = default;
};
class DescribeUserFlowStatisticsResponseBodySagStatisticsStatistics : public Darabonba::Model {
public:
  shared_ptr<string> totalBytes{};
  shared_ptr<string> userName{};

  DescribeUserFlowStatisticsResponseBodySagStatisticsStatistics() {}

  explicit DescribeUserFlowStatisticsResponseBodySagStatisticsStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalBytes) {
      res["TotalBytes"] = boost::any(*totalBytes);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalBytes") != m.end() && !m["TotalBytes"].empty()) {
      totalBytes = make_shared<string>(boost::any_cast<string>(m["TotalBytes"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeUserFlowStatisticsResponseBodySagStatisticsStatistics() = default;
};
class DescribeUserFlowStatisticsResponseBodySagStatistics : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUserFlowStatisticsResponseBodySagStatisticsStatistics>> statistics{};

  DescribeUserFlowStatisticsResponseBodySagStatistics() {}

  explicit DescribeUserFlowStatisticsResponseBodySagStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (statistics) {
      vector<boost::any> temp1;
      for(auto item1:*statistics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Statistics"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      if (typeid(vector<boost::any>) == m["Statistics"].type()) {
        vector<DescribeUserFlowStatisticsResponseBodySagStatisticsStatistics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Statistics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUserFlowStatisticsResponseBodySagStatisticsStatistics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statistics = make_shared<vector<DescribeUserFlowStatisticsResponseBodySagStatisticsStatistics>>(expect1);
      }
    }
  }


  virtual ~DescribeUserFlowStatisticsResponseBodySagStatistics() = default;
};
class DescribeUserFlowStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeUserFlowStatisticsResponseBodySagStatistics> sagStatistics{};
  shared_ptr<string> requestId{};

  DescribeUserFlowStatisticsResponseBody() {}

  explicit DescribeUserFlowStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sagStatistics) {
      res["SagStatistics"] = sagStatistics ? boost::any(sagStatistics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SagStatistics") != m.end() && !m["SagStatistics"].empty()) {
      if (typeid(map<string, boost::any>) == m["SagStatistics"].type()) {
        DescribeUserFlowStatisticsResponseBodySagStatistics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SagStatistics"]));
        sagStatistics = make_shared<DescribeUserFlowStatisticsResponseBodySagStatistics>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUserFlowStatisticsResponseBody() = default;
};
class DescribeUserFlowStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeUserFlowStatisticsResponseBody> body{};

  DescribeUserFlowStatisticsResponse() {}

  explicit DescribeUserFlowStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserFlowStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserFlowStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserFlowStatisticsResponse() = default;
};
class ModifySagLanRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};
  shared_ptr<string> portName{};
  shared_ptr<string> IPType{};
  shared_ptr<string> IP{};
  shared_ptr<string> mask{};
  shared_ptr<string> startIp{};
  shared_ptr<string> endIp{};
  shared_ptr<string> lease{};

  ModifySagLanRequest() {}

  explicit ModifySagLanRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    if (portName) {
      res["PortName"] = boost::any(*portName);
    }
    if (IPType) {
      res["IPType"] = boost::any(*IPType);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (mask) {
      res["Mask"] = boost::any(*mask);
    }
    if (startIp) {
      res["StartIp"] = boost::any(*startIp);
    }
    if (endIp) {
      res["EndIp"] = boost::any(*endIp);
    }
    if (lease) {
      res["Lease"] = boost::any(*lease);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
    if (m.find("PortName") != m.end() && !m["PortName"].empty()) {
      portName = make_shared<string>(boost::any_cast<string>(m["PortName"]));
    }
    if (m.find("IPType") != m.end() && !m["IPType"].empty()) {
      IPType = make_shared<string>(boost::any_cast<string>(m["IPType"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("Mask") != m.end() && !m["Mask"].empty()) {
      mask = make_shared<string>(boost::any_cast<string>(m["Mask"]));
    }
    if (m.find("StartIp") != m.end() && !m["StartIp"].empty()) {
      startIp = make_shared<string>(boost::any_cast<string>(m["StartIp"]));
    }
    if (m.find("EndIp") != m.end() && !m["EndIp"].empty()) {
      endIp = make_shared<string>(boost::any_cast<string>(m["EndIp"]));
    }
    if (m.find("Lease") != m.end() && !m["Lease"].empty()) {
      lease = make_shared<string>(boost::any_cast<string>(m["Lease"]));
    }
  }


  virtual ~ModifySagLanRequest() = default;
};
class ModifySagLanResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySagLanResponseBody() {}

  explicit ModifySagLanResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySagLanResponseBody() = default;
};
class ModifySagLanResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySagLanResponseBody> body{};

  ModifySagLanResponse() {}

  explicit ModifySagLanResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySagLanResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySagLanResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySagLanResponse() = default;
};
class DescribeFlowLogsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> flowLogId{};
  shared_ptr<string> flowLogName{};
  shared_ptr<string> description{};
  shared_ptr<string> status{};
  shared_ptr<string> outputType{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};

  DescribeFlowLogsRequest() {}

  explicit DescribeFlowLogsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (flowLogId) {
      res["FlowLogId"] = boost::any(*flowLogId);
    }
    if (flowLogName) {
      res["FlowLogName"] = boost::any(*flowLogName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (outputType) {
      res["OutputType"] = boost::any(*outputType);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("FlowLogId") != m.end() && !m["FlowLogId"].empty()) {
      flowLogId = make_shared<string>(boost::any_cast<string>(m["FlowLogId"]));
    }
    if (m.find("FlowLogName") != m.end() && !m["FlowLogName"].empty()) {
      flowLogName = make_shared<string>(boost::any_cast<string>(m["FlowLogName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("OutputType") != m.end() && !m["OutputType"].empty()) {
      outputType = make_shared<string>(boost::any_cast<string>(m["OutputType"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~DescribeFlowLogsRequest() = default;
};
class DescribeFlowLogsResponseBodyFlowLogsFlowLogSetType : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<long> totalSagNum{};
  shared_ptr<string> netflowServerIp{};
  shared_ptr<string> projectName{};
  shared_ptr<string> slsRegionId{};
  shared_ptr<long> activeAging{};
  shared_ptr<string> outputType{};
  shared_ptr<string> description{};
  shared_ptr<string> netflowVersion{};
  shared_ptr<long> inactiveAging{};
  shared_ptr<string> netflowServerPort{};
  shared_ptr<string> name{};
  shared_ptr<string> flowLogId{};
  shared_ptr<string> logstoreName{};
  shared_ptr<string> resourceGroupId{};

  DescribeFlowLogsResponseBodyFlowLogsFlowLogSetType() {}

  explicit DescribeFlowLogsResponseBodyFlowLogsFlowLogSetType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (totalSagNum) {
      res["TotalSagNum"] = boost::any(*totalSagNum);
    }
    if (netflowServerIp) {
      res["NetflowServerIp"] = boost::any(*netflowServerIp);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (slsRegionId) {
      res["SlsRegionId"] = boost::any(*slsRegionId);
    }
    if (activeAging) {
      res["ActiveAging"] = boost::any(*activeAging);
    }
    if (outputType) {
      res["OutputType"] = boost::any(*outputType);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (netflowVersion) {
      res["NetflowVersion"] = boost::any(*netflowVersion);
    }
    if (inactiveAging) {
      res["InactiveAging"] = boost::any(*inactiveAging);
    }
    if (netflowServerPort) {
      res["NetflowServerPort"] = boost::any(*netflowServerPort);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (flowLogId) {
      res["FlowLogId"] = boost::any(*flowLogId);
    }
    if (logstoreName) {
      res["LogstoreName"] = boost::any(*logstoreName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TotalSagNum") != m.end() && !m["TotalSagNum"].empty()) {
      totalSagNum = make_shared<long>(boost::any_cast<long>(m["TotalSagNum"]));
    }
    if (m.find("NetflowServerIp") != m.end() && !m["NetflowServerIp"].empty()) {
      netflowServerIp = make_shared<string>(boost::any_cast<string>(m["NetflowServerIp"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SlsRegionId") != m.end() && !m["SlsRegionId"].empty()) {
      slsRegionId = make_shared<string>(boost::any_cast<string>(m["SlsRegionId"]));
    }
    if (m.find("ActiveAging") != m.end() && !m["ActiveAging"].empty()) {
      activeAging = make_shared<long>(boost::any_cast<long>(m["ActiveAging"]));
    }
    if (m.find("OutputType") != m.end() && !m["OutputType"].empty()) {
      outputType = make_shared<string>(boost::any_cast<string>(m["OutputType"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("NetflowVersion") != m.end() && !m["NetflowVersion"].empty()) {
      netflowVersion = make_shared<string>(boost::any_cast<string>(m["NetflowVersion"]));
    }
    if (m.find("InactiveAging") != m.end() && !m["InactiveAging"].empty()) {
      inactiveAging = make_shared<long>(boost::any_cast<long>(m["InactiveAging"]));
    }
    if (m.find("NetflowServerPort") != m.end() && !m["NetflowServerPort"].empty()) {
      netflowServerPort = make_shared<string>(boost::any_cast<string>(m["NetflowServerPort"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("FlowLogId") != m.end() && !m["FlowLogId"].empty()) {
      flowLogId = make_shared<string>(boost::any_cast<string>(m["FlowLogId"]));
    }
    if (m.find("LogstoreName") != m.end() && !m["LogstoreName"].empty()) {
      logstoreName = make_shared<string>(boost::any_cast<string>(m["LogstoreName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeFlowLogsResponseBodyFlowLogsFlowLogSetType() = default;
};
class DescribeFlowLogsResponseBodyFlowLogs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeFlowLogsResponseBodyFlowLogsFlowLogSetType>> flowLogSetType{};

  DescribeFlowLogsResponseBodyFlowLogs() {}

  explicit DescribeFlowLogsResponseBodyFlowLogs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (flowLogSetType) {
      vector<boost::any> temp1;
      for(auto item1:*flowLogSetType){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FlowLogSetType"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FlowLogSetType") != m.end() && !m["FlowLogSetType"].empty()) {
      if (typeid(vector<boost::any>) == m["FlowLogSetType"].type()) {
        vector<DescribeFlowLogsResponseBodyFlowLogsFlowLogSetType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FlowLogSetType"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFlowLogsResponseBodyFlowLogsFlowLogSetType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        flowLogSetType = make_shared<vector<DescribeFlowLogsResponseBodyFlowLogsFlowLogSetType>>(expect1);
      }
    }
  }


  virtual ~DescribeFlowLogsResponseBodyFlowLogs() = default;
};
class DescribeFlowLogsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeFlowLogsResponseBodyFlowLogs> flowLogs{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};

  DescribeFlowLogsResponseBody() {}

  explicit DescribeFlowLogsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (flowLogs) {
      res["FlowLogs"] = flowLogs ? boost::any(flowLogs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("FlowLogs") != m.end() && !m["FlowLogs"].empty()) {
      if (typeid(map<string, boost::any>) == m["FlowLogs"].type()) {
        DescribeFlowLogsResponseBodyFlowLogs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FlowLogs"]));
        flowLogs = make_shared<DescribeFlowLogsResponseBodyFlowLogs>(model1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~DescribeFlowLogsResponseBody() = default;
};
class DescribeFlowLogsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeFlowLogsResponseBody> body{};

  DescribeFlowLogsResponse() {}

  explicit DescribeFlowLogsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFlowLogsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFlowLogsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFlowLogsResponse() = default;
};
class DescribeSmartAccessGatewayClientUsersRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> userName{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> userMail{};

  DescribeSmartAccessGatewayClientUsersRequest() {}

  explicit DescribeSmartAccessGatewayClientUsersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (userMail) {
      res["UserMail"] = boost::any(*userMail);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("UserMail") != m.end() && !m["UserMail"].empty()) {
      userMail = make_shared<string>(boost::any_cast<string>(m["UserMail"]));
    }
  }


  virtual ~DescribeSmartAccessGatewayClientUsersRequest() = default;
};
class DescribeSmartAccessGatewayClientUsersResponseBodyUsersUser : public Darabonba::Model {
public:
  shared_ptr<long> bandwidth{};
  shared_ptr<long> state{};
  shared_ptr<string> clientIp{};
  shared_ptr<string> userName{};
  shared_ptr<string> userMail{};
  shared_ptr<long> accelerateBandwidth{};

  DescribeSmartAccessGatewayClientUsersResponseBodyUsersUser() {}

  explicit DescribeSmartAccessGatewayClientUsersResponseBodyUsersUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (userMail) {
      res["UserMail"] = boost::any(*userMail);
    }
    if (accelerateBandwidth) {
      res["AccelerateBandwidth"] = boost::any(*accelerateBandwidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<long>(boost::any_cast<long>(m["State"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("UserMail") != m.end() && !m["UserMail"].empty()) {
      userMail = make_shared<string>(boost::any_cast<string>(m["UserMail"]));
    }
    if (m.find("AccelerateBandwidth") != m.end() && !m["AccelerateBandwidth"].empty()) {
      accelerateBandwidth = make_shared<long>(boost::any_cast<long>(m["AccelerateBandwidth"]));
    }
  }


  virtual ~DescribeSmartAccessGatewayClientUsersResponseBodyUsersUser() = default;
};
class DescribeSmartAccessGatewayClientUsersResponseBodyUsers : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSmartAccessGatewayClientUsersResponseBodyUsersUser>> user{};

  DescribeSmartAccessGatewayClientUsersResponseBodyUsers() {}

  explicit DescribeSmartAccessGatewayClientUsersResponseBodyUsers(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (user) {
      vector<boost::any> temp1;
      for(auto item1:*user){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["User"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("User") != m.end() && !m["User"].empty()) {
      if (typeid(vector<boost::any>) == m["User"].type()) {
        vector<DescribeSmartAccessGatewayClientUsersResponseBodyUsersUser> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["User"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSmartAccessGatewayClientUsersResponseBodyUsersUser model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        user = make_shared<vector<DescribeSmartAccessGatewayClientUsersResponseBodyUsersUser>>(expect1);
      }
    }
  }


  virtual ~DescribeSmartAccessGatewayClientUsersResponseBodyUsers() = default;
};
class DescribeSmartAccessGatewayClientUsersResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<DescribeSmartAccessGatewayClientUsersResponseBodyUsers> users{};

  DescribeSmartAccessGatewayClientUsersResponseBody() {}

  explicit DescribeSmartAccessGatewayClientUsersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (users) {
      res["Users"] = users ? boost::any(users->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("Users") != m.end() && !m["Users"].empty()) {
      if (typeid(map<string, boost::any>) == m["Users"].type()) {
        DescribeSmartAccessGatewayClientUsersResponseBodyUsers model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Users"]));
        users = make_shared<DescribeSmartAccessGatewayClientUsersResponseBodyUsers>(model1);
      }
    }
  }


  virtual ~DescribeSmartAccessGatewayClientUsersResponseBody() = default;
};
class DescribeSmartAccessGatewayClientUsersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSmartAccessGatewayClientUsersResponseBody> body{};

  DescribeSmartAccessGatewayClientUsersResponse() {}

  explicit DescribeSmartAccessGatewayClientUsersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSmartAccessGatewayClientUsersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSmartAccessGatewayClientUsersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSmartAccessGatewayClientUsersResponse() = default;
};
class DescribeHealthCheckAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> hcInstanceId{};
  shared_ptr<string> smartAGId{};

  DescribeHealthCheckAttributeRequest() {}

  explicit DescribeHealthCheckAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (hcInstanceId) {
      res["HcInstanceId"] = boost::any(*hcInstanceId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("HcInstanceId") != m.end() && !m["HcInstanceId"].empty()) {
      hcInstanceId = make_shared<string>(boost::any_cast<string>(m["HcInstanceId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
  }


  virtual ~DescribeHealthCheckAttributeRequest() = default;
};
class DescribeHealthCheckAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> srcPort{};
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<string> srcIpAddr{};
  shared_ptr<long> createTime{};
  shared_ptr<long> failCountThreshold{};
  shared_ptr<long> dstPort{};
  shared_ptr<string> name{};
  shared_ptr<long> probeCount{};
  shared_ptr<string> type{};
  shared_ptr<long> probeTimeout{};
  shared_ptr<string> hcInstanceId{};
  shared_ptr<long> rttThreshold{};
  shared_ptr<long> probeInterval{};
  shared_ptr<string> smartAGId{};
  shared_ptr<long> rttFailThreshold{};
  shared_ptr<string> dstIpAddr{};

  DescribeHealthCheckAttributeResponseBody() {}

  explicit DescribeHealthCheckAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (srcPort) {
      res["SrcPort"] = boost::any(*srcPort);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (srcIpAddr) {
      res["SrcIpAddr"] = boost::any(*srcIpAddr);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (failCountThreshold) {
      res["FailCountThreshold"] = boost::any(*failCountThreshold);
    }
    if (dstPort) {
      res["DstPort"] = boost::any(*dstPort);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (probeCount) {
      res["ProbeCount"] = boost::any(*probeCount);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (probeTimeout) {
      res["ProbeTimeout"] = boost::any(*probeTimeout);
    }
    if (hcInstanceId) {
      res["HcInstanceId"] = boost::any(*hcInstanceId);
    }
    if (rttThreshold) {
      res["RttThreshold"] = boost::any(*rttThreshold);
    }
    if (probeInterval) {
      res["ProbeInterval"] = boost::any(*probeInterval);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (rttFailThreshold) {
      res["RttFailThreshold"] = boost::any(*rttFailThreshold);
    }
    if (dstIpAddr) {
      res["DstIpAddr"] = boost::any(*dstIpAddr);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SrcPort") != m.end() && !m["SrcPort"].empty()) {
      srcPort = make_shared<long>(boost::any_cast<long>(m["SrcPort"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SrcIpAddr") != m.end() && !m["SrcIpAddr"].empty()) {
      srcIpAddr = make_shared<string>(boost::any_cast<string>(m["SrcIpAddr"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("FailCountThreshold") != m.end() && !m["FailCountThreshold"].empty()) {
      failCountThreshold = make_shared<long>(boost::any_cast<long>(m["FailCountThreshold"]));
    }
    if (m.find("DstPort") != m.end() && !m["DstPort"].empty()) {
      dstPort = make_shared<long>(boost::any_cast<long>(m["DstPort"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ProbeCount") != m.end() && !m["ProbeCount"].empty()) {
      probeCount = make_shared<long>(boost::any_cast<long>(m["ProbeCount"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ProbeTimeout") != m.end() && !m["ProbeTimeout"].empty()) {
      probeTimeout = make_shared<long>(boost::any_cast<long>(m["ProbeTimeout"]));
    }
    if (m.find("HcInstanceId") != m.end() && !m["HcInstanceId"].empty()) {
      hcInstanceId = make_shared<string>(boost::any_cast<string>(m["HcInstanceId"]));
    }
    if (m.find("RttThreshold") != m.end() && !m["RttThreshold"].empty()) {
      rttThreshold = make_shared<long>(boost::any_cast<long>(m["RttThreshold"]));
    }
    if (m.find("ProbeInterval") != m.end() && !m["ProbeInterval"].empty()) {
      probeInterval = make_shared<long>(boost::any_cast<long>(m["ProbeInterval"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("RttFailThreshold") != m.end() && !m["RttFailThreshold"].empty()) {
      rttFailThreshold = make_shared<long>(boost::any_cast<long>(m["RttFailThreshold"]));
    }
    if (m.find("DstIpAddr") != m.end() && !m["DstIpAddr"].empty()) {
      dstIpAddr = make_shared<string>(boost::any_cast<string>(m["DstIpAddr"]));
    }
  }


  virtual ~DescribeHealthCheckAttributeResponseBody() = default;
};
class DescribeHealthCheckAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeHealthCheckAttributeResponseBody> body{};

  DescribeHealthCheckAttributeResponse() {}

  explicit DescribeHealthCheckAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHealthCheckAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHealthCheckAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHealthCheckAttributeResponse() = default;
};
class ModifyQosPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> qosId{};
  shared_ptr<string> qosPolicyId{};
  shared_ptr<long> priority{};
  shared_ptr<string> sourceCidr{};
  shared_ptr<string> destCidr{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> sourcePortRange{};
  shared_ptr<string> destPortRange{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> dpiSignatureIds{};
  shared_ptr<vector<string>> dpiGroupIds{};

  ModifyQosPolicyRequest() {}

  explicit ModifyQosPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (qosPolicyId) {
      res["QosPolicyId"] = boost::any(*qosPolicyId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (sourceCidr) {
      res["SourceCidr"] = boost::any(*sourceCidr);
    }
    if (destCidr) {
      res["DestCidr"] = boost::any(*destCidr);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    if (destPortRange) {
      res["DestPortRange"] = boost::any(*destPortRange);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (dpiSignatureIds) {
      res["DpiSignatureIds"] = boost::any(*dpiSignatureIds);
    }
    if (dpiGroupIds) {
      res["DpiGroupIds"] = boost::any(*dpiGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("QosPolicyId") != m.end() && !m["QosPolicyId"].empty()) {
      qosPolicyId = make_shared<string>(boost::any_cast<string>(m["QosPolicyId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("SourceCidr") != m.end() && !m["SourceCidr"].empty()) {
      sourceCidr = make_shared<string>(boost::any_cast<string>(m["SourceCidr"]));
    }
    if (m.find("DestCidr") != m.end() && !m["DestCidr"].empty()) {
      destCidr = make_shared<string>(boost::any_cast<string>(m["DestCidr"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
    if (m.find("DestPortRange") != m.end() && !m["DestPortRange"].empty()) {
      destPortRange = make_shared<string>(boost::any_cast<string>(m["DestPortRange"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("DpiSignatureIds") != m.end() && !m["DpiSignatureIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DpiSignatureIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DpiSignatureIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dpiSignatureIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DpiGroupIds") != m.end() && !m["DpiGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DpiGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DpiGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dpiGroupIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyQosPolicyRequest() = default;
};
class ModifyQosPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyQosPolicyResponseBody() {}

  explicit ModifyQosPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyQosPolicyResponseBody() = default;
};
class ModifyQosPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyQosPolicyResponseBody> body{};

  ModifyQosPolicyResponse() {}

  explicit ModifyQosPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyQosPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyQosPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyQosPolicyResponse() = default;
};
class ModifySagExpressConnectInterfaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};
  shared_ptr<string> portName{};
  shared_ptr<string> vlan{};
  shared_ptr<string> IP{};
  shared_ptr<string> mask{};

  ModifySagExpressConnectInterfaceRequest() {}

  explicit ModifySagExpressConnectInterfaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    if (portName) {
      res["PortName"] = boost::any(*portName);
    }
    if (vlan) {
      res["Vlan"] = boost::any(*vlan);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (mask) {
      res["Mask"] = boost::any(*mask);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
    if (m.find("PortName") != m.end() && !m["PortName"].empty()) {
      portName = make_shared<string>(boost::any_cast<string>(m["PortName"]));
    }
    if (m.find("Vlan") != m.end() && !m["Vlan"].empty()) {
      vlan = make_shared<string>(boost::any_cast<string>(m["Vlan"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("Mask") != m.end() && !m["Mask"].empty()) {
      mask = make_shared<string>(boost::any_cast<string>(m["Mask"]));
    }
  }


  virtual ~ModifySagExpressConnectInterfaceRequest() = default;
};
class ModifySagExpressConnectInterfaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySagExpressConnectInterfaceResponseBody() {}

  explicit ModifySagExpressConnectInterfaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySagExpressConnectInterfaceResponseBody() = default;
};
class ModifySagExpressConnectInterfaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySagExpressConnectInterfaceResponseBody> body{};

  ModifySagExpressConnectInterfaceResponse() {}

  explicit ModifySagExpressConnectInterfaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySagExpressConnectInterfaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySagExpressConnectInterfaceResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySagExpressConnectInterfaceResponse() = default;
};
class UpdateSmartAGAccessPointRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> accessPointId{};
  shared_ptr<string> smartAGId{};

  UpdateSmartAGAccessPointRequest() {}

  explicit UpdateSmartAGAccessPointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (accessPointId) {
      res["AccessPointId"] = boost::any(*accessPointId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AccessPointId") != m.end() && !m["AccessPointId"].empty()) {
      accessPointId = make_shared<long>(boost::any_cast<long>(m["AccessPointId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
  }


  virtual ~UpdateSmartAGAccessPointRequest() = default;
};
class UpdateSmartAGAccessPointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateSmartAGAccessPointResponseBody() {}

  explicit UpdateSmartAGAccessPointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateSmartAGAccessPointResponseBody() = default;
};
class UpdateSmartAGAccessPointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateSmartAGAccessPointResponseBody> body{};

  UpdateSmartAGAccessPointResponse() {}

  explicit UpdateSmartAGAccessPointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSmartAGAccessPointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSmartAGAccessPointResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSmartAGAccessPointResponse() = default;
};
class BindSerialNumberRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> serialNumber{};

  BindSerialNumberRequest() {}

  explicit BindSerialNumberRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
  }


  virtual ~BindSerialNumberRequest() = default;
};
class BindSerialNumberResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BindSerialNumberResponseBody() {}

  explicit BindSerialNumberResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BindSerialNumberResponseBody() = default;
};
class BindSerialNumberResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BindSerialNumberResponseBody> body{};

  BindSerialNumberResponse() {}

  explicit BindSerialNumberResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindSerialNumberResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindSerialNumberResponseBody>(model1);
      }
    }
  }


  virtual ~BindSerialNumberResponse() = default;
};
class ModifySagRouteProtocolOspfRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};
  shared_ptr<string> routerId{};
  shared_ptr<long> areaId{};
  shared_ptr<long> deadTime{};
  shared_ptr<long> helloTime{};
  shared_ptr<string> authenticationType{};
  shared_ptr<long> md5KeyId{};
  shared_ptr<string> md5Key{};
  shared_ptr<string> password{};

  ModifySagRouteProtocolOspfRequest() {}

  explicit ModifySagRouteProtocolOspfRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    if (routerId) {
      res["RouterId"] = boost::any(*routerId);
    }
    if (areaId) {
      res["AreaId"] = boost::any(*areaId);
    }
    if (deadTime) {
      res["DeadTime"] = boost::any(*deadTime);
    }
    if (helloTime) {
      res["HelloTime"] = boost::any(*helloTime);
    }
    if (authenticationType) {
      res["AuthenticationType"] = boost::any(*authenticationType);
    }
    if (md5KeyId) {
      res["Md5KeyId"] = boost::any(*md5KeyId);
    }
    if (md5Key) {
      res["Md5Key"] = boost::any(*md5Key);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
    if (m.find("RouterId") != m.end() && !m["RouterId"].empty()) {
      routerId = make_shared<string>(boost::any_cast<string>(m["RouterId"]));
    }
    if (m.find("AreaId") != m.end() && !m["AreaId"].empty()) {
      areaId = make_shared<long>(boost::any_cast<long>(m["AreaId"]));
    }
    if (m.find("DeadTime") != m.end() && !m["DeadTime"].empty()) {
      deadTime = make_shared<long>(boost::any_cast<long>(m["DeadTime"]));
    }
    if (m.find("HelloTime") != m.end() && !m["HelloTime"].empty()) {
      helloTime = make_shared<long>(boost::any_cast<long>(m["HelloTime"]));
    }
    if (m.find("AuthenticationType") != m.end() && !m["AuthenticationType"].empty()) {
      authenticationType = make_shared<string>(boost::any_cast<string>(m["AuthenticationType"]));
    }
    if (m.find("Md5KeyId") != m.end() && !m["Md5KeyId"].empty()) {
      md5KeyId = make_shared<long>(boost::any_cast<long>(m["Md5KeyId"]));
    }
    if (m.find("Md5Key") != m.end() && !m["Md5Key"].empty()) {
      md5Key = make_shared<string>(boost::any_cast<string>(m["Md5Key"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
  }


  virtual ~ModifySagRouteProtocolOspfRequest() = default;
};
class ModifySagRouteProtocolOspfResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySagRouteProtocolOspfResponseBody() {}

  explicit ModifySagRouteProtocolOspfResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySagRouteProtocolOspfResponseBody() = default;
};
class ModifySagRouteProtocolOspfResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySagRouteProtocolOspfResponseBody> body{};

  ModifySagRouteProtocolOspfResponse() {}

  explicit ModifySagRouteProtocolOspfResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySagRouteProtocolOspfResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySagRouteProtocolOspfResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySagRouteProtocolOspfResponse() = default;
};
class AddDnatEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sagId{};
  shared_ptr<string> type{};
  shared_ptr<string> externalIp{};
  shared_ptr<string> externalPort{};
  shared_ptr<string> internalIp{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> internalPort{};

  AddDnatEntryRequest() {}

  explicit AddDnatEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sagId) {
      res["SagId"] = boost::any(*sagId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (externalIp) {
      res["ExternalIp"] = boost::any(*externalIp);
    }
    if (externalPort) {
      res["ExternalPort"] = boost::any(*externalPort);
    }
    if (internalIp) {
      res["InternalIp"] = boost::any(*internalIp);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (internalPort) {
      res["InternalPort"] = boost::any(*internalPort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SagId") != m.end() && !m["SagId"].empty()) {
      sagId = make_shared<string>(boost::any_cast<string>(m["SagId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ExternalIp") != m.end() && !m["ExternalIp"].empty()) {
      externalIp = make_shared<string>(boost::any_cast<string>(m["ExternalIp"]));
    }
    if (m.find("ExternalPort") != m.end() && !m["ExternalPort"].empty()) {
      externalPort = make_shared<string>(boost::any_cast<string>(m["ExternalPort"]));
    }
    if (m.find("InternalIp") != m.end() && !m["InternalIp"].empty()) {
      internalIp = make_shared<string>(boost::any_cast<string>(m["InternalIp"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("InternalPort") != m.end() && !m["InternalPort"].empty()) {
      internalPort = make_shared<string>(boost::any_cast<string>(m["InternalPort"]));
    }
  }


  virtual ~AddDnatEntryRequest() = default;
};
class AddDnatEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> dnatEntryId{};

  AddDnatEntryResponseBody() {}

  explicit AddDnatEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (dnatEntryId) {
      res["DnatEntryId"] = boost::any(*dnatEntryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DnatEntryId") != m.end() && !m["DnatEntryId"].empty()) {
      dnatEntryId = make_shared<string>(boost::any_cast<string>(m["DnatEntryId"]));
    }
  }


  virtual ~AddDnatEntryResponseBody() = default;
};
class AddDnatEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddDnatEntryResponseBody> body{};

  AddDnatEntryResponse() {}

  explicit AddDnatEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddDnatEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddDnatEntryResponseBody>(model1);
      }
    }
  }


  virtual ~AddDnatEntryResponse() = default;
};
class DeleteSagCidrRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> cidr{};
  shared_ptr<string> smartAGId{};

  DeleteSagCidrRequest() {}

  explicit DeleteSagCidrRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (cidr) {
      res["Cidr"] = boost::any(*cidr);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Cidr") != m.end() && !m["Cidr"].empty()) {
      cidr = make_shared<string>(boost::any_cast<string>(m["Cidr"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
  }


  virtual ~DeleteSagCidrRequest() = default;
};
class DeleteSagCidrResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSagCidrResponseBody() {}

  explicit DeleteSagCidrResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSagCidrResponseBody() = default;
};
class DeleteSagCidrResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteSagCidrResponseBody> body{};

  DeleteSagCidrResponse() {}

  explicit DeleteSagCidrResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSagCidrResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSagCidrResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSagCidrResponse() = default;
};
class DescribeSagRouteProtocolOspfRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};

  DescribeSagRouteProtocolOspfRequest() {}

  explicit DescribeSagRouteProtocolOspfRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
  }


  virtual ~DescribeSagRouteProtocolOspfRequest() = default;
};
class DescribeSagRouteProtocolOspfResponseBodyTaskStates : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> state{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> createTime{};

  DescribeSagRouteProtocolOspfResponseBodyTaskStates() {}

  explicit DescribeSagRouteProtocolOspfResponseBodyTaskStates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
  }


  virtual ~DescribeSagRouteProtocolOspfResponseBodyTaskStates() = default;
};
class DescribeSagRouteProtocolOspfResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> deadTime{};
  shared_ptr<long> md5KeyId{};
  shared_ptr<string> areaId{};
  shared_ptr<string> routerId{};
  shared_ptr<long> helloTime{};
  shared_ptr<string> areaType{};
  shared_ptr<vector<DescribeSagRouteProtocolOspfResponseBodyTaskStates>> taskStates{};
  shared_ptr<string> md5Key{};
  shared_ptr<string> authenticationType{};

  DescribeSagRouteProtocolOspfResponseBody() {}

  explicit DescribeSagRouteProtocolOspfResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (deadTime) {
      res["DeadTime"] = boost::any(*deadTime);
    }
    if (md5KeyId) {
      res["Md5KeyId"] = boost::any(*md5KeyId);
    }
    if (areaId) {
      res["AreaId"] = boost::any(*areaId);
    }
    if (routerId) {
      res["RouterId"] = boost::any(*routerId);
    }
    if (helloTime) {
      res["HelloTime"] = boost::any(*helloTime);
    }
    if (areaType) {
      res["AreaType"] = boost::any(*areaType);
    }
    if (taskStates) {
      vector<boost::any> temp1;
      for(auto item1:*taskStates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskStates"] = boost::any(temp1);
    }
    if (md5Key) {
      res["Md5Key"] = boost::any(*md5Key);
    }
    if (authenticationType) {
      res["AuthenticationType"] = boost::any(*authenticationType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DeadTime") != m.end() && !m["DeadTime"].empty()) {
      deadTime = make_shared<long>(boost::any_cast<long>(m["DeadTime"]));
    }
    if (m.find("Md5KeyId") != m.end() && !m["Md5KeyId"].empty()) {
      md5KeyId = make_shared<long>(boost::any_cast<long>(m["Md5KeyId"]));
    }
    if (m.find("AreaId") != m.end() && !m["AreaId"].empty()) {
      areaId = make_shared<string>(boost::any_cast<string>(m["AreaId"]));
    }
    if (m.find("RouterId") != m.end() && !m["RouterId"].empty()) {
      routerId = make_shared<string>(boost::any_cast<string>(m["RouterId"]));
    }
    if (m.find("HelloTime") != m.end() && !m["HelloTime"].empty()) {
      helloTime = make_shared<long>(boost::any_cast<long>(m["HelloTime"]));
    }
    if (m.find("AreaType") != m.end() && !m["AreaType"].empty()) {
      areaType = make_shared<string>(boost::any_cast<string>(m["AreaType"]));
    }
    if (m.find("TaskStates") != m.end() && !m["TaskStates"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskStates"].type()) {
        vector<DescribeSagRouteProtocolOspfResponseBodyTaskStates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskStates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSagRouteProtocolOspfResponseBodyTaskStates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskStates = make_shared<vector<DescribeSagRouteProtocolOspfResponseBodyTaskStates>>(expect1);
      }
    }
    if (m.find("Md5Key") != m.end() && !m["Md5Key"].empty()) {
      md5Key = make_shared<string>(boost::any_cast<string>(m["Md5Key"]));
    }
    if (m.find("AuthenticationType") != m.end() && !m["AuthenticationType"].empty()) {
      authenticationType = make_shared<string>(boost::any_cast<string>(m["AuthenticationType"]));
    }
  }


  virtual ~DescribeSagRouteProtocolOspfResponseBody() = default;
};
class DescribeSagRouteProtocolOspfResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSagRouteProtocolOspfResponseBody> body{};

  DescribeSagRouteProtocolOspfResponse() {}

  explicit DescribeSagRouteProtocolOspfResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSagRouteProtocolOspfResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSagRouteProtocolOspfResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSagRouteProtocolOspfResponse() = default;
};
class DescribeRouteDistributionStrategiesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> sourceType{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeRouteDistributionStrategiesRequest() {}

  explicit DescribeRouteDistributionStrategiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeRouteDistributionStrategiesRequest() = default;
};
class DescribeRouteDistributionStrategiesResponseBodyStrategiesStrategy : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> strategyPublishStatus{};
  shared_ptr<string> routeDistribution{};
  shared_ptr<long> createTime{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> sourceType{};
  shared_ptr<bool> isConflict{};
  shared_ptr<string> destCidrBlock{};
  shared_ptr<string> conflictInfo{};
  shared_ptr<string> hcInstanceId{};
  shared_ptr<string> routeSource{};

  DescribeRouteDistributionStrategiesResponseBodyStrategiesStrategy() {}

  explicit DescribeRouteDistributionStrategiesResponseBodyStrategiesStrategy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (strategyPublishStatus) {
      res["StrategyPublishStatus"] = boost::any(*strategyPublishStatus);
    }
    if (routeDistribution) {
      res["RouteDistribution"] = boost::any(*routeDistribution);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (isConflict) {
      res["IsConflict"] = boost::any(*isConflict);
    }
    if (destCidrBlock) {
      res["DestCidrBlock"] = boost::any(*destCidrBlock);
    }
    if (conflictInfo) {
      res["ConflictInfo"] = boost::any(*conflictInfo);
    }
    if (hcInstanceId) {
      res["HcInstanceId"] = boost::any(*hcInstanceId);
    }
    if (routeSource) {
      res["RouteSource"] = boost::any(*routeSource);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("StrategyPublishStatus") != m.end() && !m["StrategyPublishStatus"].empty()) {
      strategyPublishStatus = make_shared<string>(boost::any_cast<string>(m["StrategyPublishStatus"]));
    }
    if (m.find("RouteDistribution") != m.end() && !m["RouteDistribution"].empty()) {
      routeDistribution = make_shared<string>(boost::any_cast<string>(m["RouteDistribution"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("IsConflict") != m.end() && !m["IsConflict"].empty()) {
      isConflict = make_shared<bool>(boost::any_cast<bool>(m["IsConflict"]));
    }
    if (m.find("DestCidrBlock") != m.end() && !m["DestCidrBlock"].empty()) {
      destCidrBlock = make_shared<string>(boost::any_cast<string>(m["DestCidrBlock"]));
    }
    if (m.find("ConflictInfo") != m.end() && !m["ConflictInfo"].empty()) {
      conflictInfo = make_shared<string>(boost::any_cast<string>(m["ConflictInfo"]));
    }
    if (m.find("HcInstanceId") != m.end() && !m["HcInstanceId"].empty()) {
      hcInstanceId = make_shared<string>(boost::any_cast<string>(m["HcInstanceId"]));
    }
    if (m.find("RouteSource") != m.end() && !m["RouteSource"].empty()) {
      routeSource = make_shared<string>(boost::any_cast<string>(m["RouteSource"]));
    }
  }


  virtual ~DescribeRouteDistributionStrategiesResponseBodyStrategiesStrategy() = default;
};
class DescribeRouteDistributionStrategiesResponseBodyStrategies : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRouteDistributionStrategiesResponseBodyStrategiesStrategy>> strategy{};

  DescribeRouteDistributionStrategiesResponseBodyStrategies() {}

  explicit DescribeRouteDistributionStrategiesResponseBodyStrategies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (strategy) {
      vector<boost::any> temp1;
      for(auto item1:*strategy){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Strategy"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Strategy") != m.end() && !m["Strategy"].empty()) {
      if (typeid(vector<boost::any>) == m["Strategy"].type()) {
        vector<DescribeRouteDistributionStrategiesResponseBodyStrategiesStrategy> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Strategy"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRouteDistributionStrategiesResponseBodyStrategiesStrategy model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        strategy = make_shared<vector<DescribeRouteDistributionStrategiesResponseBodyStrategiesStrategy>>(expect1);
      }
    }
  }


  virtual ~DescribeRouteDistributionStrategiesResponseBodyStrategies() = default;
};
class DescribeRouteDistributionStrategiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<DescribeRouteDistributionStrategiesResponseBodyStrategies> strategies{};

  DescribeRouteDistributionStrategiesResponseBody() {}

  explicit DescribeRouteDistributionStrategiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (strategies) {
      res["Strategies"] = strategies ? boost::any(strategies->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("Strategies") != m.end() && !m["Strategies"].empty()) {
      if (typeid(map<string, boost::any>) == m["Strategies"].type()) {
        DescribeRouteDistributionStrategiesResponseBodyStrategies model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Strategies"]));
        strategies = make_shared<DescribeRouteDistributionStrategiesResponseBodyStrategies>(model1);
      }
    }
  }


  virtual ~DescribeRouteDistributionStrategiesResponseBody() = default;
};
class DescribeRouteDistributionStrategiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeRouteDistributionStrategiesResponseBody> body{};

  DescribeRouteDistributionStrategiesResponse() {}

  explicit DescribeRouteDistributionStrategiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRouteDistributionStrategiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRouteDistributionStrategiesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRouteDistributionStrategiesResponse() = default;
};
class DescribeSagHaRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};

  DescribeSagHaRequest() {}

  explicit DescribeSagHaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
  }


  virtual ~DescribeSagHaRequest() = default;
};
class DescribeSagHaResponseBodyPorts : public Darabonba::Model {
public:
  shared_ptr<string> portName{};
  shared_ptr<string> virtualIp{};

  DescribeSagHaResponseBodyPorts() {}

  explicit DescribeSagHaResponseBodyPorts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (portName) {
      res["PortName"] = boost::any(*portName);
    }
    if (virtualIp) {
      res["VirtualIp"] = boost::any(*virtualIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("PortName") != m.end() && !m["PortName"].empty()) {
      portName = make_shared<string>(boost::any_cast<string>(m["PortName"]));
    }
    if (m.find("VirtualIp") != m.end() && !m["VirtualIp"].empty()) {
      virtualIp = make_shared<string>(boost::any_cast<string>(m["VirtualIp"]));
    }
  }


  virtual ~DescribeSagHaResponseBodyPorts() = default;
};
class DescribeSagHaResponseBodyTaskStates : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> state{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> createTime{};

  DescribeSagHaResponseBodyTaskStates() {}

  explicit DescribeSagHaResponseBodyTaskStates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
  }


  virtual ~DescribeSagHaResponseBodyTaskStates() = default;
};
class DescribeSagHaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> mode{};
  shared_ptr<vector<DescribeSagHaResponseBodyPorts>> ports{};
  shared_ptr<vector<DescribeSagHaResponseBodyTaskStates>> taskStates{};

  DescribeSagHaResponseBody() {}

  explicit DescribeSagHaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (ports) {
      vector<boost::any> temp1;
      for(auto item1:*ports){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ports"] = boost::any(temp1);
    }
    if (taskStates) {
      vector<boost::any> temp1;
      for(auto item1:*taskStates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskStates"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("Ports") != m.end() && !m["Ports"].empty()) {
      if (typeid(vector<boost::any>) == m["Ports"].type()) {
        vector<DescribeSagHaResponseBodyPorts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ports"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSagHaResponseBodyPorts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ports = make_shared<vector<DescribeSagHaResponseBodyPorts>>(expect1);
      }
    }
    if (m.find("TaskStates") != m.end() && !m["TaskStates"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskStates"].type()) {
        vector<DescribeSagHaResponseBodyTaskStates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskStates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSagHaResponseBodyTaskStates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskStates = make_shared<vector<DescribeSagHaResponseBodyTaskStates>>(expect1);
      }
    }
  }


  virtual ~DescribeSagHaResponseBody() = default;
};
class DescribeSagHaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSagHaResponseBody> body{};

  DescribeSagHaResponse() {}

  explicit DescribeSagHaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSagHaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSagHaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSagHaResponse() = default;
};
class AddACLRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> aclId{};
  shared_ptr<string> description{};
  shared_ptr<string> direction{};
  shared_ptr<string> sourceCidr{};
  shared_ptr<string> destCidr{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> sourcePortRange{};
  shared_ptr<string> destPortRange{};
  shared_ptr<string> policy{};
  shared_ptr<long> priority{};
  shared_ptr<string> type{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> dpiSignatureIds{};
  shared_ptr<vector<string>> dpiGroupIds{};

  AddACLRuleRequest() {}

  explicit AddACLRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (sourceCidr) {
      res["SourceCidr"] = boost::any(*sourceCidr);
    }
    if (destCidr) {
      res["DestCidr"] = boost::any(*destCidr);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    if (destPortRange) {
      res["DestPortRange"] = boost::any(*destPortRange);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (dpiSignatureIds) {
      res["DpiSignatureIds"] = boost::any(*dpiSignatureIds);
    }
    if (dpiGroupIds) {
      res["DpiGroupIds"] = boost::any(*dpiGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("SourceCidr") != m.end() && !m["SourceCidr"].empty()) {
      sourceCidr = make_shared<string>(boost::any_cast<string>(m["SourceCidr"]));
    }
    if (m.find("DestCidr") != m.end() && !m["DestCidr"].empty()) {
      destCidr = make_shared<string>(boost::any_cast<string>(m["DestCidr"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
    if (m.find("DestPortRange") != m.end() && !m["DestPortRange"].empty()) {
      destPortRange = make_shared<string>(boost::any_cast<string>(m["DestPortRange"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("DpiSignatureIds") != m.end() && !m["DpiSignatureIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DpiSignatureIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DpiSignatureIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dpiSignatureIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DpiGroupIds") != m.end() && !m["DpiGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DpiGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DpiGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dpiGroupIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AddACLRuleRequest() = default;
};
class AddACLRuleResponseBodyDpiGroupIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dpiGroupId{};

  AddACLRuleResponseBodyDpiGroupIds() {}

  explicit AddACLRuleResponseBodyDpiGroupIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dpiGroupId) {
      res["DpiGroupId"] = boost::any(*dpiGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DpiGroupId") != m.end() && !m["DpiGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DpiGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DpiGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dpiGroupId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AddACLRuleResponseBodyDpiGroupIds() = default;
};
class AddACLRuleResponseBodyDpiSignatureIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dpiSignatureId{};

  AddACLRuleResponseBodyDpiSignatureIds() {}

  explicit AddACLRuleResponseBodyDpiSignatureIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dpiSignatureId) {
      res["DpiSignatureId"] = boost::any(*dpiSignatureId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DpiSignatureId") != m.end() && !m["DpiSignatureId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DpiSignatureId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DpiSignatureId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dpiSignatureId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~AddACLRuleResponseBodyDpiSignatureIds() = default;
};
class AddACLRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> policy{};
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sourcePortRange{};
  shared_ptr<string> sourceCidr{};
  shared_ptr<long> priority{};
  shared_ptr<string> aclId{};
  shared_ptr<string> acrId{};
  shared_ptr<string> destPortRange{};
  shared_ptr<string> direction{};
  shared_ptr<AddACLRuleResponseBodyDpiGroupIds> dpiGroupIds{};
  shared_ptr<string> name{};
  shared_ptr<string> type{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> destCidr{};
  shared_ptr<AddACLRuleResponseBodyDpiSignatureIds> dpiSignatureIds{};
  shared_ptr<string> ipProtocol{};

  AddACLRuleResponseBody() {}

  explicit AddACLRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    if (sourceCidr) {
      res["SourceCidr"] = boost::any(*sourceCidr);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (acrId) {
      res["AcrId"] = boost::any(*acrId);
    }
    if (destPortRange) {
      res["DestPortRange"] = boost::any(*destPortRange);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (dpiGroupIds) {
      res["DpiGroupIds"] = dpiGroupIds ? boost::any(dpiGroupIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (destCidr) {
      res["DestCidr"] = boost::any(*destCidr);
    }
    if (dpiSignatureIds) {
      res["DpiSignatureIds"] = dpiSignatureIds ? boost::any(dpiSignatureIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
    if (m.find("SourceCidr") != m.end() && !m["SourceCidr"].empty()) {
      sourceCidr = make_shared<string>(boost::any_cast<string>(m["SourceCidr"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("AcrId") != m.end() && !m["AcrId"].empty()) {
      acrId = make_shared<string>(boost::any_cast<string>(m["AcrId"]));
    }
    if (m.find("DestPortRange") != m.end() && !m["DestPortRange"].empty()) {
      destPortRange = make_shared<string>(boost::any_cast<string>(m["DestPortRange"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("DpiGroupIds") != m.end() && !m["DpiGroupIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["DpiGroupIds"].type()) {
        AddACLRuleResponseBodyDpiGroupIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DpiGroupIds"]));
        dpiGroupIds = make_shared<AddACLRuleResponseBodyDpiGroupIds>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("DestCidr") != m.end() && !m["DestCidr"].empty()) {
      destCidr = make_shared<string>(boost::any_cast<string>(m["DestCidr"]));
    }
    if (m.find("DpiSignatureIds") != m.end() && !m["DpiSignatureIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["DpiSignatureIds"].type()) {
        AddACLRuleResponseBodyDpiSignatureIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DpiSignatureIds"]));
        dpiSignatureIds = make_shared<AddACLRuleResponseBodyDpiSignatureIds>(model1);
      }
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
  }


  virtual ~AddACLRuleResponseBody() = default;
};
class AddACLRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddACLRuleResponseBody> body{};

  AddACLRuleResponse() {}

  explicit AddACLRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddACLRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddACLRuleResponseBody>(model1);
      }
    }
  }


  virtual ~AddACLRuleResponse() = default;
};
class AssociateFlowLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> flowLogId{};
  shared_ptr<string> smartAGId{};

  AssociateFlowLogRequest() {}

  explicit AssociateFlowLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (flowLogId) {
      res["FlowLogId"] = boost::any(*flowLogId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("FlowLogId") != m.end() && !m["FlowLogId"].empty()) {
      flowLogId = make_shared<string>(boost::any_cast<string>(m["FlowLogId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
  }


  virtual ~AssociateFlowLogRequest() = default;
};
class AssociateFlowLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AssociateFlowLogResponseBody() {}

  explicit AssociateFlowLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AssociateFlowLogResponseBody() = default;
};
class AssociateFlowLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AssociateFlowLogResponseBody> body{};

  AssociateFlowLogResponse() {}

  explicit AssociateFlowLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssociateFlowLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssociateFlowLogResponseBody>(model1);
      }
    }
  }


  virtual ~AssociateFlowLogResponse() = default;
};
class BindSmartAccessGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ccnId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> smartAGUid{};

  BindSmartAccessGatewayRequest() {}

  explicit BindSmartAccessGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ccnId) {
      res["CcnId"] = boost::any(*ccnId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGUid) {
      res["SmartAGUid"] = boost::any(*smartAGUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("CcnId") != m.end() && !m["CcnId"].empty()) {
      ccnId = make_shared<string>(boost::any_cast<string>(m["CcnId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGUid") != m.end() && !m["SmartAGUid"].empty()) {
      smartAGUid = make_shared<long>(boost::any_cast<long>(m["SmartAGUid"]));
    }
  }


  virtual ~BindSmartAccessGatewayRequest() = default;
};
class BindSmartAccessGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BindSmartAccessGatewayResponseBody() {}

  explicit BindSmartAccessGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BindSmartAccessGatewayResponseBody() = default;
};
class BindSmartAccessGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BindSmartAccessGatewayResponseBody> body{};

  BindSmartAccessGatewayResponse() {}

  explicit BindSmartAccessGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindSmartAccessGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindSmartAccessGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~BindSmartAccessGatewayResponse() = default;
};
class DisassociateACLRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> aclId{};
  shared_ptr<string> smartAGId{};

  DisassociateACLRequest() {}

  explicit DisassociateACLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
  }


  virtual ~DisassociateACLRequest() = default;
};
class DisassociateACLResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisassociateACLResponseBody() {}

  explicit DisassociateACLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisassociateACLResponseBody() = default;
};
class DisassociateACLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DisassociateACLResponseBody> body{};

  DisassociateACLResponse() {}

  explicit DisassociateACLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisassociateACLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisassociateACLResponseBody>(model1);
      }
    }
  }


  virtual ~DisassociateACLResponse() = default;
};
class DeactiveFlowLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> flowLogId{};

  DeactiveFlowLogRequest() {}

  explicit DeactiveFlowLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (flowLogId) {
      res["FlowLogId"] = boost::any(*flowLogId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("FlowLogId") != m.end() && !m["FlowLogId"].empty()) {
      flowLogId = make_shared<string>(boost::any_cast<string>(m["FlowLogId"]));
    }
  }


  virtual ~DeactiveFlowLogRequest() = default;
};
class DeactiveFlowLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeactiveFlowLogResponseBody() {}

  explicit DeactiveFlowLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeactiveFlowLogResponseBody() = default;
};
class DeactiveFlowLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeactiveFlowLogResponseBody> body{};

  DeactiveFlowLogResponse() {}

  explicit DeactiveFlowLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeactiveFlowLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeactiveFlowLogResponseBody>(model1);
      }
    }
  }


  virtual ~DeactiveFlowLogResponse() = default;
};
class ActiveFlowLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> flowLogId{};

  ActiveFlowLogRequest() {}

  explicit ActiveFlowLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (flowLogId) {
      res["FlowLogId"] = boost::any(*flowLogId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("FlowLogId") != m.end() && !m["FlowLogId"].empty()) {
      flowLogId = make_shared<string>(boost::any_cast<string>(m["FlowLogId"]));
    }
  }


  virtual ~ActiveFlowLogRequest() = default;
};
class ActiveFlowLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ActiveFlowLogResponseBody() {}

  explicit ActiveFlowLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ActiveFlowLogResponseBody() = default;
};
class ActiveFlowLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ActiveFlowLogResponseBody> body{};

  ActiveFlowLogResponse() {}

  explicit ActiveFlowLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ActiveFlowLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ActiveFlowLogResponseBody>(model1);
      }
    }
  }


  virtual ~ActiveFlowLogResponse() = default;
};
class KickOutClientsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> username{};

  KickOutClientsRequest() {}

  explicit KickOutClientsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~KickOutClientsRequest() = default;
};
class KickOutClientsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  KickOutClientsResponseBody() {}

  explicit KickOutClientsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~KickOutClientsResponseBody() = default;
};
class KickOutClientsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<KickOutClientsResponseBody> body{};

  KickOutClientsResponse() {}

  explicit KickOutClientsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        KickOutClientsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<KickOutClientsResponseBody>(model1);
      }
    }
  }


  virtual ~KickOutClientsResponse() = default;
};
class ModifySagPortRoleRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};
  shared_ptr<string> portName{};
  shared_ptr<string> role{};

  ModifySagPortRoleRequest() {}

  explicit ModifySagPortRoleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    if (portName) {
      res["PortName"] = boost::any(*portName);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
    if (m.find("PortName") != m.end() && !m["PortName"].empty()) {
      portName = make_shared<string>(boost::any_cast<string>(m["PortName"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
  }


  virtual ~ModifySagPortRoleRequest() = default;
};
class ModifySagPortRoleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySagPortRoleResponseBody() {}

  explicit ModifySagPortRoleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySagPortRoleResponseBody() = default;
};
class ModifySagPortRoleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySagPortRoleResponseBody> body{};

  ModifySagPortRoleResponse() {}

  explicit ModifySagPortRoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySagPortRoleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySagPortRoleResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySagPortRoleResponse() = default;
};
class ModifySagWanSnatRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};
  shared_ptr<string> snat{};

  ModifySagWanSnatRequest() {}

  explicit ModifySagWanSnatRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    if (snat) {
      res["Snat"] = boost::any(*snat);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
    if (m.find("Snat") != m.end() && !m["Snat"].empty()) {
      snat = make_shared<string>(boost::any_cast<string>(m["Snat"]));
    }
  }


  virtual ~ModifySagWanSnatRequest() = default;
};
class ModifySagWanSnatResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySagWanSnatResponseBody() {}

  explicit ModifySagWanSnatResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySagWanSnatResponseBody() = default;
};
class ModifySagWanSnatResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySagWanSnatResponseBody> body{};

  ModifySagWanSnatResponse() {}

  explicit ModifySagWanSnatResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySagWanSnatResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySagWanSnatResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySagWanSnatResponse() = default;
};
class ListDpiConfigErrorRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> dpiConfigType{};
  shared_ptr<string> ruleInstanceId{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> maxResults{};

  ListDpiConfigErrorRequest() {}

  explicit ListDpiConfigErrorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (dpiConfigType) {
      res["DpiConfigType"] = boost::any(*dpiConfigType);
    }
    if (ruleInstanceId) {
      res["RuleInstanceId"] = boost::any(*ruleInstanceId);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("DpiConfigType") != m.end() && !m["DpiConfigType"].empty()) {
      dpiConfigType = make_shared<string>(boost::any_cast<string>(m["DpiConfigType"]));
    }
    if (m.find("RuleInstanceId") != m.end() && !m["RuleInstanceId"].empty()) {
      ruleInstanceId = make_shared<string>(boost::any_cast<string>(m["RuleInstanceId"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
  }


  virtual ~ListDpiConfigErrorRequest() = default;
};
class ListDpiConfigErrorResponseBodyDpiConfigErrorRuleConfigErrorList : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dpiSignatureIds{};
  shared_ptr<string> ruleId{};
  shared_ptr<vector<string>> dpiGroupIds{};

  ListDpiConfigErrorResponseBodyDpiConfigErrorRuleConfigErrorList() {}

  explicit ListDpiConfigErrorResponseBodyDpiConfigErrorRuleConfigErrorList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dpiSignatureIds) {
      res["DpiSignatureIds"] = boost::any(*dpiSignatureIds);
    }
    if (ruleId) {
      res["RuleId"] = boost::any(*ruleId);
    }
    if (dpiGroupIds) {
      res["DpiGroupIds"] = boost::any(*dpiGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DpiSignatureIds") != m.end() && !m["DpiSignatureIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DpiSignatureIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DpiSignatureIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dpiSignatureIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RuleId") != m.end() && !m["RuleId"].empty()) {
      ruleId = make_shared<string>(boost::any_cast<string>(m["RuleId"]));
    }
    if (m.find("DpiGroupIds") != m.end() && !m["DpiGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DpiGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DpiGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dpiGroupIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDpiConfigErrorResponseBodyDpiConfigErrorRuleConfigErrorList() = default;
};
class ListDpiConfigErrorResponseBodyDpiConfigError : public Darabonba::Model {
public:
  shared_ptr<string> SN{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> errorType{};
  shared_ptr<vector<ListDpiConfigErrorResponseBodyDpiConfigErrorRuleConfigErrorList>> ruleConfigErrorList{};

  ListDpiConfigErrorResponseBodyDpiConfigError() {}

  explicit ListDpiConfigErrorResponseBodyDpiConfigError(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (SN) {
      res["SN"] = boost::any(*SN);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (errorType) {
      res["ErrorType"] = boost::any(*errorType);
    }
    if (ruleConfigErrorList) {
      vector<boost::any> temp1;
      for(auto item1:*ruleConfigErrorList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RuleConfigErrorList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SN") != m.end() && !m["SN"].empty()) {
      SN = make_shared<string>(boost::any_cast<string>(m["SN"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("ErrorType") != m.end() && !m["ErrorType"].empty()) {
      errorType = make_shared<string>(boost::any_cast<string>(m["ErrorType"]));
    }
    if (m.find("RuleConfigErrorList") != m.end() && !m["RuleConfigErrorList"].empty()) {
      if (typeid(vector<boost::any>) == m["RuleConfigErrorList"].type()) {
        vector<ListDpiConfigErrorResponseBodyDpiConfigErrorRuleConfigErrorList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RuleConfigErrorList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDpiConfigErrorResponseBodyDpiConfigErrorRuleConfigErrorList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ruleConfigErrorList = make_shared<vector<ListDpiConfigErrorResponseBodyDpiConfigErrorRuleConfigErrorList>>(expect1);
      }
    }
  }


  virtual ~ListDpiConfigErrorResponseBodyDpiConfigError() = default;
};
class ListDpiConfigErrorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> total{};
  shared_ptr<long> maxResults{};
  shared_ptr<vector<ListDpiConfigErrorResponseBodyDpiConfigError>> dpiConfigError{};

  ListDpiConfigErrorResponseBody() {}

  explicit ListDpiConfigErrorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (total) {
      res["Total"] = boost::any(*total);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (dpiConfigError) {
      vector<boost::any> temp1;
      for(auto item1:*dpiConfigError){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DpiConfigError"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Total") != m.end() && !m["Total"].empty()) {
      total = make_shared<long>(boost::any_cast<long>(m["Total"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("DpiConfigError") != m.end() && !m["DpiConfigError"].empty()) {
      if (typeid(vector<boost::any>) == m["DpiConfigError"].type()) {
        vector<ListDpiConfigErrorResponseBodyDpiConfigError> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DpiConfigError"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDpiConfigErrorResponseBodyDpiConfigError model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dpiConfigError = make_shared<vector<ListDpiConfigErrorResponseBodyDpiConfigError>>(expect1);
      }
    }
  }


  virtual ~ListDpiConfigErrorResponseBody() = default;
};
class ListDpiConfigErrorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListDpiConfigErrorResponseBody> body{};

  ListDpiConfigErrorResponse() {}

  explicit ListDpiConfigErrorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDpiConfigErrorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDpiConfigErrorResponseBody>(model1);
      }
    }
  }


  virtual ~ListDpiConfigErrorResponse() = default;
};
class DeleteACLRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> aclId{};

  DeleteACLRequest() {}

  explicit DeleteACLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
  }


  virtual ~DeleteACLRequest() = default;
};
class DeleteACLResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteACLResponseBody() {}

  explicit DeleteACLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteACLResponseBody() = default;
};
class DeleteACLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteACLResponseBody> body{};

  DeleteACLResponse() {}

  explicit DeleteACLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteACLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteACLResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteACLResponse() = default;
};
class UpdateSmartAGEnterpriseCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> enterpriseCode{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> clientToken{};

  UpdateSmartAGEnterpriseCodeRequest() {}

  explicit UpdateSmartAGEnterpriseCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (enterpriseCode) {
      res["EnterpriseCode"] = boost::any(*enterpriseCode);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("EnterpriseCode") != m.end() && !m["EnterpriseCode"].empty()) {
      enterpriseCode = make_shared<string>(boost::any_cast<string>(m["EnterpriseCode"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~UpdateSmartAGEnterpriseCodeRequest() = default;
};
class UpdateSmartAGEnterpriseCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateSmartAGEnterpriseCodeResponseBody() {}

  explicit UpdateSmartAGEnterpriseCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateSmartAGEnterpriseCodeResponseBody() = default;
};
class UpdateSmartAGEnterpriseCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateSmartAGEnterpriseCodeResponseBody> body{};

  UpdateSmartAGEnterpriseCodeResponse() {}

  explicit UpdateSmartAGEnterpriseCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSmartAGEnterpriseCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSmartAGEnterpriseCodeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSmartAGEnterpriseCodeResponse() = default;
};
class AssociateACLRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> aclId{};
  shared_ptr<string> smartAGId{};

  AssociateACLRequest() {}

  explicit AssociateACLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
  }


  virtual ~AssociateACLRequest() = default;
};
class AssociateACLResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AssociateACLResponseBody() {}

  explicit AssociateACLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AssociateACLResponseBody() = default;
};
class AssociateACLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AssociateACLResponseBody> body{};

  AssociateACLResponse() {}

  explicit AssociateACLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AssociateACLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AssociateACLResponseBody>(model1);
      }
    }
  }


  virtual ~AssociateACLResponse() = default;
};
class ModifyHealthCheckRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> hcInstanceId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> type{};
  shared_ptr<string> dstIpAddr{};
  shared_ptr<long> dstPort{};
  shared_ptr<string> srcIpAddr{};
  shared_ptr<long> srcPort{};
  shared_ptr<long> probeInterval{};
  shared_ptr<long> probeCount{};
  shared_ptr<long> probeTimeout{};
  shared_ptr<long> rttThreshold{};
  shared_ptr<long> rttFailThreshold{};
  shared_ptr<long> failCountThreshold{};

  ModifyHealthCheckRequest() {}

  explicit ModifyHealthCheckRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (hcInstanceId) {
      res["HcInstanceId"] = boost::any(*hcInstanceId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (dstIpAddr) {
      res["DstIpAddr"] = boost::any(*dstIpAddr);
    }
    if (dstPort) {
      res["DstPort"] = boost::any(*dstPort);
    }
    if (srcIpAddr) {
      res["SrcIpAddr"] = boost::any(*srcIpAddr);
    }
    if (srcPort) {
      res["SrcPort"] = boost::any(*srcPort);
    }
    if (probeInterval) {
      res["ProbeInterval"] = boost::any(*probeInterval);
    }
    if (probeCount) {
      res["ProbeCount"] = boost::any(*probeCount);
    }
    if (probeTimeout) {
      res["ProbeTimeout"] = boost::any(*probeTimeout);
    }
    if (rttThreshold) {
      res["RttThreshold"] = boost::any(*rttThreshold);
    }
    if (rttFailThreshold) {
      res["RttFailThreshold"] = boost::any(*rttFailThreshold);
    }
    if (failCountThreshold) {
      res["FailCountThreshold"] = boost::any(*failCountThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("HcInstanceId") != m.end() && !m["HcInstanceId"].empty()) {
      hcInstanceId = make_shared<string>(boost::any_cast<string>(m["HcInstanceId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("DstIpAddr") != m.end() && !m["DstIpAddr"].empty()) {
      dstIpAddr = make_shared<string>(boost::any_cast<string>(m["DstIpAddr"]));
    }
    if (m.find("DstPort") != m.end() && !m["DstPort"].empty()) {
      dstPort = make_shared<long>(boost::any_cast<long>(m["DstPort"]));
    }
    if (m.find("SrcIpAddr") != m.end() && !m["SrcIpAddr"].empty()) {
      srcIpAddr = make_shared<string>(boost::any_cast<string>(m["SrcIpAddr"]));
    }
    if (m.find("SrcPort") != m.end() && !m["SrcPort"].empty()) {
      srcPort = make_shared<long>(boost::any_cast<long>(m["SrcPort"]));
    }
    if (m.find("ProbeInterval") != m.end() && !m["ProbeInterval"].empty()) {
      probeInterval = make_shared<long>(boost::any_cast<long>(m["ProbeInterval"]));
    }
    if (m.find("ProbeCount") != m.end() && !m["ProbeCount"].empty()) {
      probeCount = make_shared<long>(boost::any_cast<long>(m["ProbeCount"]));
    }
    if (m.find("ProbeTimeout") != m.end() && !m["ProbeTimeout"].empty()) {
      probeTimeout = make_shared<long>(boost::any_cast<long>(m["ProbeTimeout"]));
    }
    if (m.find("RttThreshold") != m.end() && !m["RttThreshold"].empty()) {
      rttThreshold = make_shared<long>(boost::any_cast<long>(m["RttThreshold"]));
    }
    if (m.find("RttFailThreshold") != m.end() && !m["RttFailThreshold"].empty()) {
      rttFailThreshold = make_shared<long>(boost::any_cast<long>(m["RttFailThreshold"]));
    }
    if (m.find("FailCountThreshold") != m.end() && !m["FailCountThreshold"].empty()) {
      failCountThreshold = make_shared<long>(boost::any_cast<long>(m["FailCountThreshold"]));
    }
  }


  virtual ~ModifyHealthCheckRequest() = default;
};
class ModifyHealthCheckResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyHealthCheckResponseBody() {}

  explicit ModifyHealthCheckResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyHealthCheckResponseBody() = default;
};
class ModifyHealthCheckResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyHealthCheckResponseBody> body{};

  ModifyHealthCheckResponse() {}

  explicit ModifyHealthCheckResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyHealthCheckResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyHealthCheckResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyHealthCheckResponse() = default;
};
class CreateEnterpriseCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> enterpriseCode{};
  shared_ptr<string> clientToken{};

  CreateEnterpriseCodeRequest() {}

  explicit CreateEnterpriseCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (enterpriseCode) {
      res["EnterpriseCode"] = boost::any(*enterpriseCode);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("EnterpriseCode") != m.end() && !m["EnterpriseCode"].empty()) {
      enterpriseCode = make_shared<string>(boost::any_cast<string>(m["EnterpriseCode"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~CreateEnterpriseCodeRequest() = default;
};
class CreateEnterpriseCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateEnterpriseCodeResponseBody() {}

  explicit CreateEnterpriseCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateEnterpriseCodeResponseBody() = default;
};
class CreateEnterpriseCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateEnterpriseCodeResponseBody> body{};

  CreateEnterpriseCodeResponse() {}

  explicit CreateEnterpriseCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateEnterpriseCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateEnterpriseCodeResponseBody>(model1);
      }
    }
  }


  virtual ~CreateEnterpriseCodeResponse() = default;
};
class DescribeACLsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> aclIds{};
  shared_ptr<string> name{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};

  DescribeACLsRequest() {}

  explicit DescribeACLsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (aclIds) {
      res["AclIds"] = boost::any(*aclIds);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AclIds") != m.end() && !m["AclIds"].empty()) {
      aclIds = make_shared<string>(boost::any_cast<string>(m["AclIds"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~DescribeACLsRequest() = default;
};
class DescribeACLsResponseBodyAclsAcl : public Darabonba::Model {
public:
  shared_ptr<string> sagCount{};
  shared_ptr<string> aclId{};
  shared_ptr<string> name{};
  shared_ptr<string> resourceGroupId{};

  DescribeACLsResponseBodyAclsAcl() {}

  explicit DescribeACLsResponseBodyAclsAcl(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sagCount) {
      res["SagCount"] = boost::any(*sagCount);
    }
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SagCount") != m.end() && !m["SagCount"].empty()) {
      sagCount = make_shared<string>(boost::any_cast<string>(m["SagCount"]));
    }
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeACLsResponseBodyAclsAcl() = default;
};
class DescribeACLsResponseBodyAcls : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeACLsResponseBodyAclsAcl>> acl{};

  DescribeACLsResponseBodyAcls() {}

  explicit DescribeACLsResponseBodyAcls(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acl) {
      vector<boost::any> temp1;
      for(auto item1:*acl){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Acl"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Acl") != m.end() && !m["Acl"].empty()) {
      if (typeid(vector<boost::any>) == m["Acl"].type()) {
        vector<DescribeACLsResponseBodyAclsAcl> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Acl"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeACLsResponseBodyAclsAcl model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        acl = make_shared<vector<DescribeACLsResponseBodyAclsAcl>>(expect1);
      }
    }
  }


  virtual ~DescribeACLsResponseBodyAcls() = default;
};
class DescribeACLsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<DescribeACLsResponseBodyAcls> acls{};

  DescribeACLsResponseBody() {}

  explicit DescribeACLsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (acls) {
      res["Acls"] = acls ? boost::any(acls->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("Acls") != m.end() && !m["Acls"].empty()) {
      if (typeid(map<string, boost::any>) == m["Acls"].type()) {
        DescribeACLsResponseBodyAcls model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Acls"]));
        acls = make_shared<DescribeACLsResponseBodyAcls>(model1);
      }
    }
  }


  virtual ~DescribeACLsResponseBody() = default;
};
class DescribeACLsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeACLsResponseBody> body{};

  DescribeACLsResponse() {}

  explicit DescribeACLsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeACLsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeACLsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeACLsResponse() = default;
};
class ResetSmartAccessGatewayClientUserPasswordRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> userName{};
  shared_ptr<string> password{};

  ResetSmartAccessGatewayClientUserPasswordRequest() {}

  explicit ResetSmartAccessGatewayClientUserPasswordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
  }


  virtual ~ResetSmartAccessGatewayClientUserPasswordRequest() = default;
};
class ResetSmartAccessGatewayClientUserPasswordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ResetSmartAccessGatewayClientUserPasswordResponseBody() {}

  explicit ResetSmartAccessGatewayClientUserPasswordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResetSmartAccessGatewayClientUserPasswordResponseBody() = default;
};
class ResetSmartAccessGatewayClientUserPasswordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ResetSmartAccessGatewayClientUserPasswordResponseBody> body{};

  ResetSmartAccessGatewayClientUserPasswordResponse() {}

  explicit ResetSmartAccessGatewayClientUserPasswordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResetSmartAccessGatewayClientUserPasswordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResetSmartAccessGatewayClientUserPasswordResponseBody>(model1);
      }
    }
  }


  virtual ~ResetSmartAccessGatewayClientUserPasswordResponse() = default;
};
class UnlockSmartAccessGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> regionId{};

  UnlockSmartAccessGatewayRequest() {}

  explicit UnlockSmartAccessGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~UnlockSmartAccessGatewayRequest() = default;
};
class UnlockSmartAccessGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnlockSmartAccessGatewayResponseBody() {}

  explicit UnlockSmartAccessGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnlockSmartAccessGatewayResponseBody() = default;
};
class UnlockSmartAccessGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UnlockSmartAccessGatewayResponseBody> body{};

  UnlockSmartAccessGatewayResponse() {}

  explicit UnlockSmartAccessGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnlockSmartAccessGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnlockSmartAccessGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~UnlockSmartAccessGatewayResponse() = default;
};
class DescribeUnbindFlowLogSagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};

  DescribeUnbindFlowLogSagsRequest() {}

  explicit DescribeUnbindFlowLogSagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeUnbindFlowLogSagsRequest() = default;
};
class DescribeUnbindFlowLogSagsResponseBodySagsSag : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> name{};

  DescribeUnbindFlowLogSagsResponseBodySagsSag() {}

  explicit DescribeUnbindFlowLogSagsResponseBodySagsSag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeUnbindFlowLogSagsResponseBodySagsSag() = default;
};
class DescribeUnbindFlowLogSagsResponseBodySags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUnbindFlowLogSagsResponseBodySagsSag>> sag{};

  DescribeUnbindFlowLogSagsResponseBodySags() {}

  explicit DescribeUnbindFlowLogSagsResponseBodySags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sag) {
      vector<boost::any> temp1;
      for(auto item1:*sag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sag") != m.end() && !m["Sag"].empty()) {
      if (typeid(vector<boost::any>) == m["Sag"].type()) {
        vector<DescribeUnbindFlowLogSagsResponseBodySagsSag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUnbindFlowLogSagsResponseBodySagsSag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sag = make_shared<vector<DescribeUnbindFlowLogSagsResponseBodySagsSag>>(expect1);
      }
    }
  }


  virtual ~DescribeUnbindFlowLogSagsResponseBodySags() = default;
};
class DescribeUnbindFlowLogSagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<long> count{};
  shared_ptr<DescribeUnbindFlowLogSagsResponseBodySags> sags{};

  DescribeUnbindFlowLogSagsResponseBody() {}

  explicit DescribeUnbindFlowLogSagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (sags) {
      res["Sags"] = sags ? boost::any(sags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Sags") != m.end() && !m["Sags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Sags"].type()) {
        DescribeUnbindFlowLogSagsResponseBodySags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Sags"]));
        sags = make_shared<DescribeUnbindFlowLogSagsResponseBodySags>(model1);
      }
    }
  }


  virtual ~DescribeUnbindFlowLogSagsResponseBody() = default;
};
class DescribeUnbindFlowLogSagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeUnbindFlowLogSagsResponseBody> body{};

  DescribeUnbindFlowLogSagsResponse() {}

  explicit DescribeUnbindFlowLogSagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUnbindFlowLogSagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUnbindFlowLogSagsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUnbindFlowLogSagsResponse() = default;
};
class DisassociateFlowLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> flowLogId{};
  shared_ptr<string> smartAGId{};

  DisassociateFlowLogRequest() {}

  explicit DisassociateFlowLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (flowLogId) {
      res["FlowLogId"] = boost::any(*flowLogId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("FlowLogId") != m.end() && !m["FlowLogId"].empty()) {
      flowLogId = make_shared<string>(boost::any_cast<string>(m["FlowLogId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
  }


  virtual ~DisassociateFlowLogRequest() = default;
};
class DisassociateFlowLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisassociateFlowLogResponseBody() {}

  explicit DisassociateFlowLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisassociateFlowLogResponseBody() = default;
};
class DisassociateFlowLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DisassociateFlowLogResponseBody> body{};

  DisassociateFlowLogResponse() {}

  explicit DisassociateFlowLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisassociateFlowLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisassociateFlowLogResponseBody>(model1);
      }
    }
  }


  virtual ~DisassociateFlowLogResponse() = default;
};
class DescribeSagGlobalRouteProtocolRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};

  DescribeSagGlobalRouteProtocolRequest() {}

  explicit DescribeSagGlobalRouteProtocolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
  }


  virtual ~DescribeSagGlobalRouteProtocolRequest() = default;
};
class DescribeSagGlobalRouteProtocolResponseBodyTaskStates : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> state{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> createTime{};

  DescribeSagGlobalRouteProtocolResponseBodyTaskStates() {}

  explicit DescribeSagGlobalRouteProtocolResponseBodyTaskStates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
  }


  virtual ~DescribeSagGlobalRouteProtocolResponseBodyTaskStates() = default;
};
class DescribeSagGlobalRouteProtocolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> routeProtocol{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSagGlobalRouteProtocolResponseBodyTaskStates>> taskStates{};

  DescribeSagGlobalRouteProtocolResponseBody() {}

  explicit DescribeSagGlobalRouteProtocolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routeProtocol) {
      res["RouteProtocol"] = boost::any(*routeProtocol);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskStates) {
      vector<boost::any> temp1;
      for(auto item1:*taskStates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskStates"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RouteProtocol") != m.end() && !m["RouteProtocol"].empty()) {
      routeProtocol = make_shared<string>(boost::any_cast<string>(m["RouteProtocol"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskStates") != m.end() && !m["TaskStates"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskStates"].type()) {
        vector<DescribeSagGlobalRouteProtocolResponseBodyTaskStates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskStates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSagGlobalRouteProtocolResponseBodyTaskStates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskStates = make_shared<vector<DescribeSagGlobalRouteProtocolResponseBodyTaskStates>>(expect1);
      }
    }
  }


  virtual ~DescribeSagGlobalRouteProtocolResponseBody() = default;
};
class DescribeSagGlobalRouteProtocolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSagGlobalRouteProtocolResponseBody> body{};

  DescribeSagGlobalRouteProtocolResponse() {}

  explicit DescribeSagGlobalRouteProtocolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSagGlobalRouteProtocolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSagGlobalRouteProtocolResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSagGlobalRouteProtocolResponse() = default;
};
class DescribeSagExpressConnectInterfaceListRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};
  shared_ptr<string> portName{};

  DescribeSagExpressConnectInterfaceListRequest() {}

  explicit DescribeSagExpressConnectInterfaceListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    if (portName) {
      res["PortName"] = boost::any(*portName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
    if (m.find("PortName") != m.end() && !m["PortName"].empty()) {
      portName = make_shared<string>(boost::any_cast<string>(m["PortName"]));
    }
  }


  virtual ~DescribeSagExpressConnectInterfaceListRequest() = default;
};
class DescribeSagExpressConnectInterfaceListResponseBodyInterfaces : public Darabonba::Model {
public:
  shared_ptr<string> mask{};
  shared_ptr<string> vlan{};
  shared_ptr<string> IP{};

  DescribeSagExpressConnectInterfaceListResponseBodyInterfaces() {}

  explicit DescribeSagExpressConnectInterfaceListResponseBodyInterfaces(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mask) {
      res["Mask"] = boost::any(*mask);
    }
    if (vlan) {
      res["Vlan"] = boost::any(*vlan);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Mask") != m.end() && !m["Mask"].empty()) {
      mask = make_shared<string>(boost::any_cast<string>(m["Mask"]));
    }
    if (m.find("Vlan") != m.end() && !m["Vlan"].empty()) {
      vlan = make_shared<string>(boost::any_cast<string>(m["Vlan"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
  }


  virtual ~DescribeSagExpressConnectInterfaceListResponseBodyInterfaces() = default;
};
class DescribeSagExpressConnectInterfaceListResponseBodyTaskStates : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> state{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> createTime{};

  DescribeSagExpressConnectInterfaceListResponseBodyTaskStates() {}

  explicit DescribeSagExpressConnectInterfaceListResponseBodyTaskStates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
  }


  virtual ~DescribeSagExpressConnectInterfaceListResponseBodyTaskStates() = default;
};
class DescribeSagExpressConnectInterfaceListResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSagExpressConnectInterfaceListResponseBodyInterfaces>> interfaces{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSagExpressConnectInterfaceListResponseBodyTaskStates>> taskStates{};

  DescribeSagExpressConnectInterfaceListResponseBody() {}

  explicit DescribeSagExpressConnectInterfaceListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (interfaces) {
      vector<boost::any> temp1;
      for(auto item1:*interfaces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Interfaces"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskStates) {
      vector<boost::any> temp1;
      for(auto item1:*taskStates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskStates"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Interfaces") != m.end() && !m["Interfaces"].empty()) {
      if (typeid(vector<boost::any>) == m["Interfaces"].type()) {
        vector<DescribeSagExpressConnectInterfaceListResponseBodyInterfaces> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Interfaces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSagExpressConnectInterfaceListResponseBodyInterfaces model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        interfaces = make_shared<vector<DescribeSagExpressConnectInterfaceListResponseBodyInterfaces>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskStates") != m.end() && !m["TaskStates"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskStates"].type()) {
        vector<DescribeSagExpressConnectInterfaceListResponseBodyTaskStates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskStates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSagExpressConnectInterfaceListResponseBodyTaskStates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskStates = make_shared<vector<DescribeSagExpressConnectInterfaceListResponseBodyTaskStates>>(expect1);
      }
    }
  }


  virtual ~DescribeSagExpressConnectInterfaceListResponseBody() = default;
};
class DescribeSagExpressConnectInterfaceListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSagExpressConnectInterfaceListResponseBody> body{};

  DescribeSagExpressConnectInterfaceListResponse() {}

  explicit DescribeSagExpressConnectInterfaceListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSagExpressConnectInterfaceListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSagExpressConnectInterfaceListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSagExpressConnectInterfaceListResponse() = default;
};
class CreateACLRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> name{};

  CreateACLRequest() {}

  explicit CreateACLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~CreateACLRequest() = default;
};
class CreateACLResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> aclId{};
  shared_ptr<string> resourceGroupId{};

  CreateACLResponseBody() {}

  explicit CreateACLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~CreateACLResponseBody() = default;
};
class CreateACLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateACLResponseBody> body{};

  CreateACLResponse() {}

  explicit CreateACLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateACLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateACLResponseBody>(model1);
      }
    }
  }


  virtual ~CreateACLResponse() = default;
};
class RebootSmartAccessGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> serialNumber{};

  RebootSmartAccessGatewayRequest() {}

  explicit RebootSmartAccessGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
  }


  virtual ~RebootSmartAccessGatewayRequest() = default;
};
class RebootSmartAccessGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RebootSmartAccessGatewayResponseBody() {}

  explicit RebootSmartAccessGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RebootSmartAccessGatewayResponseBody() = default;
};
class RebootSmartAccessGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RebootSmartAccessGatewayResponseBody> body{};

  RebootSmartAccessGatewayResponse() {}

  explicit RebootSmartAccessGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RebootSmartAccessGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RebootSmartAccessGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~RebootSmartAccessGatewayResponse() = default;
};
class ModifySagStaticRouteRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};
  shared_ptr<string> portName{};
  shared_ptr<string> destinationCidr{};
  shared_ptr<string> nextHop{};
  shared_ptr<string> vlan{};

  ModifySagStaticRouteRequest() {}

  explicit ModifySagStaticRouteRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    if (portName) {
      res["PortName"] = boost::any(*portName);
    }
    if (destinationCidr) {
      res["DestinationCidr"] = boost::any(*destinationCidr);
    }
    if (nextHop) {
      res["NextHop"] = boost::any(*nextHop);
    }
    if (vlan) {
      res["Vlan"] = boost::any(*vlan);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
    if (m.find("PortName") != m.end() && !m["PortName"].empty()) {
      portName = make_shared<string>(boost::any_cast<string>(m["PortName"]));
    }
    if (m.find("DestinationCidr") != m.end() && !m["DestinationCidr"].empty()) {
      destinationCidr = make_shared<string>(boost::any_cast<string>(m["DestinationCidr"]));
    }
    if (m.find("NextHop") != m.end() && !m["NextHop"].empty()) {
      nextHop = make_shared<string>(boost::any_cast<string>(m["NextHop"]));
    }
    if (m.find("Vlan") != m.end() && !m["Vlan"].empty()) {
      vlan = make_shared<string>(boost::any_cast<string>(m["Vlan"]));
    }
  }


  virtual ~ModifySagStaticRouteRequest() = default;
};
class ModifySagStaticRouteResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySagStaticRouteResponseBody() {}

  explicit ModifySagStaticRouteResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySagStaticRouteResponseBody() = default;
};
class ModifySagStaticRouteResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySagStaticRouteResponseBody> body{};

  ModifySagStaticRouteResponse() {}

  explicit ModifySagStaticRouteResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySagStaticRouteResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySagStaticRouteResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySagStaticRouteResponse() = default;
};
class RevokeInstanceFromVbrRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> vbrInstanceId{};

  RevokeInstanceFromVbrRequest() {}

  explicit RevokeInstanceFromVbrRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (vbrInstanceId) {
      res["VbrInstanceId"] = boost::any(*vbrInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("VbrInstanceId") != m.end() && !m["VbrInstanceId"].empty()) {
      vbrInstanceId = make_shared<string>(boost::any_cast<string>(m["VbrInstanceId"]));
    }
  }


  virtual ~RevokeInstanceFromVbrRequest() = default;
};
class RevokeInstanceFromVbrResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RevokeInstanceFromVbrResponseBody() {}

  explicit RevokeInstanceFromVbrResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RevokeInstanceFromVbrResponseBody() = default;
};
class RevokeInstanceFromVbrResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RevokeInstanceFromVbrResponseBody> body{};

  RevokeInstanceFromVbrResponse() {}

  explicit RevokeInstanceFromVbrResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokeInstanceFromVbrResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokeInstanceFromVbrResponseBody>(model1);
      }
    }
  }


  virtual ~RevokeInstanceFromVbrResponse() = default;
};
class DescribeCloudConnectNetworksRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeCloudConnectNetworksRequestTag() {}

  explicit DescribeCloudConnectNetworksRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeCloudConnectNetworksRequestTag() = default;
};
class DescribeCloudConnectNetworksRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> name{};
  shared_ptr<string> ccnId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<vector<DescribeCloudConnectNetworksRequestTag>> tag{};

  DescribeCloudConnectNetworksRequest() {}

  explicit DescribeCloudConnectNetworksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ccnId) {
      res["CcnId"] = boost::any(*ccnId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("CcnId") != m.end() && !m["CcnId"].empty()) {
      ccnId = make_shared<string>(boost::any_cast<string>(m["CcnId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeCloudConnectNetworksRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudConnectNetworksRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeCloudConnectNetworksRequestTag>>(expect1);
      }
    }
  }


  virtual ~DescribeCloudConnectNetworksRequest() = default;
};
class DescribeCloudConnectNetworksResponseBodyCloudConnectNetworksCloudConnectNetworkTagsTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  DescribeCloudConnectNetworksResponseBodyCloudConnectNetworksCloudConnectNetworkTagsTag() {}

  explicit DescribeCloudConnectNetworksResponseBodyCloudConnectNetworksCloudConnectNetworkTagsTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~DescribeCloudConnectNetworksResponseBodyCloudConnectNetworksCloudConnectNetworkTagsTag() = default;
};
class DescribeCloudConnectNetworksResponseBodyCloudConnectNetworksCloudConnectNetworkTags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCloudConnectNetworksResponseBodyCloudConnectNetworksCloudConnectNetworkTagsTag>> tag{};

  DescribeCloudConnectNetworksResponseBodyCloudConnectNetworksCloudConnectNetworkTags() {}

  explicit DescribeCloudConnectNetworksResponseBodyCloudConnectNetworksCloudConnectNetworkTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<DescribeCloudConnectNetworksResponseBodyCloudConnectNetworksCloudConnectNetworkTagsTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudConnectNetworksResponseBodyCloudConnectNetworksCloudConnectNetworkTagsTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<DescribeCloudConnectNetworksResponseBodyCloudConnectNetworksCloudConnectNetworkTagsTag>>(expect1);
      }
    }
  }


  virtual ~DescribeCloudConnectNetworksResponseBodyCloudConnectNetworksCloudConnectNetworkTags() = default;
};
class DescribeCloudConnectNetworksResponseBodyCloudConnectNetworksCloudConnectNetwork : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> associatedCenOwnerId{};
  shared_ptr<string> associatedCloudBoxCount{};
  shared_ptr<DescribeCloudConnectNetworksResponseBodyCloudConnectNetworksCloudConnectNetworkTags> tags{};
  shared_ptr<string> interworkingStatus{};
  shared_ptr<string> ccnId{};
  shared_ptr<string> availableCloudBoxCount{};
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> description{};
  shared_ptr<string> snatCidrBlock{};
  shared_ptr<string> associatedCenId{};
  shared_ptr<string> name{};
  shared_ptr<string> resourceGroupId{};

  DescribeCloudConnectNetworksResponseBodyCloudConnectNetworksCloudConnectNetwork() {}

  explicit DescribeCloudConnectNetworksResponseBodyCloudConnectNetworksCloudConnectNetwork(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (associatedCenOwnerId) {
      res["AssociatedCenOwnerId"] = boost::any(*associatedCenOwnerId);
    }
    if (associatedCloudBoxCount) {
      res["AssociatedCloudBoxCount"] = boost::any(*associatedCloudBoxCount);
    }
    if (tags) {
      res["Tags"] = tags ? boost::any(tags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (interworkingStatus) {
      res["InterworkingStatus"] = boost::any(*interworkingStatus);
    }
    if (ccnId) {
      res["CcnId"] = boost::any(*ccnId);
    }
    if (availableCloudBoxCount) {
      res["AvailableCloudBoxCount"] = boost::any(*availableCloudBoxCount);
    }
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (snatCidrBlock) {
      res["SnatCidrBlock"] = boost::any(*snatCidrBlock);
    }
    if (associatedCenId) {
      res["AssociatedCenId"] = boost::any(*associatedCenId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("AssociatedCenOwnerId") != m.end() && !m["AssociatedCenOwnerId"].empty()) {
      associatedCenOwnerId = make_shared<string>(boost::any_cast<string>(m["AssociatedCenOwnerId"]));
    }
    if (m.find("AssociatedCloudBoxCount") != m.end() && !m["AssociatedCloudBoxCount"].empty()) {
      associatedCloudBoxCount = make_shared<string>(boost::any_cast<string>(m["AssociatedCloudBoxCount"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Tags"].type()) {
        DescribeCloudConnectNetworksResponseBodyCloudConnectNetworksCloudConnectNetworkTags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Tags"]));
        tags = make_shared<DescribeCloudConnectNetworksResponseBodyCloudConnectNetworksCloudConnectNetworkTags>(model1);
      }
    }
    if (m.find("InterworkingStatus") != m.end() && !m["InterworkingStatus"].empty()) {
      interworkingStatus = make_shared<string>(boost::any_cast<string>(m["InterworkingStatus"]));
    }
    if (m.find("CcnId") != m.end() && !m["CcnId"].empty()) {
      ccnId = make_shared<string>(boost::any_cast<string>(m["CcnId"]));
    }
    if (m.find("AvailableCloudBoxCount") != m.end() && !m["AvailableCloudBoxCount"].empty()) {
      availableCloudBoxCount = make_shared<string>(boost::any_cast<string>(m["AvailableCloudBoxCount"]));
    }
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SnatCidrBlock") != m.end() && !m["SnatCidrBlock"].empty()) {
      snatCidrBlock = make_shared<string>(boost::any_cast<string>(m["SnatCidrBlock"]));
    }
    if (m.find("AssociatedCenId") != m.end() && !m["AssociatedCenId"].empty()) {
      associatedCenId = make_shared<string>(boost::any_cast<string>(m["AssociatedCenId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeCloudConnectNetworksResponseBodyCloudConnectNetworksCloudConnectNetwork() = default;
};
class DescribeCloudConnectNetworksResponseBodyCloudConnectNetworks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeCloudConnectNetworksResponseBodyCloudConnectNetworksCloudConnectNetwork>> cloudConnectNetwork{};

  DescribeCloudConnectNetworksResponseBodyCloudConnectNetworks() {}

  explicit DescribeCloudConnectNetworksResponseBodyCloudConnectNetworks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cloudConnectNetwork) {
      vector<boost::any> temp1;
      for(auto item1:*cloudConnectNetwork){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CloudConnectNetwork"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CloudConnectNetwork") != m.end() && !m["CloudConnectNetwork"].empty()) {
      if (typeid(vector<boost::any>) == m["CloudConnectNetwork"].type()) {
        vector<DescribeCloudConnectNetworksResponseBodyCloudConnectNetworksCloudConnectNetwork> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CloudConnectNetwork"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCloudConnectNetworksResponseBodyCloudConnectNetworksCloudConnectNetwork model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cloudConnectNetwork = make_shared<vector<DescribeCloudConnectNetworksResponseBodyCloudConnectNetworksCloudConnectNetwork>>(expect1);
      }
    }
  }


  virtual ~DescribeCloudConnectNetworksResponseBodyCloudConnectNetworks() = default;
};
class DescribeCloudConnectNetworksResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeCloudConnectNetworksResponseBodyCloudConnectNetworks> cloudConnectNetworks{};
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};

  DescribeCloudConnectNetworksResponseBody() {}

  explicit DescribeCloudConnectNetworksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cloudConnectNetworks) {
      res["CloudConnectNetworks"] = cloudConnectNetworks ? boost::any(cloudConnectNetworks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CloudConnectNetworks") != m.end() && !m["CloudConnectNetworks"].empty()) {
      if (typeid(map<string, boost::any>) == m["CloudConnectNetworks"].type()) {
        DescribeCloudConnectNetworksResponseBodyCloudConnectNetworks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CloudConnectNetworks"]));
        cloudConnectNetworks = make_shared<DescribeCloudConnectNetworksResponseBodyCloudConnectNetworks>(model1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~DescribeCloudConnectNetworksResponseBody() = default;
};
class DescribeCloudConnectNetworksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeCloudConnectNetworksResponseBody> body{};

  DescribeCloudConnectNetworksResponse() {}

  explicit DescribeCloudConnectNetworksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCloudConnectNetworksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCloudConnectNetworksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCloudConnectNetworksResponse() = default;
};
class ModifyACLRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> aclId{};
  shared_ptr<string> acrId{};
  shared_ptr<string> description{};
  shared_ptr<string> direction{};
  shared_ptr<string> sourceCidr{};
  shared_ptr<string> destCidr{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> sourcePortRange{};
  shared_ptr<string> destPortRange{};
  shared_ptr<string> policy{};
  shared_ptr<long> priority{};
  shared_ptr<string> type{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> dpiSignatureIds{};
  shared_ptr<vector<string>> dpiGroupIds{};

  ModifyACLRuleRequest() {}

  explicit ModifyACLRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (acrId) {
      res["AcrId"] = boost::any(*acrId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (sourceCidr) {
      res["SourceCidr"] = boost::any(*sourceCidr);
    }
    if (destCidr) {
      res["DestCidr"] = boost::any(*destCidr);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    if (destPortRange) {
      res["DestPortRange"] = boost::any(*destPortRange);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (dpiSignatureIds) {
      res["DpiSignatureIds"] = boost::any(*dpiSignatureIds);
    }
    if (dpiGroupIds) {
      res["DpiGroupIds"] = boost::any(*dpiGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("AcrId") != m.end() && !m["AcrId"].empty()) {
      acrId = make_shared<string>(boost::any_cast<string>(m["AcrId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("SourceCidr") != m.end() && !m["SourceCidr"].empty()) {
      sourceCidr = make_shared<string>(boost::any_cast<string>(m["SourceCidr"]));
    }
    if (m.find("DestCidr") != m.end() && !m["DestCidr"].empty()) {
      destCidr = make_shared<string>(boost::any_cast<string>(m["DestCidr"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
    if (m.find("DestPortRange") != m.end() && !m["DestPortRange"].empty()) {
      destPortRange = make_shared<string>(boost::any_cast<string>(m["DestPortRange"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("DpiSignatureIds") != m.end() && !m["DpiSignatureIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DpiSignatureIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DpiSignatureIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dpiSignatureIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DpiGroupIds") != m.end() && !m["DpiGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DpiGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DpiGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dpiGroupIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyACLRuleRequest() = default;
};
class ModifyACLRuleResponseBodyDpiGroupIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dpiGroupId{};

  ModifyACLRuleResponseBodyDpiGroupIds() {}

  explicit ModifyACLRuleResponseBodyDpiGroupIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dpiGroupId) {
      res["DpiGroupId"] = boost::any(*dpiGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DpiGroupId") != m.end() && !m["DpiGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DpiGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DpiGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dpiGroupId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyACLRuleResponseBodyDpiGroupIds() = default;
};
class ModifyACLRuleResponseBodyDpiSignatureIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dpiSignatureId{};

  ModifyACLRuleResponseBodyDpiSignatureIds() {}

  explicit ModifyACLRuleResponseBodyDpiSignatureIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dpiSignatureId) {
      res["DpiSignatureId"] = boost::any(*dpiSignatureId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DpiSignatureId") != m.end() && !m["DpiSignatureId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DpiSignatureId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DpiSignatureId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dpiSignatureId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyACLRuleResponseBodyDpiSignatureIds() = default;
};
class ModifyACLRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> policy{};
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<string> sourcePortRange{};
  shared_ptr<string> sourceCidr{};
  shared_ptr<long> priority{};
  shared_ptr<string> aclId{};
  shared_ptr<string> acrId{};
  shared_ptr<string> destPortRange{};
  shared_ptr<string> direction{};
  shared_ptr<ModifyACLRuleResponseBodyDpiGroupIds> dpiGroupIds{};
  shared_ptr<string> name{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> destCidr{};
  shared_ptr<ModifyACLRuleResponseBodyDpiSignatureIds> dpiSignatureIds{};
  shared_ptr<string> ipProtocol{};

  ModifyACLRuleResponseBody() {}

  explicit ModifyACLRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    if (sourceCidr) {
      res["SourceCidr"] = boost::any(*sourceCidr);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (acrId) {
      res["AcrId"] = boost::any(*acrId);
    }
    if (destPortRange) {
      res["DestPortRange"] = boost::any(*destPortRange);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (dpiGroupIds) {
      res["DpiGroupIds"] = dpiGroupIds ? boost::any(dpiGroupIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (destCidr) {
      res["DestCidr"] = boost::any(*destCidr);
    }
    if (dpiSignatureIds) {
      res["DpiSignatureIds"] = dpiSignatureIds ? boost::any(dpiSignatureIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
    if (m.find("SourceCidr") != m.end() && !m["SourceCidr"].empty()) {
      sourceCidr = make_shared<string>(boost::any_cast<string>(m["SourceCidr"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("AcrId") != m.end() && !m["AcrId"].empty()) {
      acrId = make_shared<string>(boost::any_cast<string>(m["AcrId"]));
    }
    if (m.find("DestPortRange") != m.end() && !m["DestPortRange"].empty()) {
      destPortRange = make_shared<string>(boost::any_cast<string>(m["DestPortRange"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("DpiGroupIds") != m.end() && !m["DpiGroupIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["DpiGroupIds"].type()) {
        ModifyACLRuleResponseBodyDpiGroupIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DpiGroupIds"]));
        dpiGroupIds = make_shared<ModifyACLRuleResponseBodyDpiGroupIds>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("DestCidr") != m.end() && !m["DestCidr"].empty()) {
      destCidr = make_shared<string>(boost::any_cast<string>(m["DestCidr"]));
    }
    if (m.find("DpiSignatureIds") != m.end() && !m["DpiSignatureIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["DpiSignatureIds"].type()) {
        ModifyACLRuleResponseBodyDpiSignatureIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DpiSignatureIds"]));
        dpiSignatureIds = make_shared<ModifyACLRuleResponseBodyDpiSignatureIds>(model1);
      }
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
  }


  virtual ~ModifyACLRuleResponseBody() = default;
};
class ModifyACLRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyACLRuleResponseBody> body{};

  ModifyACLRuleResponse() {}

  explicit ModifyACLRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyACLRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyACLRuleResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyACLRuleResponse() = default;
};
class ModifySmartAccessGatewayClientUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> userName{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> email{};

  ModifySmartAccessGatewayClientUserRequest() {}

  explicit ModifySmartAccessGatewayClientUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (email) {
      res["Email"] = boost::any(*email);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("Email") != m.end() && !m["Email"].empty()) {
      email = make_shared<string>(boost::any_cast<string>(m["Email"]));
    }
  }


  virtual ~ModifySmartAccessGatewayClientUserRequest() = default;
};
class ModifySmartAccessGatewayClientUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> userName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> userMail{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> clientIp{};

  ModifySmartAccessGatewayClientUserResponseBody() {}

  explicit ModifySmartAccessGatewayClientUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userMail) {
      res["UserMail"] = boost::any(*userMail);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserMail") != m.end() && !m["UserMail"].empty()) {
      userMail = make_shared<string>(boost::any_cast<string>(m["UserMail"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
  }


  virtual ~ModifySmartAccessGatewayClientUserResponseBody() = default;
};
class ModifySmartAccessGatewayClientUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySmartAccessGatewayClientUserResponseBody> body{};

  ModifySmartAccessGatewayClientUserResponse() {}

  explicit ModifySmartAccessGatewayClientUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySmartAccessGatewayClientUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySmartAccessGatewayClientUserResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySmartAccessGatewayClientUserResponse() = default;
};
class DescribeSagManagementPortRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};

  DescribeSagManagementPortRequest() {}

  explicit DescribeSagManagementPortRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
  }


  virtual ~DescribeSagManagementPortRequest() = default;
};
class DescribeSagManagementPortResponseBodyTaskStates : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> state{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> createTime{};

  DescribeSagManagementPortResponseBodyTaskStates() {}

  explicit DescribeSagManagementPortResponseBodyTaskStates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
  }


  virtual ~DescribeSagManagementPortResponseBodyTaskStates() = default;
};
class DescribeSagManagementPortResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> gateway{};
  shared_ptr<string> IP{};
  shared_ptr<string> mask{};
  shared_ptr<vector<DescribeSagManagementPortResponseBodyTaskStates>> taskStates{};

  DescribeSagManagementPortResponseBody() {}

  explicit DescribeSagManagementPortResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (gateway) {
      res["Gateway"] = boost::any(*gateway);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (mask) {
      res["Mask"] = boost::any(*mask);
    }
    if (taskStates) {
      vector<boost::any> temp1;
      for(auto item1:*taskStates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskStates"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Gateway") != m.end() && !m["Gateway"].empty()) {
      gateway = make_shared<string>(boost::any_cast<string>(m["Gateway"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("Mask") != m.end() && !m["Mask"].empty()) {
      mask = make_shared<string>(boost::any_cast<string>(m["Mask"]));
    }
    if (m.find("TaskStates") != m.end() && !m["TaskStates"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskStates"].type()) {
        vector<DescribeSagManagementPortResponseBodyTaskStates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskStates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSagManagementPortResponseBodyTaskStates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskStates = make_shared<vector<DescribeSagManagementPortResponseBodyTaskStates>>(expect1);
      }
    }
  }


  virtual ~DescribeSagManagementPortResponseBody() = default;
};
class DescribeSagManagementPortResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSagManagementPortResponseBody> body{};

  DescribeSagManagementPortResponse() {}

  explicit DescribeSagManagementPortResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSagManagementPortResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSagManagementPortResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSagManagementPortResponse() = default;
};
class UpgradeSmartAccessGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> bandWidthSpec{};
  shared_ptr<bool> autoPay{};

  UpgradeSmartAccessGatewayRequest() {}

  explicit UpgradeSmartAccessGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (bandWidthSpec) {
      res["BandWidthSpec"] = boost::any(*bandWidthSpec);
    }
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("BandWidthSpec") != m.end() && !m["BandWidthSpec"].empty()) {
      bandWidthSpec = make_shared<long>(boost::any_cast<long>(m["BandWidthSpec"]));
    }
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
  }


  virtual ~UpgradeSmartAccessGatewayRequest() = default;
};
class UpgradeSmartAccessGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> orderId{};

  UpgradeSmartAccessGatewayResponseBody() {}

  explicit UpgradeSmartAccessGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
  }


  virtual ~UpgradeSmartAccessGatewayResponseBody() = default;
};
class UpgradeSmartAccessGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpgradeSmartAccessGatewayResponseBody> body{};

  UpgradeSmartAccessGatewayResponse() {}

  explicit UpgradeSmartAccessGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpgradeSmartAccessGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpgradeSmartAccessGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~UpgradeSmartAccessGatewayResponse() = default;
};
class GetSmartAGDpiAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};

  GetSmartAGDpiAttributeRequest() {}

  explicit GetSmartAGDpiAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
  }


  virtual ~GetSmartAGDpiAttributeRequest() = default;
};
class GetSmartAGDpiAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> logstoreName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> slsRegion{};
  shared_ptr<string> dpiMonitorStatus{};
  shared_ptr<string> dpiStatus{};

  GetSmartAGDpiAttributeResponseBody() {}

  explicit GetSmartAGDpiAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (logstoreName) {
      res["LogstoreName"] = boost::any(*logstoreName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (slsRegion) {
      res["SlsRegion"] = boost::any(*slsRegion);
    }
    if (dpiMonitorStatus) {
      res["DpiMonitorStatus"] = boost::any(*dpiMonitorStatus);
    }
    if (dpiStatus) {
      res["DpiStatus"] = boost::any(*dpiStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LogstoreName") != m.end() && !m["LogstoreName"].empty()) {
      logstoreName = make_shared<string>(boost::any_cast<string>(m["LogstoreName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SlsRegion") != m.end() && !m["SlsRegion"].empty()) {
      slsRegion = make_shared<string>(boost::any_cast<string>(m["SlsRegion"]));
    }
    if (m.find("DpiMonitorStatus") != m.end() && !m["DpiMonitorStatus"].empty()) {
      dpiMonitorStatus = make_shared<string>(boost::any_cast<string>(m["DpiMonitorStatus"]));
    }
    if (m.find("DpiStatus") != m.end() && !m["DpiStatus"].empty()) {
      dpiStatus = make_shared<string>(boost::any_cast<string>(m["DpiStatus"]));
    }
  }


  virtual ~GetSmartAGDpiAttributeResponseBody() = default;
};
class GetSmartAGDpiAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetSmartAGDpiAttributeResponseBody> body{};

  GetSmartAGDpiAttributeResponse() {}

  explicit GetSmartAGDpiAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSmartAGDpiAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSmartAGDpiAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~GetSmartAGDpiAttributeResponse() = default;
};
class DisassociateQosRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> qosId{};
  shared_ptr<string> smartAGId{};

  DisassociateQosRequest() {}

  explicit DisassociateQosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
  }


  virtual ~DisassociateQosRequest() = default;
};
class DisassociateQosResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisassociateQosResponseBody() {}

  explicit DisassociateQosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisassociateQosResponseBody() = default;
};
class DisassociateQosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DisassociateQosResponseBody> body{};

  DisassociateQosResponse() {}

  explicit DisassociateQosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisassociateQosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisassociateQosResponseBody>(model1);
      }
    }
  }


  virtual ~DisassociateQosResponse() = default;
};
class ModifyRouteDistributionStrategyRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> hcInstanceId{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> destCidrBlock{};
  shared_ptr<string> routeSource{};
  shared_ptr<string> routeDistribution{};

  ModifyRouteDistributionStrategyRequest() {}

  explicit ModifyRouteDistributionStrategyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (hcInstanceId) {
      res["HcInstanceId"] = boost::any(*hcInstanceId);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (destCidrBlock) {
      res["DestCidrBlock"] = boost::any(*destCidrBlock);
    }
    if (routeSource) {
      res["RouteSource"] = boost::any(*routeSource);
    }
    if (routeDistribution) {
      res["RouteDistribution"] = boost::any(*routeDistribution);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("HcInstanceId") != m.end() && !m["HcInstanceId"].empty()) {
      hcInstanceId = make_shared<string>(boost::any_cast<string>(m["HcInstanceId"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("DestCidrBlock") != m.end() && !m["DestCidrBlock"].empty()) {
      destCidrBlock = make_shared<string>(boost::any_cast<string>(m["DestCidrBlock"]));
    }
    if (m.find("RouteSource") != m.end() && !m["RouteSource"].empty()) {
      routeSource = make_shared<string>(boost::any_cast<string>(m["RouteSource"]));
    }
    if (m.find("RouteDistribution") != m.end() && !m["RouteDistribution"].empty()) {
      routeDistribution = make_shared<string>(boost::any_cast<string>(m["RouteDistribution"]));
    }
  }


  virtual ~ModifyRouteDistributionStrategyRequest() = default;
};
class ModifyRouteDistributionStrategyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyRouteDistributionStrategyResponseBody() {}

  explicit ModifyRouteDistributionStrategyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyRouteDistributionStrategyResponseBody() = default;
};
class ModifyRouteDistributionStrategyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyRouteDistributionStrategyResponseBody> body{};

  ModifyRouteDistributionStrategyResponse() {}

  explicit ModifyRouteDistributionStrategyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyRouteDistributionStrategyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyRouteDistributionStrategyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyRouteDistributionStrategyResponse() = default;
};
class ModifySagPortRouteProtocolRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};
  shared_ptr<string> portName{};
  shared_ptr<string> vlan{};
  shared_ptr<string> routeProtocol{};
  shared_ptr<string> remoteIp{};
  shared_ptr<string> remoteAs{};

  ModifySagPortRouteProtocolRequest() {}

  explicit ModifySagPortRouteProtocolRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    if (portName) {
      res["PortName"] = boost::any(*portName);
    }
    if (vlan) {
      res["Vlan"] = boost::any(*vlan);
    }
    if (routeProtocol) {
      res["RouteProtocol"] = boost::any(*routeProtocol);
    }
    if (remoteIp) {
      res["RemoteIp"] = boost::any(*remoteIp);
    }
    if (remoteAs) {
      res["RemoteAs"] = boost::any(*remoteAs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
    if (m.find("PortName") != m.end() && !m["PortName"].empty()) {
      portName = make_shared<string>(boost::any_cast<string>(m["PortName"]));
    }
    if (m.find("Vlan") != m.end() && !m["Vlan"].empty()) {
      vlan = make_shared<string>(boost::any_cast<string>(m["Vlan"]));
    }
    if (m.find("RouteProtocol") != m.end() && !m["RouteProtocol"].empty()) {
      routeProtocol = make_shared<string>(boost::any_cast<string>(m["RouteProtocol"]));
    }
    if (m.find("RemoteIp") != m.end() && !m["RemoteIp"].empty()) {
      remoteIp = make_shared<string>(boost::any_cast<string>(m["RemoteIp"]));
    }
    if (m.find("RemoteAs") != m.end() && !m["RemoteAs"].empty()) {
      remoteAs = make_shared<string>(boost::any_cast<string>(m["RemoteAs"]));
    }
  }


  virtual ~ModifySagPortRouteProtocolRequest() = default;
};
class ModifySagPortRouteProtocolResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySagPortRouteProtocolResponseBody() {}

  explicit ModifySagPortRouteProtocolResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySagPortRouteProtocolResponseBody() = default;
};
class ModifySagPortRouteProtocolResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySagPortRouteProtocolResponseBody> body{};

  ModifySagPortRouteProtocolResponse() {}

  explicit ModifySagPortRouteProtocolResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySagPortRouteProtocolResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySagPortRouteProtocolResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySagPortRouteProtocolResponse() = default;
};
class EnableSmartAccessGatewayUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> userName{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> regionId{};

  EnableSmartAccessGatewayUserRequest() {}

  explicit EnableSmartAccessGatewayUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~EnableSmartAccessGatewayUserRequest() = default;
};
class EnableSmartAccessGatewayUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableSmartAccessGatewayUserResponseBody() {}

  explicit EnableSmartAccessGatewayUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableSmartAccessGatewayUserResponseBody() = default;
};
class EnableSmartAccessGatewayUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<EnableSmartAccessGatewayUserResponseBody> body{};

  EnableSmartAccessGatewayUserResponse() {}

  explicit EnableSmartAccessGatewayUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableSmartAccessGatewayUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableSmartAccessGatewayUserResponseBody>(model1);
      }
    }
  }


  virtual ~EnableSmartAccessGatewayUserResponse() = default;
};
class ModifyQosRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> qosId{};
  shared_ptr<string> qosName{};
  shared_ptr<string> qosDescription{};

  ModifyQosRequest() {}

  explicit ModifyQosRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (qosName) {
      res["QosName"] = boost::any(*qosName);
    }
    if (qosDescription) {
      res["QosDescription"] = boost::any(*qosDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("QosName") != m.end() && !m["QosName"].empty()) {
      qosName = make_shared<string>(boost::any_cast<string>(m["QosName"]));
    }
    if (m.find("QosDescription") != m.end() && !m["QosDescription"].empty()) {
      qosDescription = make_shared<string>(boost::any_cast<string>(m["QosDescription"]));
    }
  }


  virtual ~ModifyQosRequest() = default;
};
class ModifyQosResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyQosResponseBody() {}

  explicit ModifyQosResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyQosResponseBody() = default;
};
class ModifyQosResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyQosResponseBody> body{};

  ModifyQosResponse() {}

  explicit ModifyQosResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyQosResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyQosResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyQosResponse() = default;
};
class GetAclAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> aclId{};

  GetAclAttributeRequest() {}

  explicit GetAclAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
  }


  virtual ~GetAclAttributeRequest() = default;
};
class GetAclAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> aclId{};
  shared_ptr<long> errorConfigSmartAGCount{};
  shared_ptr<string> aclName{};

  GetAclAttributeResponseBody() {}

  explicit GetAclAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (errorConfigSmartAGCount) {
      res["ErrorConfigSmartAGCount"] = boost::any(*errorConfigSmartAGCount);
    }
    if (aclName) {
      res["AclName"] = boost::any(*aclName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("ErrorConfigSmartAGCount") != m.end() && !m["ErrorConfigSmartAGCount"].empty()) {
      errorConfigSmartAGCount = make_shared<long>(boost::any_cast<long>(m["ErrorConfigSmartAGCount"]));
    }
    if (m.find("AclName") != m.end() && !m["AclName"].empty()) {
      aclName = make_shared<string>(boost::any_cast<string>(m["AclName"]));
    }
  }


  virtual ~GetAclAttributeResponseBody() = default;
};
class GetAclAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetAclAttributeResponseBody> body{};

  GetAclAttributeResponse() {}

  explicit GetAclAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetAclAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetAclAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~GetAclAttributeResponse() = default;
};
class DescribeSagWanListRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};

  DescribeSagWanListRequest() {}

  explicit DescribeSagWanListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
  }


  virtual ~DescribeSagWanListRequest() = default;
};
class DescribeSagWanListResponseBodyWans : public Darabonba::Model {
public:
  shared_ptr<long> weight{};
  shared_ptr<string> mask{};
  shared_ptr<string> gateway{};
  shared_ptr<string> portName{};
  shared_ptr<string> IPType{};
  shared_ptr<long> priority{};
  shared_ptr<long> bandWidth{};
  shared_ptr<string> trafficState{};
  shared_ptr<string> IP{};
  shared_ptr<string> ISP{};
  shared_ptr<string> username{};

  DescribeSagWanListResponseBodyWans() {}

  explicit DescribeSagWanListResponseBodyWans(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    if (mask) {
      res["Mask"] = boost::any(*mask);
    }
    if (gateway) {
      res["Gateway"] = boost::any(*gateway);
    }
    if (portName) {
      res["PortName"] = boost::any(*portName);
    }
    if (IPType) {
      res["IPType"] = boost::any(*IPType);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (bandWidth) {
      res["BandWidth"] = boost::any(*bandWidth);
    }
    if (trafficState) {
      res["TrafficState"] = boost::any(*trafficState);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (ISP) {
      res["ISP"] = boost::any(*ISP);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
    if (m.find("Mask") != m.end() && !m["Mask"].empty()) {
      mask = make_shared<string>(boost::any_cast<string>(m["Mask"]));
    }
    if (m.find("Gateway") != m.end() && !m["Gateway"].empty()) {
      gateway = make_shared<string>(boost::any_cast<string>(m["Gateway"]));
    }
    if (m.find("PortName") != m.end() && !m["PortName"].empty()) {
      portName = make_shared<string>(boost::any_cast<string>(m["PortName"]));
    }
    if (m.find("IPType") != m.end() && !m["IPType"].empty()) {
      IPType = make_shared<string>(boost::any_cast<string>(m["IPType"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("BandWidth") != m.end() && !m["BandWidth"].empty()) {
      bandWidth = make_shared<long>(boost::any_cast<long>(m["BandWidth"]));
    }
    if (m.find("TrafficState") != m.end() && !m["TrafficState"].empty()) {
      trafficState = make_shared<string>(boost::any_cast<string>(m["TrafficState"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("ISP") != m.end() && !m["ISP"].empty()) {
      ISP = make_shared<string>(boost::any_cast<string>(m["ISP"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
  }


  virtual ~DescribeSagWanListResponseBodyWans() = default;
};
class DescribeSagWanListResponseBodyTaskStates : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> state{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> createTime{};

  DescribeSagWanListResponseBodyTaskStates() {}

  explicit DescribeSagWanListResponseBodyTaskStates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
  }


  virtual ~DescribeSagWanListResponseBodyTaskStates() = default;
};
class DescribeSagWanListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSagWanListResponseBodyWans>> wans{};
  shared_ptr<vector<DescribeSagWanListResponseBodyTaskStates>> taskStates{};

  DescribeSagWanListResponseBody() {}

  explicit DescribeSagWanListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (wans) {
      vector<boost::any> temp1;
      for(auto item1:*wans){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Wans"] = boost::any(temp1);
    }
    if (taskStates) {
      vector<boost::any> temp1;
      for(auto item1:*taskStates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskStates"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Wans") != m.end() && !m["Wans"].empty()) {
      if (typeid(vector<boost::any>) == m["Wans"].type()) {
        vector<DescribeSagWanListResponseBodyWans> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Wans"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSagWanListResponseBodyWans model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        wans = make_shared<vector<DescribeSagWanListResponseBodyWans>>(expect1);
      }
    }
    if (m.find("TaskStates") != m.end() && !m["TaskStates"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskStates"].type()) {
        vector<DescribeSagWanListResponseBodyTaskStates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskStates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSagWanListResponseBodyTaskStates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskStates = make_shared<vector<DescribeSagWanListResponseBodyTaskStates>>(expect1);
      }
    }
  }


  virtual ~DescribeSagWanListResponseBody() = default;
};
class DescribeSagWanListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSagWanListResponseBody> body{};

  DescribeSagWanListResponse() {}

  explicit DescribeSagWanListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSagWanListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSagWanListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSagWanListResponse() = default;
};
class ListSmartAGApiUnsupportedFeatureRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> openApiName{};

  ListSmartAGApiUnsupportedFeatureRequest() {}

  explicit ListSmartAGApiUnsupportedFeatureRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (openApiName) {
      res["OpenApiName"] = boost::any(*openApiName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("OpenApiName") != m.end() && !m["OpenApiName"].empty()) {
      openApiName = make_shared<string>(boost::any_cast<string>(m["OpenApiName"]));
    }
  }


  virtual ~ListSmartAGApiUnsupportedFeatureRequest() = default;
};
class ListSmartAGApiUnsupportedFeatureResponseBodyFeatures : public Darabonba::Model {
public:
  shared_ptr<string> feature{};

  ListSmartAGApiUnsupportedFeatureResponseBodyFeatures() {}

  explicit ListSmartAGApiUnsupportedFeatureResponseBodyFeatures(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (feature) {
      res["Feature"] = boost::any(*feature);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Feature") != m.end() && !m["Feature"].empty()) {
      feature = make_shared<string>(boost::any_cast<string>(m["Feature"]));
    }
  }


  virtual ~ListSmartAGApiUnsupportedFeatureResponseBodyFeatures() = default;
};
class ListSmartAGApiUnsupportedFeatureResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSmartAGApiUnsupportedFeatureResponseBodyFeatures>> features{};

  ListSmartAGApiUnsupportedFeatureResponseBody() {}

  explicit ListSmartAGApiUnsupportedFeatureResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (features) {
      vector<boost::any> temp1;
      for(auto item1:*features){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Features"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Features") != m.end() && !m["Features"].empty()) {
      if (typeid(vector<boost::any>) == m["Features"].type()) {
        vector<ListSmartAGApiUnsupportedFeatureResponseBodyFeatures> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Features"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSmartAGApiUnsupportedFeatureResponseBodyFeatures model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        features = make_shared<vector<ListSmartAGApiUnsupportedFeatureResponseBodyFeatures>>(expect1);
      }
    }
  }


  virtual ~ListSmartAGApiUnsupportedFeatureResponseBody() = default;
};
class ListSmartAGApiUnsupportedFeatureResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListSmartAGApiUnsupportedFeatureResponseBody> body{};

  ListSmartAGApiUnsupportedFeatureResponse() {}

  explicit ListSmartAGApiUnsupportedFeatureResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSmartAGApiUnsupportedFeatureResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSmartAGApiUnsupportedFeatureResponseBody>(model1);
      }
    }
  }


  virtual ~ListSmartAGApiUnsupportedFeatureResponse() = default;
};
class EnableSmartAGDpiMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};
  shared_ptr<string> slsProjectName{};
  shared_ptr<string> slsLogStore{};

  EnableSmartAGDpiMonitorRequest() {}

  explicit EnableSmartAGDpiMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    if (slsProjectName) {
      res["SlsProjectName"] = boost::any(*slsProjectName);
    }
    if (slsLogStore) {
      res["SlsLogStore"] = boost::any(*slsLogStore);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
    if (m.find("SlsProjectName") != m.end() && !m["SlsProjectName"].empty()) {
      slsProjectName = make_shared<string>(boost::any_cast<string>(m["SlsProjectName"]));
    }
    if (m.find("SlsLogStore") != m.end() && !m["SlsLogStore"].empty()) {
      slsLogStore = make_shared<string>(boost::any_cast<string>(m["SlsLogStore"]));
    }
  }


  virtual ~EnableSmartAGDpiMonitorRequest() = default;
};
class EnableSmartAGDpiMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EnableSmartAGDpiMonitorResponseBody() {}

  explicit EnableSmartAGDpiMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EnableSmartAGDpiMonitorResponseBody() = default;
};
class EnableSmartAGDpiMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<EnableSmartAGDpiMonitorResponseBody> body{};

  EnableSmartAGDpiMonitorResponse() {}

  explicit EnableSmartAGDpiMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EnableSmartAGDpiMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EnableSmartAGDpiMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~EnableSmartAGDpiMonitorResponse() = default;
};
class ActivateSmartAccessGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> regionId{};

  ActivateSmartAccessGatewayRequest() {}

  explicit ActivateSmartAccessGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~ActivateSmartAccessGatewayRequest() = default;
};
class ActivateSmartAccessGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ActivateSmartAccessGatewayResponseBody() {}

  explicit ActivateSmartAccessGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ActivateSmartAccessGatewayResponseBody() = default;
};
class ActivateSmartAccessGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ActivateSmartAccessGatewayResponseBody> body{};

  ActivateSmartAccessGatewayResponse() {}

  explicit ActivateSmartAccessGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ActivateSmartAccessGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ActivateSmartAccessGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~ActivateSmartAccessGatewayResponse() = default;
};
class DeleteACLRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> aclId{};
  shared_ptr<string> acrId{};

  DeleteACLRuleRequest() {}

  explicit DeleteACLRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (acrId) {
      res["AcrId"] = boost::any(*acrId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("AcrId") != m.end() && !m["AcrId"].empty()) {
      acrId = make_shared<string>(boost::any_cast<string>(m["AcrId"]));
    }
  }


  virtual ~DeleteACLRuleRequest() = default;
};
class DeleteACLRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteACLRuleResponseBody() {}

  explicit DeleteACLRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteACLRuleResponseBody() = default;
};
class DeleteACLRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteACLRuleResponseBody> body{};

  DeleteACLRuleResponse() {}

  explicit DeleteACLRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteACLRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteACLRuleResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteACLRuleResponse() = default;
};
class MoveResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> newResourceGroupId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ownerAccount{};

  MoveResourceGroupRequest() {}

  explicit MoveResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (newResourceGroupId) {
      res["NewResourceGroupId"] = boost::any(*newResourceGroupId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("NewResourceGroupId") != m.end() && !m["NewResourceGroupId"].empty()) {
      newResourceGroupId = make_shared<string>(boost::any_cast<string>(m["NewResourceGroupId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
  }


  virtual ~MoveResourceGroupRequest() = default;
};
class MoveResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  MoveResourceGroupResponseBody() {}

  explicit MoveResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~MoveResourceGroupResponseBody() = default;
};
class MoveResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<MoveResourceGroupResponseBody> body{};

  MoveResourceGroupResponse() {}

  explicit MoveResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MoveResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MoveResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~MoveResourceGroupResponse() = default;
};
class DescribeSagVbrRelationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> vbrRegionId{};
  shared_ptr<vector<string>> vbrInstanceIds{};

  DescribeSagVbrRelationsRequest() {}

  explicit DescribeSagVbrRelationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (vbrRegionId) {
      res["VbrRegionId"] = boost::any(*vbrRegionId);
    }
    if (vbrInstanceIds) {
      res["VbrInstanceIds"] = boost::any(*vbrInstanceIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("VbrRegionId") != m.end() && !m["VbrRegionId"].empty()) {
      vbrRegionId = make_shared<string>(boost::any_cast<string>(m["VbrRegionId"]));
    }
    if (m.find("VbrInstanceIds") != m.end() && !m["VbrInstanceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["VbrInstanceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["VbrInstanceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      vbrInstanceIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSagVbrRelationsRequest() = default;
};
class DescribeSagVbrRelationsResponseBodySagVbrRelations : public Darabonba::Model {
public:
  shared_ptr<string> vbrInstanceId{};
  shared_ptr<string> sagUid{};
  shared_ptr<string> sagInstanceId{};

  DescribeSagVbrRelationsResponseBodySagVbrRelations() {}

  explicit DescribeSagVbrRelationsResponseBodySagVbrRelations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (vbrInstanceId) {
      res["VbrInstanceId"] = boost::any(*vbrInstanceId);
    }
    if (sagUid) {
      res["SagUid"] = boost::any(*sagUid);
    }
    if (sagInstanceId) {
      res["SagInstanceId"] = boost::any(*sagInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("VbrInstanceId") != m.end() && !m["VbrInstanceId"].empty()) {
      vbrInstanceId = make_shared<string>(boost::any_cast<string>(m["VbrInstanceId"]));
    }
    if (m.find("SagUid") != m.end() && !m["SagUid"].empty()) {
      sagUid = make_shared<string>(boost::any_cast<string>(m["SagUid"]));
    }
    if (m.find("SagInstanceId") != m.end() && !m["SagInstanceId"].empty()) {
      sagInstanceId = make_shared<string>(boost::any_cast<string>(m["SagInstanceId"]));
    }
  }


  virtual ~DescribeSagVbrRelationsResponseBodySagVbrRelations() = default;
};
class DescribeSagVbrRelationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSagVbrRelationsResponseBodySagVbrRelations>> sagVbrRelations{};

  DescribeSagVbrRelationsResponseBody() {}

  explicit DescribeSagVbrRelationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (sagVbrRelations) {
      vector<boost::any> temp1;
      for(auto item1:*sagVbrRelations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SagVbrRelations"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SagVbrRelations") != m.end() && !m["SagVbrRelations"].empty()) {
      if (typeid(vector<boost::any>) == m["SagVbrRelations"].type()) {
        vector<DescribeSagVbrRelationsResponseBodySagVbrRelations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SagVbrRelations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSagVbrRelationsResponseBodySagVbrRelations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sagVbrRelations = make_shared<vector<DescribeSagVbrRelationsResponseBodySagVbrRelations>>(expect1);
      }
    }
  }


  virtual ~DescribeSagVbrRelationsResponseBody() = default;
};
class DescribeSagVbrRelationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSagVbrRelationsResponseBody> body{};

  DescribeSagVbrRelationsResponse() {}

  explicit DescribeSagVbrRelationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSagVbrRelationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSagVbrRelationsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSagVbrRelationsResponse() = default;
};
class CreateSmartAccessGatewayClientUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> userName{};
  shared_ptr<string> clientIp{};
  shared_ptr<string> userMail{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> password{};

  CreateSmartAccessGatewayClientUserRequest() {}

  explicit CreateSmartAccessGatewayClientUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    if (userMail) {
      res["UserMail"] = boost::any(*userMail);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
    if (m.find("UserMail") != m.end() && !m["UserMail"].empty()) {
      userMail = make_shared<string>(boost::any_cast<string>(m["UserMail"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
  }


  virtual ~CreateSmartAccessGatewayClientUserRequest() = default;
};
class CreateSmartAccessGatewayClientUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> userName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> userMail{};
  shared_ptr<long> bandwidth{};
  shared_ptr<string> clientIp{};

  CreateSmartAccessGatewayClientUserResponseBody() {}

  explicit CreateSmartAccessGatewayClientUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (userMail) {
      res["UserMail"] = boost::any(*userMail);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (clientIp) {
      res["ClientIp"] = boost::any(*clientIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UserMail") != m.end() && !m["UserMail"].empty()) {
      userMail = make_shared<string>(boost::any_cast<string>(m["UserMail"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
    if (m.find("ClientIp") != m.end() && !m["ClientIp"].empty()) {
      clientIp = make_shared<string>(boost::any_cast<string>(m["ClientIp"]));
    }
  }


  virtual ~CreateSmartAccessGatewayClientUserResponseBody() = default;
};
class CreateSmartAccessGatewayClientUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateSmartAccessGatewayClientUserResponseBody> body{};

  CreateSmartAccessGatewayClientUserResponse() {}

  explicit CreateSmartAccessGatewayClientUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSmartAccessGatewayClientUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSmartAccessGatewayClientUserResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSmartAccessGatewayClientUserResponse() = default;
};
class GetQosAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> qosId{};

  GetQosAttributeRequest() {}

  explicit GetQosAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
  }


  virtual ~GetQosAttributeRequest() = default;
};
class GetQosAttributeResponseBodyQosPolicies : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<long> startTime{};
  shared_ptr<string> destCidr{};
  shared_ptr<string> destPortRange{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<long> priority{};
  shared_ptr<string> qosPolicieDescription{};
  shared_ptr<string> sourceCidr{};
  shared_ptr<string> qosPolicieName{};
  shared_ptr<string> sourcePortRange{};

  GetQosAttributeResponseBodyQosPolicies() {}

  explicit GetQosAttributeResponseBodyQosPolicies(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (destCidr) {
      res["DestCidr"] = boost::any(*destCidr);
    }
    if (destPortRange) {
      res["DestPortRange"] = boost::any(*destPortRange);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (qosPolicieDescription) {
      res["QosPolicieDescription"] = boost::any(*qosPolicieDescription);
    }
    if (sourceCidr) {
      res["SourceCidr"] = boost::any(*sourceCidr);
    }
    if (qosPolicieName) {
      res["QosPolicieName"] = boost::any(*qosPolicieName);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("DestCidr") != m.end() && !m["DestCidr"].empty()) {
      destCidr = make_shared<string>(boost::any_cast<string>(m["DestCidr"]));
    }
    if (m.find("DestPortRange") != m.end() && !m["DestPortRange"].empty()) {
      destPortRange = make_shared<string>(boost::any_cast<string>(m["DestPortRange"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("QosPolicieDescription") != m.end() && !m["QosPolicieDescription"].empty()) {
      qosPolicieDescription = make_shared<string>(boost::any_cast<string>(m["QosPolicieDescription"]));
    }
    if (m.find("SourceCidr") != m.end() && !m["SourceCidr"].empty()) {
      sourceCidr = make_shared<string>(boost::any_cast<string>(m["SourceCidr"]));
    }
    if (m.find("QosPolicieName") != m.end() && !m["QosPolicieName"].empty()) {
      qosPolicieName = make_shared<string>(boost::any_cast<string>(m["QosPolicieName"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
  }


  virtual ~GetQosAttributeResponseBodyQosPolicies() = default;
};
class GetQosAttributeResponseBodyQosCars : public Darabonba::Model {
public:
  shared_ptr<long> maxBandwidthAbs{};
  shared_ptr<string> qosCarName{};
  shared_ptr<string> percentSourceType{};
  shared_ptr<long> minBandwidthAbs{};
  shared_ptr<long> maxBandwidthPercent{};
  shared_ptr<string> qosCarDescription{};
  shared_ptr<string> limitType{};
  shared_ptr<long> priority{};
  shared_ptr<long> minBandwidthPercent{};
  shared_ptr<string> qosCarId{};

  GetQosAttributeResponseBodyQosCars() {}

  explicit GetQosAttributeResponseBodyQosCars(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxBandwidthAbs) {
      res["MaxBandwidthAbs"] = boost::any(*maxBandwidthAbs);
    }
    if (qosCarName) {
      res["QosCarName"] = boost::any(*qosCarName);
    }
    if (percentSourceType) {
      res["PercentSourceType"] = boost::any(*percentSourceType);
    }
    if (minBandwidthAbs) {
      res["MinBandwidthAbs"] = boost::any(*minBandwidthAbs);
    }
    if (maxBandwidthPercent) {
      res["MaxBandwidthPercent"] = boost::any(*maxBandwidthPercent);
    }
    if (qosCarDescription) {
      res["QosCarDescription"] = boost::any(*qosCarDescription);
    }
    if (limitType) {
      res["LimitType"] = boost::any(*limitType);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (minBandwidthPercent) {
      res["MinBandwidthPercent"] = boost::any(*minBandwidthPercent);
    }
    if (qosCarId) {
      res["QosCarId"] = boost::any(*qosCarId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxBandwidthAbs") != m.end() && !m["MaxBandwidthAbs"].empty()) {
      maxBandwidthAbs = make_shared<long>(boost::any_cast<long>(m["MaxBandwidthAbs"]));
    }
    if (m.find("QosCarName") != m.end() && !m["QosCarName"].empty()) {
      qosCarName = make_shared<string>(boost::any_cast<string>(m["QosCarName"]));
    }
    if (m.find("PercentSourceType") != m.end() && !m["PercentSourceType"].empty()) {
      percentSourceType = make_shared<string>(boost::any_cast<string>(m["PercentSourceType"]));
    }
    if (m.find("MinBandwidthAbs") != m.end() && !m["MinBandwidthAbs"].empty()) {
      minBandwidthAbs = make_shared<long>(boost::any_cast<long>(m["MinBandwidthAbs"]));
    }
    if (m.find("MaxBandwidthPercent") != m.end() && !m["MaxBandwidthPercent"].empty()) {
      maxBandwidthPercent = make_shared<long>(boost::any_cast<long>(m["MaxBandwidthPercent"]));
    }
    if (m.find("QosCarDescription") != m.end() && !m["QosCarDescription"].empty()) {
      qosCarDescription = make_shared<string>(boost::any_cast<string>(m["QosCarDescription"]));
    }
    if (m.find("LimitType") != m.end() && !m["LimitType"].empty()) {
      limitType = make_shared<string>(boost::any_cast<string>(m["LimitType"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("MinBandwidthPercent") != m.end() && !m["MinBandwidthPercent"].empty()) {
      minBandwidthPercent = make_shared<long>(boost::any_cast<long>(m["MinBandwidthPercent"]));
    }
    if (m.find("QosCarId") != m.end() && !m["QosCarId"].empty()) {
      qosCarId = make_shared<string>(boost::any_cast<string>(m["QosCarId"]));
    }
  }


  virtual ~GetQosAttributeResponseBodyQosCars() = default;
};
class GetQosAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GetQosAttributeResponseBodyQosPolicies>> qosPolicies{};
  shared_ptr<vector<GetQosAttributeResponseBodyQosCars>> qosCars{};
  shared_ptr<string> requestId{};
  shared_ptr<long> errorConfigSmartAGCount{};
  shared_ptr<string> qosName{};
  shared_ptr<string> qosDescription{};

  GetQosAttributeResponseBody() {}

  explicit GetQosAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qosPolicies) {
      vector<boost::any> temp1;
      for(auto item1:*qosPolicies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QosPolicies"] = boost::any(temp1);
    }
    if (qosCars) {
      vector<boost::any> temp1;
      for(auto item1:*qosCars){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QosCars"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (errorConfigSmartAGCount) {
      res["ErrorConfigSmartAGCount"] = boost::any(*errorConfigSmartAGCount);
    }
    if (qosName) {
      res["QosName"] = boost::any(*qosName);
    }
    if (qosDescription) {
      res["QosDescription"] = boost::any(*qosDescription);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QosPolicies") != m.end() && !m["QosPolicies"].empty()) {
      if (typeid(vector<boost::any>) == m["QosPolicies"].type()) {
        vector<GetQosAttributeResponseBodyQosPolicies> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QosPolicies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetQosAttributeResponseBodyQosPolicies model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        qosPolicies = make_shared<vector<GetQosAttributeResponseBodyQosPolicies>>(expect1);
      }
    }
    if (m.find("QosCars") != m.end() && !m["QosCars"].empty()) {
      if (typeid(vector<boost::any>) == m["QosCars"].type()) {
        vector<GetQosAttributeResponseBodyQosCars> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QosCars"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetQosAttributeResponseBodyQosCars model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        qosCars = make_shared<vector<GetQosAttributeResponseBodyQosCars>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("ErrorConfigSmartAGCount") != m.end() && !m["ErrorConfigSmartAGCount"].empty()) {
      errorConfigSmartAGCount = make_shared<long>(boost::any_cast<long>(m["ErrorConfigSmartAGCount"]));
    }
    if (m.find("QosName") != m.end() && !m["QosName"].empty()) {
      qosName = make_shared<string>(boost::any_cast<string>(m["QosName"]));
    }
    if (m.find("QosDescription") != m.end() && !m["QosDescription"].empty()) {
      qosDescription = make_shared<string>(boost::any_cast<string>(m["QosDescription"]));
    }
  }


  virtual ~GetQosAttributeResponseBody() = default;
};
class GetQosAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetQosAttributeResponseBody> body{};

  GetQosAttributeResponse() {}

  explicit GetQosAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetQosAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetQosAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~GetQosAttributeResponse() = default;
};
class CreateHealthCheckRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> type{};
  shared_ptr<string> dstIpAddr{};
  shared_ptr<long> dstPort{};
  shared_ptr<string> srcIpAddr{};
  shared_ptr<long> srcPort{};
  shared_ptr<long> probeInterval{};
  shared_ptr<long> probeCount{};
  shared_ptr<long> probeTimeout{};
  shared_ptr<long> rttThreshold{};
  shared_ptr<long> rttFailThreshold{};
  shared_ptr<long> failCountThreshold{};

  CreateHealthCheckRequest() {}

  explicit CreateHealthCheckRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (dstIpAddr) {
      res["DstIpAddr"] = boost::any(*dstIpAddr);
    }
    if (dstPort) {
      res["DstPort"] = boost::any(*dstPort);
    }
    if (srcIpAddr) {
      res["SrcIpAddr"] = boost::any(*srcIpAddr);
    }
    if (srcPort) {
      res["SrcPort"] = boost::any(*srcPort);
    }
    if (probeInterval) {
      res["ProbeInterval"] = boost::any(*probeInterval);
    }
    if (probeCount) {
      res["ProbeCount"] = boost::any(*probeCount);
    }
    if (probeTimeout) {
      res["ProbeTimeout"] = boost::any(*probeTimeout);
    }
    if (rttThreshold) {
      res["RttThreshold"] = boost::any(*rttThreshold);
    }
    if (rttFailThreshold) {
      res["RttFailThreshold"] = boost::any(*rttFailThreshold);
    }
    if (failCountThreshold) {
      res["FailCountThreshold"] = boost::any(*failCountThreshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("DstIpAddr") != m.end() && !m["DstIpAddr"].empty()) {
      dstIpAddr = make_shared<string>(boost::any_cast<string>(m["DstIpAddr"]));
    }
    if (m.find("DstPort") != m.end() && !m["DstPort"].empty()) {
      dstPort = make_shared<long>(boost::any_cast<long>(m["DstPort"]));
    }
    if (m.find("SrcIpAddr") != m.end() && !m["SrcIpAddr"].empty()) {
      srcIpAddr = make_shared<string>(boost::any_cast<string>(m["SrcIpAddr"]));
    }
    if (m.find("SrcPort") != m.end() && !m["SrcPort"].empty()) {
      srcPort = make_shared<long>(boost::any_cast<long>(m["SrcPort"]));
    }
    if (m.find("ProbeInterval") != m.end() && !m["ProbeInterval"].empty()) {
      probeInterval = make_shared<long>(boost::any_cast<long>(m["ProbeInterval"]));
    }
    if (m.find("ProbeCount") != m.end() && !m["ProbeCount"].empty()) {
      probeCount = make_shared<long>(boost::any_cast<long>(m["ProbeCount"]));
    }
    if (m.find("ProbeTimeout") != m.end() && !m["ProbeTimeout"].empty()) {
      probeTimeout = make_shared<long>(boost::any_cast<long>(m["ProbeTimeout"]));
    }
    if (m.find("RttThreshold") != m.end() && !m["RttThreshold"].empty()) {
      rttThreshold = make_shared<long>(boost::any_cast<long>(m["RttThreshold"]));
    }
    if (m.find("RttFailThreshold") != m.end() && !m["RttFailThreshold"].empty()) {
      rttFailThreshold = make_shared<long>(boost::any_cast<long>(m["RttFailThreshold"]));
    }
    if (m.find("FailCountThreshold") != m.end() && !m["FailCountThreshold"].empty()) {
      failCountThreshold = make_shared<long>(boost::any_cast<long>(m["FailCountThreshold"]));
    }
  }


  virtual ~CreateHealthCheckRequest() = default;
};
class CreateHealthCheckResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> instanceId{};

  CreateHealthCheckResponseBody() {}

  explicit CreateHealthCheckResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~CreateHealthCheckResponseBody() = default;
};
class CreateHealthCheckResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateHealthCheckResponseBody> body{};

  CreateHealthCheckResponse() {}

  explicit CreateHealthCheckResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateHealthCheckResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateHealthCheckResponseBody>(model1);
      }
    }
  }


  virtual ~CreateHealthCheckResponse() = default;
};
class ModifySagRemoteAccessRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> remoteAccessIp{};

  ModifySagRemoteAccessRequest() {}

  explicit ModifySagRemoteAccessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (remoteAccessIp) {
      res["RemoteAccessIp"] = boost::any(*remoteAccessIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("RemoteAccessIp") != m.end() && !m["RemoteAccessIp"].empty()) {
      remoteAccessIp = make_shared<string>(boost::any_cast<string>(m["RemoteAccessIp"]));
    }
  }


  virtual ~ModifySagRemoteAccessRequest() = default;
};
class ModifySagRemoteAccessResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> serialNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<string> message{};
  shared_ptr<string> remoteAccessIp{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  ModifySagRemoteAccessResponseBody() {}

  explicit ModifySagRemoteAccessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (remoteAccessIp) {
      res["RemoteAccessIp"] = boost::any(*remoteAccessIp);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RemoteAccessIp") != m.end() && !m["RemoteAccessIp"].empty()) {
      remoteAccessIp = make_shared<string>(boost::any_cast<string>(m["RemoteAccessIp"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~ModifySagRemoteAccessResponseBody() = default;
};
class ModifySagRemoteAccessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySagRemoteAccessResponseBody> body{};

  ModifySagRemoteAccessResponse() {}

  explicit ModifySagRemoteAccessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySagRemoteAccessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySagRemoteAccessResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySagRemoteAccessResponse() = default;
};
class RevokeSagInstanceFromCcnRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> ccnInstanceId{};

  RevokeSagInstanceFromCcnRequest() {}

  explicit RevokeSagInstanceFromCcnRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (ccnInstanceId) {
      res["CcnInstanceId"] = boost::any(*ccnInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("CcnInstanceId") != m.end() && !m["CcnInstanceId"].empty()) {
      ccnInstanceId = make_shared<string>(boost::any_cast<string>(m["CcnInstanceId"]));
    }
  }


  virtual ~RevokeSagInstanceFromCcnRequest() = default;
};
class RevokeSagInstanceFromCcnResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RevokeSagInstanceFromCcnResponseBody() {}

  explicit RevokeSagInstanceFromCcnResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RevokeSagInstanceFromCcnResponseBody() = default;
};
class RevokeSagInstanceFromCcnResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RevokeSagInstanceFromCcnResponseBody> body{};

  RevokeSagInstanceFromCcnResponse() {}

  explicit RevokeSagInstanceFromCcnResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokeSagInstanceFromCcnResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokeSagInstanceFromCcnResponseBody>(model1);
      }
    }
  }


  virtual ~RevokeSagInstanceFromCcnResponse() = default;
};
class DeleteEnterpriseCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> enterpriseCode{};
  shared_ptr<string> clientToken{};

  DeleteEnterpriseCodeRequest() {}

  explicit DeleteEnterpriseCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (enterpriseCode) {
      res["EnterpriseCode"] = boost::any(*enterpriseCode);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("EnterpriseCode") != m.end() && !m["EnterpriseCode"].empty()) {
      enterpriseCode = make_shared<string>(boost::any_cast<string>(m["EnterpriseCode"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~DeleteEnterpriseCodeRequest() = default;
};
class DeleteEnterpriseCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteEnterpriseCodeResponseBody() {}

  explicit DeleteEnterpriseCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteEnterpriseCodeResponseBody() = default;
};
class DeleteEnterpriseCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteEnterpriseCodeResponseBody> body{};

  DeleteEnterpriseCodeResponse() {}

  explicit DeleteEnterpriseCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteEnterpriseCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteEnterpriseCodeResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteEnterpriseCodeResponse() = default;
};
class DeleteSmartAccessGatewayClientUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> userName{};

  DeleteSmartAccessGatewayClientUserRequest() {}

  explicit DeleteSmartAccessGatewayClientUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DeleteSmartAccessGatewayClientUserRequest() = default;
};
class DeleteSmartAccessGatewayClientUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSmartAccessGatewayClientUserResponseBody() {}

  explicit DeleteSmartAccessGatewayClientUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSmartAccessGatewayClientUserResponseBody() = default;
};
class DeleteSmartAccessGatewayClientUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteSmartAccessGatewayClientUserResponseBody> body{};

  DeleteSmartAccessGatewayClientUserResponse() {}

  explicit DeleteSmartAccessGatewayClientUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSmartAccessGatewayClientUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSmartAccessGatewayClientUserResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSmartAccessGatewayClientUserResponse() = default;
};
class ListSmartAGByAccessPointRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> accessPointId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> smartAGStatus{};

  ListSmartAGByAccessPointRequest() {}

  explicit ListSmartAGByAccessPointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (accessPointId) {
      res["AccessPointId"] = boost::any(*accessPointId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (smartAGStatus) {
      res["SmartAGStatus"] = boost::any(*smartAGStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("AccessPointId") != m.end() && !m["AccessPointId"].empty()) {
      accessPointId = make_shared<long>(boost::any_cast<long>(m["AccessPointId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("SmartAGStatus") != m.end() && !m["SmartAGStatus"].empty()) {
      smartAGStatus = make_shared<string>(boost::any_cast<string>(m["SmartAGStatus"]));
    }
  }


  virtual ~ListSmartAGByAccessPointRequest() = default;
};
class ListSmartAGByAccessPointResponseBodySmartAccessGateways : public Darabonba::Model {
public:
  shared_ptr<string> routingStrategy{};
  shared_ptr<string> smartAGName{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGStatus{};
  shared_ptr<string> smartAGDescription{};
  shared_ptr<string> associatedCcnId{};
  shared_ptr<string> hardwareVersion{};

  ListSmartAGByAccessPointResponseBodySmartAccessGateways() {}

  explicit ListSmartAGByAccessPointResponseBodySmartAccessGateways(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (routingStrategy) {
      res["RoutingStrategy"] = boost::any(*routingStrategy);
    }
    if (smartAGName) {
      res["SmartAGName"] = boost::any(*smartAGName);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGStatus) {
      res["SmartAGStatus"] = boost::any(*smartAGStatus);
    }
    if (smartAGDescription) {
      res["SmartAGDescription"] = boost::any(*smartAGDescription);
    }
    if (associatedCcnId) {
      res["AssociatedCcnId"] = boost::any(*associatedCcnId);
    }
    if (hardwareVersion) {
      res["HardwareVersion"] = boost::any(*hardwareVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RoutingStrategy") != m.end() && !m["RoutingStrategy"].empty()) {
      routingStrategy = make_shared<string>(boost::any_cast<string>(m["RoutingStrategy"]));
    }
    if (m.find("SmartAGName") != m.end() && !m["SmartAGName"].empty()) {
      smartAGName = make_shared<string>(boost::any_cast<string>(m["SmartAGName"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGStatus") != m.end() && !m["SmartAGStatus"].empty()) {
      smartAGStatus = make_shared<string>(boost::any_cast<string>(m["SmartAGStatus"]));
    }
    if (m.find("SmartAGDescription") != m.end() && !m["SmartAGDescription"].empty()) {
      smartAGDescription = make_shared<string>(boost::any_cast<string>(m["SmartAGDescription"]));
    }
    if (m.find("AssociatedCcnId") != m.end() && !m["AssociatedCcnId"].empty()) {
      associatedCcnId = make_shared<string>(boost::any_cast<string>(m["AssociatedCcnId"]));
    }
    if (m.find("HardwareVersion") != m.end() && !m["HardwareVersion"].empty()) {
      hardwareVersion = make_shared<string>(boost::any_cast<string>(m["HardwareVersion"]));
    }
  }


  virtual ~ListSmartAGByAccessPointResponseBodySmartAccessGateways() = default;
};
class ListSmartAGByAccessPointResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSmartAGByAccessPointResponseBodySmartAccessGateways>> smartAccessGateways{};

  ListSmartAGByAccessPointResponseBody() {}

  explicit ListSmartAGByAccessPointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (smartAccessGateways) {
      vector<boost::any> temp1;
      for(auto item1:*smartAccessGateways){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SmartAccessGateways"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SmartAccessGateways") != m.end() && !m["SmartAccessGateways"].empty()) {
      if (typeid(vector<boost::any>) == m["SmartAccessGateways"].type()) {
        vector<ListSmartAGByAccessPointResponseBodySmartAccessGateways> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SmartAccessGateways"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSmartAGByAccessPointResponseBodySmartAccessGateways model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        smartAccessGateways = make_shared<vector<ListSmartAGByAccessPointResponseBodySmartAccessGateways>>(expect1);
      }
    }
  }


  virtual ~ListSmartAGByAccessPointResponseBody() = default;
};
class ListSmartAGByAccessPointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListSmartAGByAccessPointResponseBody> body{};

  ListSmartAGByAccessPointResponse() {}

  explicit ListSmartAGByAccessPointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSmartAGByAccessPointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSmartAGByAccessPointResponseBody>(model1);
      }
    }
  }


  virtual ~ListSmartAGByAccessPointResponse() = default;
};
class DescribeGrantRulesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> associatedCcnId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};

  DescribeGrantRulesRequest() {}

  explicit DescribeGrantRulesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (associatedCcnId) {
      res["AssociatedCcnId"] = boost::any(*associatedCcnId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AssociatedCcnId") != m.end() && !m["AssociatedCcnId"].empty()) {
      associatedCcnId = make_shared<string>(boost::any_cast<string>(m["AssociatedCcnId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~DescribeGrantRulesRequest() = default;
};
class DescribeGrantRulesResponseBodyGrantRulesGrantRule : public Darabonba::Model {
public:
  shared_ptr<string> cenInstanceId{};
  shared_ptr<long> cenUid{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> grantRuleId{};
  shared_ptr<bool> grantTrafficService{};
  shared_ptr<long> gmtModified{};
  shared_ptr<long> ccnUid{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ccnInstanceId{};

  DescribeGrantRulesResponseBodyGrantRulesGrantRule() {}

  explicit DescribeGrantRulesResponseBodyGrantRulesGrantRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cenInstanceId) {
      res["CenInstanceId"] = boost::any(*cenInstanceId);
    }
    if (cenUid) {
      res["CenUid"] = boost::any(*cenUid);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (grantRuleId) {
      res["GrantRuleId"] = boost::any(*grantRuleId);
    }
    if (grantTrafficService) {
      res["GrantTrafficService"] = boost::any(*grantTrafficService);
    }
    if (gmtModified) {
      res["GmtModified"] = boost::any(*gmtModified);
    }
    if (ccnUid) {
      res["CcnUid"] = boost::any(*ccnUid);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ccnInstanceId) {
      res["CcnInstanceId"] = boost::any(*ccnInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CenInstanceId") != m.end() && !m["CenInstanceId"].empty()) {
      cenInstanceId = make_shared<string>(boost::any_cast<string>(m["CenInstanceId"]));
    }
    if (m.find("CenUid") != m.end() && !m["CenUid"].empty()) {
      cenUid = make_shared<long>(boost::any_cast<long>(m["CenUid"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("GrantRuleId") != m.end() && !m["GrantRuleId"].empty()) {
      grantRuleId = make_shared<string>(boost::any_cast<string>(m["GrantRuleId"]));
    }
    if (m.find("GrantTrafficService") != m.end() && !m["GrantTrafficService"].empty()) {
      grantTrafficService = make_shared<bool>(boost::any_cast<bool>(m["GrantTrafficService"]));
    }
    if (m.find("GmtModified") != m.end() && !m["GmtModified"].empty()) {
      gmtModified = make_shared<long>(boost::any_cast<long>(m["GmtModified"]));
    }
    if (m.find("CcnUid") != m.end() && !m["CcnUid"].empty()) {
      ccnUid = make_shared<long>(boost::any_cast<long>(m["CcnUid"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("CcnInstanceId") != m.end() && !m["CcnInstanceId"].empty()) {
      ccnInstanceId = make_shared<string>(boost::any_cast<string>(m["CcnInstanceId"]));
    }
  }


  virtual ~DescribeGrantRulesResponseBodyGrantRulesGrantRule() = default;
};
class DescribeGrantRulesResponseBodyGrantRules : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeGrantRulesResponseBodyGrantRulesGrantRule>> grantRule{};

  DescribeGrantRulesResponseBodyGrantRules() {}

  explicit DescribeGrantRulesResponseBodyGrantRules(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (grantRule) {
      vector<boost::any> temp1;
      for(auto item1:*grantRule){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["GrantRule"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GrantRule") != m.end() && !m["GrantRule"].empty()) {
      if (typeid(vector<boost::any>) == m["GrantRule"].type()) {
        vector<DescribeGrantRulesResponseBodyGrantRulesGrantRule> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["GrantRule"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeGrantRulesResponseBodyGrantRulesGrantRule model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        grantRule = make_shared<vector<DescribeGrantRulesResponseBodyGrantRulesGrantRule>>(expect1);
      }
    }
  }


  virtual ~DescribeGrantRulesResponseBodyGrantRules() = default;
};
class DescribeGrantRulesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<DescribeGrantRulesResponseBodyGrantRules> grantRules{};

  DescribeGrantRulesResponseBody() {}

  explicit DescribeGrantRulesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (grantRules) {
      res["GrantRules"] = grantRules ? boost::any(grantRules->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("GrantRules") != m.end() && !m["GrantRules"].empty()) {
      if (typeid(map<string, boost::any>) == m["GrantRules"].type()) {
        DescribeGrantRulesResponseBodyGrantRules model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["GrantRules"]));
        grantRules = make_shared<DescribeGrantRulesResponseBodyGrantRules>(model1);
      }
    }
  }


  virtual ~DescribeGrantRulesResponseBody() = default;
};
class DescribeGrantRulesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeGrantRulesResponseBody> body{};

  DescribeGrantRulesResponse() {}

  explicit DescribeGrantRulesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeGrantRulesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeGrantRulesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeGrantRulesResponse() = default;
};
class CreateSagExpressConnectInterfaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};
  shared_ptr<string> portName{};
  shared_ptr<string> vlan{};
  shared_ptr<string> IP{};
  shared_ptr<string> mask{};

  CreateSagExpressConnectInterfaceRequest() {}

  explicit CreateSagExpressConnectInterfaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    if (portName) {
      res["PortName"] = boost::any(*portName);
    }
    if (vlan) {
      res["Vlan"] = boost::any(*vlan);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (mask) {
      res["Mask"] = boost::any(*mask);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
    if (m.find("PortName") != m.end() && !m["PortName"].empty()) {
      portName = make_shared<string>(boost::any_cast<string>(m["PortName"]));
    }
    if (m.find("Vlan") != m.end() && !m["Vlan"].empty()) {
      vlan = make_shared<string>(boost::any_cast<string>(m["Vlan"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("Mask") != m.end() && !m["Mask"].empty()) {
      mask = make_shared<string>(boost::any_cast<string>(m["Mask"]));
    }
  }


  virtual ~CreateSagExpressConnectInterfaceRequest() = default;
};
class CreateSagExpressConnectInterfaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  CreateSagExpressConnectInterfaceResponseBody() {}

  explicit CreateSagExpressConnectInterfaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateSagExpressConnectInterfaceResponseBody() = default;
};
class CreateSagExpressConnectInterfaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateSagExpressConnectInterfaceResponseBody> body{};

  CreateSagExpressConnectInterfaceResponse() {}

  explicit CreateSagExpressConnectInterfaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSagExpressConnectInterfaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSagExpressConnectInterfaceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSagExpressConnectInterfaceResponse() = default;
};
class UnbindSmartAccessGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ccnId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> smartAGUid{};

  UnbindSmartAccessGatewayRequest() {}

  explicit UnbindSmartAccessGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ccnId) {
      res["CcnId"] = boost::any(*ccnId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGUid) {
      res["SmartAGUid"] = boost::any(*smartAGUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("CcnId") != m.end() && !m["CcnId"].empty()) {
      ccnId = make_shared<string>(boost::any_cast<string>(m["CcnId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGUid") != m.end() && !m["SmartAGUid"].empty()) {
      smartAGUid = make_shared<long>(boost::any_cast<long>(m["SmartAGUid"]));
    }
  }


  virtual ~UnbindSmartAccessGatewayRequest() = default;
};
class UnbindSmartAccessGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnbindSmartAccessGatewayResponseBody() {}

  explicit UnbindSmartAccessGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnbindSmartAccessGatewayResponseBody() = default;
};
class UnbindSmartAccessGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UnbindSmartAccessGatewayResponseBody> body{};

  UnbindSmartAccessGatewayResponse() {}

  explicit UnbindSmartAccessGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindSmartAccessGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindSmartAccessGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindSmartAccessGatewayResponse() = default;
};
class CreateSmartAccessGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> maxBandWidth{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<long> period{};
  shared_ptr<bool> autoPay{};
  shared_ptr<string> hardWareSpec{};
  shared_ptr<string> receiverCountry{};
  shared_ptr<string> receiverState{};
  shared_ptr<string> receiverCity{};
  shared_ptr<string> receiverDistrict{};
  shared_ptr<string> receiverTown{};
  shared_ptr<string> receiverZip{};
  shared_ptr<string> receiverPhone{};
  shared_ptr<string> receiverMobile{};
  shared_ptr<string> receiverName{};
  shared_ptr<string> receiverEmail{};
  shared_ptr<string> buyerMessage{};
  shared_ptr<string> receiverAddress{};
  shared_ptr<string> haType{};
  shared_ptr<string> chargeType{};
  shared_ptr<bool> alreadyHaveSag{};
  shared_ptr<string> CPEVersion{};

  CreateSmartAccessGatewayRequest() {}

  explicit CreateSmartAccessGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (maxBandWidth) {
      res["MaxBandWidth"] = boost::any(*maxBandWidth);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (hardWareSpec) {
      res["HardWareSpec"] = boost::any(*hardWareSpec);
    }
    if (receiverCountry) {
      res["ReceiverCountry"] = boost::any(*receiverCountry);
    }
    if (receiverState) {
      res["ReceiverState"] = boost::any(*receiverState);
    }
    if (receiverCity) {
      res["ReceiverCity"] = boost::any(*receiverCity);
    }
    if (receiverDistrict) {
      res["ReceiverDistrict"] = boost::any(*receiverDistrict);
    }
    if (receiverTown) {
      res["ReceiverTown"] = boost::any(*receiverTown);
    }
    if (receiverZip) {
      res["ReceiverZip"] = boost::any(*receiverZip);
    }
    if (receiverPhone) {
      res["ReceiverPhone"] = boost::any(*receiverPhone);
    }
    if (receiverMobile) {
      res["ReceiverMobile"] = boost::any(*receiverMobile);
    }
    if (receiverName) {
      res["ReceiverName"] = boost::any(*receiverName);
    }
    if (receiverEmail) {
      res["ReceiverEmail"] = boost::any(*receiverEmail);
    }
    if (buyerMessage) {
      res["BuyerMessage"] = boost::any(*buyerMessage);
    }
    if (receiverAddress) {
      res["ReceiverAddress"] = boost::any(*receiverAddress);
    }
    if (haType) {
      res["HaType"] = boost::any(*haType);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (alreadyHaveSag) {
      res["AlreadyHaveSag"] = boost::any(*alreadyHaveSag);
    }
    if (CPEVersion) {
      res["CPEVersion"] = boost::any(*CPEVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("MaxBandWidth") != m.end() && !m["MaxBandWidth"].empty()) {
      maxBandWidth = make_shared<long>(boost::any_cast<long>(m["MaxBandWidth"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("HardWareSpec") != m.end() && !m["HardWareSpec"].empty()) {
      hardWareSpec = make_shared<string>(boost::any_cast<string>(m["HardWareSpec"]));
    }
    if (m.find("ReceiverCountry") != m.end() && !m["ReceiverCountry"].empty()) {
      receiverCountry = make_shared<string>(boost::any_cast<string>(m["ReceiverCountry"]));
    }
    if (m.find("ReceiverState") != m.end() && !m["ReceiverState"].empty()) {
      receiverState = make_shared<string>(boost::any_cast<string>(m["ReceiverState"]));
    }
    if (m.find("ReceiverCity") != m.end() && !m["ReceiverCity"].empty()) {
      receiverCity = make_shared<string>(boost::any_cast<string>(m["ReceiverCity"]));
    }
    if (m.find("ReceiverDistrict") != m.end() && !m["ReceiverDistrict"].empty()) {
      receiverDistrict = make_shared<string>(boost::any_cast<string>(m["ReceiverDistrict"]));
    }
    if (m.find("ReceiverTown") != m.end() && !m["ReceiverTown"].empty()) {
      receiverTown = make_shared<string>(boost::any_cast<string>(m["ReceiverTown"]));
    }
    if (m.find("ReceiverZip") != m.end() && !m["ReceiverZip"].empty()) {
      receiverZip = make_shared<string>(boost::any_cast<string>(m["ReceiverZip"]));
    }
    if (m.find("ReceiverPhone") != m.end() && !m["ReceiverPhone"].empty()) {
      receiverPhone = make_shared<string>(boost::any_cast<string>(m["ReceiverPhone"]));
    }
    if (m.find("ReceiverMobile") != m.end() && !m["ReceiverMobile"].empty()) {
      receiverMobile = make_shared<string>(boost::any_cast<string>(m["ReceiverMobile"]));
    }
    if (m.find("ReceiverName") != m.end() && !m["ReceiverName"].empty()) {
      receiverName = make_shared<string>(boost::any_cast<string>(m["ReceiverName"]));
    }
    if (m.find("ReceiverEmail") != m.end() && !m["ReceiverEmail"].empty()) {
      receiverEmail = make_shared<string>(boost::any_cast<string>(m["ReceiverEmail"]));
    }
    if (m.find("BuyerMessage") != m.end() && !m["BuyerMessage"].empty()) {
      buyerMessage = make_shared<string>(boost::any_cast<string>(m["BuyerMessage"]));
    }
    if (m.find("ReceiverAddress") != m.end() && !m["ReceiverAddress"].empty()) {
      receiverAddress = make_shared<string>(boost::any_cast<string>(m["ReceiverAddress"]));
    }
    if (m.find("HaType") != m.end() && !m["HaType"].empty()) {
      haType = make_shared<string>(boost::any_cast<string>(m["HaType"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("AlreadyHaveSag") != m.end() && !m["AlreadyHaveSag"].empty()) {
      alreadyHaveSag = make_shared<bool>(boost::any_cast<bool>(m["AlreadyHaveSag"]));
    }
    if (m.find("CPEVersion") != m.end() && !m["CPEVersion"].empty()) {
      CPEVersion = make_shared<string>(boost::any_cast<string>(m["CPEVersion"]));
    }
  }


  virtual ~CreateSmartAccessGatewayRequest() = default;
};
class CreateSmartAccessGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> requestId{};
  shared_ptr<string> orderId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> name{};
  shared_ptr<string> resourceGroupId{};

  CreateSmartAccessGatewayResponseBody() {}

  explicit CreateSmartAccessGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~CreateSmartAccessGatewayResponseBody() = default;
};
class CreateSmartAccessGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateSmartAccessGatewayResponseBody> body{};

  CreateSmartAccessGatewayResponse() {}

  explicit CreateSmartAccessGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSmartAccessGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSmartAccessGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSmartAccessGatewayResponse() = default;
};
class DeleteFlowLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> flowLogId{};

  DeleteFlowLogRequest() {}

  explicit DeleteFlowLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (flowLogId) {
      res["FlowLogId"] = boost::any(*flowLogId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("FlowLogId") != m.end() && !m["FlowLogId"].empty()) {
      flowLogId = make_shared<string>(boost::any_cast<string>(m["FlowLogId"]));
    }
  }


  virtual ~DeleteFlowLogRequest() = default;
};
class DeleteFlowLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteFlowLogResponseBody() {}

  explicit DeleteFlowLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteFlowLogResponseBody() = default;
};
class DeleteFlowLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteFlowLogResponseBody> body{};

  DeleteFlowLogResponse() {}

  explicit DeleteFlowLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFlowLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFlowLogResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFlowLogResponse() = default;
};
class DescribeSagOnlineClientStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<string>> smartAGIds{};

  DescribeSagOnlineClientStatisticsRequest() {}

  explicit DescribeSagOnlineClientStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGIds) {
      res["SmartAGIds"] = boost::any(*smartAGIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGIds") != m.end() && !m["SmartAGIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SmartAGIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SmartAGIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      smartAGIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSagOnlineClientStatisticsRequest() = default;
};
class DescribeSagOnlineClientStatisticsResponseBodySagStatisticsStatistics : public Darabonba::Model {
public:
  shared_ptr<string> smartAGId{};
  shared_ptr<string> onlineCount{};

  DescribeSagOnlineClientStatisticsResponseBodySagStatisticsStatistics() {}

  explicit DescribeSagOnlineClientStatisticsResponseBodySagStatisticsStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (onlineCount) {
      res["OnlineCount"] = boost::any(*onlineCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("OnlineCount") != m.end() && !m["OnlineCount"].empty()) {
      onlineCount = make_shared<string>(boost::any_cast<string>(m["OnlineCount"]));
    }
  }


  virtual ~DescribeSagOnlineClientStatisticsResponseBodySagStatisticsStatistics() = default;
};
class DescribeSagOnlineClientStatisticsResponseBodySagStatistics : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSagOnlineClientStatisticsResponseBodySagStatisticsStatistics>> statistics{};

  DescribeSagOnlineClientStatisticsResponseBodySagStatistics() {}

  explicit DescribeSagOnlineClientStatisticsResponseBodySagStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (statistics) {
      vector<boost::any> temp1;
      for(auto item1:*statistics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Statistics"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      if (typeid(vector<boost::any>) == m["Statistics"].type()) {
        vector<DescribeSagOnlineClientStatisticsResponseBodySagStatisticsStatistics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Statistics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSagOnlineClientStatisticsResponseBodySagStatisticsStatistics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statistics = make_shared<vector<DescribeSagOnlineClientStatisticsResponseBodySagStatisticsStatistics>>(expect1);
      }
    }
  }


  virtual ~DescribeSagOnlineClientStatisticsResponseBodySagStatistics() = default;
};
class DescribeSagOnlineClientStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeSagOnlineClientStatisticsResponseBodySagStatistics> sagStatistics{};
  shared_ptr<string> requestId{};

  DescribeSagOnlineClientStatisticsResponseBody() {}

  explicit DescribeSagOnlineClientStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sagStatistics) {
      res["SagStatistics"] = sagStatistics ? boost::any(sagStatistics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SagStatistics") != m.end() && !m["SagStatistics"].empty()) {
      if (typeid(map<string, boost::any>) == m["SagStatistics"].type()) {
        DescribeSagOnlineClientStatisticsResponseBodySagStatistics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SagStatistics"]));
        sagStatistics = make_shared<DescribeSagOnlineClientStatisticsResponseBodySagStatistics>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeSagOnlineClientStatisticsResponseBody() = default;
};
class DescribeSagOnlineClientStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSagOnlineClientStatisticsResponseBody> body{};

  DescribeSagOnlineClientStatisticsResponse() {}

  explicit DescribeSagOnlineClientStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSagOnlineClientStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSagOnlineClientStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSagOnlineClientStatisticsResponse() = default;
};
class ModifyCloudConnectNetworkRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ccnId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> regionId{};
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> interworkingStatus{};

  ModifyCloudConnectNetworkRequest() {}

  explicit ModifyCloudConnectNetworkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ccnId) {
      res["CcnId"] = boost::any(*ccnId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (interworkingStatus) {
      res["InterworkingStatus"] = boost::any(*interworkingStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("CcnId") != m.end() && !m["CcnId"].empty()) {
      ccnId = make_shared<string>(boost::any_cast<string>(m["CcnId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("InterworkingStatus") != m.end() && !m["InterworkingStatus"].empty()) {
      interworkingStatus = make_shared<string>(boost::any_cast<string>(m["InterworkingStatus"]));
    }
  }


  virtual ~ModifyCloudConnectNetworkRequest() = default;
};
class ModifyCloudConnectNetworkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyCloudConnectNetworkResponseBody() {}

  explicit ModifyCloudConnectNetworkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyCloudConnectNetworkResponseBody() = default;
};
class ModifyCloudConnectNetworkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyCloudConnectNetworkResponseBody> body{};

  ModifyCloudConnectNetworkResponse() {}

  explicit ModifyCloudConnectNetworkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyCloudConnectNetworkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyCloudConnectNetworkResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyCloudConnectNetworkResponse() = default;
};
class ModifySmartAccessGatewayUpBandwidthRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> upBandwidthWan{};
  shared_ptr<long> upBandwidth4G{};

  ModifySmartAccessGatewayUpBandwidthRequest() {}

  explicit ModifySmartAccessGatewayUpBandwidthRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (upBandwidthWan) {
      res["UpBandwidthWan"] = boost::any(*upBandwidthWan);
    }
    if (upBandwidth4G) {
      res["UpBandwidth4G"] = boost::any(*upBandwidth4G);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("UpBandwidthWan") != m.end() && !m["UpBandwidthWan"].empty()) {
      upBandwidthWan = make_shared<long>(boost::any_cast<long>(m["UpBandwidthWan"]));
    }
    if (m.find("UpBandwidth4G") != m.end() && !m["UpBandwidth4G"].empty()) {
      upBandwidth4G = make_shared<long>(boost::any_cast<long>(m["UpBandwidth4G"]));
    }
  }


  virtual ~ModifySmartAccessGatewayUpBandwidthRequest() = default;
};
class ModifySmartAccessGatewayUpBandwidthResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySmartAccessGatewayUpBandwidthResponseBody() {}

  explicit ModifySmartAccessGatewayUpBandwidthResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySmartAccessGatewayUpBandwidthResponseBody() = default;
};
class ModifySmartAccessGatewayUpBandwidthResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySmartAccessGatewayUpBandwidthResponseBody> body{};

  ModifySmartAccessGatewayUpBandwidthResponse() {}

  explicit ModifySmartAccessGatewayUpBandwidthResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySmartAccessGatewayUpBandwidthResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySmartAccessGatewayUpBandwidthResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySmartAccessGatewayUpBandwidthResponse() = default;
};
class GrantSagInstanceToCcnRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> ccnInstanceId{};
  shared_ptr<long> ccnUid{};
  shared_ptr<bool> grantTrafficService{};

  GrantSagInstanceToCcnRequest() {}

  explicit GrantSagInstanceToCcnRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (ccnInstanceId) {
      res["CcnInstanceId"] = boost::any(*ccnInstanceId);
    }
    if (ccnUid) {
      res["CcnUid"] = boost::any(*ccnUid);
    }
    if (grantTrafficService) {
      res["GrantTrafficService"] = boost::any(*grantTrafficService);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("CcnInstanceId") != m.end() && !m["CcnInstanceId"].empty()) {
      ccnInstanceId = make_shared<string>(boost::any_cast<string>(m["CcnInstanceId"]));
    }
    if (m.find("CcnUid") != m.end() && !m["CcnUid"].empty()) {
      ccnUid = make_shared<long>(boost::any_cast<long>(m["CcnUid"]));
    }
    if (m.find("GrantTrafficService") != m.end() && !m["GrantTrafficService"].empty()) {
      grantTrafficService = make_shared<bool>(boost::any_cast<bool>(m["GrantTrafficService"]));
    }
  }


  virtual ~GrantSagInstanceToCcnRequest() = default;
};
class GrantSagInstanceToCcnResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> instanceId{};

  GrantSagInstanceToCcnResponseBody() {}

  explicit GrantSagInstanceToCcnResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~GrantSagInstanceToCcnResponseBody() = default;
};
class GrantSagInstanceToCcnResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GrantSagInstanceToCcnResponseBody> body{};

  GrantSagInstanceToCcnResponse() {}

  explicit GrantSagInstanceToCcnResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GrantSagInstanceToCcnResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GrantSagInstanceToCcnResponseBody>(model1);
      }
    }
  }


  virtual ~GrantSagInstanceToCcnResponse() = default;
};
class ModifySmartAccessGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> name{};
  shared_ptr<string> description{};
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> regionId{};
  shared_ptr<long> securityLockThreshold{};
  shared_ptr<string> routingStrategy{};

  ModifySmartAccessGatewayRequest() {}

  explicit ModifySmartAccessGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (securityLockThreshold) {
      res["SecurityLockThreshold"] = boost::any(*securityLockThreshold);
    }
    if (routingStrategy) {
      res["RoutingStrategy"] = boost::any(*routingStrategy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SecurityLockThreshold") != m.end() && !m["SecurityLockThreshold"].empty()) {
      securityLockThreshold = make_shared<long>(boost::any_cast<long>(m["SecurityLockThreshold"]));
    }
    if (m.find("RoutingStrategy") != m.end() && !m["RoutingStrategy"].empty()) {
      routingStrategy = make_shared<string>(boost::any_cast<string>(m["RoutingStrategy"]));
    }
  }


  virtual ~ModifySmartAccessGatewayRequest() = default;
};
class ModifySmartAccessGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySmartAccessGatewayResponseBody() {}

  explicit ModifySmartAccessGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySmartAccessGatewayResponseBody() = default;
};
class ModifySmartAccessGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySmartAccessGatewayResponseBody> body{};

  ModifySmartAccessGatewayResponse() {}

  explicit ModifySmartAccessGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySmartAccessGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySmartAccessGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySmartAccessGatewayResponse() = default;
};
class UpdateSmartAccessGatewayVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> versionCode{};
  shared_ptr<string> regionId{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> versionType{};

  UpdateSmartAccessGatewayVersionRequest() {}

  explicit UpdateSmartAccessGatewayVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
  }


  virtual ~UpdateSmartAccessGatewayVersionRequest() = default;
};
class UpdateSmartAccessGatewayVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateSmartAccessGatewayVersionResponseBody() {}

  explicit UpdateSmartAccessGatewayVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateSmartAccessGatewayVersionResponseBody() = default;
};
class UpdateSmartAccessGatewayVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateSmartAccessGatewayVersionResponseBody> body{};

  UpdateSmartAccessGatewayVersionResponse() {}

  explicit UpdateSmartAccessGatewayVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSmartAccessGatewayVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSmartAccessGatewayVersionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSmartAccessGatewayVersionResponse() = default;
};
class DescribeSagDropTopNRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> size{};

  DescribeSagDropTopNRequest() {}

  explicit DescribeSagDropTopNRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
  }


  virtual ~DescribeSagDropTopNRequest() = default;
};
class DescribeSagDropTopNResponseBodyDropTopN : public Darabonba::Model {
public:
  shared_ptr<string> dropRate{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<string> regionId{};

  DescribeSagDropTopNResponseBodyDropTopN() {}

  explicit DescribeSagDropTopNResponseBodyDropTopN(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dropRate) {
      res["DropRate"] = boost::any(*dropRate);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DropRate") != m.end() && !m["DropRate"].empty()) {
      dropRate = make_shared<string>(boost::any_cast<string>(m["DropRate"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeSagDropTopNResponseBodyDropTopN() = default;
};
class DescribeSagDropTopNResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSagDropTopNResponseBodyDropTopN>> dropTopN{};

  DescribeSagDropTopNResponseBody() {}

  explicit DescribeSagDropTopNResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (dropTopN) {
      vector<boost::any> temp1;
      for(auto item1:*dropTopN){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DropTopN"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DropTopN") != m.end() && !m["DropTopN"].empty()) {
      if (typeid(vector<boost::any>) == m["DropTopN"].type()) {
        vector<DescribeSagDropTopNResponseBodyDropTopN> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DropTopN"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSagDropTopNResponseBodyDropTopN model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dropTopN = make_shared<vector<DescribeSagDropTopNResponseBodyDropTopN>>(expect1);
      }
    }
  }


  virtual ~DescribeSagDropTopNResponseBody() = default;
};
class DescribeSagDropTopNResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSagDropTopNResponseBody> body{};

  DescribeSagDropTopNResponse() {}

  explicit DescribeSagDropTopNResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSagDropTopNResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSagDropTopNResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSagDropTopNResponse() = default;
};
class DescribeSagLanListRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};

  DescribeSagLanListRequest() {}

  explicit DescribeSagLanListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
  }


  virtual ~DescribeSagLanListRequest() = default;
};
class DescribeSagLanListResponseBodyTaskStates : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> state{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> createTime{};

  DescribeSagLanListResponseBodyTaskStates() {}

  explicit DescribeSagLanListResponseBodyTaskStates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
  }


  virtual ~DescribeSagLanListResponseBodyTaskStates() = default;
};
class DescribeSagLanListResponseBodyLans : public Darabonba::Model {
public:
  shared_ptr<string> lease{};
  shared_ptr<string> mask{};
  shared_ptr<string> endIp{};
  shared_ptr<string> portName{};
  shared_ptr<string> startIp{};
  shared_ptr<string> IPType{};
  shared_ptr<string> IP{};

  DescribeSagLanListResponseBodyLans() {}

  explicit DescribeSagLanListResponseBodyLans(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lease) {
      res["Lease"] = boost::any(*lease);
    }
    if (mask) {
      res["Mask"] = boost::any(*mask);
    }
    if (endIp) {
      res["EndIp"] = boost::any(*endIp);
    }
    if (portName) {
      res["PortName"] = boost::any(*portName);
    }
    if (startIp) {
      res["StartIp"] = boost::any(*startIp);
    }
    if (IPType) {
      res["IPType"] = boost::any(*IPType);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Lease") != m.end() && !m["Lease"].empty()) {
      lease = make_shared<string>(boost::any_cast<string>(m["Lease"]));
    }
    if (m.find("Mask") != m.end() && !m["Mask"].empty()) {
      mask = make_shared<string>(boost::any_cast<string>(m["Mask"]));
    }
    if (m.find("EndIp") != m.end() && !m["EndIp"].empty()) {
      endIp = make_shared<string>(boost::any_cast<string>(m["EndIp"]));
    }
    if (m.find("PortName") != m.end() && !m["PortName"].empty()) {
      portName = make_shared<string>(boost::any_cast<string>(m["PortName"]));
    }
    if (m.find("StartIp") != m.end() && !m["StartIp"].empty()) {
      startIp = make_shared<string>(boost::any_cast<string>(m["StartIp"]));
    }
    if (m.find("IPType") != m.end() && !m["IPType"].empty()) {
      IPType = make_shared<string>(boost::any_cast<string>(m["IPType"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
  }


  virtual ~DescribeSagLanListResponseBodyLans() = default;
};
class DescribeSagLanListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSagLanListResponseBodyTaskStates>> taskStates{};
  shared_ptr<vector<DescribeSagLanListResponseBodyLans>> lans{};

  DescribeSagLanListResponseBody() {}

  explicit DescribeSagLanListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskStates) {
      vector<boost::any> temp1;
      for(auto item1:*taskStates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskStates"] = boost::any(temp1);
    }
    if (lans) {
      vector<boost::any> temp1;
      for(auto item1:*lans){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Lans"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskStates") != m.end() && !m["TaskStates"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskStates"].type()) {
        vector<DescribeSagLanListResponseBodyTaskStates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskStates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSagLanListResponseBodyTaskStates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskStates = make_shared<vector<DescribeSagLanListResponseBodyTaskStates>>(expect1);
      }
    }
    if (m.find("Lans") != m.end() && !m["Lans"].empty()) {
      if (typeid(vector<boost::any>) == m["Lans"].type()) {
        vector<DescribeSagLanListResponseBodyLans> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Lans"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSagLanListResponseBodyLans model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        lans = make_shared<vector<DescribeSagLanListResponseBodyLans>>(expect1);
      }
    }
  }


  virtual ~DescribeSagLanListResponseBody() = default;
};
class DescribeSagLanListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSagLanListResponseBody> body{};

  DescribeSagLanListResponse() {}

  explicit DescribeSagLanListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSagLanListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSagLanListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSagLanListResponse() = default;
};
class DescribeACLAttributeRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> aclId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> direction{};
  shared_ptr<string> order{};
  shared_ptr<string> name{};

  DescribeACLAttributeRequest() {}

  explicit DescribeACLAttributeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeACLAttributeRequest() = default;
};
class DescribeACLAttributeResponseBodyAcrsAcrDpiSignatureIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dpiSignatureId{};

  DescribeACLAttributeResponseBodyAcrsAcrDpiSignatureIds() {}

  explicit DescribeACLAttributeResponseBodyAcrsAcrDpiSignatureIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dpiSignatureId) {
      res["DpiSignatureId"] = boost::any(*dpiSignatureId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DpiSignatureId") != m.end() && !m["DpiSignatureId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DpiSignatureId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DpiSignatureId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dpiSignatureId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeACLAttributeResponseBodyAcrsAcrDpiSignatureIds() = default;
};
class DescribeACLAttributeResponseBodyAcrsAcrDpiGroupIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dpiGroupId{};

  DescribeACLAttributeResponseBodyAcrsAcrDpiGroupIds() {}

  explicit DescribeACLAttributeResponseBodyAcrsAcrDpiGroupIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dpiGroupId) {
      res["DpiGroupId"] = boost::any(*dpiGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DpiGroupId") != m.end() && !m["DpiGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DpiGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DpiGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dpiGroupId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeACLAttributeResponseBodyAcrsAcrDpiGroupIds() = default;
};
class DescribeACLAttributeResponseBodyAcrsAcr : public Darabonba::Model {
public:
  shared_ptr<string> direction{};
  shared_ptr<string> type{};
  shared_ptr<DescribeACLAttributeResponseBodyAcrsAcrDpiSignatureIds> dpiSignatureIds{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<long> priority{};
  shared_ptr<string> aclId{};
  shared_ptr<string> policy{};
  shared_ptr<string> description{};
  shared_ptr<long> gmtCreate{};
  shared_ptr<string> destCidr{};
  shared_ptr<string> destPortRange{};
  shared_ptr<string> name{};
  shared_ptr<string> acrId{};
  shared_ptr<string> sourceCidr{};
  shared_ptr<string> sourcePortRange{};
  shared_ptr<DescribeACLAttributeResponseBodyAcrsAcrDpiGroupIds> dpiGroupIds{};

  DescribeACLAttributeResponseBodyAcrsAcr() {}

  explicit DescribeACLAttributeResponseBodyAcrsAcr(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (dpiSignatureIds) {
      res["DpiSignatureIds"] = dpiSignatureIds ? boost::any(dpiSignatureIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (gmtCreate) {
      res["GmtCreate"] = boost::any(*gmtCreate);
    }
    if (destCidr) {
      res["DestCidr"] = boost::any(*destCidr);
    }
    if (destPortRange) {
      res["DestPortRange"] = boost::any(*destPortRange);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (acrId) {
      res["AcrId"] = boost::any(*acrId);
    }
    if (sourceCidr) {
      res["SourceCidr"] = boost::any(*sourceCidr);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    if (dpiGroupIds) {
      res["DpiGroupIds"] = dpiGroupIds ? boost::any(dpiGroupIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("DpiSignatureIds") != m.end() && !m["DpiSignatureIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["DpiSignatureIds"].type()) {
        DescribeACLAttributeResponseBodyAcrsAcrDpiSignatureIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DpiSignatureIds"]));
        dpiSignatureIds = make_shared<DescribeACLAttributeResponseBodyAcrsAcrDpiSignatureIds>(model1);
      }
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("GmtCreate") != m.end() && !m["GmtCreate"].empty()) {
      gmtCreate = make_shared<long>(boost::any_cast<long>(m["GmtCreate"]));
    }
    if (m.find("DestCidr") != m.end() && !m["DestCidr"].empty()) {
      destCidr = make_shared<string>(boost::any_cast<string>(m["DestCidr"]));
    }
    if (m.find("DestPortRange") != m.end() && !m["DestPortRange"].empty()) {
      destPortRange = make_shared<string>(boost::any_cast<string>(m["DestPortRange"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("AcrId") != m.end() && !m["AcrId"].empty()) {
      acrId = make_shared<string>(boost::any_cast<string>(m["AcrId"]));
    }
    if (m.find("SourceCidr") != m.end() && !m["SourceCidr"].empty()) {
      sourceCidr = make_shared<string>(boost::any_cast<string>(m["SourceCidr"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
    if (m.find("DpiGroupIds") != m.end() && !m["DpiGroupIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["DpiGroupIds"].type()) {
        DescribeACLAttributeResponseBodyAcrsAcrDpiGroupIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DpiGroupIds"]));
        dpiGroupIds = make_shared<DescribeACLAttributeResponseBodyAcrsAcrDpiGroupIds>(model1);
      }
    }
  }


  virtual ~DescribeACLAttributeResponseBodyAcrsAcr() = default;
};
class DescribeACLAttributeResponseBodyAcrs : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeACLAttributeResponseBodyAcrsAcr>> acr{};

  DescribeACLAttributeResponseBodyAcrs() {}

  explicit DescribeACLAttributeResponseBodyAcrs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acr) {
      vector<boost::any> temp1;
      for(auto item1:*acr){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Acr"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Acr") != m.end() && !m["Acr"].empty()) {
      if (typeid(vector<boost::any>) == m["Acr"].type()) {
        vector<DescribeACLAttributeResponseBodyAcrsAcr> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Acr"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeACLAttributeResponseBodyAcrsAcr model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        acr = make_shared<vector<DescribeACLAttributeResponseBodyAcrsAcr>>(expect1);
      }
    }
  }


  virtual ~DescribeACLAttributeResponseBodyAcrs() = default;
};
class DescribeACLAttributeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<DescribeACLAttributeResponseBodyAcrs> acrs{};

  DescribeACLAttributeResponseBody() {}

  explicit DescribeACLAttributeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (acrs) {
      res["Acrs"] = acrs ? boost::any(acrs->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("Acrs") != m.end() && !m["Acrs"].empty()) {
      if (typeid(map<string, boost::any>) == m["Acrs"].type()) {
        DescribeACLAttributeResponseBodyAcrs model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Acrs"]));
        acrs = make_shared<DescribeACLAttributeResponseBodyAcrs>(model1);
      }
    }
  }


  virtual ~DescribeACLAttributeResponseBody() = default;
};
class DescribeACLAttributeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeACLAttributeResponseBody> body{};

  DescribeACLAttributeResponse() {}

  explicit DescribeACLAttributeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeACLAttributeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeACLAttributeResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeACLAttributeResponse() = default;
};
class DeleteSagExpressConnectInterfaceRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};
  shared_ptr<string> portName{};
  shared_ptr<string> vlan{};

  DeleteSagExpressConnectInterfaceRequest() {}

  explicit DeleteSagExpressConnectInterfaceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    if (portName) {
      res["PortName"] = boost::any(*portName);
    }
    if (vlan) {
      res["Vlan"] = boost::any(*vlan);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
    if (m.find("PortName") != m.end() && !m["PortName"].empty()) {
      portName = make_shared<string>(boost::any_cast<string>(m["PortName"]));
    }
    if (m.find("Vlan") != m.end() && !m["Vlan"].empty()) {
      vlan = make_shared<string>(boost::any_cast<string>(m["Vlan"]));
    }
  }


  virtual ~DeleteSagExpressConnectInterfaceRequest() = default;
};
class DeleteSagExpressConnectInterfaceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSagExpressConnectInterfaceResponseBody() {}

  explicit DeleteSagExpressConnectInterfaceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSagExpressConnectInterfaceResponseBody() = default;
};
class DeleteSagExpressConnectInterfaceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteSagExpressConnectInterfaceResponseBody> body{};

  DeleteSagExpressConnectInterfaceResponse() {}

  explicit DeleteSagExpressConnectInterfaceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSagExpressConnectInterfaceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSagExpressConnectInterfaceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSagExpressConnectInterfaceResponse() = default;
};
class ListEnterpriseCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> enterpriseCode{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> maxResults{};

  ListEnterpriseCodeRequest() {}

  explicit ListEnterpriseCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (enterpriseCode) {
      res["EnterpriseCode"] = boost::any(*enterpriseCode);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("EnterpriseCode") != m.end() && !m["EnterpriseCode"].empty()) {
      enterpriseCode = make_shared<string>(boost::any_cast<string>(m["EnterpriseCode"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
  }


  virtual ~ListEnterpriseCodeRequest() = default;
};
class ListEnterpriseCodeResponseBodyEnterpriseCodes : public Darabonba::Model {
public:
  shared_ptr<bool> isDefault{};
  shared_ptr<string> enterpriseCode{};

  ListEnterpriseCodeResponseBodyEnterpriseCodes() {}

  explicit ListEnterpriseCodeResponseBodyEnterpriseCodes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (enterpriseCode) {
      res["EnterpriseCode"] = boost::any(*enterpriseCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("EnterpriseCode") != m.end() && !m["EnterpriseCode"].empty()) {
      enterpriseCode = make_shared<string>(boost::any_cast<string>(m["EnterpriseCode"]));
    }
  }


  virtual ~ListEnterpriseCodeResponseBodyEnterpriseCodes() = default;
};
class ListEnterpriseCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> maxResults{};
  shared_ptr<vector<ListEnterpriseCodeResponseBodyEnterpriseCodes>> enterpriseCodes{};

  ListEnterpriseCodeResponseBody() {}

  explicit ListEnterpriseCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (enterpriseCodes) {
      vector<boost::any> temp1;
      for(auto item1:*enterpriseCodes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["EnterpriseCodes"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("EnterpriseCodes") != m.end() && !m["EnterpriseCodes"].empty()) {
      if (typeid(vector<boost::any>) == m["EnterpriseCodes"].type()) {
        vector<ListEnterpriseCodeResponseBodyEnterpriseCodes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["EnterpriseCodes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEnterpriseCodeResponseBodyEnterpriseCodes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        enterpriseCodes = make_shared<vector<ListEnterpriseCodeResponseBodyEnterpriseCodes>>(expect1);
      }
    }
  }


  virtual ~ListEnterpriseCodeResponseBody() = default;
};
class ListEnterpriseCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListEnterpriseCodeResponseBody> body{};

  ListEnterpriseCodeResponse() {}

  explicit ListEnterpriseCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEnterpriseCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEnterpriseCodeResponseBody>(model1);
      }
    }
  }


  virtual ~ListEnterpriseCodeResponse() = default;
};
class CreateSmartAccessGatewaySoftwareRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> period{};
  shared_ptr<bool> autoPay{};
  shared_ptr<string> chargeType{};
  shared_ptr<long> userCount{};
  shared_ptr<long> dataPlan{};

  CreateSmartAccessGatewaySoftwareRequest() {}

  explicit CreateSmartAccessGatewaySoftwareRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (period) {
      res["Period"] = boost::any(*period);
    }
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (chargeType) {
      res["ChargeType"] = boost::any(*chargeType);
    }
    if (userCount) {
      res["UserCount"] = boost::any(*userCount);
    }
    if (dataPlan) {
      res["DataPlan"] = boost::any(*dataPlan);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Period") != m.end() && !m["Period"].empty()) {
      period = make_shared<long>(boost::any_cast<long>(m["Period"]));
    }
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("ChargeType") != m.end() && !m["ChargeType"].empty()) {
      chargeType = make_shared<string>(boost::any_cast<string>(m["ChargeType"]));
    }
    if (m.find("UserCount") != m.end() && !m["UserCount"].empty()) {
      userCount = make_shared<long>(boost::any_cast<long>(m["UserCount"]));
    }
    if (m.find("DataPlan") != m.end() && !m["DataPlan"].empty()) {
      dataPlan = make_shared<long>(boost::any_cast<long>(m["DataPlan"]));
    }
  }


  virtual ~CreateSmartAccessGatewaySoftwareRequest() = default;
};
class CreateSmartAccessGatewaySoftwareResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> orderId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> resourceGroupId{};

  CreateSmartAccessGatewaySoftwareResponseBody() {}

  explicit CreateSmartAccessGatewaySoftwareResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~CreateSmartAccessGatewaySoftwareResponseBody() = default;
};
class CreateSmartAccessGatewaySoftwareResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateSmartAccessGatewaySoftwareResponseBody> body{};

  CreateSmartAccessGatewaySoftwareResponse() {}

  explicit CreateSmartAccessGatewaySoftwareResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSmartAccessGatewaySoftwareResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSmartAccessGatewaySoftwareResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSmartAccessGatewaySoftwareResponse() = default;
};
class DescribeQosesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> qosIds{};
  shared_ptr<string> qosName{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};

  DescribeQosesRequest() {}

  explicit DescribeQosesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (qosIds) {
      res["QosIds"] = boost::any(*qosIds);
    }
    if (qosName) {
      res["QosName"] = boost::any(*qosName);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("QosIds") != m.end() && !m["QosIds"].empty()) {
      qosIds = make_shared<string>(boost::any_cast<string>(m["QosIds"]));
    }
    if (m.find("QosName") != m.end() && !m["QosName"].empty()) {
      qosName = make_shared<string>(boost::any_cast<string>(m["QosName"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~DescribeQosesRequest() = default;
};
class DescribeQosesResponseBodyQosesQos : public Darabonba::Model {
public:
  shared_ptr<string> qosDescription{};
  shared_ptr<string> sagCount{};
  shared_ptr<string> smartAGIds{};
  shared_ptr<string> qosId{};
  shared_ptr<string> qosName{};
  shared_ptr<string> resourceGroupId{};

  DescribeQosesResponseBodyQosesQos() {}

  explicit DescribeQosesResponseBodyQosesQos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qosDescription) {
      res["QosDescription"] = boost::any(*qosDescription);
    }
    if (sagCount) {
      res["SagCount"] = boost::any(*sagCount);
    }
    if (smartAGIds) {
      res["SmartAGIds"] = boost::any(*smartAGIds);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (qosName) {
      res["QosName"] = boost::any(*qosName);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QosDescription") != m.end() && !m["QosDescription"].empty()) {
      qosDescription = make_shared<string>(boost::any_cast<string>(m["QosDescription"]));
    }
    if (m.find("SagCount") != m.end() && !m["SagCount"].empty()) {
      sagCount = make_shared<string>(boost::any_cast<string>(m["SagCount"]));
    }
    if (m.find("SmartAGIds") != m.end() && !m["SmartAGIds"].empty()) {
      smartAGIds = make_shared<string>(boost::any_cast<string>(m["SmartAGIds"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("QosName") != m.end() && !m["QosName"].empty()) {
      qosName = make_shared<string>(boost::any_cast<string>(m["QosName"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~DescribeQosesResponseBodyQosesQos() = default;
};
class DescribeQosesResponseBodyQoses : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeQosesResponseBodyQosesQos>> qos{};

  DescribeQosesResponseBodyQoses() {}

  explicit DescribeQosesResponseBodyQoses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qos) {
      vector<boost::any> temp1;
      for(auto item1:*qos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Qos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Qos") != m.end() && !m["Qos"].empty()) {
      if (typeid(vector<boost::any>) == m["Qos"].type()) {
        vector<DescribeQosesResponseBodyQosesQos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Qos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeQosesResponseBodyQosesQos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        qos = make_shared<vector<DescribeQosesResponseBodyQosesQos>>(expect1);
      }
    }
  }


  virtual ~DescribeQosesResponseBodyQoses() = default;
};
class DescribeQosesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<DescribeQosesResponseBodyQoses> qoses{};

  DescribeQosesResponseBody() {}

  explicit DescribeQosesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (qoses) {
      res["Qoses"] = qoses ? boost::any(qoses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("Qoses") != m.end() && !m["Qoses"].empty()) {
      if (typeid(map<string, boost::any>) == m["Qoses"].type()) {
        DescribeQosesResponseBodyQoses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Qoses"]));
        qoses = make_shared<DescribeQosesResponseBodyQoses>(model1);
      }
    }
  }


  virtual ~DescribeQosesResponseBody() = default;
};
class DescribeQosesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeQosesResponseBody> body{};

  DescribeQosesResponse() {}

  explicit DescribeQosesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeQosesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeQosesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeQosesResponse() = default;
};
class UpgradeSmartAccessGatewaySoftwareRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> autoPay{};
  shared_ptr<long> dataPlan{};
  shared_ptr<long> userCount{};

  UpgradeSmartAccessGatewaySoftwareRequest() {}

  explicit UpgradeSmartAccessGatewaySoftwareRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (dataPlan) {
      res["DataPlan"] = boost::any(*dataPlan);
    }
    if (userCount) {
      res["UserCount"] = boost::any(*userCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("DataPlan") != m.end() && !m["DataPlan"].empty()) {
      dataPlan = make_shared<long>(boost::any_cast<long>(m["DataPlan"]));
    }
    if (m.find("UserCount") != m.end() && !m["UserCount"].empty()) {
      userCount = make_shared<long>(boost::any_cast<long>(m["UserCount"]));
    }
  }


  virtual ~UpgradeSmartAccessGatewaySoftwareRequest() = default;
};
class UpgradeSmartAccessGatewaySoftwareResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> orderId{};

  UpgradeSmartAccessGatewaySoftwareResponseBody() {}

  explicit UpgradeSmartAccessGatewaySoftwareResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
  }


  virtual ~UpgradeSmartAccessGatewaySoftwareResponseBody() = default;
};
class UpgradeSmartAccessGatewaySoftwareResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpgradeSmartAccessGatewaySoftwareResponseBody> body{};

  UpgradeSmartAccessGatewaySoftwareResponse() {}

  explicit UpgradeSmartAccessGatewaySoftwareResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpgradeSmartAccessGatewaySoftwareResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpgradeSmartAccessGatewaySoftwareResponseBody>(model1);
      }
    }
  }


  virtual ~UpgradeSmartAccessGatewaySoftwareResponse() = default;
};
class DescribeSagCurrentDnsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};

  DescribeSagCurrentDnsRequest() {}

  explicit DescribeSagCurrentDnsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
  }


  virtual ~DescribeSagCurrentDnsRequest() = default;
};
class DescribeSagCurrentDnsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> slaveDns{};
  shared_ptr<string> masterDns{};

  DescribeSagCurrentDnsResponseBody() {}

  explicit DescribeSagCurrentDnsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (slaveDns) {
      res["SlaveDns"] = boost::any(*slaveDns);
    }
    if (masterDns) {
      res["MasterDns"] = boost::any(*masterDns);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SlaveDns") != m.end() && !m["SlaveDns"].empty()) {
      slaveDns = make_shared<string>(boost::any_cast<string>(m["SlaveDns"]));
    }
    if (m.find("MasterDns") != m.end() && !m["MasterDns"].empty()) {
      masterDns = make_shared<string>(boost::any_cast<string>(m["MasterDns"]));
    }
  }


  virtual ~DescribeSagCurrentDnsResponseBody() = default;
};
class DescribeSagCurrentDnsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSagCurrentDnsResponseBody> body{};

  DescribeSagCurrentDnsResponse() {}

  explicit DescribeSagCurrentDnsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSagCurrentDnsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSagCurrentDnsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSagCurrentDnsResponse() = default;
};
class DescribeSmartAccessGatewaysRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> associatedCcnId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> status{};
  shared_ptr<string> name{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> aclIds{};
  shared_ptr<string> unboundAclIds{};
  shared_ptr<string> instanceType{};
  shared_ptr<bool> canAssociateQos{};
  shared_ptr<string> hardwareType{};
  shared_ptr<string> softwareVersion{};
  shared_ptr<string> versionComparator{};
  shared_ptr<string> businessState{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<string>> smartAGIds{};

  DescribeSmartAccessGatewaysRequest() {}

  explicit DescribeSmartAccessGatewaysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (associatedCcnId) {
      res["AssociatedCcnId"] = boost::any(*associatedCcnId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (aclIds) {
      res["AclIds"] = boost::any(*aclIds);
    }
    if (unboundAclIds) {
      res["UnboundAclIds"] = boost::any(*unboundAclIds);
    }
    if (instanceType) {
      res["InstanceType"] = boost::any(*instanceType);
    }
    if (canAssociateQos) {
      res["CanAssociateQos"] = boost::any(*canAssociateQos);
    }
    if (hardwareType) {
      res["HardwareType"] = boost::any(*hardwareType);
    }
    if (softwareVersion) {
      res["SoftwareVersion"] = boost::any(*softwareVersion);
    }
    if (versionComparator) {
      res["VersionComparator"] = boost::any(*versionComparator);
    }
    if (businessState) {
      res["BusinessState"] = boost::any(*businessState);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (smartAGIds) {
      res["SmartAGIds"] = boost::any(*smartAGIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AssociatedCcnId") != m.end() && !m["AssociatedCcnId"].empty()) {
      associatedCcnId = make_shared<string>(boost::any_cast<string>(m["AssociatedCcnId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("AclIds") != m.end() && !m["AclIds"].empty()) {
      aclIds = make_shared<string>(boost::any_cast<string>(m["AclIds"]));
    }
    if (m.find("UnboundAclIds") != m.end() && !m["UnboundAclIds"].empty()) {
      unboundAclIds = make_shared<string>(boost::any_cast<string>(m["UnboundAclIds"]));
    }
    if (m.find("InstanceType") != m.end() && !m["InstanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["InstanceType"]));
    }
    if (m.find("CanAssociateQos") != m.end() && !m["CanAssociateQos"].empty()) {
      canAssociateQos = make_shared<bool>(boost::any_cast<bool>(m["CanAssociateQos"]));
    }
    if (m.find("HardwareType") != m.end() && !m["HardwareType"].empty()) {
      hardwareType = make_shared<string>(boost::any_cast<string>(m["HardwareType"]));
    }
    if (m.find("SoftwareVersion") != m.end() && !m["SoftwareVersion"].empty()) {
      softwareVersion = make_shared<string>(boost::any_cast<string>(m["SoftwareVersion"]));
    }
    if (m.find("VersionComparator") != m.end() && !m["VersionComparator"].empty()) {
      versionComparator = make_shared<string>(boost::any_cast<string>(m["VersionComparator"]));
    }
    if (m.find("BusinessState") != m.end() && !m["BusinessState"].empty()) {
      businessState = make_shared<string>(boost::any_cast<string>(m["BusinessState"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("SmartAGIds") != m.end() && !m["SmartAGIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SmartAGIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SmartAGIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      smartAGIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeSmartAccessGatewaysRequest() = default;
};
class DescribeSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGatewayLinksLink : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> status{};
  shared_ptr<long> endTime{};
  shared_ptr<string> bandwidth{};
  shared_ptr<string> relateInstanceRegionId{};
  shared_ptr<string> relateInstanceId{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> commodityType{};

  DescribeSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGatewayLinksLink() {}

  explicit DescribeSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGatewayLinksLink(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (relateInstanceRegionId) {
      res["RelateInstanceRegionId"] = boost::any(*relateInstanceRegionId);
    }
    if (relateInstanceId) {
      res["RelateInstanceId"] = boost::any(*relateInstanceId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (commodityType) {
      res["CommodityType"] = boost::any(*commodityType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<string>(boost::any_cast<string>(m["Bandwidth"]));
    }
    if (m.find("RelateInstanceRegionId") != m.end() && !m["RelateInstanceRegionId"].empty()) {
      relateInstanceRegionId = make_shared<string>(boost::any_cast<string>(m["RelateInstanceRegionId"]));
    }
    if (m.find("RelateInstanceId") != m.end() && !m["RelateInstanceId"].empty()) {
      relateInstanceId = make_shared<string>(boost::any_cast<string>(m["RelateInstanceId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("CommodityType") != m.end() && !m["CommodityType"].empty()) {
      commodityType = make_shared<string>(boost::any_cast<string>(m["CommodityType"]));
    }
  }


  virtual ~DescribeSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGatewayLinksLink() = default;
};
class DescribeSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGatewayLinks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGatewayLinksLink>> link{};

  DescribeSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGatewayLinks() {}

  explicit DescribeSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGatewayLinks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (link) {
      vector<boost::any> temp1;
      for(auto item1:*link){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Link"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Link") != m.end() && !m["Link"].empty()) {
      if (typeid(vector<boost::any>) == m["Link"].type()) {
        vector<DescribeSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGatewayLinksLink> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Link"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGatewayLinksLink model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        link = make_shared<vector<DescribeSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGatewayLinksLink>>(expect1);
      }
    }
  }


  virtual ~DescribeSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGatewayLinks() = default;
};
class DescribeSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGateway : public Darabonba::Model {
public:
  shared_ptr<string> serialNumber{};
  shared_ptr<string> status{};
  shared_ptr<long> upBandwidth4G{};
  shared_ptr<string> backupStatus{};
  shared_ptr<string> idaasApplicationId{};
  shared_ptr<string> softwareVersion{};
  shared_ptr<long> createTime{};
  shared_ptr<string> smartAGId{};
  shared_ptr<long> upBandwidthWan{};
  shared_ptr<string> city{};
  shared_ptr<string> aclIds{};
  shared_ptr<string> qosIds{};
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> description{};
  shared_ptr<string> ipsecStatus{};
  shared_ptr<string> enterpriseCode{};
  shared_ptr<string> dpiStatus{};
  shared_ptr<string> associatedCcnId{};
  shared_ptr<string> name{};
  shared_ptr<string> hardwareVersion{};
  shared_ptr<string> idaasId{};
  shared_ptr<long> dataPlan{};
  shared_ptr<string> associatedCcnName{};
  shared_ptr<string> resellerUid{};
  shared_ptr<string> dpiMonitorStatus{};
  shared_ptr<string> maxBandwidth{};
  shared_ptr<long> smartAGUid{};
  shared_ptr<string> backupSoftwareVersion{};
  shared_ptr<long> endTime{};
  shared_ptr<string> resellerInstanceId{};
  shared_ptr<string> vpnStatus{};
  shared_ptr<string> routingStrategy{};
  shared_ptr<long> securityLockThreshold{};
  shared_ptr<DescribeSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGatewayLinks> links{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> userCount{};
  shared_ptr<string> accessPointId{};
  shared_ptr<string> applicationBandwidthPackageId{};
  shared_ptr<long> accelerateBandwidth{};

  DescribeSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGateway() {}

  explicit DescribeSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGateway(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (upBandwidth4G) {
      res["UpBandwidth4G"] = boost::any(*upBandwidth4G);
    }
    if (backupStatus) {
      res["BackupStatus"] = boost::any(*backupStatus);
    }
    if (idaasApplicationId) {
      res["IdaasApplicationId"] = boost::any(*idaasApplicationId);
    }
    if (softwareVersion) {
      res["SoftwareVersion"] = boost::any(*softwareVersion);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (upBandwidthWan) {
      res["UpBandwidthWan"] = boost::any(*upBandwidthWan);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (aclIds) {
      res["AclIds"] = boost::any(*aclIds);
    }
    if (qosIds) {
      res["QosIds"] = boost::any(*qosIds);
    }
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (ipsecStatus) {
      res["IpsecStatus"] = boost::any(*ipsecStatus);
    }
    if (enterpriseCode) {
      res["EnterpriseCode"] = boost::any(*enterpriseCode);
    }
    if (dpiStatus) {
      res["DpiStatus"] = boost::any(*dpiStatus);
    }
    if (associatedCcnId) {
      res["AssociatedCcnId"] = boost::any(*associatedCcnId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (hardwareVersion) {
      res["HardwareVersion"] = boost::any(*hardwareVersion);
    }
    if (idaasId) {
      res["IdaasId"] = boost::any(*idaasId);
    }
    if (dataPlan) {
      res["DataPlan"] = boost::any(*dataPlan);
    }
    if (associatedCcnName) {
      res["AssociatedCcnName"] = boost::any(*associatedCcnName);
    }
    if (resellerUid) {
      res["ResellerUid"] = boost::any(*resellerUid);
    }
    if (dpiMonitorStatus) {
      res["DpiMonitorStatus"] = boost::any(*dpiMonitorStatus);
    }
    if (maxBandwidth) {
      res["MaxBandwidth"] = boost::any(*maxBandwidth);
    }
    if (smartAGUid) {
      res["SmartAGUid"] = boost::any(*smartAGUid);
    }
    if (backupSoftwareVersion) {
      res["BackupSoftwareVersion"] = boost::any(*backupSoftwareVersion);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (resellerInstanceId) {
      res["ResellerInstanceId"] = boost::any(*resellerInstanceId);
    }
    if (vpnStatus) {
      res["VpnStatus"] = boost::any(*vpnStatus);
    }
    if (routingStrategy) {
      res["RoutingStrategy"] = boost::any(*routingStrategy);
    }
    if (securityLockThreshold) {
      res["SecurityLockThreshold"] = boost::any(*securityLockThreshold);
    }
    if (links) {
      res["Links"] = links ? boost::any(links->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (userCount) {
      res["UserCount"] = boost::any(*userCount);
    }
    if (accessPointId) {
      res["AccessPointId"] = boost::any(*accessPointId);
    }
    if (applicationBandwidthPackageId) {
      res["ApplicationBandwidthPackageId"] = boost::any(*applicationBandwidthPackageId);
    }
    if (accelerateBandwidth) {
      res["AccelerateBandwidth"] = boost::any(*accelerateBandwidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("UpBandwidth4G") != m.end() && !m["UpBandwidth4G"].empty()) {
      upBandwidth4G = make_shared<long>(boost::any_cast<long>(m["UpBandwidth4G"]));
    }
    if (m.find("BackupStatus") != m.end() && !m["BackupStatus"].empty()) {
      backupStatus = make_shared<string>(boost::any_cast<string>(m["BackupStatus"]));
    }
    if (m.find("IdaasApplicationId") != m.end() && !m["IdaasApplicationId"].empty()) {
      idaasApplicationId = make_shared<string>(boost::any_cast<string>(m["IdaasApplicationId"]));
    }
    if (m.find("SoftwareVersion") != m.end() && !m["SoftwareVersion"].empty()) {
      softwareVersion = make_shared<string>(boost::any_cast<string>(m["SoftwareVersion"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("UpBandwidthWan") != m.end() && !m["UpBandwidthWan"].empty()) {
      upBandwidthWan = make_shared<long>(boost::any_cast<long>(m["UpBandwidthWan"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("AclIds") != m.end() && !m["AclIds"].empty()) {
      aclIds = make_shared<string>(boost::any_cast<string>(m["AclIds"]));
    }
    if (m.find("QosIds") != m.end() && !m["QosIds"].empty()) {
      qosIds = make_shared<string>(boost::any_cast<string>(m["QosIds"]));
    }
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("IpsecStatus") != m.end() && !m["IpsecStatus"].empty()) {
      ipsecStatus = make_shared<string>(boost::any_cast<string>(m["IpsecStatus"]));
    }
    if (m.find("EnterpriseCode") != m.end() && !m["EnterpriseCode"].empty()) {
      enterpriseCode = make_shared<string>(boost::any_cast<string>(m["EnterpriseCode"]));
    }
    if (m.find("DpiStatus") != m.end() && !m["DpiStatus"].empty()) {
      dpiStatus = make_shared<string>(boost::any_cast<string>(m["DpiStatus"]));
    }
    if (m.find("AssociatedCcnId") != m.end() && !m["AssociatedCcnId"].empty()) {
      associatedCcnId = make_shared<string>(boost::any_cast<string>(m["AssociatedCcnId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("HardwareVersion") != m.end() && !m["HardwareVersion"].empty()) {
      hardwareVersion = make_shared<string>(boost::any_cast<string>(m["HardwareVersion"]));
    }
    if (m.find("IdaasId") != m.end() && !m["IdaasId"].empty()) {
      idaasId = make_shared<string>(boost::any_cast<string>(m["IdaasId"]));
    }
    if (m.find("DataPlan") != m.end() && !m["DataPlan"].empty()) {
      dataPlan = make_shared<long>(boost::any_cast<long>(m["DataPlan"]));
    }
    if (m.find("AssociatedCcnName") != m.end() && !m["AssociatedCcnName"].empty()) {
      associatedCcnName = make_shared<string>(boost::any_cast<string>(m["AssociatedCcnName"]));
    }
    if (m.find("ResellerUid") != m.end() && !m["ResellerUid"].empty()) {
      resellerUid = make_shared<string>(boost::any_cast<string>(m["ResellerUid"]));
    }
    if (m.find("DpiMonitorStatus") != m.end() && !m["DpiMonitorStatus"].empty()) {
      dpiMonitorStatus = make_shared<string>(boost::any_cast<string>(m["DpiMonitorStatus"]));
    }
    if (m.find("MaxBandwidth") != m.end() && !m["MaxBandwidth"].empty()) {
      maxBandwidth = make_shared<string>(boost::any_cast<string>(m["MaxBandwidth"]));
    }
    if (m.find("SmartAGUid") != m.end() && !m["SmartAGUid"].empty()) {
      smartAGUid = make_shared<long>(boost::any_cast<long>(m["SmartAGUid"]));
    }
    if (m.find("BackupSoftwareVersion") != m.end() && !m["BackupSoftwareVersion"].empty()) {
      backupSoftwareVersion = make_shared<string>(boost::any_cast<string>(m["BackupSoftwareVersion"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("ResellerInstanceId") != m.end() && !m["ResellerInstanceId"].empty()) {
      resellerInstanceId = make_shared<string>(boost::any_cast<string>(m["ResellerInstanceId"]));
    }
    if (m.find("VpnStatus") != m.end() && !m["VpnStatus"].empty()) {
      vpnStatus = make_shared<string>(boost::any_cast<string>(m["VpnStatus"]));
    }
    if (m.find("RoutingStrategy") != m.end() && !m["RoutingStrategy"].empty()) {
      routingStrategy = make_shared<string>(boost::any_cast<string>(m["RoutingStrategy"]));
    }
    if (m.find("SecurityLockThreshold") != m.end() && !m["SecurityLockThreshold"].empty()) {
      securityLockThreshold = make_shared<long>(boost::any_cast<long>(m["SecurityLockThreshold"]));
    }
    if (m.find("Links") != m.end() && !m["Links"].empty()) {
      if (typeid(map<string, boost::any>) == m["Links"].type()) {
        DescribeSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGatewayLinks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Links"]));
        links = make_shared<DescribeSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGatewayLinks>(model1);
      }
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("UserCount") != m.end() && !m["UserCount"].empty()) {
      userCount = make_shared<long>(boost::any_cast<long>(m["UserCount"]));
    }
    if (m.find("AccessPointId") != m.end() && !m["AccessPointId"].empty()) {
      accessPointId = make_shared<string>(boost::any_cast<string>(m["AccessPointId"]));
    }
    if (m.find("ApplicationBandwidthPackageId") != m.end() && !m["ApplicationBandwidthPackageId"].empty()) {
      applicationBandwidthPackageId = make_shared<string>(boost::any_cast<string>(m["ApplicationBandwidthPackageId"]));
    }
    if (m.find("AccelerateBandwidth") != m.end() && !m["AccelerateBandwidth"].empty()) {
      accelerateBandwidth = make_shared<long>(boost::any_cast<long>(m["AccelerateBandwidth"]));
    }
  }


  virtual ~DescribeSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGateway() = default;
};
class DescribeSmartAccessGatewaysResponseBodySmartAccessGateways : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGateway>> smartAccessGateway{};

  DescribeSmartAccessGatewaysResponseBodySmartAccessGateways() {}

  explicit DescribeSmartAccessGatewaysResponseBodySmartAccessGateways(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (smartAccessGateway) {
      vector<boost::any> temp1;
      for(auto item1:*smartAccessGateway){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SmartAccessGateway"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SmartAccessGateway") != m.end() && !m["SmartAccessGateway"].empty()) {
      if (typeid(vector<boost::any>) == m["SmartAccessGateway"].type()) {
        vector<DescribeSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGateway> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SmartAccessGateway"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGateway model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        smartAccessGateway = make_shared<vector<DescribeSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGateway>>(expect1);
      }
    }
  }


  virtual ~DescribeSmartAccessGatewaysResponseBodySmartAccessGateways() = default;
};
class DescribeSmartAccessGatewaysResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<DescribeSmartAccessGatewaysResponseBodySmartAccessGateways> smartAccessGateways{};

  DescribeSmartAccessGatewaysResponseBody() {}

  explicit DescribeSmartAccessGatewaysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (smartAccessGateways) {
      res["SmartAccessGateways"] = smartAccessGateways ? boost::any(smartAccessGateways->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("SmartAccessGateways") != m.end() && !m["SmartAccessGateways"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmartAccessGateways"].type()) {
        DescribeSmartAccessGatewaysResponseBodySmartAccessGateways model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmartAccessGateways"]));
        smartAccessGateways = make_shared<DescribeSmartAccessGatewaysResponseBodySmartAccessGateways>(model1);
      }
    }
  }


  virtual ~DescribeSmartAccessGatewaysResponseBody() = default;
};
class DescribeSmartAccessGatewaysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSmartAccessGatewaysResponseBody> body{};

  DescribeSmartAccessGatewaysResponse() {}

  explicit DescribeSmartAccessGatewaysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSmartAccessGatewaysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSmartAccessGatewaysResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSmartAccessGatewaysResponse() = default;
};
class DescribeQosCarsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> qosId{};
  shared_ptr<string> qosCarId{};
  shared_ptr<string> order{};
  shared_ptr<string> description{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};

  DescribeQosCarsRequest() {}

  explicit DescribeQosCarsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (qosCarId) {
      res["QosCarId"] = boost::any(*qosCarId);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("QosCarId") != m.end() && !m["QosCarId"].empty()) {
      qosCarId = make_shared<string>(boost::any_cast<string>(m["QosCarId"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~DescribeQosCarsRequest() = default;
};
class DescribeQosCarsResponseBodyQosCarsQosCar : public Darabonba::Model {
public:
  shared_ptr<long> maxBandwidthAbs{};
  shared_ptr<string> percentSourceType{};
  shared_ptr<long> minBandwidthAbs{};
  shared_ptr<long> maxBandwidthPercent{};
  shared_ptr<string> description{};
  shared_ptr<string> qosId{};
  shared_ptr<string> limitType{};
  shared_ptr<long> priority{};
  shared_ptr<string> name{};
  shared_ptr<long> minBandwidthPercent{};
  shared_ptr<string> qosCarId{};

  DescribeQosCarsResponseBodyQosCarsQosCar() {}

  explicit DescribeQosCarsResponseBodyQosCarsQosCar(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxBandwidthAbs) {
      res["MaxBandwidthAbs"] = boost::any(*maxBandwidthAbs);
    }
    if (percentSourceType) {
      res["PercentSourceType"] = boost::any(*percentSourceType);
    }
    if (minBandwidthAbs) {
      res["MinBandwidthAbs"] = boost::any(*minBandwidthAbs);
    }
    if (maxBandwidthPercent) {
      res["MaxBandwidthPercent"] = boost::any(*maxBandwidthPercent);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (limitType) {
      res["LimitType"] = boost::any(*limitType);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (minBandwidthPercent) {
      res["MinBandwidthPercent"] = boost::any(*minBandwidthPercent);
    }
    if (qosCarId) {
      res["QosCarId"] = boost::any(*qosCarId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxBandwidthAbs") != m.end() && !m["MaxBandwidthAbs"].empty()) {
      maxBandwidthAbs = make_shared<long>(boost::any_cast<long>(m["MaxBandwidthAbs"]));
    }
    if (m.find("PercentSourceType") != m.end() && !m["PercentSourceType"].empty()) {
      percentSourceType = make_shared<string>(boost::any_cast<string>(m["PercentSourceType"]));
    }
    if (m.find("MinBandwidthAbs") != m.end() && !m["MinBandwidthAbs"].empty()) {
      minBandwidthAbs = make_shared<long>(boost::any_cast<long>(m["MinBandwidthAbs"]));
    }
    if (m.find("MaxBandwidthPercent") != m.end() && !m["MaxBandwidthPercent"].empty()) {
      maxBandwidthPercent = make_shared<long>(boost::any_cast<long>(m["MaxBandwidthPercent"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("LimitType") != m.end() && !m["LimitType"].empty()) {
      limitType = make_shared<string>(boost::any_cast<string>(m["LimitType"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("MinBandwidthPercent") != m.end() && !m["MinBandwidthPercent"].empty()) {
      minBandwidthPercent = make_shared<long>(boost::any_cast<long>(m["MinBandwidthPercent"]));
    }
    if (m.find("QosCarId") != m.end() && !m["QosCarId"].empty()) {
      qosCarId = make_shared<string>(boost::any_cast<string>(m["QosCarId"]));
    }
  }


  virtual ~DescribeQosCarsResponseBodyQosCarsQosCar() = default;
};
class DescribeQosCarsResponseBodyQosCars : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeQosCarsResponseBodyQosCarsQosCar>> qosCar{};

  DescribeQosCarsResponseBodyQosCars() {}

  explicit DescribeQosCarsResponseBodyQosCars(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (qosCar) {
      vector<boost::any> temp1;
      for(auto item1:*qosCar){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["QosCar"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("QosCar") != m.end() && !m["QosCar"].empty()) {
      if (typeid(vector<boost::any>) == m["QosCar"].type()) {
        vector<DescribeQosCarsResponseBodyQosCarsQosCar> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["QosCar"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeQosCarsResponseBodyQosCarsQosCar model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        qosCar = make_shared<vector<DescribeQosCarsResponseBodyQosCarsQosCar>>(expect1);
      }
    }
  }


  virtual ~DescribeQosCarsResponseBodyQosCars() = default;
};
class DescribeQosCarsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<DescribeQosCarsResponseBodyQosCars> qosCars{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};

  DescribeQosCarsResponseBody() {}

  explicit DescribeQosCarsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (qosCars) {
      res["QosCars"] = qosCars ? boost::any(qosCars->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("QosCars") != m.end() && !m["QosCars"].empty()) {
      if (typeid(map<string, boost::any>) == m["QosCars"].type()) {
        DescribeQosCarsResponseBodyQosCars model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["QosCars"]));
        qosCars = make_shared<DescribeQosCarsResponseBodyQosCars>(model1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~DescribeQosCarsResponseBody() = default;
};
class DescribeQosCarsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeQosCarsResponseBody> body{};

  DescribeQosCarsResponse() {}

  explicit DescribeQosCarsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeQosCarsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeQosCarsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeQosCarsResponse() = default;
};
class DescribeUserOnlineClientStatisticsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<vector<string>> userNames{};

  DescribeUserOnlineClientStatisticsRequest() {}

  explicit DescribeUserOnlineClientStatisticsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (userNames) {
      res["UserNames"] = boost::any(*userNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("UserNames") != m.end() && !m["UserNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["UserNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["UserNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      userNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeUserOnlineClientStatisticsRequest() = default;
};
class DescribeUserOnlineClientStatisticsResponseBodyUserStatisticsStatistics : public Darabonba::Model {
public:
  shared_ptr<string> onlineCount{};
  shared_ptr<string> userName{};

  DescribeUserOnlineClientStatisticsResponseBodyUserStatisticsStatistics() {}

  explicit DescribeUserOnlineClientStatisticsResponseBodyUserStatisticsStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (onlineCount) {
      res["OnlineCount"] = boost::any(*onlineCount);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OnlineCount") != m.end() && !m["OnlineCount"].empty()) {
      onlineCount = make_shared<string>(boost::any_cast<string>(m["OnlineCount"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
  }


  virtual ~DescribeUserOnlineClientStatisticsResponseBodyUserStatisticsStatistics() = default;
};
class DescribeUserOnlineClientStatisticsResponseBodyUserStatistics : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeUserOnlineClientStatisticsResponseBodyUserStatisticsStatistics>> statistics{};

  DescribeUserOnlineClientStatisticsResponseBodyUserStatistics() {}

  explicit DescribeUserOnlineClientStatisticsResponseBodyUserStatistics(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (statistics) {
      vector<boost::any> temp1;
      for(auto item1:*statistics){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Statistics"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Statistics") != m.end() && !m["Statistics"].empty()) {
      if (typeid(vector<boost::any>) == m["Statistics"].type()) {
        vector<DescribeUserOnlineClientStatisticsResponseBodyUserStatisticsStatistics> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Statistics"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeUserOnlineClientStatisticsResponseBodyUserStatisticsStatistics model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statistics = make_shared<vector<DescribeUserOnlineClientStatisticsResponseBodyUserStatisticsStatistics>>(expect1);
      }
    }
  }


  virtual ~DescribeUserOnlineClientStatisticsResponseBodyUserStatistics() = default;
};
class DescribeUserOnlineClientStatisticsResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeUserOnlineClientStatisticsResponseBodyUserStatistics> userStatistics{};
  shared_ptr<string> requestId{};

  DescribeUserOnlineClientStatisticsResponseBody() {}

  explicit DescribeUserOnlineClientStatisticsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (userStatistics) {
      res["UserStatistics"] = userStatistics ? boost::any(userStatistics->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UserStatistics") != m.end() && !m["UserStatistics"].empty()) {
      if (typeid(map<string, boost::any>) == m["UserStatistics"].type()) {
        DescribeUserOnlineClientStatisticsResponseBodyUserStatistics model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UserStatistics"]));
        userStatistics = make_shared<DescribeUserOnlineClientStatisticsResponseBodyUserStatistics>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DescribeUserOnlineClientStatisticsResponseBody() = default;
};
class DescribeUserOnlineClientStatisticsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeUserOnlineClientStatisticsResponseBody> body{};

  DescribeUserOnlineClientStatisticsResponse() {}

  explicit DescribeUserOnlineClientStatisticsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeUserOnlineClientStatisticsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeUserOnlineClientStatisticsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeUserOnlineClientStatisticsResponse() = default;
};
class UpdateEnterpriseCodeRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> enterpriseCode{};
  shared_ptr<bool> isDefault{};
  shared_ptr<string> clientToken{};

  UpdateEnterpriseCodeRequest() {}

  explicit UpdateEnterpriseCodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (enterpriseCode) {
      res["EnterpriseCode"] = boost::any(*enterpriseCode);
    }
    if (isDefault) {
      res["IsDefault"] = boost::any(*isDefault);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("EnterpriseCode") != m.end() && !m["EnterpriseCode"].empty()) {
      enterpriseCode = make_shared<string>(boost::any_cast<string>(m["EnterpriseCode"]));
    }
    if (m.find("IsDefault") != m.end() && !m["IsDefault"].empty()) {
      isDefault = make_shared<bool>(boost::any_cast<bool>(m["IsDefault"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~UpdateEnterpriseCodeRequest() = default;
};
class UpdateEnterpriseCodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateEnterpriseCodeResponseBody() {}

  explicit UpdateEnterpriseCodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateEnterpriseCodeResponseBody() = default;
};
class UpdateEnterpriseCodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UpdateEnterpriseCodeResponseBody> body{};

  UpdateEnterpriseCodeResponse() {}

  explicit UpdateEnterpriseCodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateEnterpriseCodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateEnterpriseCodeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateEnterpriseCodeResponse() = default;
};
class BindVbrRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> vbrId{};
  shared_ptr<string> vbrRegionId{};
  shared_ptr<long> smartAGUid{};

  BindVbrRequest() {}

  explicit BindVbrRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (vbrId) {
      res["VbrId"] = boost::any(*vbrId);
    }
    if (vbrRegionId) {
      res["VbrRegionId"] = boost::any(*vbrRegionId);
    }
    if (smartAGUid) {
      res["SmartAGUid"] = boost::any(*smartAGUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("VbrId") != m.end() && !m["VbrId"].empty()) {
      vbrId = make_shared<string>(boost::any_cast<string>(m["VbrId"]));
    }
    if (m.find("VbrRegionId") != m.end() && !m["VbrRegionId"].empty()) {
      vbrRegionId = make_shared<string>(boost::any_cast<string>(m["VbrRegionId"]));
    }
    if (m.find("SmartAGUid") != m.end() && !m["SmartAGUid"].empty()) {
      smartAGUid = make_shared<long>(boost::any_cast<long>(m["SmartAGUid"]));
    }
  }


  virtual ~BindVbrRequest() = default;
};
class BindVbrResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BindVbrResponseBody() {}

  explicit BindVbrResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BindVbrResponseBody() = default;
};
class BindVbrResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<BindVbrResponseBody> body{};

  BindVbrResponse() {}

  explicit BindVbrResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BindVbrResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BindVbrResponseBody>(model1);
      }
    }
  }


  virtual ~BindVbrResponse() = default;
};
class DescribeSagRouteProtocolBgpRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};

  DescribeSagRouteProtocolBgpRequest() {}

  explicit DescribeSagRouteProtocolBgpRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
  }


  virtual ~DescribeSagRouteProtocolBgpRequest() = default;
};
class DescribeSagRouteProtocolBgpResponseBodyTaskStates : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> state{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> createTime{};

  DescribeSagRouteProtocolBgpResponseBodyTaskStates() {}

  explicit DescribeSagRouteProtocolBgpResponseBodyTaskStates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
  }


  virtual ~DescribeSagRouteProtocolBgpResponseBodyTaskStates() = default;
};
class DescribeSagRouteProtocolBgpResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> holdTime{};
  shared_ptr<string> requestId{};
  shared_ptr<long> keepAlive{};
  shared_ptr<long> localAs{};
  shared_ptr<string> routerId{};
  shared_ptr<vector<DescribeSagRouteProtocolBgpResponseBodyTaskStates>> taskStates{};

  DescribeSagRouteProtocolBgpResponseBody() {}

  explicit DescribeSagRouteProtocolBgpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (holdTime) {
      res["HoldTime"] = boost::any(*holdTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (keepAlive) {
      res["KeepAlive"] = boost::any(*keepAlive);
    }
    if (localAs) {
      res["LocalAs"] = boost::any(*localAs);
    }
    if (routerId) {
      res["RouterId"] = boost::any(*routerId);
    }
    if (taskStates) {
      vector<boost::any> temp1;
      for(auto item1:*taskStates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskStates"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HoldTime") != m.end() && !m["HoldTime"].empty()) {
      holdTime = make_shared<long>(boost::any_cast<long>(m["HoldTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("KeepAlive") != m.end() && !m["KeepAlive"].empty()) {
      keepAlive = make_shared<long>(boost::any_cast<long>(m["KeepAlive"]));
    }
    if (m.find("LocalAs") != m.end() && !m["LocalAs"].empty()) {
      localAs = make_shared<long>(boost::any_cast<long>(m["LocalAs"]));
    }
    if (m.find("RouterId") != m.end() && !m["RouterId"].empty()) {
      routerId = make_shared<string>(boost::any_cast<string>(m["RouterId"]));
    }
    if (m.find("TaskStates") != m.end() && !m["TaskStates"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskStates"].type()) {
        vector<DescribeSagRouteProtocolBgpResponseBodyTaskStates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskStates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSagRouteProtocolBgpResponseBodyTaskStates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskStates = make_shared<vector<DescribeSagRouteProtocolBgpResponseBodyTaskStates>>(expect1);
      }
    }
  }


  virtual ~DescribeSagRouteProtocolBgpResponseBody() = default;
};
class DescribeSagRouteProtocolBgpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSagRouteProtocolBgpResponseBody> body{};

  DescribeSagRouteProtocolBgpResponse() {}

  explicit DescribeSagRouteProtocolBgpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSagRouteProtocolBgpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSagRouteProtocolBgpResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSagRouteProtocolBgpResponse() = default;
};
class DisableSmartAccessGatewayUserRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> userName{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> regionId{};

  DisableSmartAccessGatewayUserRequest() {}

  explicit DisableSmartAccessGatewayUserRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (userName) {
      res["UserName"] = boost::any(*userName);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("UserName") != m.end() && !m["UserName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["UserName"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DisableSmartAccessGatewayUserRequest() = default;
};
class DisableSmartAccessGatewayUserResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableSmartAccessGatewayUserResponseBody() {}

  explicit DisableSmartAccessGatewayUserResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableSmartAccessGatewayUserResponseBody() = default;
};
class DisableSmartAccessGatewayUserResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DisableSmartAccessGatewayUserResponseBody> body{};

  DisableSmartAccessGatewayUserResponse() {}

  explicit DisableSmartAccessGatewayUserResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableSmartAccessGatewayUserResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableSmartAccessGatewayUserResponseBody>(model1);
      }
    }
  }


  virtual ~DisableSmartAccessGatewayUserResponse() = default;
};
class DeleteDnatEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sagId{};
  shared_ptr<string> dnatEntryId{};

  DeleteDnatEntryRequest() {}

  explicit DeleteDnatEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sagId) {
      res["SagId"] = boost::any(*sagId);
    }
    if (dnatEntryId) {
      res["DnatEntryId"] = boost::any(*dnatEntryId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SagId") != m.end() && !m["SagId"].empty()) {
      sagId = make_shared<string>(boost::any_cast<string>(m["SagId"]));
    }
    if (m.find("DnatEntryId") != m.end() && !m["DnatEntryId"].empty()) {
      dnatEntryId = make_shared<string>(boost::any_cast<string>(m["DnatEntryId"]));
    }
  }


  virtual ~DeleteDnatEntryRequest() = default;
};
class DeleteDnatEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDnatEntryResponseBody() {}

  explicit DeleteDnatEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDnatEntryResponseBody() = default;
};
class DeleteDnatEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteDnatEntryResponseBody> body{};

  DeleteDnatEntryResponse() {}

  explicit DeleteDnatEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDnatEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDnatEntryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDnatEntryResponse() = default;
};
class ModifyACLRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> aclId{};
  shared_ptr<string> name{};

  ModifyACLRequest() {}

  explicit ModifyACLRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (aclId) {
      res["AclId"] = boost::any(*aclId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AclId") != m.end() && !m["AclId"].empty()) {
      aclId = make_shared<string>(boost::any_cast<string>(m["AclId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ModifyACLRequest() = default;
};
class ModifyACLResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyACLResponseBody() {}

  explicit ModifyACLResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyACLResponseBody() = default;
};
class ModifyACLResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyACLResponseBody> body{};

  ModifyACLResponse() {}

  explicit ModifyACLResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyACLResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyACLResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyACLResponse() = default;
};
class GetSmartAccessGatewayUseLimitRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};

  GetSmartAccessGatewayUseLimitRequest() {}

  explicit GetSmartAccessGatewayUseLimitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetSmartAccessGatewayUseLimitRequest() = default;
};
class GetSmartAccessGatewayUseLimitResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> usedAmount{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalAmount{};

  GetSmartAccessGatewayUseLimitResponseBody() {}

  explicit GetSmartAccessGatewayUseLimitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (usedAmount) {
      res["UsedAmount"] = boost::any(*usedAmount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalAmount) {
      res["TotalAmount"] = boost::any(*totalAmount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UsedAmount") != m.end() && !m["UsedAmount"].empty()) {
      usedAmount = make_shared<long>(boost::any_cast<long>(m["UsedAmount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalAmount") != m.end() && !m["TotalAmount"].empty()) {
      totalAmount = make_shared<long>(boost::any_cast<long>(m["TotalAmount"]));
    }
  }


  virtual ~GetSmartAccessGatewayUseLimitResponseBody() = default;
};
class GetSmartAccessGatewayUseLimitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetSmartAccessGatewayUseLimitResponseBody> body{};

  GetSmartAccessGatewayUseLimitResponse() {}

  explicit GetSmartAccessGatewayUseLimitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSmartAccessGatewayUseLimitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSmartAccessGatewayUseLimitResponseBody>(model1);
      }
    }
  }


  virtual ~GetSmartAccessGatewayUseLimitResponse() = default;
};
class DeleteSmartAccessGatewayRequest : public Darabonba::Model {
public:
  shared_ptr<string> regionId{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> resourceOwnerId{};

  DeleteSmartAccessGatewayRequest() {}

  explicit DeleteSmartAccessGatewayRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
  }


  virtual ~DeleteSmartAccessGatewayRequest() = default;
};
class DeleteSmartAccessGatewayResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteSmartAccessGatewayResponseBody() {}

  explicit DeleteSmartAccessGatewayResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteSmartAccessGatewayResponseBody() = default;
};
class DeleteSmartAccessGatewayResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteSmartAccessGatewayResponseBody> body{};

  DeleteSmartAccessGatewayResponse() {}

  explicit DeleteSmartAccessGatewayResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSmartAccessGatewayResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSmartAccessGatewayResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSmartAccessGatewayResponse() = default;
};
class GrantInstanceToCbnRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<long> cenUid{};
  shared_ptr<string> ccnInstanceId{};
  shared_ptr<string> cenInstanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> grantTrafficService{};

  GrantInstanceToCbnRequest() {}

  explicit GrantInstanceToCbnRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (cenUid) {
      res["CenUid"] = boost::any(*cenUid);
    }
    if (ccnInstanceId) {
      res["CcnInstanceId"] = boost::any(*ccnInstanceId);
    }
    if (cenInstanceId) {
      res["CenInstanceId"] = boost::any(*cenInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (grantTrafficService) {
      res["GrantTrafficService"] = boost::any(*grantTrafficService);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("CenUid") != m.end() && !m["CenUid"].empty()) {
      cenUid = make_shared<long>(boost::any_cast<long>(m["CenUid"]));
    }
    if (m.find("CcnInstanceId") != m.end() && !m["CcnInstanceId"].empty()) {
      ccnInstanceId = make_shared<string>(boost::any_cast<string>(m["CcnInstanceId"]));
    }
    if (m.find("CenInstanceId") != m.end() && !m["CenInstanceId"].empty()) {
      cenInstanceId = make_shared<string>(boost::any_cast<string>(m["CenInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("GrantTrafficService") != m.end() && !m["GrantTrafficService"].empty()) {
      grantTrafficService = make_shared<bool>(boost::any_cast<bool>(m["GrantTrafficService"]));
    }
  }


  virtual ~GrantInstanceToCbnRequest() = default;
};
class GrantInstanceToCbnResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  GrantInstanceToCbnResponseBody() {}

  explicit GrantInstanceToCbnResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GrantInstanceToCbnResponseBody() = default;
};
class GrantInstanceToCbnResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GrantInstanceToCbnResponseBody> body{};

  GrantInstanceToCbnResponse() {}

  explicit GrantInstanceToCbnResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GrantInstanceToCbnResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GrantInstanceToCbnResponseBody>(model1);
      }
    }
  }


  virtual ~GrantInstanceToCbnResponse() = default;
};
class AddSnatEntryRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> cidrBlock{};
  shared_ptr<string> snatIp{};

  AddSnatEntryRequest() {}

  explicit AddSnatEntryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (snatIp) {
      res["SnatIp"] = boost::any(*snatIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("SnatIp") != m.end() && !m["SnatIp"].empty()) {
      snatIp = make_shared<string>(boost::any_cast<string>(m["SnatIp"]));
    }
  }


  virtual ~AddSnatEntryRequest() = default;
};
class AddSnatEntryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> instanceId{};

  AddSnatEntryResponseBody() {}

  explicit AddSnatEntryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
  }


  virtual ~AddSnatEntryResponseBody() = default;
};
class AddSnatEntryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<AddSnatEntryResponseBody> body{};

  AddSnatEntryResponse() {}

  explicit AddSnatEntryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddSnatEntryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddSnatEntryResponseBody>(model1);
      }
    }
  }


  virtual ~AddSnatEntryResponse() = default;
};
class DisableSmartAGDpiMonitorRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};

  DisableSmartAGDpiMonitorRequest() {}

  explicit DisableSmartAGDpiMonitorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["DryRun"] = boost::any(*dryRun);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("DryRun") != m.end() && !m["DryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["DryRun"]));
    }
  }


  virtual ~DisableSmartAGDpiMonitorRequest() = default;
};
class DisableSmartAGDpiMonitorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DisableSmartAGDpiMonitorResponseBody() {}

  explicit DisableSmartAGDpiMonitorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DisableSmartAGDpiMonitorResponseBody() = default;
};
class DisableSmartAGDpiMonitorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DisableSmartAGDpiMonitorResponseBody> body{};

  DisableSmartAGDpiMonitorResponse() {}

  explicit DisableSmartAGDpiMonitorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DisableSmartAGDpiMonitorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DisableSmartAGDpiMonitorResponseBody>(model1);
      }
    }
  }


  virtual ~DisableSmartAGDpiMonitorResponse() = default;
};
class DescribeSnatEntriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeSnatEntriesRequest() {}

  explicit DescribeSnatEntriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeSnatEntriesRequest() = default;
};
class DescribeSnatEntriesResponseBodySnatEntriesSnatEntry : public Darabonba::Model {
public:
  shared_ptr<string> cidrBlock{};
  shared_ptr<long> createTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> snatIp{};

  DescribeSnatEntriesResponseBodySnatEntriesSnatEntry() {}

  explicit DescribeSnatEntriesResponseBodySnatEntriesSnatEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cidrBlock) {
      res["CidrBlock"] = boost::any(*cidrBlock);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (snatIp) {
      res["SnatIp"] = boost::any(*snatIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CidrBlock") != m.end() && !m["CidrBlock"].empty()) {
      cidrBlock = make_shared<string>(boost::any_cast<string>(m["CidrBlock"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("SnatIp") != m.end() && !m["SnatIp"].empty()) {
      snatIp = make_shared<string>(boost::any_cast<string>(m["SnatIp"]));
    }
  }


  virtual ~DescribeSnatEntriesResponseBodySnatEntriesSnatEntry() = default;
};
class DescribeSnatEntriesResponseBodySnatEntries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSnatEntriesResponseBodySnatEntriesSnatEntry>> snatEntry{};

  DescribeSnatEntriesResponseBodySnatEntries() {}

  explicit DescribeSnatEntriesResponseBodySnatEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (snatEntry) {
      vector<boost::any> temp1;
      for(auto item1:*snatEntry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SnatEntry"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SnatEntry") != m.end() && !m["SnatEntry"].empty()) {
      if (typeid(vector<boost::any>) == m["SnatEntry"].type()) {
        vector<DescribeSnatEntriesResponseBodySnatEntriesSnatEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SnatEntry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSnatEntriesResponseBodySnatEntriesSnatEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        snatEntry = make_shared<vector<DescribeSnatEntriesResponseBodySnatEntriesSnatEntry>>(expect1);
      }
    }
  }


  virtual ~DescribeSnatEntriesResponseBodySnatEntries() = default;
};
class DescribeSnatEntriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSnatEntriesResponseBodySnatEntries> snatEntries{};
  shared_ptr<long> pageNumber{};

  DescribeSnatEntriesResponseBody() {}

  explicit DescribeSnatEntriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (snatEntries) {
      res["SnatEntries"] = snatEntries ? boost::any(snatEntries->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SnatEntries") != m.end() && !m["SnatEntries"].empty()) {
      if (typeid(map<string, boost::any>) == m["SnatEntries"].type()) {
        DescribeSnatEntriesResponseBodySnatEntries model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SnatEntries"]));
        snatEntries = make_shared<DescribeSnatEntriesResponseBodySnatEntries>(model1);
      }
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~DescribeSnatEntriesResponseBody() = default;
};
class DescribeSnatEntriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSnatEntriesResponseBody> body{};

  DescribeSnatEntriesResponse() {}

  explicit DescribeSnatEntriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSnatEntriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSnatEntriesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSnatEntriesResponse() = default;
};
class ModifyClientUserDNSRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<vector<string>> appDNS{};
  shared_ptr<vector<string>> recoveredDNS{};

  ModifyClientUserDNSRequest() {}

  explicit ModifyClientUserDNSRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (appDNS) {
      res["AppDNS"] = boost::any(*appDNS);
    }
    if (recoveredDNS) {
      res["RecoveredDNS"] = boost::any(*recoveredDNS);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("AppDNS") != m.end() && !m["AppDNS"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AppDNS"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AppDNS"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      appDNS = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RecoveredDNS") != m.end() && !m["RecoveredDNS"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecoveredDNS"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecoveredDNS"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recoveredDNS = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ModifyClientUserDNSRequest() = default;
};
class ModifyClientUserDNSResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyClientUserDNSResponseBody() {}

  explicit ModifyClientUserDNSResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyClientUserDNSResponseBody() = default;
};
class ModifyClientUserDNSResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyClientUserDNSResponseBody> body{};

  ModifyClientUserDNSResponse() {}

  explicit ModifyClientUserDNSResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyClientUserDNSResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyClientUserDNSResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyClientUserDNSResponse() = default;
};
class ModifySagRouteProtocolBgpRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};
  shared_ptr<string> routerId{};
  shared_ptr<long> localAs{};
  shared_ptr<long> holdTime{};
  shared_ptr<long> keepAlive{};

  ModifySagRouteProtocolBgpRequest() {}

  explicit ModifySagRouteProtocolBgpRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    if (routerId) {
      res["RouterId"] = boost::any(*routerId);
    }
    if (localAs) {
      res["LocalAs"] = boost::any(*localAs);
    }
    if (holdTime) {
      res["HoldTime"] = boost::any(*holdTime);
    }
    if (keepAlive) {
      res["KeepAlive"] = boost::any(*keepAlive);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
    if (m.find("RouterId") != m.end() && !m["RouterId"].empty()) {
      routerId = make_shared<string>(boost::any_cast<string>(m["RouterId"]));
    }
    if (m.find("LocalAs") != m.end() && !m["LocalAs"].empty()) {
      localAs = make_shared<long>(boost::any_cast<long>(m["LocalAs"]));
    }
    if (m.find("HoldTime") != m.end() && !m["HoldTime"].empty()) {
      holdTime = make_shared<long>(boost::any_cast<long>(m["HoldTime"]));
    }
    if (m.find("KeepAlive") != m.end() && !m["KeepAlive"].empty()) {
      keepAlive = make_shared<long>(boost::any_cast<long>(m["KeepAlive"]));
    }
  }


  virtual ~ModifySagRouteProtocolBgpRequest() = default;
};
class ModifySagRouteProtocolBgpResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySagRouteProtocolBgpResponseBody() {}

  explicit ModifySagRouteProtocolBgpResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySagRouteProtocolBgpResponseBody() = default;
};
class ModifySagRouteProtocolBgpResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySagRouteProtocolBgpResponseBody> body{};

  ModifySagRouteProtocolBgpResponse() {}

  explicit ModifySagRouteProtocolBgpResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySagRouteProtocolBgpResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySagRouteProtocolBgpResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySagRouteProtocolBgpResponse() = default;
};
class ModifyQosCarRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> description{};
  shared_ptr<string> regionId{};
  shared_ptr<string> qosId{};
  shared_ptr<string> qosCarId{};
  shared_ptr<long> priority{};
  shared_ptr<string> limitType{};
  shared_ptr<long> minBandwidthAbs{};
  shared_ptr<long> maxBandwidthAbs{};
  shared_ptr<long> minBandwidthPercent{};
  shared_ptr<long> maxBandwidthPercent{};
  shared_ptr<string> percentSourceType{};
  shared_ptr<string> name{};

  ModifyQosCarRequest() {}

  explicit ModifyQosCarRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (qosCarId) {
      res["QosCarId"] = boost::any(*qosCarId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (limitType) {
      res["LimitType"] = boost::any(*limitType);
    }
    if (minBandwidthAbs) {
      res["MinBandwidthAbs"] = boost::any(*minBandwidthAbs);
    }
    if (maxBandwidthAbs) {
      res["MaxBandwidthAbs"] = boost::any(*maxBandwidthAbs);
    }
    if (minBandwidthPercent) {
      res["MinBandwidthPercent"] = boost::any(*minBandwidthPercent);
    }
    if (maxBandwidthPercent) {
      res["MaxBandwidthPercent"] = boost::any(*maxBandwidthPercent);
    }
    if (percentSourceType) {
      res["PercentSourceType"] = boost::any(*percentSourceType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("QosCarId") != m.end() && !m["QosCarId"].empty()) {
      qosCarId = make_shared<string>(boost::any_cast<string>(m["QosCarId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("LimitType") != m.end() && !m["LimitType"].empty()) {
      limitType = make_shared<string>(boost::any_cast<string>(m["LimitType"]));
    }
    if (m.find("MinBandwidthAbs") != m.end() && !m["MinBandwidthAbs"].empty()) {
      minBandwidthAbs = make_shared<long>(boost::any_cast<long>(m["MinBandwidthAbs"]));
    }
    if (m.find("MaxBandwidthAbs") != m.end() && !m["MaxBandwidthAbs"].empty()) {
      maxBandwidthAbs = make_shared<long>(boost::any_cast<long>(m["MaxBandwidthAbs"]));
    }
    if (m.find("MinBandwidthPercent") != m.end() && !m["MinBandwidthPercent"].empty()) {
      minBandwidthPercent = make_shared<long>(boost::any_cast<long>(m["MinBandwidthPercent"]));
    }
    if (m.find("MaxBandwidthPercent") != m.end() && !m["MaxBandwidthPercent"].empty()) {
      maxBandwidthPercent = make_shared<long>(boost::any_cast<long>(m["MaxBandwidthPercent"]));
    }
    if (m.find("PercentSourceType") != m.end() && !m["PercentSourceType"].empty()) {
      percentSourceType = make_shared<string>(boost::any_cast<string>(m["PercentSourceType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~ModifyQosCarRequest() = default;
};
class ModifyQosCarResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyQosCarResponseBody() {}

  explicit ModifyQosCarResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyQosCarResponseBody() = default;
};
class ModifyQosCarResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyQosCarResponseBody> body{};

  ModifyQosCarResponse() {}

  explicit ModifyQosCarResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyQosCarResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyQosCarResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyQosCarResponse() = default;
};
class CreateFlowLogRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<long> activeAging{};
  shared_ptr<long> inactiveAging{};
  shared_ptr<string> outputType{};
  shared_ptr<string> slsRegionId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> logstoreName{};
  shared_ptr<string> netflowServerIp{};
  shared_ptr<long> netflowServerPort{};
  shared_ptr<string> netflowVersion{};

  CreateFlowLogRequest() {}

  explicit CreateFlowLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (activeAging) {
      res["ActiveAging"] = boost::any(*activeAging);
    }
    if (inactiveAging) {
      res["InactiveAging"] = boost::any(*inactiveAging);
    }
    if (outputType) {
      res["OutputType"] = boost::any(*outputType);
    }
    if (slsRegionId) {
      res["SlsRegionId"] = boost::any(*slsRegionId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (logstoreName) {
      res["LogstoreName"] = boost::any(*logstoreName);
    }
    if (netflowServerIp) {
      res["NetflowServerIp"] = boost::any(*netflowServerIp);
    }
    if (netflowServerPort) {
      res["NetflowServerPort"] = boost::any(*netflowServerPort);
    }
    if (netflowVersion) {
      res["NetflowVersion"] = boost::any(*netflowVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ActiveAging") != m.end() && !m["ActiveAging"].empty()) {
      activeAging = make_shared<long>(boost::any_cast<long>(m["ActiveAging"]));
    }
    if (m.find("InactiveAging") != m.end() && !m["InactiveAging"].empty()) {
      inactiveAging = make_shared<long>(boost::any_cast<long>(m["InactiveAging"]));
    }
    if (m.find("OutputType") != m.end() && !m["OutputType"].empty()) {
      outputType = make_shared<string>(boost::any_cast<string>(m["OutputType"]));
    }
    if (m.find("SlsRegionId") != m.end() && !m["SlsRegionId"].empty()) {
      slsRegionId = make_shared<string>(boost::any_cast<string>(m["SlsRegionId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("LogstoreName") != m.end() && !m["LogstoreName"].empty()) {
      logstoreName = make_shared<string>(boost::any_cast<string>(m["LogstoreName"]));
    }
    if (m.find("NetflowServerIp") != m.end() && !m["NetflowServerIp"].empty()) {
      netflowServerIp = make_shared<string>(boost::any_cast<string>(m["NetflowServerIp"]));
    }
    if (m.find("NetflowServerPort") != m.end() && !m["NetflowServerPort"].empty()) {
      netflowServerPort = make_shared<long>(boost::any_cast<long>(m["NetflowServerPort"]));
    }
    if (m.find("NetflowVersion") != m.end() && !m["NetflowVersion"].empty()) {
      netflowVersion = make_shared<string>(boost::any_cast<string>(m["NetflowVersion"]));
    }
  }


  virtual ~CreateFlowLogRequest() = default;
};
class CreateFlowLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> flowLogId{};
  shared_ptr<string> resourceGroupId{};

  CreateFlowLogResponseBody() {}

  explicit CreateFlowLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (flowLogId) {
      res["FlowLogId"] = boost::any(*flowLogId);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("FlowLogId") != m.end() && !m["FlowLogId"].empty()) {
      flowLogId = make_shared<string>(boost::any_cast<string>(m["FlowLogId"]));
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
  }


  virtual ~CreateFlowLogResponseBody() = default;
};
class CreateFlowLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateFlowLogResponseBody> body{};

  CreateFlowLogResponse() {}

  explicit CreateFlowLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFlowLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFlowLogResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFlowLogResponse() = default;
};
class ModifyDeviceAutoUpgradePolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> cronExpression{};
  shared_ptr<string> upgradeType{};
  shared_ptr<long> duration{};
  shared_ptr<string> timeZone{};
  shared_ptr<string> versionType{};

  ModifyDeviceAutoUpgradePolicyRequest() {}

  explicit ModifyDeviceAutoUpgradePolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (cronExpression) {
      res["CronExpression"] = boost::any(*cronExpression);
    }
    if (upgradeType) {
      res["UpgradeType"] = boost::any(*upgradeType);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("CronExpression") != m.end() && !m["CronExpression"].empty()) {
      cronExpression = make_shared<string>(boost::any_cast<string>(m["CronExpression"]));
    }
    if (m.find("UpgradeType") != m.end() && !m["UpgradeType"].empty()) {
      upgradeType = make_shared<string>(boost::any_cast<string>(m["UpgradeType"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["Duration"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
  }


  virtual ~ModifyDeviceAutoUpgradePolicyRequest() = default;
};
class ModifyDeviceAutoUpgradePolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifyDeviceAutoUpgradePolicyResponseBody() {}

  explicit ModifyDeviceAutoUpgradePolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifyDeviceAutoUpgradePolicyResponseBody() = default;
};
class ModifyDeviceAutoUpgradePolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifyDeviceAutoUpgradePolicyResponseBody> body{};

  ModifyDeviceAutoUpgradePolicyResponse() {}

  explicit ModifyDeviceAutoUpgradePolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDeviceAutoUpgradePolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDeviceAutoUpgradePolicyResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDeviceAutoUpgradePolicyResponse() = default;
};
class DescribeClientUserDNSRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};

  DescribeClientUserDNSRequest() {}

  explicit DescribeClientUserDNSRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
  }


  virtual ~DescribeClientUserDNSRequest() = default;
};
class DescribeClientUserDNSResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<string>> appDNS{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> recoveredDNS{};

  DescribeClientUserDNSResponseBody() {}

  explicit DescribeClientUserDNSResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appDNS) {
      res["AppDNS"] = boost::any(*appDNS);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (recoveredDNS) {
      res["RecoveredDNS"] = boost::any(*recoveredDNS);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppDNS") != m.end() && !m["AppDNS"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["AppDNS"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["AppDNS"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      appDNS = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("RecoveredDNS") != m.end() && !m["RecoveredDNS"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecoveredDNS"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecoveredDNS"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recoveredDNS = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DescribeClientUserDNSResponseBody() = default;
};
class DescribeClientUserDNSResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeClientUserDNSResponseBody> body{};

  DescribeClientUserDNSResponse() {}

  explicit DescribeClientUserDNSResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeClientUserDNSResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeClientUserDNSResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeClientUserDNSResponse() = default;
};
class ClearSagCipherRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sagId{};
  shared_ptr<string> snNumber{};

  ClearSagCipherRequest() {}

  explicit ClearSagCipherRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sagId) {
      res["SagId"] = boost::any(*sagId);
    }
    if (snNumber) {
      res["SnNumber"] = boost::any(*snNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SagId") != m.end() && !m["SagId"].empty()) {
      sagId = make_shared<string>(boost::any_cast<string>(m["SagId"]));
    }
    if (m.find("SnNumber") != m.end() && !m["SnNumber"].empty()) {
      snNumber = make_shared<string>(boost::any_cast<string>(m["SnNumber"]));
    }
  }


  virtual ~ClearSagCipherRequest() = default;
};
class ClearSagCipherResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ClearSagCipherResponseBody() {}

  explicit ClearSagCipherResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ClearSagCipherResponseBody() = default;
};
class ClearSagCipherResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ClearSagCipherResponseBody> body{};

  ClearSagCipherResponse() {}

  explicit ClearSagCipherResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ClearSagCipherResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ClearSagCipherResponseBody>(model1);
      }
    }
  }


  virtual ~ClearSagCipherResponse() = default;
};
class DescribeSagWan4GRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};

  DescribeSagWan4GRequest() {}

  explicit DescribeSagWan4GRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
  }


  virtual ~DescribeSagWan4GRequest() = default;
};
class DescribeSagWan4GResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> trafficState{};
  shared_ptr<string> requestId{};
  shared_ptr<long> priority{};
  shared_ptr<string> ip{};
  shared_ptr<string> strength{};
  shared_ptr<string> mac{};

  DescribeSagWan4GResponseBody() {}

  explicit DescribeSagWan4GResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (trafficState) {
      res["TrafficState"] = boost::any(*trafficState);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (ip) {
      res["Ip"] = boost::any(*ip);
    }
    if (strength) {
      res["Strength"] = boost::any(*strength);
    }
    if (mac) {
      res["Mac"] = boost::any(*mac);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TrafficState") != m.end() && !m["TrafficState"].empty()) {
      trafficState = make_shared<string>(boost::any_cast<string>(m["TrafficState"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Ip") != m.end() && !m["Ip"].empty()) {
      ip = make_shared<string>(boost::any_cast<string>(m["Ip"]));
    }
    if (m.find("Strength") != m.end() && !m["Strength"].empty()) {
      strength = make_shared<string>(boost::any_cast<string>(m["Strength"]));
    }
    if (m.find("Mac") != m.end() && !m["Mac"].empty()) {
      mac = make_shared<string>(boost::any_cast<string>(m["Mac"]));
    }
  }


  virtual ~DescribeSagWan4GResponseBody() = default;
};
class DescribeSagWan4GResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSagWan4GResponseBody> body{};

  DescribeSagWan4GResponse() {}

  explicit DescribeSagWan4GResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSagWan4GResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSagWan4GResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSagWan4GResponse() = default;
};
class ModifySagUserDnsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};
  shared_ptr<string> masterDns{};
  shared_ptr<string> slaveDns{};

  ModifySagUserDnsRequest() {}

  explicit ModifySagUserDnsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    if (masterDns) {
      res["MasterDns"] = boost::any(*masterDns);
    }
    if (slaveDns) {
      res["SlaveDns"] = boost::any(*slaveDns);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
    if (m.find("MasterDns") != m.end() && !m["MasterDns"].empty()) {
      masterDns = make_shared<string>(boost::any_cast<string>(m["MasterDns"]));
    }
    if (m.find("SlaveDns") != m.end() && !m["SlaveDns"].empty()) {
      slaveDns = make_shared<string>(boost::any_cast<string>(m["SlaveDns"]));
    }
  }


  virtual ~ModifySagUserDnsRequest() = default;
};
class ModifySagUserDnsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySagUserDnsResponseBody() {}

  explicit ModifySagUserDnsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySagUserDnsResponseBody() = default;
};
class ModifySagUserDnsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySagUserDnsResponseBody> body{};

  ModifySagUserDnsResponse() {}

  explicit ModifySagUserDnsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySagUserDnsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySagUserDnsResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySagUserDnsResponse() = default;
};
class ModifySagManagementPortRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};
  shared_ptr<string> IP{};
  shared_ptr<string> mask{};
  shared_ptr<string> gateway{};

  ModifySagManagementPortRequest() {}

  explicit ModifySagManagementPortRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (mask) {
      res["Mask"] = boost::any(*mask);
    }
    if (gateway) {
      res["Gateway"] = boost::any(*gateway);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("Mask") != m.end() && !m["Mask"].empty()) {
      mask = make_shared<string>(boost::any_cast<string>(m["Mask"]));
    }
    if (m.find("Gateway") != m.end() && !m["Gateway"].empty()) {
      gateway = make_shared<string>(boost::any_cast<string>(m["Gateway"]));
    }
  }


  virtual ~ModifySagManagementPortRequest() = default;
};
class ModifySagManagementPortResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySagManagementPortResponseBody() {}

  explicit ModifySagManagementPortResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySagManagementPortResponseBody() = default;
};
class ModifySagManagementPortResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySagManagementPortResponseBody> body{};

  ModifySagManagementPortResponse() {}

  explicit ModifySagManagementPortResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySagManagementPortResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySagManagementPortResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySagManagementPortResponse() = default;
};
class DescribeDnatEntriesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> sagId{};
  shared_ptr<string> type{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};

  DescribeDnatEntriesRequest() {}

  explicit DescribeDnatEntriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (sagId) {
      res["SagId"] = boost::any(*sagId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SagId") != m.end() && !m["SagId"].empty()) {
      sagId = make_shared<string>(boost::any_cast<string>(m["SagId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~DescribeDnatEntriesRequest() = default;
};
class DescribeDnatEntriesResponseBodyDnatEntriesDnatEntry : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> sagId{};
  shared_ptr<string> internalIp{};
  shared_ptr<string> internalPort{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> externalPort{};
  shared_ptr<string> dnatEntryId{};
  shared_ptr<string> externalIp{};

  DescribeDnatEntriesResponseBodyDnatEntriesDnatEntry() {}

  explicit DescribeDnatEntriesResponseBodyDnatEntriesDnatEntry(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (sagId) {
      res["SagId"] = boost::any(*sagId);
    }
    if (internalIp) {
      res["InternalIp"] = boost::any(*internalIp);
    }
    if (internalPort) {
      res["InternalPort"] = boost::any(*internalPort);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (externalPort) {
      res["ExternalPort"] = boost::any(*externalPort);
    }
    if (dnatEntryId) {
      res["DnatEntryId"] = boost::any(*dnatEntryId);
    }
    if (externalIp) {
      res["ExternalIp"] = boost::any(*externalIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("SagId") != m.end() && !m["SagId"].empty()) {
      sagId = make_shared<string>(boost::any_cast<string>(m["SagId"]));
    }
    if (m.find("InternalIp") != m.end() && !m["InternalIp"].empty()) {
      internalIp = make_shared<string>(boost::any_cast<string>(m["InternalIp"]));
    }
    if (m.find("InternalPort") != m.end() && !m["InternalPort"].empty()) {
      internalPort = make_shared<string>(boost::any_cast<string>(m["InternalPort"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("ExternalPort") != m.end() && !m["ExternalPort"].empty()) {
      externalPort = make_shared<string>(boost::any_cast<string>(m["ExternalPort"]));
    }
    if (m.find("DnatEntryId") != m.end() && !m["DnatEntryId"].empty()) {
      dnatEntryId = make_shared<string>(boost::any_cast<string>(m["DnatEntryId"]));
    }
    if (m.find("ExternalIp") != m.end() && !m["ExternalIp"].empty()) {
      externalIp = make_shared<string>(boost::any_cast<string>(m["ExternalIp"]));
    }
  }


  virtual ~DescribeDnatEntriesResponseBodyDnatEntriesDnatEntry() = default;
};
class DescribeDnatEntriesResponseBodyDnatEntries : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeDnatEntriesResponseBodyDnatEntriesDnatEntry>> dnatEntry{};

  DescribeDnatEntriesResponseBodyDnatEntries() {}

  explicit DescribeDnatEntriesResponseBodyDnatEntries(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dnatEntry) {
      vector<boost::any> temp1;
      for(auto item1:*dnatEntry){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DnatEntry"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DnatEntry") != m.end() && !m["DnatEntry"].empty()) {
      if (typeid(vector<boost::any>) == m["DnatEntry"].type()) {
        vector<DescribeDnatEntriesResponseBodyDnatEntriesDnatEntry> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DnatEntry"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDnatEntriesResponseBodyDnatEntriesDnatEntry model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dnatEntry = make_shared<vector<DescribeDnatEntriesResponseBodyDnatEntriesDnatEntry>>(expect1);
      }
    }
  }


  virtual ~DescribeDnatEntriesResponseBodyDnatEntries() = default;
};
class DescribeDnatEntriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<DescribeDnatEntriesResponseBodyDnatEntries> dnatEntries{};

  DescribeDnatEntriesResponseBody() {}

  explicit DescribeDnatEntriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (dnatEntries) {
      res["DnatEntries"] = dnatEntries ? boost::any(dnatEntries->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("DnatEntries") != m.end() && !m["DnatEntries"].empty()) {
      if (typeid(map<string, boost::any>) == m["DnatEntries"].type()) {
        DescribeDnatEntriesResponseBodyDnatEntries model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DnatEntries"]));
        dnatEntries = make_shared<DescribeDnatEntriesResponseBodyDnatEntries>(model1);
      }
    }
  }


  virtual ~DescribeDnatEntriesResponseBody() = default;
};
class DescribeDnatEntriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDnatEntriesResponseBody> body{};

  DescribeDnatEntriesResponse() {}

  explicit DescribeDnatEntriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDnatEntriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDnatEntriesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDnatEntriesResponse() = default;
};
class DescribeSmartAccessGatewayVersionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};
  shared_ptr<string> versionType{};

  DescribeSmartAccessGatewayVersionsRequest() {}

  explicit DescribeSmartAccessGatewayVersionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
  }


  virtual ~DescribeSmartAccessGatewayVersionsRequest() = default;
};
class DescribeSmartAccessGatewayVersionsResponseBodySmartAGVersionsSmartAGVersion : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<long> createTime{};
  shared_ptr<string> versionName{};
  shared_ptr<string> versionCode{};

  DescribeSmartAccessGatewayVersionsResponseBodySmartAGVersionsSmartAGVersion() {}

  explicit DescribeSmartAccessGatewayVersionsResponseBodySmartAGVersionsSmartAGVersion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (versionName) {
      res["VersionName"] = boost::any(*versionName);
    }
    if (versionCode) {
      res["VersionCode"] = boost::any(*versionCode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["CreateTime"]));
    }
    if (m.find("VersionName") != m.end() && !m["VersionName"].empty()) {
      versionName = make_shared<string>(boost::any_cast<string>(m["VersionName"]));
    }
    if (m.find("VersionCode") != m.end() && !m["VersionCode"].empty()) {
      versionCode = make_shared<string>(boost::any_cast<string>(m["VersionCode"]));
    }
  }


  virtual ~DescribeSmartAccessGatewayVersionsResponseBodySmartAGVersionsSmartAGVersion() = default;
};
class DescribeSmartAccessGatewayVersionsResponseBodySmartAGVersions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSmartAccessGatewayVersionsResponseBodySmartAGVersionsSmartAGVersion>> smartAGVersion{};

  DescribeSmartAccessGatewayVersionsResponseBodySmartAGVersions() {}

  explicit DescribeSmartAccessGatewayVersionsResponseBodySmartAGVersions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (smartAGVersion) {
      vector<boost::any> temp1;
      for(auto item1:*smartAGVersion){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SmartAGVersion"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SmartAGVersion") != m.end() && !m["SmartAGVersion"].empty()) {
      if (typeid(vector<boost::any>) == m["SmartAGVersion"].type()) {
        vector<DescribeSmartAccessGatewayVersionsResponseBodySmartAGVersionsSmartAGVersion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SmartAGVersion"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSmartAccessGatewayVersionsResponseBodySmartAGVersionsSmartAGVersion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        smartAGVersion = make_shared<vector<DescribeSmartAccessGatewayVersionsResponseBodySmartAGVersionsSmartAGVersion>>(expect1);
      }
    }
  }


  virtual ~DescribeSmartAccessGatewayVersionsResponseBodySmartAGVersions() = default;
};
class DescribeSmartAccessGatewayVersionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSmartAccessGatewayVersionsResponseBodySmartAGVersions> smartAGVersions{};

  DescribeSmartAccessGatewayVersionsResponseBody() {}

  explicit DescribeSmartAccessGatewayVersionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (smartAGVersions) {
      res["SmartAGVersions"] = smartAGVersions ? boost::any(smartAGVersions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SmartAGVersions") != m.end() && !m["SmartAGVersions"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmartAGVersions"].type()) {
        DescribeSmartAccessGatewayVersionsResponseBodySmartAGVersions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmartAGVersions"]));
        smartAGVersions = make_shared<DescribeSmartAccessGatewayVersionsResponseBodySmartAGVersions>(model1);
      }
    }
  }


  virtual ~DescribeSmartAccessGatewayVersionsResponseBody() = default;
};
class DescribeSmartAccessGatewayVersionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSmartAccessGatewayVersionsResponseBody> body{};

  DescribeSmartAccessGatewayVersionsResponse() {}

  explicit DescribeSmartAccessGatewayVersionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSmartAccessGatewayVersionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSmartAccessGatewayVersionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSmartAccessGatewayVersionsResponse() = default;
};
class RevokeInstanceFromCbnRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ccnInstanceId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> cenInstanceId{};

  RevokeInstanceFromCbnRequest() {}

  explicit RevokeInstanceFromCbnRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ccnInstanceId) {
      res["CcnInstanceId"] = boost::any(*ccnInstanceId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (cenInstanceId) {
      res["CenInstanceId"] = boost::any(*cenInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("CcnInstanceId") != m.end() && !m["CcnInstanceId"].empty()) {
      ccnInstanceId = make_shared<string>(boost::any_cast<string>(m["CcnInstanceId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("CenInstanceId") != m.end() && !m["CenInstanceId"].empty()) {
      cenInstanceId = make_shared<string>(boost::any_cast<string>(m["CenInstanceId"]));
    }
  }


  virtual ~RevokeInstanceFromCbnRequest() = default;
};
class RevokeInstanceFromCbnResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RevokeInstanceFromCbnResponseBody() {}

  explicit RevokeInstanceFromCbnResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RevokeInstanceFromCbnResponseBody() = default;
};
class RevokeInstanceFromCbnResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<RevokeInstanceFromCbnResponseBody> body{};

  RevokeInstanceFromCbnResponse() {}

  explicit RevokeInstanceFromCbnResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RevokeInstanceFromCbnResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RevokeInstanceFromCbnResponseBody>(model1);
      }
    }
  }


  virtual ~RevokeInstanceFromCbnResponse() = default;
};
class DescribeSagRemoteAccessRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> regionId{};

  DescribeSagRemoteAccessRequest() {}

  explicit DescribeSagRemoteAccessRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeSagRemoteAccessRequest() = default;
};
class DescribeSagRemoteAccessResponseBodyRemoteAccessesRemoteAccess : public Darabonba::Model {
public:
  shared_ptr<string> serialNumber{};
  shared_ptr<string> remoteAccessIp{};

  DescribeSagRemoteAccessResponseBodyRemoteAccessesRemoteAccess() {}

  explicit DescribeSagRemoteAccessResponseBodyRemoteAccessesRemoteAccess(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (remoteAccessIp) {
      res["RemoteAccessIp"] = boost::any(*remoteAccessIp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("RemoteAccessIp") != m.end() && !m["RemoteAccessIp"].empty()) {
      remoteAccessIp = make_shared<string>(boost::any_cast<string>(m["RemoteAccessIp"]));
    }
  }


  virtual ~DescribeSagRemoteAccessResponseBodyRemoteAccessesRemoteAccess() = default;
};
class DescribeSagRemoteAccessResponseBodyRemoteAccesses : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSagRemoteAccessResponseBodyRemoteAccessesRemoteAccess>> remoteAccess{};

  DescribeSagRemoteAccessResponseBodyRemoteAccesses() {}

  explicit DescribeSagRemoteAccessResponseBodyRemoteAccesses(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remoteAccess) {
      vector<boost::any> temp1;
      for(auto item1:*remoteAccess){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["RemoteAccess"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemoteAccess") != m.end() && !m["RemoteAccess"].empty()) {
      if (typeid(vector<boost::any>) == m["RemoteAccess"].type()) {
        vector<DescribeSagRemoteAccessResponseBodyRemoteAccessesRemoteAccess> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["RemoteAccess"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSagRemoteAccessResponseBodyRemoteAccessesRemoteAccess model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        remoteAccess = make_shared<vector<DescribeSagRemoteAccessResponseBodyRemoteAccessesRemoteAccess>>(expect1);
      }
    }
  }


  virtual ~DescribeSagRemoteAccessResponseBodyRemoteAccesses() = default;
};
class DescribeSagRemoteAccessResponseBody : public Darabonba::Model {
public:
  shared_ptr<DescribeSagRemoteAccessResponseBodyRemoteAccesses> remoteAccesses{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> code{};
  shared_ptr<bool> success{};

  DescribeSagRemoteAccessResponseBody() {}

  explicit DescribeSagRemoteAccessResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (remoteAccesses) {
      res["RemoteAccesses"] = remoteAccesses ? boost::any(remoteAccesses->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RemoteAccesses") != m.end() && !m["RemoteAccesses"].empty()) {
      if (typeid(map<string, boost::any>) == m["RemoteAccesses"].type()) {
        DescribeSagRemoteAccessResponseBodyRemoteAccesses model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RemoteAccesses"]));
        remoteAccesses = make_shared<DescribeSagRemoteAccessResponseBodyRemoteAccesses>(model1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~DescribeSagRemoteAccessResponseBody() = default;
};
class DescribeSagRemoteAccessResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSagRemoteAccessResponseBody> body{};

  DescribeSagRemoteAccessResponse() {}

  explicit DescribeSagRemoteAccessResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSagRemoteAccessResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSagRemoteAccessResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSagRemoteAccessResponse() = default;
};
class CreateQosPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> description{};
  shared_ptr<string> regionId{};
  shared_ptr<string> qosId{};
  shared_ptr<long> priority{};
  shared_ptr<string> sourceCidr{};
  shared_ptr<string> destCidr{};
  shared_ptr<string> ipProtocol{};
  shared_ptr<string> sourcePortRange{};
  shared_ptr<string> destPortRange{};
  shared_ptr<string> startTime{};
  shared_ptr<string> endTime{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> dpiSignatureIds{};
  shared_ptr<vector<string>> dpiGroupIds{};

  CreateQosPolicyRequest() {}

  explicit CreateQosPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (sourceCidr) {
      res["SourceCidr"] = boost::any(*sourceCidr);
    }
    if (destCidr) {
      res["DestCidr"] = boost::any(*destCidr);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    if (destPortRange) {
      res["DestPortRange"] = boost::any(*destPortRange);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (dpiSignatureIds) {
      res["DpiSignatureIds"] = boost::any(*dpiSignatureIds);
    }
    if (dpiGroupIds) {
      res["DpiGroupIds"] = boost::any(*dpiGroupIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("SourceCidr") != m.end() && !m["SourceCidr"].empty()) {
      sourceCidr = make_shared<string>(boost::any_cast<string>(m["SourceCidr"]));
    }
    if (m.find("DestCidr") != m.end() && !m["DestCidr"].empty()) {
      destCidr = make_shared<string>(boost::any_cast<string>(m["DestCidr"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
    if (m.find("DestPortRange") != m.end() && !m["DestPortRange"].empty()) {
      destPortRange = make_shared<string>(boost::any_cast<string>(m["DestPortRange"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("DpiSignatureIds") != m.end() && !m["DpiSignatureIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DpiSignatureIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DpiSignatureIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dpiSignatureIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DpiGroupIds") != m.end() && !m["DpiGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DpiGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DpiGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dpiGroupIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateQosPolicyRequest() = default;
};
class CreateQosPolicyResponseBodyDpiGroupIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dpiGroupId{};

  CreateQosPolicyResponseBodyDpiGroupIds() {}

  explicit CreateQosPolicyResponseBodyDpiGroupIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dpiGroupId) {
      res["DpiGroupId"] = boost::any(*dpiGroupId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DpiGroupId") != m.end() && !m["DpiGroupId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DpiGroupId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DpiGroupId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dpiGroupId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateQosPolicyResponseBodyDpiGroupIds() = default;
};
class CreateQosPolicyResponseBodyDpiSignatureIds : public Darabonba::Model {
public:
  shared_ptr<vector<string>> dpiSignatureId{};

  CreateQosPolicyResponseBodyDpiSignatureIds() {}

  explicit CreateQosPolicyResponseBodyDpiSignatureIds(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dpiSignatureId) {
      res["DpiSignatureId"] = boost::any(*dpiSignatureId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DpiSignatureId") != m.end() && !m["DpiSignatureId"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DpiSignatureId"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DpiSignatureId"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dpiSignatureId = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateQosPolicyResponseBodyDpiSignatureIds() = default;
};
class CreateQosPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> endTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> qosPolicyId{};
  shared_ptr<string> sourcePortRange{};
  shared_ptr<string> sourceCidr{};
  shared_ptr<long> priority{};
  shared_ptr<string> startTime{};
  shared_ptr<string> destPortRange{};
  shared_ptr<CreateQosPolicyResponseBodyDpiGroupIds> dpiGroupIds{};
  shared_ptr<string> name{};
  shared_ptr<string> destCidr{};
  shared_ptr<CreateQosPolicyResponseBodyDpiSignatureIds> dpiSignatureIds{};
  shared_ptr<string> qosId{};
  shared_ptr<string> ipProtocol{};

  CreateQosPolicyResponseBody() {}

  explicit CreateQosPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (qosPolicyId) {
      res["QosPolicyId"] = boost::any(*qosPolicyId);
    }
    if (sourcePortRange) {
      res["SourcePortRange"] = boost::any(*sourcePortRange);
    }
    if (sourceCidr) {
      res["SourceCidr"] = boost::any(*sourceCidr);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (destPortRange) {
      res["DestPortRange"] = boost::any(*destPortRange);
    }
    if (dpiGroupIds) {
      res["DpiGroupIds"] = dpiGroupIds ? boost::any(dpiGroupIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (destCidr) {
      res["DestCidr"] = boost::any(*destCidr);
    }
    if (dpiSignatureIds) {
      res["DpiSignatureIds"] = dpiSignatureIds ? boost::any(dpiSignatureIds->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (ipProtocol) {
      res["IpProtocol"] = boost::any(*ipProtocol);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("QosPolicyId") != m.end() && !m["QosPolicyId"].empty()) {
      qosPolicyId = make_shared<string>(boost::any_cast<string>(m["QosPolicyId"]));
    }
    if (m.find("SourcePortRange") != m.end() && !m["SourcePortRange"].empty()) {
      sourcePortRange = make_shared<string>(boost::any_cast<string>(m["SourcePortRange"]));
    }
    if (m.find("SourceCidr") != m.end() && !m["SourceCidr"].empty()) {
      sourceCidr = make_shared<string>(boost::any_cast<string>(m["SourceCidr"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("DestPortRange") != m.end() && !m["DestPortRange"].empty()) {
      destPortRange = make_shared<string>(boost::any_cast<string>(m["DestPortRange"]));
    }
    if (m.find("DpiGroupIds") != m.end() && !m["DpiGroupIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["DpiGroupIds"].type()) {
        CreateQosPolicyResponseBodyDpiGroupIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DpiGroupIds"]));
        dpiGroupIds = make_shared<CreateQosPolicyResponseBodyDpiGroupIds>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("DestCidr") != m.end() && !m["DestCidr"].empty()) {
      destCidr = make_shared<string>(boost::any_cast<string>(m["DestCidr"]));
    }
    if (m.find("DpiSignatureIds") != m.end() && !m["DpiSignatureIds"].empty()) {
      if (typeid(map<string, boost::any>) == m["DpiSignatureIds"].type()) {
        CreateQosPolicyResponseBodyDpiSignatureIds model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DpiSignatureIds"]));
        dpiSignatureIds = make_shared<CreateQosPolicyResponseBodyDpiSignatureIds>(model1);
      }
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("IpProtocol") != m.end() && !m["IpProtocol"].empty()) {
      ipProtocol = make_shared<string>(boost::any_cast<string>(m["IpProtocol"]));
    }
  }


  virtual ~CreateQosPolicyResponseBody() = default;
};
class CreateQosPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<CreateQosPolicyResponseBody> body{};

  CreateQosPolicyResponse() {}

  explicit CreateQosPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateQosPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateQosPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateQosPolicyResponse() = default;
};
class DescribeFlowLogSagsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> flowLogId{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};

  DescribeFlowLogSagsRequest() {}

  explicit DescribeFlowLogSagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (flowLogId) {
      res["FlowLogId"] = boost::any(*flowLogId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("FlowLogId") != m.end() && !m["FlowLogId"].empty()) {
      flowLogId = make_shared<string>(boost::any_cast<string>(m["FlowLogId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~DescribeFlowLogSagsRequest() = default;
};
class DescribeFlowLogSagsResponseBodySagsSag : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> name{};

  DescribeFlowLogSagsResponseBodySagsSag() {}

  explicit DescribeFlowLogSagsResponseBodySagsSag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeFlowLogSagsResponseBodySagsSag() = default;
};
class DescribeFlowLogSagsResponseBodySags : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeFlowLogSagsResponseBodySagsSag>> sag{};

  DescribeFlowLogSagsResponseBodySags() {}

  explicit DescribeFlowLogSagsResponseBodySags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sag) {
      vector<boost::any> temp1;
      for(auto item1:*sag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Sag") != m.end() && !m["Sag"].empty()) {
      if (typeid(vector<boost::any>) == m["Sag"].type()) {
        vector<DescribeFlowLogSagsResponseBodySagsSag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeFlowLogSagsResponseBodySagsSag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sag = make_shared<vector<DescribeFlowLogSagsResponseBodySagsSag>>(expect1);
      }
    }
  }


  virtual ~DescribeFlowLogSagsResponseBodySags() = default;
};
class DescribeFlowLogSagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<DescribeFlowLogSagsResponseBodySags> sags{};

  DescribeFlowLogSagsResponseBody() {}

  explicit DescribeFlowLogSagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (sags) {
      res["Sags"] = sags ? boost::any(sags->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("Sags") != m.end() && !m["Sags"].empty()) {
      if (typeid(map<string, boost::any>) == m["Sags"].type()) {
        DescribeFlowLogSagsResponseBodySags model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Sags"]));
        sags = make_shared<DescribeFlowLogSagsResponseBodySags>(model1);
      }
    }
  }


  virtual ~DescribeFlowLogSagsResponseBody() = default;
};
class DescribeFlowLogSagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeFlowLogSagsResponseBody> body{};

  DescribeFlowLogSagsResponse() {}

  explicit DescribeFlowLogSagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeFlowLogSagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeFlowLogSagsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeFlowLogSagsResponse() = default;
};
class ModifySagWifiRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};
  shared_ptr<string> isEnable{};
  shared_ptr<string> SSID{};
  shared_ptr<string> isBroadcast{};
  shared_ptr<string> channel{};
  shared_ptr<string> bandwidth{};
  shared_ptr<string> isAuth{};
  shared_ptr<string> authenticationType{};
  shared_ptr<string> encryptAlgorithm{};
  shared_ptr<string> password{};

  ModifySagWifiRequest() {}

  explicit ModifySagWifiRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    if (isEnable) {
      res["IsEnable"] = boost::any(*isEnable);
    }
    if (SSID) {
      res["SSID"] = boost::any(*SSID);
    }
    if (isBroadcast) {
      res["IsBroadcast"] = boost::any(*isBroadcast);
    }
    if (channel) {
      res["Channel"] = boost::any(*channel);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    if (isAuth) {
      res["IsAuth"] = boost::any(*isAuth);
    }
    if (authenticationType) {
      res["AuthenticationType"] = boost::any(*authenticationType);
    }
    if (encryptAlgorithm) {
      res["EncryptAlgorithm"] = boost::any(*encryptAlgorithm);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
    if (m.find("IsEnable") != m.end() && !m["IsEnable"].empty()) {
      isEnable = make_shared<string>(boost::any_cast<string>(m["IsEnable"]));
    }
    if (m.find("SSID") != m.end() && !m["SSID"].empty()) {
      SSID = make_shared<string>(boost::any_cast<string>(m["SSID"]));
    }
    if (m.find("IsBroadcast") != m.end() && !m["IsBroadcast"].empty()) {
      isBroadcast = make_shared<string>(boost::any_cast<string>(m["IsBroadcast"]));
    }
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      channel = make_shared<string>(boost::any_cast<string>(m["Channel"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<string>(boost::any_cast<string>(m["Bandwidth"]));
    }
    if (m.find("IsAuth") != m.end() && !m["IsAuth"].empty()) {
      isAuth = make_shared<string>(boost::any_cast<string>(m["IsAuth"]));
    }
    if (m.find("AuthenticationType") != m.end() && !m["AuthenticationType"].empty()) {
      authenticationType = make_shared<string>(boost::any_cast<string>(m["AuthenticationType"]));
    }
    if (m.find("EncryptAlgorithm") != m.end() && !m["EncryptAlgorithm"].empty()) {
      encryptAlgorithm = make_shared<string>(boost::any_cast<string>(m["EncryptAlgorithm"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
  }


  virtual ~ModifySagWifiRequest() = default;
};
class ModifySagWifiResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySagWifiResponseBody() {}

  explicit ModifySagWifiResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySagWifiResponseBody() = default;
};
class ModifySagWifiResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySagWifiResponseBody> body{};

  ModifySagWifiResponse() {}

  explicit ModifySagWifiResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySagWifiResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySagWifiResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySagWifiResponse() = default;
};
class ModifySagWanRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};
  shared_ptr<string> portName{};
  shared_ptr<string> IPType{};
  shared_ptr<string> IP{};
  shared_ptr<string> mask{};
  shared_ptr<string> gateway{};
  shared_ptr<string> username{};
  shared_ptr<string> password{};
  shared_ptr<long> priority{};
  shared_ptr<long> weight{};
  shared_ptr<string> ISP{};
  shared_ptr<long> bandwidth{};

  ModifySagWanRequest() {}

  explicit ModifySagWanRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    if (portName) {
      res["PortName"] = boost::any(*portName);
    }
    if (IPType) {
      res["IPType"] = boost::any(*IPType);
    }
    if (IP) {
      res["IP"] = boost::any(*IP);
    }
    if (mask) {
      res["Mask"] = boost::any(*mask);
    }
    if (gateway) {
      res["Gateway"] = boost::any(*gateway);
    }
    if (username) {
      res["Username"] = boost::any(*username);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (priority) {
      res["Priority"] = boost::any(*priority);
    }
    if (weight) {
      res["Weight"] = boost::any(*weight);
    }
    if (ISP) {
      res["ISP"] = boost::any(*ISP);
    }
    if (bandwidth) {
      res["Bandwidth"] = boost::any(*bandwidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
    if (m.find("PortName") != m.end() && !m["PortName"].empty()) {
      portName = make_shared<string>(boost::any_cast<string>(m["PortName"]));
    }
    if (m.find("IPType") != m.end() && !m["IPType"].empty()) {
      IPType = make_shared<string>(boost::any_cast<string>(m["IPType"]));
    }
    if (m.find("IP") != m.end() && !m["IP"].empty()) {
      IP = make_shared<string>(boost::any_cast<string>(m["IP"]));
    }
    if (m.find("Mask") != m.end() && !m["Mask"].empty()) {
      mask = make_shared<string>(boost::any_cast<string>(m["Mask"]));
    }
    if (m.find("Gateway") != m.end() && !m["Gateway"].empty()) {
      gateway = make_shared<string>(boost::any_cast<string>(m["Gateway"]));
    }
    if (m.find("Username") != m.end() && !m["Username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["Username"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Priority") != m.end() && !m["Priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["Priority"]));
    }
    if (m.find("Weight") != m.end() && !m["Weight"].empty()) {
      weight = make_shared<long>(boost::any_cast<long>(m["Weight"]));
    }
    if (m.find("ISP") != m.end() && !m["ISP"].empty()) {
      ISP = make_shared<string>(boost::any_cast<string>(m["ISP"]));
    }
    if (m.find("Bandwidth") != m.end() && !m["Bandwidth"].empty()) {
      bandwidth = make_shared<long>(boost::any_cast<long>(m["Bandwidth"]));
    }
  }


  virtual ~ModifySagWanRequest() = default;
};
class ModifySagWanResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ModifySagWanResponseBody() {}

  explicit ModifySagWanResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ModifySagWanResponseBody() = default;
};
class ModifySagWanResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ModifySagWanResponseBody> body{};

  ModifySagWanResponse() {}

  explicit ModifySagWanResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifySagWanResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifySagWanResponseBody>(model1);
      }
    }
  }


  virtual ~ModifySagWanResponse() = default;
};
class DescribeSmartAccessGatewayHaRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> regionId{};

  DescribeSmartAccessGatewayHaRequest() {}

  explicit DescribeSmartAccessGatewayHaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeSmartAccessGatewayHaRequest() = default;
};
class DescribeSmartAccessGatewayHaResponseBodyLinkBackupInfoListLinkBackupInfoList : public Darabonba::Model {
public:
  shared_ptr<string> mainLinkId{};
  shared_ptr<string> backupLinkState{};
  shared_ptr<string> linkLevelBackupState{};
  shared_ptr<string> backupLinkId{};
  shared_ptr<string> mainLinkState{};
  shared_ptr<string> linkLevelBackupType{};

  DescribeSmartAccessGatewayHaResponseBodyLinkBackupInfoListLinkBackupInfoList() {}

  explicit DescribeSmartAccessGatewayHaResponseBodyLinkBackupInfoListLinkBackupInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mainLinkId) {
      res["MainLinkId"] = boost::any(*mainLinkId);
    }
    if (backupLinkState) {
      res["BackupLinkState"] = boost::any(*backupLinkState);
    }
    if (linkLevelBackupState) {
      res["LinkLevelBackupState"] = boost::any(*linkLevelBackupState);
    }
    if (backupLinkId) {
      res["BackupLinkId"] = boost::any(*backupLinkId);
    }
    if (mainLinkState) {
      res["MainLinkState"] = boost::any(*mainLinkState);
    }
    if (linkLevelBackupType) {
      res["LinkLevelBackupType"] = boost::any(*linkLevelBackupType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MainLinkId") != m.end() && !m["MainLinkId"].empty()) {
      mainLinkId = make_shared<string>(boost::any_cast<string>(m["MainLinkId"]));
    }
    if (m.find("BackupLinkState") != m.end() && !m["BackupLinkState"].empty()) {
      backupLinkState = make_shared<string>(boost::any_cast<string>(m["BackupLinkState"]));
    }
    if (m.find("LinkLevelBackupState") != m.end() && !m["LinkLevelBackupState"].empty()) {
      linkLevelBackupState = make_shared<string>(boost::any_cast<string>(m["LinkLevelBackupState"]));
    }
    if (m.find("BackupLinkId") != m.end() && !m["BackupLinkId"].empty()) {
      backupLinkId = make_shared<string>(boost::any_cast<string>(m["BackupLinkId"]));
    }
    if (m.find("MainLinkState") != m.end() && !m["MainLinkState"].empty()) {
      mainLinkState = make_shared<string>(boost::any_cast<string>(m["MainLinkState"]));
    }
    if (m.find("LinkLevelBackupType") != m.end() && !m["LinkLevelBackupType"].empty()) {
      linkLevelBackupType = make_shared<string>(boost::any_cast<string>(m["LinkLevelBackupType"]));
    }
  }


  virtual ~DescribeSmartAccessGatewayHaResponseBodyLinkBackupInfoListLinkBackupInfoList() = default;
};
class DescribeSmartAccessGatewayHaResponseBodyLinkBackupInfoList : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeSmartAccessGatewayHaResponseBodyLinkBackupInfoListLinkBackupInfoList>> linkBackupInfoList{};

  DescribeSmartAccessGatewayHaResponseBodyLinkBackupInfoList() {}

  explicit DescribeSmartAccessGatewayHaResponseBodyLinkBackupInfoList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (linkBackupInfoList) {
      vector<boost::any> temp1;
      for(auto item1:*linkBackupInfoList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LinkBackupInfoList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LinkBackupInfoList") != m.end() && !m["LinkBackupInfoList"].empty()) {
      if (typeid(vector<boost::any>) == m["LinkBackupInfoList"].type()) {
        vector<DescribeSmartAccessGatewayHaResponseBodyLinkBackupInfoListLinkBackupInfoList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LinkBackupInfoList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSmartAccessGatewayHaResponseBodyLinkBackupInfoListLinkBackupInfoList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        linkBackupInfoList = make_shared<vector<DescribeSmartAccessGatewayHaResponseBodyLinkBackupInfoListLinkBackupInfoList>>(expect1);
      }
    }
  }


  virtual ~DescribeSmartAccessGatewayHaResponseBodyLinkBackupInfoList() = default;
};
class DescribeSmartAccessGatewayHaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> deviceLevelBackupState{};
  shared_ptr<string> requestId{};
  shared_ptr<string> backupDeviceId{};
  shared_ptr<DescribeSmartAccessGatewayHaResponseBodyLinkBackupInfoList> linkBackupInfoList{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> deviceLevelBackupType{};
  shared_ptr<string> mainDeviceId{};

  DescribeSmartAccessGatewayHaResponseBody() {}

  explicit DescribeSmartAccessGatewayHaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceLevelBackupState) {
      res["DeviceLevelBackupState"] = boost::any(*deviceLevelBackupState);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (backupDeviceId) {
      res["BackupDeviceId"] = boost::any(*backupDeviceId);
    }
    if (linkBackupInfoList) {
      res["LinkBackupInfoList"] = linkBackupInfoList ? boost::any(linkBackupInfoList->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (deviceLevelBackupType) {
      res["DeviceLevelBackupType"] = boost::any(*deviceLevelBackupType);
    }
    if (mainDeviceId) {
      res["MainDeviceId"] = boost::any(*mainDeviceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceLevelBackupState") != m.end() && !m["DeviceLevelBackupState"].empty()) {
      deviceLevelBackupState = make_shared<string>(boost::any_cast<string>(m["DeviceLevelBackupState"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("BackupDeviceId") != m.end() && !m["BackupDeviceId"].empty()) {
      backupDeviceId = make_shared<string>(boost::any_cast<string>(m["BackupDeviceId"]));
    }
    if (m.find("LinkBackupInfoList") != m.end() && !m["LinkBackupInfoList"].empty()) {
      if (typeid(map<string, boost::any>) == m["LinkBackupInfoList"].type()) {
        DescribeSmartAccessGatewayHaResponseBodyLinkBackupInfoList model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LinkBackupInfoList"]));
        linkBackupInfoList = make_shared<DescribeSmartAccessGatewayHaResponseBodyLinkBackupInfoList>(model1);
      }
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("DeviceLevelBackupType") != m.end() && !m["DeviceLevelBackupType"].empty()) {
      deviceLevelBackupType = make_shared<string>(boost::any_cast<string>(m["DeviceLevelBackupType"]));
    }
    if (m.find("MainDeviceId") != m.end() && !m["MainDeviceId"].empty()) {
      mainDeviceId = make_shared<string>(boost::any_cast<string>(m["MainDeviceId"]));
    }
  }


  virtual ~DescribeSmartAccessGatewayHaResponseBody() = default;
};
class DescribeSmartAccessGatewayHaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSmartAccessGatewayHaResponseBody> body{};

  DescribeSmartAccessGatewayHaResponse() {}

  explicit DescribeSmartAccessGatewayHaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSmartAccessGatewayHaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSmartAccessGatewayHaResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSmartAccessGatewayHaResponse() = default;
};
class DeleteCloudConnectNetworkRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> ccnId{};
  shared_ptr<string> regionId{};

  DeleteCloudConnectNetworkRequest() {}

  explicit DeleteCloudConnectNetworkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (ccnId) {
      res["CcnId"] = boost::any(*ccnId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("CcnId") != m.end() && !m["CcnId"].empty()) {
      ccnId = make_shared<string>(boost::any_cast<string>(m["CcnId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DeleteCloudConnectNetworkRequest() = default;
};
class DeleteCloudConnectNetworkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteCloudConnectNetworkResponseBody() {}

  explicit DeleteCloudConnectNetworkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteCloudConnectNetworkResponseBody() = default;
};
class DeleteCloudConnectNetworkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteCloudConnectNetworkResponseBody> body{};

  DeleteCloudConnectNetworkResponse() {}

  explicit DeleteCloudConnectNetworkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCloudConnectNetworkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCloudConnectNetworkResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCloudConnectNetworkResponse() = default;
};
class DowngradeSmartAccessGatewaySoftwareRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> regionId{};
  shared_ptr<bool> autoPay{};
  shared_ptr<long> dataPlan{};
  shared_ptr<long> userCount{};

  DowngradeSmartAccessGatewaySoftwareRequest() {}

  explicit DowngradeSmartAccessGatewaySoftwareRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (autoPay) {
      res["AutoPay"] = boost::any(*autoPay);
    }
    if (dataPlan) {
      res["DataPlan"] = boost::any(*dataPlan);
    }
    if (userCount) {
      res["UserCount"] = boost::any(*userCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("AutoPay") != m.end() && !m["AutoPay"].empty()) {
      autoPay = make_shared<bool>(boost::any_cast<bool>(m["AutoPay"]));
    }
    if (m.find("DataPlan") != m.end() && !m["DataPlan"].empty()) {
      dataPlan = make_shared<long>(boost::any_cast<long>(m["DataPlan"]));
    }
    if (m.find("UserCount") != m.end() && !m["UserCount"].empty()) {
      userCount = make_shared<long>(boost::any_cast<long>(m["UserCount"]));
    }
  }


  virtual ~DowngradeSmartAccessGatewaySoftwareRequest() = default;
};
class DowngradeSmartAccessGatewaySoftwareResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> orderId{};

  DowngradeSmartAccessGatewaySoftwareResponseBody() {}

  explicit DowngradeSmartAccessGatewaySoftwareResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (orderId) {
      res["OrderId"] = boost::any(*orderId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("OrderId") != m.end() && !m["OrderId"].empty()) {
      orderId = make_shared<string>(boost::any_cast<string>(m["OrderId"]));
    }
  }


  virtual ~DowngradeSmartAccessGatewaySoftwareResponseBody() = default;
};
class DowngradeSmartAccessGatewaySoftwareResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DowngradeSmartAccessGatewaySoftwareResponseBody> body{};

  DowngradeSmartAccessGatewaySoftwareResponse() {}

  explicit DowngradeSmartAccessGatewaySoftwareResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DowngradeSmartAccessGatewaySoftwareResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DowngradeSmartAccessGatewaySoftwareResponseBody>(model1);
      }
    }
  }


  virtual ~DowngradeSmartAccessGatewaySoftwareResponse() = default;
};
class DescribeRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> acceptLanguage{};

  DescribeRegionsRequest() {}

  explicit DescribeRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
  }


  virtual ~DescribeRegionsRequest() = default;
};
class DescribeRegionsResponseBodyRegionsRegion : public Darabonba::Model {
public:
  shared_ptr<string> localName{};
  shared_ptr<string> regionEndpoint{};
  shared_ptr<string> regionId{};

  DescribeRegionsResponseBodyRegionsRegion() {}

  explicit DescribeRegionsResponseBodyRegionsRegion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (regionEndpoint) {
      res["RegionEndpoint"] = boost::any(*regionEndpoint);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("RegionEndpoint") != m.end() && !m["RegionEndpoint"].empty()) {
      regionEndpoint = make_shared<string>(boost::any_cast<string>(m["RegionEndpoint"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~DescribeRegionsResponseBodyRegionsRegion() = default;
};
class DescribeRegionsResponseBodyRegions : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeRegionsResponseBodyRegionsRegion>> region{};

  DescribeRegionsResponseBodyRegions() {}

  explicit DescribeRegionsResponseBodyRegions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (region) {
      vector<boost::any> temp1;
      for(auto item1:*region){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Region"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Region") != m.end() && !m["Region"].empty()) {
      if (typeid(vector<boost::any>) == m["Region"].type()) {
        vector<DescribeRegionsResponseBodyRegionsRegion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Region"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRegionsResponseBodyRegionsRegion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        region = make_shared<vector<DescribeRegionsResponseBodyRegionsRegion>>(expect1);
      }
    }
  }


  virtual ~DescribeRegionsResponseBodyRegions() = default;
};
class DescribeRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeRegionsResponseBodyRegions> regions{};

  DescribeRegionsResponseBody() {}

  explicit DescribeRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (regions) {
      res["Regions"] = regions ? boost::any(regions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(map<string, boost::any>) == m["Regions"].type()) {
        DescribeRegionsResponseBodyRegions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Regions"]));
        regions = make_shared<DescribeRegionsResponseBodyRegions>(model1);
      }
    }
  }


  virtual ~DescribeRegionsResponseBody() = default;
};
class DescribeRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeRegionsResponseBody> body{};

  DescribeRegionsResponse() {}

  explicit DescribeRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRegionsResponse() = default;
};
class DescribeHealthChecksRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> hcInstanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> pageNumber{};
  shared_ptr<long> pageSize{};

  DescribeHealthChecksRequest() {}

  explicit DescribeHealthChecksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (hcInstanceId) {
      res["HcInstanceId"] = boost::any(*hcInstanceId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("HcInstanceId") != m.end() && !m["HcInstanceId"].empty()) {
      hcInstanceId = make_shared<string>(boost::any_cast<string>(m["HcInstanceId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
  }


  virtual ~DescribeHealthChecksRequest() = default;
};
class DescribeHealthChecksResponseBodyHealthChecksHealthCheck : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<long> probeTimeout{};
  shared_ptr<string> status{};
  shared_ptr<string> dstIpAddr{};
  shared_ptr<long> relationCount{};
  shared_ptr<long> rttFailThreshold{};
  shared_ptr<string> smartAGId{};
  shared_ptr<long> dstPort{};
  shared_ptr<long> failCountThreshold{};
  shared_ptr<long> rttThreshold{};
  shared_ptr<long> srcPort{};
  shared_ptr<long> probeCount{};
  shared_ptr<string> description{};
  shared_ptr<string> srcIpAddr{};
  shared_ptr<long> probeInterval{};
  shared_ptr<string> name{};
  shared_ptr<string> hcInstanceId{};

  DescribeHealthChecksResponseBodyHealthChecksHealthCheck() {}

  explicit DescribeHealthChecksResponseBodyHealthChecksHealthCheck(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (probeTimeout) {
      res["ProbeTimeout"] = boost::any(*probeTimeout);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (dstIpAddr) {
      res["DstIpAddr"] = boost::any(*dstIpAddr);
    }
    if (relationCount) {
      res["RelationCount"] = boost::any(*relationCount);
    }
    if (rttFailThreshold) {
      res["RttFailThreshold"] = boost::any(*rttFailThreshold);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (dstPort) {
      res["DstPort"] = boost::any(*dstPort);
    }
    if (failCountThreshold) {
      res["FailCountThreshold"] = boost::any(*failCountThreshold);
    }
    if (rttThreshold) {
      res["RttThreshold"] = boost::any(*rttThreshold);
    }
    if (srcPort) {
      res["SrcPort"] = boost::any(*srcPort);
    }
    if (probeCount) {
      res["ProbeCount"] = boost::any(*probeCount);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (srcIpAddr) {
      res["SrcIpAddr"] = boost::any(*srcIpAddr);
    }
    if (probeInterval) {
      res["ProbeInterval"] = boost::any(*probeInterval);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (hcInstanceId) {
      res["HcInstanceId"] = boost::any(*hcInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("ProbeTimeout") != m.end() && !m["ProbeTimeout"].empty()) {
      probeTimeout = make_shared<long>(boost::any_cast<long>(m["ProbeTimeout"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("DstIpAddr") != m.end() && !m["DstIpAddr"].empty()) {
      dstIpAddr = make_shared<string>(boost::any_cast<string>(m["DstIpAddr"]));
    }
    if (m.find("RelationCount") != m.end() && !m["RelationCount"].empty()) {
      relationCount = make_shared<long>(boost::any_cast<long>(m["RelationCount"]));
    }
    if (m.find("RttFailThreshold") != m.end() && !m["RttFailThreshold"].empty()) {
      rttFailThreshold = make_shared<long>(boost::any_cast<long>(m["RttFailThreshold"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("DstPort") != m.end() && !m["DstPort"].empty()) {
      dstPort = make_shared<long>(boost::any_cast<long>(m["DstPort"]));
    }
    if (m.find("FailCountThreshold") != m.end() && !m["FailCountThreshold"].empty()) {
      failCountThreshold = make_shared<long>(boost::any_cast<long>(m["FailCountThreshold"]));
    }
    if (m.find("RttThreshold") != m.end() && !m["RttThreshold"].empty()) {
      rttThreshold = make_shared<long>(boost::any_cast<long>(m["RttThreshold"]));
    }
    if (m.find("SrcPort") != m.end() && !m["SrcPort"].empty()) {
      srcPort = make_shared<long>(boost::any_cast<long>(m["SrcPort"]));
    }
    if (m.find("ProbeCount") != m.end() && !m["ProbeCount"].empty()) {
      probeCount = make_shared<long>(boost::any_cast<long>(m["ProbeCount"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("SrcIpAddr") != m.end() && !m["SrcIpAddr"].empty()) {
      srcIpAddr = make_shared<string>(boost::any_cast<string>(m["SrcIpAddr"]));
    }
    if (m.find("ProbeInterval") != m.end() && !m["ProbeInterval"].empty()) {
      probeInterval = make_shared<long>(boost::any_cast<long>(m["ProbeInterval"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("HcInstanceId") != m.end() && !m["HcInstanceId"].empty()) {
      hcInstanceId = make_shared<string>(boost::any_cast<string>(m["HcInstanceId"]));
    }
  }


  virtual ~DescribeHealthChecksResponseBodyHealthChecksHealthCheck() = default;
};
class DescribeHealthChecksResponseBodyHealthChecks : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeHealthChecksResponseBodyHealthChecksHealthCheck>> healthCheck{};

  DescribeHealthChecksResponseBodyHealthChecks() {}

  explicit DescribeHealthChecksResponseBodyHealthChecks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (healthCheck) {
      vector<boost::any> temp1;
      for(auto item1:*healthCheck){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["HealthCheck"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("HealthCheck") != m.end() && !m["HealthCheck"].empty()) {
      if (typeid(vector<boost::any>) == m["HealthCheck"].type()) {
        vector<DescribeHealthChecksResponseBodyHealthChecksHealthCheck> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["HealthCheck"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeHealthChecksResponseBodyHealthChecksHealthCheck model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        healthCheck = make_shared<vector<DescribeHealthChecksResponseBodyHealthChecksHealthCheck>>(expect1);
      }
    }
  }


  virtual ~DescribeHealthChecksResponseBodyHealthChecks() = default;
};
class DescribeHealthChecksResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<DescribeHealthChecksResponseBodyHealthChecks> healthChecks{};

  DescribeHealthChecksResponseBody() {}

  explicit DescribeHealthChecksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (healthChecks) {
      res["HealthChecks"] = healthChecks ? boost::any(healthChecks->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("HealthChecks") != m.end() && !m["HealthChecks"].empty()) {
      if (typeid(map<string, boost::any>) == m["HealthChecks"].type()) {
        DescribeHealthChecksResponseBodyHealthChecks model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HealthChecks"]));
        healthChecks = make_shared<DescribeHealthChecksResponseBodyHealthChecks>(model1);
      }
    }
  }


  virtual ~DescribeHealthChecksResponseBody() = default;
};
class DescribeHealthChecksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeHealthChecksResponseBody> body{};

  DescribeHealthChecksResponse() {}

  explicit DescribeHealthChecksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeHealthChecksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeHealthChecksResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeHealthChecksResponse() = default;
};
class GetCloudConnectNetworkUseLimitRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};

  GetCloudConnectNetworkUseLimitRequest() {}

  explicit GetCloudConnectNetworkUseLimitRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~GetCloudConnectNetworkUseLimitRequest() = default;
};
class GetCloudConnectNetworkUseLimitResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> usedAmount{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalAmount{};

  GetCloudConnectNetworkUseLimitResponseBody() {}

  explicit GetCloudConnectNetworkUseLimitResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (usedAmount) {
      res["UsedAmount"] = boost::any(*usedAmount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalAmount) {
      res["TotalAmount"] = boost::any(*totalAmount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UsedAmount") != m.end() && !m["UsedAmount"].empty()) {
      usedAmount = make_shared<long>(boost::any_cast<long>(m["UsedAmount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalAmount") != m.end() && !m["TotalAmount"].empty()) {
      totalAmount = make_shared<long>(boost::any_cast<long>(m["TotalAmount"]));
    }
  }


  virtual ~GetCloudConnectNetworkUseLimitResponseBody() = default;
};
class GetCloudConnectNetworkUseLimitResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<GetCloudConnectNetworkUseLimitResponseBody> body{};

  GetCloudConnectNetworkUseLimitResponse() {}

  explicit GetCloudConnectNetworkUseLimitResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetCloudConnectNetworkUseLimitResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetCloudConnectNetworkUseLimitResponseBody>(model1);
      }
    }
  }


  virtual ~GetCloudConnectNetworkUseLimitResponse() = default;
};
class ListAccessPointsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> smartAGId{};
  shared_ptr<long> pageNumber{};

  ListAccessPointsRequest() {}

  explicit ListAccessPointsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
  }


  virtual ~ListAccessPointsRequest() = default;
};
class ListAccessPointsResponseBodyAccessPoints : public Darabonba::Model {
public:
  shared_ptr<string> longitude{};
  shared_ptr<long> activeSmartAGCount{};
  shared_ptr<long> inactiveSmartAGCount{};
  shared_ptr<string> latitude{};
  shared_ptr<long> accessPointId{};

  ListAccessPointsResponseBodyAccessPoints() {}

  explicit ListAccessPointsResponseBodyAccessPoints(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (longitude) {
      res["Longitude"] = boost::any(*longitude);
    }
    if (activeSmartAGCount) {
      res["ActiveSmartAGCount"] = boost::any(*activeSmartAGCount);
    }
    if (inactiveSmartAGCount) {
      res["InactiveSmartAGCount"] = boost::any(*inactiveSmartAGCount);
    }
    if (latitude) {
      res["Latitude"] = boost::any(*latitude);
    }
    if (accessPointId) {
      res["AccessPointId"] = boost::any(*accessPointId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Longitude") != m.end() && !m["Longitude"].empty()) {
      longitude = make_shared<string>(boost::any_cast<string>(m["Longitude"]));
    }
    if (m.find("ActiveSmartAGCount") != m.end() && !m["ActiveSmartAGCount"].empty()) {
      activeSmartAGCount = make_shared<long>(boost::any_cast<long>(m["ActiveSmartAGCount"]));
    }
    if (m.find("InactiveSmartAGCount") != m.end() && !m["InactiveSmartAGCount"].empty()) {
      inactiveSmartAGCount = make_shared<long>(boost::any_cast<long>(m["InactiveSmartAGCount"]));
    }
    if (m.find("Latitude") != m.end() && !m["Latitude"].empty()) {
      latitude = make_shared<string>(boost::any_cast<string>(m["Latitude"]));
    }
    if (m.find("AccessPointId") != m.end() && !m["AccessPointId"].empty()) {
      accessPointId = make_shared<long>(boost::any_cast<long>(m["AccessPointId"]));
    }
  }


  virtual ~ListAccessPointsResponseBodyAccessPoints() = default;
};
class ListAccessPointsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<ListAccessPointsResponseBodyAccessPoints>> accessPoints{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> requestId{};

  ListAccessPointsResponseBody() {}

  explicit ListAccessPointsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessPoints) {
      vector<boost::any> temp1;
      for(auto item1:*accessPoints){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AccessPoints"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessPoints") != m.end() && !m["AccessPoints"].empty()) {
      if (typeid(vector<boost::any>) == m["AccessPoints"].type()) {
        vector<ListAccessPointsResponseBodyAccessPoints> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AccessPoints"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAccessPointsResponseBodyAccessPoints model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        accessPoints = make_shared<vector<ListAccessPointsResponseBodyAccessPoints>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListAccessPointsResponseBody() = default;
};
class ListAccessPointsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListAccessPointsResponseBody> body{};

  ListAccessPointsResponse() {}

  explicit ListAccessPointsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAccessPointsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAccessPointsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAccessPointsResponse() = default;
};
class DeleteQosCarRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> qosId{};
  shared_ptr<string> qosCarId{};

  DeleteQosCarRequest() {}

  explicit DeleteQosCarRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (qosId) {
      res["QosId"] = boost::any(*qosId);
    }
    if (qosCarId) {
      res["QosCarId"] = boost::any(*qosCarId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("QosId") != m.end() && !m["QosId"].empty()) {
      qosId = make_shared<string>(boost::any_cast<string>(m["QosId"]));
    }
    if (m.find("QosCarId") != m.end() && !m["QosCarId"].empty()) {
      qosCarId = make_shared<string>(boost::any_cast<string>(m["QosCarId"]));
    }
  }


  virtual ~DeleteQosCarRequest() = default;
};
class DeleteQosCarResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteQosCarResponseBody() {}

  explicit DeleteQosCarResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteQosCarResponseBody() = default;
};
class DeleteQosCarResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DeleteQosCarResponseBody> body{};

  DeleteQosCarResponse() {}

  explicit DeleteQosCarResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteQosCarResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteQosCarResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteQosCarResponse() = default;
};
class DescribeDeviceAutoUpgradePolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> versionType{};

  DescribeDeviceAutoUpgradePolicyRequest() {}

  explicit DescribeDeviceAutoUpgradePolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (versionType) {
      res["VersionType"] = boost::any(*versionType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("VersionType") != m.end() && !m["VersionType"].empty()) {
      versionType = make_shared<string>(boost::any_cast<string>(m["VersionType"]));
    }
  }


  virtual ~DescribeDeviceAutoUpgradePolicyRequest() = default;
};
class DescribeDeviceAutoUpgradePolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> upgradeType{};
  shared_ptr<string> timeZone{};
  shared_ptr<string> serialNumber{};
  shared_ptr<string> requestId{};
  shared_ptr<string> jitter{};
  shared_ptr<string> duration{};
  shared_ptr<string> cronExpression{};
  shared_ptr<string> smartAGId{};

  DescribeDeviceAutoUpgradePolicyResponseBody() {}

  explicit DescribeDeviceAutoUpgradePolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (upgradeType) {
      res["UpgradeType"] = boost::any(*upgradeType);
    }
    if (timeZone) {
      res["TimeZone"] = boost::any(*timeZone);
    }
    if (serialNumber) {
      res["SerialNumber"] = boost::any(*serialNumber);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (jitter) {
      res["Jitter"] = boost::any(*jitter);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (cronExpression) {
      res["CronExpression"] = boost::any(*cronExpression);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("UpgradeType") != m.end() && !m["UpgradeType"].empty()) {
      upgradeType = make_shared<string>(boost::any_cast<string>(m["UpgradeType"]));
    }
    if (m.find("TimeZone") != m.end() && !m["TimeZone"].empty()) {
      timeZone = make_shared<string>(boost::any_cast<string>(m["TimeZone"]));
    }
    if (m.find("SerialNumber") != m.end() && !m["SerialNumber"].empty()) {
      serialNumber = make_shared<string>(boost::any_cast<string>(m["SerialNumber"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Jitter") != m.end() && !m["Jitter"].empty()) {
      jitter = make_shared<string>(boost::any_cast<string>(m["Jitter"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<string>(boost::any_cast<string>(m["Duration"]));
    }
    if (m.find("CronExpression") != m.end() && !m["CronExpression"].empty()) {
      cronExpression = make_shared<string>(boost::any_cast<string>(m["CronExpression"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
  }


  virtual ~DescribeDeviceAutoUpgradePolicyResponseBody() = default;
};
class DescribeDeviceAutoUpgradePolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeDeviceAutoUpgradePolicyResponseBody> body{};

  DescribeDeviceAutoUpgradePolicyResponse() {}

  explicit DescribeDeviceAutoUpgradePolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDeviceAutoUpgradePolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDeviceAutoUpgradePolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDeviceAutoUpgradePolicyResponse() = default;
};
class ListDpiSignaturesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> dpiGroupId{};
  shared_ptr<vector<string>> dpiSignatureIds{};
  shared_ptr<vector<string>> dpiSignatureNames{};

  ListDpiSignaturesRequest() {}

  explicit ListDpiSignaturesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (dpiGroupId) {
      res["DpiGroupId"] = boost::any(*dpiGroupId);
    }
    if (dpiSignatureIds) {
      res["DpiSignatureIds"] = boost::any(*dpiSignatureIds);
    }
    if (dpiSignatureNames) {
      res["DpiSignatureNames"] = boost::any(*dpiSignatureNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("DpiGroupId") != m.end() && !m["DpiGroupId"].empty()) {
      dpiGroupId = make_shared<string>(boost::any_cast<string>(m["DpiGroupId"]));
    }
    if (m.find("DpiSignatureIds") != m.end() && !m["DpiSignatureIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DpiSignatureIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DpiSignatureIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dpiSignatureIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DpiSignatureNames") != m.end() && !m["DpiSignatureNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DpiSignatureNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DpiSignatureNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dpiSignatureNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDpiSignaturesRequest() = default;
};
class ListDpiSignaturesResponseBodyDpiSignature : public Darabonba::Model {
public:
  shared_ptr<string> dpiSignatureId{};
  shared_ptr<string> minSignatureDbVersion{};
  shared_ptr<string> dpiGroupId{};
  shared_ptr<string> minEngineVersion{};
  shared_ptr<string> dpiSignatureName{};

  ListDpiSignaturesResponseBodyDpiSignature() {}

  explicit ListDpiSignaturesResponseBodyDpiSignature(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dpiSignatureId) {
      res["DpiSignatureId"] = boost::any(*dpiSignatureId);
    }
    if (minSignatureDbVersion) {
      res["MinSignatureDbVersion"] = boost::any(*minSignatureDbVersion);
    }
    if (dpiGroupId) {
      res["DpiGroupId"] = boost::any(*dpiGroupId);
    }
    if (minEngineVersion) {
      res["MinEngineVersion"] = boost::any(*minEngineVersion);
    }
    if (dpiSignatureName) {
      res["DpiSignatureName"] = boost::any(*dpiSignatureName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DpiSignatureId") != m.end() && !m["DpiSignatureId"].empty()) {
      dpiSignatureId = make_shared<string>(boost::any_cast<string>(m["DpiSignatureId"]));
    }
    if (m.find("MinSignatureDbVersion") != m.end() && !m["MinSignatureDbVersion"].empty()) {
      minSignatureDbVersion = make_shared<string>(boost::any_cast<string>(m["MinSignatureDbVersion"]));
    }
    if (m.find("DpiGroupId") != m.end() && !m["DpiGroupId"].empty()) {
      dpiGroupId = make_shared<string>(boost::any_cast<string>(m["DpiGroupId"]));
    }
    if (m.find("MinEngineVersion") != m.end() && !m["MinEngineVersion"].empty()) {
      minEngineVersion = make_shared<string>(boost::any_cast<string>(m["MinEngineVersion"]));
    }
    if (m.find("DpiSignatureName") != m.end() && !m["DpiSignatureName"].empty()) {
      dpiSignatureName = make_shared<string>(boost::any_cast<string>(m["DpiSignatureName"]));
    }
  }


  virtual ~ListDpiSignaturesResponseBodyDpiSignature() = default;
};
class ListDpiSignaturesResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListDpiSignaturesResponseBodyDpiSignature>> dpiSignature{};

  ListDpiSignaturesResponseBody() {}

  explicit ListDpiSignaturesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (dpiSignature) {
      vector<boost::any> temp1;
      for(auto item1:*dpiSignature){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DpiSignature"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DpiSignature") != m.end() && !m["DpiSignature"].empty()) {
      if (typeid(vector<boost::any>) == m["DpiSignature"].type()) {
        vector<ListDpiSignaturesResponseBodyDpiSignature> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DpiSignature"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDpiSignaturesResponseBodyDpiSignature model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dpiSignature = make_shared<vector<ListDpiSignaturesResponseBodyDpiSignature>>(expect1);
      }
    }
  }


  virtual ~ListDpiSignaturesResponseBody() = default;
};
class ListDpiSignaturesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListDpiSignaturesResponseBody> body{};

  ListDpiSignaturesResponse() {}

  explicit ListDpiSignaturesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDpiSignaturesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDpiSignaturesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDpiSignaturesResponse() = default;
};
class UnbindVbrRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> vbrId{};
  shared_ptr<string> vbrRegionId{};
  shared_ptr<long> smartAGUid{};

  UnbindVbrRequest() {}

  explicit UnbindVbrRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (vbrId) {
      res["VbrId"] = boost::any(*vbrId);
    }
    if (vbrRegionId) {
      res["VbrRegionId"] = boost::any(*vbrRegionId);
    }
    if (smartAGUid) {
      res["SmartAGUid"] = boost::any(*smartAGUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("VbrId") != m.end() && !m["VbrId"].empty()) {
      vbrId = make_shared<string>(boost::any_cast<string>(m["VbrId"]));
    }
    if (m.find("VbrRegionId") != m.end() && !m["VbrRegionId"].empty()) {
      vbrRegionId = make_shared<string>(boost::any_cast<string>(m["VbrRegionId"]));
    }
    if (m.find("SmartAGUid") != m.end() && !m["SmartAGUid"].empty()) {
      smartAGUid = make_shared<long>(boost::any_cast<long>(m["SmartAGUid"]));
    }
  }


  virtual ~UnbindVbrRequest() = default;
};
class UnbindVbrResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UnbindVbrResponseBody() {}

  explicit UnbindVbrResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UnbindVbrResponseBody() = default;
};
class UnbindVbrResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<UnbindVbrResponseBody> body{};

  UnbindVbrResponse() {}

  explicit UnbindVbrResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UnbindVbrResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UnbindVbrResponseBody>(model1);
      }
    }
  }


  virtual ~UnbindVbrResponse() = default;
};
class DescribeBindableSmartAccessGatewaysRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> ccnId{};
  shared_ptr<bool> crossAccount{};
  shared_ptr<long> pageSize{};
  shared_ptr<long> pageNumber{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> name{};

  DescribeBindableSmartAccessGatewaysRequest() {}

  explicit DescribeBindableSmartAccessGatewaysRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (ccnId) {
      res["CcnId"] = boost::any(*ccnId);
    }
    if (crossAccount) {
      res["CrossAccount"] = boost::any(*crossAccount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("CcnId") != m.end() && !m["CcnId"].empty()) {
      ccnId = make_shared<string>(boost::any_cast<string>(m["CcnId"]));
    }
    if (m.find("CrossAccount") != m.end() && !m["CrossAccount"].empty()) {
      crossAccount = make_shared<bool>(boost::any_cast<bool>(m["CrossAccount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~DescribeBindableSmartAccessGatewaysRequest() = default;
};
class DescribeBindableSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGateway : public Darabonba::Model {
public:
  shared_ptr<string> smartAGId{};
  shared_ptr<string> name{};
  shared_ptr<long> smartAGUid{};

  DescribeBindableSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGateway() {}

  explicit DescribeBindableSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGateway(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (smartAGUid) {
      res["SmartAGUid"] = boost::any(*smartAGUid);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("SmartAGUid") != m.end() && !m["SmartAGUid"].empty()) {
      smartAGUid = make_shared<long>(boost::any_cast<long>(m["SmartAGUid"]));
    }
  }


  virtual ~DescribeBindableSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGateway() = default;
};
class DescribeBindableSmartAccessGatewaysResponseBodySmartAccessGateways : public Darabonba::Model {
public:
  shared_ptr<vector<DescribeBindableSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGateway>> smartAccessGateway{};

  DescribeBindableSmartAccessGatewaysResponseBodySmartAccessGateways() {}

  explicit DescribeBindableSmartAccessGatewaysResponseBodySmartAccessGateways(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (smartAccessGateway) {
      vector<boost::any> temp1;
      for(auto item1:*smartAccessGateway){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SmartAccessGateway"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SmartAccessGateway") != m.end() && !m["SmartAccessGateway"].empty()) {
      if (typeid(vector<boost::any>) == m["SmartAccessGateway"].type()) {
        vector<DescribeBindableSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGateway> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SmartAccessGateway"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeBindableSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGateway model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        smartAccessGateway = make_shared<vector<DescribeBindableSmartAccessGatewaysResponseBodySmartAccessGatewaysSmartAccessGateway>>(expect1);
      }
    }
  }


  virtual ~DescribeBindableSmartAccessGatewaysResponseBodySmartAccessGateways() = default;
};
class DescribeBindableSmartAccessGatewaysResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<long> pageNumber{};
  shared_ptr<DescribeBindableSmartAccessGatewaysResponseBodySmartAccessGateways> smartAccessGateways{};

  DescribeBindableSmartAccessGatewaysResponseBody() {}

  explicit DescribeBindableSmartAccessGatewaysResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (pageNumber) {
      res["PageNumber"] = boost::any(*pageNumber);
    }
    if (smartAccessGateways) {
      res["SmartAccessGateways"] = smartAccessGateways ? boost::any(smartAccessGateways->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("PageNumber") != m.end() && !m["PageNumber"].empty()) {
      pageNumber = make_shared<long>(boost::any_cast<long>(m["PageNumber"]));
    }
    if (m.find("SmartAccessGateways") != m.end() && !m["SmartAccessGateways"].empty()) {
      if (typeid(map<string, boost::any>) == m["SmartAccessGateways"].type()) {
        DescribeBindableSmartAccessGatewaysResponseBodySmartAccessGateways model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["SmartAccessGateways"]));
        smartAccessGateways = make_shared<DescribeBindableSmartAccessGatewaysResponseBodySmartAccessGateways>(model1);
      }
    }
  }


  virtual ~DescribeBindableSmartAccessGatewaysResponseBody() = default;
};
class DescribeBindableSmartAccessGatewaysResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeBindableSmartAccessGatewaysResponseBody> body{};

  DescribeBindableSmartAccessGatewaysResponse() {}

  explicit DescribeBindableSmartAccessGatewaysResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeBindableSmartAccessGatewaysResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeBindableSmartAccessGatewaysResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeBindableSmartAccessGatewaysResponse() = default;
};
class DescribeSagPortListRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> smartAGId{};
  shared_ptr<string> smartAGSn{};

  DescribeSagPortListRequest() {}

  explicit DescribeSagPortListRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (smartAGId) {
      res["SmartAGId"] = boost::any(*smartAGId);
    }
    if (smartAGSn) {
      res["SmartAGSn"] = boost::any(*smartAGSn);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("SmartAGId") != m.end() && !m["SmartAGId"].empty()) {
      smartAGId = make_shared<string>(boost::any_cast<string>(m["SmartAGId"]));
    }
    if (m.find("SmartAGSn") != m.end() && !m["SmartAGSn"].empty()) {
      smartAGSn = make_shared<string>(boost::any_cast<string>(m["SmartAGSn"]));
    }
  }


  virtual ~DescribeSagPortListRequest() = default;
};
class DescribeSagPortListResponseBodyPorts : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> portName{};
  shared_ptr<string> role{};
  shared_ptr<string> mac{};

  DescribeSagPortListResponseBodyPorts() {}

  explicit DescribeSagPortListResponseBodyPorts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (portName) {
      res["PortName"] = boost::any(*portName);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (mac) {
      res["Mac"] = boost::any(*mac);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("PortName") != m.end() && !m["PortName"].empty()) {
      portName = make_shared<string>(boost::any_cast<string>(m["PortName"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Mac") != m.end() && !m["Mac"].empty()) {
      mac = make_shared<string>(boost::any_cast<string>(m["Mac"]));
    }
  }


  virtual ~DescribeSagPortListResponseBodyPorts() = default;
};
class DescribeSagPortListResponseBodyTaskStates : public Darabonba::Model {
public:
  shared_ptr<string> errorMessage{};
  shared_ptr<string> state{};
  shared_ptr<string> errorCode{};
  shared_ptr<string> createTime{};

  DescribeSagPortListResponseBodyTaskStates() {}

  explicit DescribeSagPortListResponseBodyTaskStates(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
  }


  virtual ~DescribeSagPortListResponseBodyTaskStates() = default;
};
class DescribeSagPortListResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeSagPortListResponseBodyPorts>> ports{};
  shared_ptr<vector<DescribeSagPortListResponseBodyTaskStates>> taskStates{};

  DescribeSagPortListResponseBody() {}

  explicit DescribeSagPortListResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (ports) {
      vector<boost::any> temp1;
      for(auto item1:*ports){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Ports"] = boost::any(temp1);
    }
    if (taskStates) {
      vector<boost::any> temp1;
      for(auto item1:*taskStates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TaskStates"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Ports") != m.end() && !m["Ports"].empty()) {
      if (typeid(vector<boost::any>) == m["Ports"].type()) {
        vector<DescribeSagPortListResponseBodyPorts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Ports"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSagPortListResponseBodyPorts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ports = make_shared<vector<DescribeSagPortListResponseBodyPorts>>(expect1);
      }
    }
    if (m.find("TaskStates") != m.end() && !m["TaskStates"].empty()) {
      if (typeid(vector<boost::any>) == m["TaskStates"].type()) {
        vector<DescribeSagPortListResponseBodyTaskStates> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TaskStates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeSagPortListResponseBodyTaskStates model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        taskStates = make_shared<vector<DescribeSagPortListResponseBodyTaskStates>>(expect1);
      }
    }
  }


  virtual ~DescribeSagPortListResponseBody() = default;
};
class DescribeSagPortListResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<DescribeSagPortListResponseBody> body{};

  DescribeSagPortListResponse() {}

  explicit DescribeSagPortListResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSagPortListResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSagPortListResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSagPortListResponse() = default;
};
class ListDpiGroupsRequest : public Darabonba::Model {
public:
  shared_ptr<string> ownerAccount{};
  shared_ptr<long> ownerId{};
  shared_ptr<string> resourceOwnerAccount{};
  shared_ptr<long> resourceOwnerId{};
  shared_ptr<string> regionId{};
  shared_ptr<string> nextToken{};
  shared_ptr<long> maxResults{};
  shared_ptr<vector<string>> dpiGroupIds{};
  shared_ptr<vector<string>> dpiGroupNames{};

  ListDpiGroupsRequest() {}

  explicit ListDpiGroupsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerAccount) {
      res["OwnerAccount"] = boost::any(*ownerAccount);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (resourceOwnerAccount) {
      res["ResourceOwnerAccount"] = boost::any(*resourceOwnerAccount);
    }
    if (resourceOwnerId) {
      res["ResourceOwnerId"] = boost::any(*resourceOwnerId);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (dpiGroupIds) {
      res["DpiGroupIds"] = boost::any(*dpiGroupIds);
    }
    if (dpiGroupNames) {
      res["DpiGroupNames"] = boost::any(*dpiGroupNames);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerAccount") != m.end() && !m["OwnerAccount"].empty()) {
      ownerAccount = make_shared<string>(boost::any_cast<string>(m["OwnerAccount"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<long>(boost::any_cast<long>(m["OwnerId"]));
    }
    if (m.find("ResourceOwnerAccount") != m.end() && !m["ResourceOwnerAccount"].empty()) {
      resourceOwnerAccount = make_shared<string>(boost::any_cast<string>(m["ResourceOwnerAccount"]));
    }
    if (m.find("ResourceOwnerId") != m.end() && !m["ResourceOwnerId"].empty()) {
      resourceOwnerId = make_shared<long>(boost::any_cast<long>(m["ResourceOwnerId"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("DpiGroupIds") != m.end() && !m["DpiGroupIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DpiGroupIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DpiGroupIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dpiGroupIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("DpiGroupNames") != m.end() && !m["DpiGroupNames"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["DpiGroupNames"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["DpiGroupNames"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      dpiGroupNames = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDpiGroupsRequest() = default;
};
class ListDpiGroupsResponseBodyDpiGroup : public Darabonba::Model {
public:
  shared_ptr<string> minSignatureDbVersion{};
  shared_ptr<string> dpiGroupName{};
  shared_ptr<string> dpiGroupId{};
  shared_ptr<string> minEngineVersion{};

  ListDpiGroupsResponseBodyDpiGroup() {}

  explicit ListDpiGroupsResponseBodyDpiGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (minSignatureDbVersion) {
      res["MinSignatureDbVersion"] = boost::any(*minSignatureDbVersion);
    }
    if (dpiGroupName) {
      res["DpiGroupName"] = boost::any(*dpiGroupName);
    }
    if (dpiGroupId) {
      res["DpiGroupId"] = boost::any(*dpiGroupId);
    }
    if (minEngineVersion) {
      res["MinEngineVersion"] = boost::any(*minEngineVersion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MinSignatureDbVersion") != m.end() && !m["MinSignatureDbVersion"].empty()) {
      minSignatureDbVersion = make_shared<string>(boost::any_cast<string>(m["MinSignatureDbVersion"]));
    }
    if (m.find("DpiGroupName") != m.end() && !m["DpiGroupName"].empty()) {
      dpiGroupName = make_shared<string>(boost::any_cast<string>(m["DpiGroupName"]));
    }
    if (m.find("DpiGroupId") != m.end() && !m["DpiGroupId"].empty()) {
      dpiGroupId = make_shared<string>(boost::any_cast<string>(m["DpiGroupId"]));
    }
    if (m.find("MinEngineVersion") != m.end() && !m["MinEngineVersion"].empty()) {
      minEngineVersion = make_shared<string>(boost::any_cast<string>(m["MinEngineVersion"]));
    }
  }


  virtual ~ListDpiGroupsResponseBodyDpiGroup() = default;
};
class ListDpiGroupsResponseBody : public Darabonba::Model {
public:
  shared_ptr<long> totalCount{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListDpiGroupsResponseBodyDpiGroup>> dpiGroup{};

  ListDpiGroupsResponseBody() {}

  explicit ListDpiGroupsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (dpiGroup) {
      vector<boost::any> temp1;
      for(auto item1:*dpiGroup){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["DpiGroup"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("DpiGroup") != m.end() && !m["DpiGroup"].empty()) {
      if (typeid(vector<boost::any>) == m["DpiGroup"].type()) {
        vector<ListDpiGroupsResponseBodyDpiGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["DpiGroup"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDpiGroupsResponseBodyDpiGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dpiGroup = make_shared<vector<ListDpiGroupsResponseBodyDpiGroup>>(expect1);
      }
    }
  }


  virtual ~ListDpiGroupsResponseBody() = default;
};
class ListDpiGroupsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<ListDpiGroupsResponseBody> body{};

  ListDpiGroupsResponse() {}

  explicit ListDpiGroupsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDpiGroupsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDpiGroupsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDpiGroupsResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  GrantSagInstanceToVbrResponse grantSagInstanceToVbrWithOptions(shared_ptr<GrantSagInstanceToVbrRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GrantSagInstanceToVbrResponse grantSagInstanceToVbr(shared_ptr<GrantSagInstanceToVbrRequest> request);
  DescribeSagTrafficTopNResponse describeSagTrafficTopNWithOptions(shared_ptr<DescribeSagTrafficTopNRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSagTrafficTopNResponse describeSagTrafficTopN(shared_ptr<DescribeSagTrafficTopNRequest> request);
  DescribeGrantSagVbrRulesResponse describeGrantSagVbrRulesWithOptions(shared_ptr<DescribeGrantSagVbrRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGrantSagVbrRulesResponse describeGrantSagVbrRules(shared_ptr<DescribeGrantSagVbrRulesRequest> request);
  DescribeSagStaticRouteListResponse describeSagStaticRouteListWithOptions(shared_ptr<DescribeSagStaticRouteListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSagStaticRouteListResponse describeSagStaticRouteList(shared_ptr<DescribeSagStaticRouteListRequest> request);
  DescribeSagRouteListResponse describeSagRouteListWithOptions(shared_ptr<DescribeSagRouteListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSagRouteListResponse describeSagRouteList(shared_ptr<DescribeSagRouteListRequest> request);
  ProbeAccessPointNetworkQualityResponse probeAccessPointNetworkQualityWithOptions(shared_ptr<ProbeAccessPointNetworkQualityRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ProbeAccessPointNetworkQualityResponse probeAccessPointNetworkQuality(shared_ptr<ProbeAccessPointNetworkQualityRequest> request);
  ModifySagGlobalRouteProtocolResponse modifySagGlobalRouteProtocolWithOptions(shared_ptr<ModifySagGlobalRouteProtocolRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySagGlobalRouteProtocolResponse modifySagGlobalRouteProtocol(shared_ptr<ModifySagGlobalRouteProtocolRequest> request);
  DeleteRouteDistributionStrategyResponse deleteRouteDistributionStrategyWithOptions(shared_ptr<DeleteRouteDistributionStrategyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteRouteDistributionStrategyResponse deleteRouteDistributionStrategy(shared_ptr<DeleteRouteDistributionStrategyRequest> request);
  CreateQosCarResponse createQosCarWithOptions(shared_ptr<CreateQosCarRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateQosCarResponse createQosCar(shared_ptr<CreateQosCarRequest> request);
  UpdateSmartAGDpiAttributeResponse updateSmartAGDpiAttributeWithOptions(shared_ptr<UpdateSmartAGDpiAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSmartAGDpiAttributeResponse updateSmartAGDpiAttribute(shared_ptr<UpdateSmartAGDpiAttributeRequest> request);
  ClearSagRouteableAddressResponse clearSagRouteableAddressWithOptions(shared_ptr<ClearSagRouteableAddressRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ClearSagRouteableAddressResponse clearSagRouteableAddress(shared_ptr<ClearSagRouteableAddressRequest> request);
  AssociateQosResponse associateQosWithOptions(shared_ptr<AssociateQosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssociateQosResponse associateQos(shared_ptr<AssociateQosRequest> request);
  ModifySAGAdminPasswordResponse modifySAGAdminPasswordWithOptions(shared_ptr<ModifySAGAdminPasswordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySAGAdminPasswordResponse modifySAGAdminPassword(shared_ptr<ModifySAGAdminPasswordRequest> request);
  DowngradeSmartAccessGatewayResponse downgradeSmartAccessGatewayWithOptions(shared_ptr<DowngradeSmartAccessGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DowngradeSmartAccessGatewayResponse downgradeSmartAccessGateway(shared_ptr<DowngradeSmartAccessGatewayRequest> request);
  DescribeSagPortRouteProtocolListResponse describeSagPortRouteProtocolListWithOptions(shared_ptr<DescribeSagPortRouteProtocolListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSagPortRouteProtocolListResponse describeSagPortRouteProtocolList(shared_ptr<DescribeSagPortRouteProtocolListRequest> request);
  DescribeSagWanSnatResponse describeSagWanSnatWithOptions(shared_ptr<DescribeSagWanSnatRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSagWanSnatResponse describeSagWanSnat(shared_ptr<DescribeSagWanSnatRequest> request);
  DescribeSagUserDnsResponse describeSagUserDnsWithOptions(shared_ptr<DescribeSagUserDnsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSagUserDnsResponse describeSagUserDns(shared_ptr<DescribeSagUserDnsRequest> request);
  ListAccessPointNetworkQualitiesResponse listAccessPointNetworkQualitiesWithOptions(shared_ptr<ListAccessPointNetworkQualitiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAccessPointNetworkQualitiesResponse listAccessPointNetworkQualities(shared_ptr<ListAccessPointNetworkQualitiesRequest> request);
  ModifyFlowLogAttributeResponse modifyFlowLogAttributeWithOptions(shared_ptr<ModifyFlowLogAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyFlowLogAttributeResponse modifyFlowLogAttribute(shared_ptr<ModifyFlowLogAttributeRequest> request);
  DescribeQosPoliciesResponse describeQosPoliciesWithOptions(shared_ptr<DescribeQosPoliciesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeQosPoliciesResponse describeQosPolicies(shared_ptr<DescribeQosPoliciesRequest> request);
  CreateQosResponse createQosWithOptions(shared_ptr<CreateQosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateQosResponse createQos(shared_ptr<CreateQosRequest> request);
  DiscribeSmartAccessGatewayDiagnosisReportResponse discribeSmartAccessGatewayDiagnosisReportWithOptions(shared_ptr<DiscribeSmartAccessGatewayDiagnosisReportRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DiscribeSmartAccessGatewayDiagnosisReportResponse discribeSmartAccessGatewayDiagnosisReport(shared_ptr<DiscribeSmartAccessGatewayDiagnosisReportRequest> request);
  RoamClientUserResponse roamClientUserWithOptions(shared_ptr<RoamClientUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RoamClientUserResponse roamClientUser(shared_ptr<RoamClientUserRequest> request);
  CreateSagStaticRouteResponse createSagStaticRouteWithOptions(shared_ptr<CreateSagStaticRouteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSagStaticRouteResponse createSagStaticRoute(shared_ptr<CreateSagStaticRouteRequest> request);
  DescribeSmartAccessGatewayAttributeResponse describeSmartAccessGatewayAttributeWithOptions(shared_ptr<DescribeSmartAccessGatewayAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSmartAccessGatewayAttributeResponse describeSmartAccessGatewayAttribute(shared_ptr<DescribeSmartAccessGatewayAttributeRequest> request);
  CreateCloudConnectNetworkResponse createCloudConnectNetworkWithOptions(shared_ptr<CreateCloudConnectNetworkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCloudConnectNetworkResponse createCloudConnectNetwork(shared_ptr<CreateCloudConnectNetworkRequest> request);
  DeleteQosPolicyResponse deleteQosPolicyWithOptions(shared_ptr<DeleteQosPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteQosPolicyResponse deleteQosPolicy(shared_ptr<DeleteQosPolicyRequest> request);
  ModifySagHaResponse modifySagHaWithOptions(shared_ptr<ModifySagHaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySagHaResponse modifySagHa(shared_ptr<ModifySagHaRequest> request);
  DeleteHealthCheckResponse deleteHealthCheckWithOptions(shared_ptr<DeleteHealthCheckRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteHealthCheckResponse deleteHealthCheck(shared_ptr<DeleteHealthCheckRequest> request);
  SynchronizeSmartAGWebConfigResponse synchronizeSmartAGWebConfigWithOptions(shared_ptr<SynchronizeSmartAGWebConfigRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SynchronizeSmartAGWebConfigResponse synchronizeSmartAGWebConfig(shared_ptr<SynchronizeSmartAGWebConfigRequest> request);
  DeleteSnatEntryResponse deleteSnatEntryWithOptions(shared_ptr<DeleteSnatEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSnatEntryResponse deleteSnatEntry(shared_ptr<DeleteSnatEntryRequest> request);
  DeleteQosResponse deleteQosWithOptions(shared_ptr<DeleteQosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteQosResponse deleteQos(shared_ptr<DeleteQosRequest> request);
  AddSagCidrResponse addSagCidrWithOptions(shared_ptr<AddSagCidrRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddSagCidrResponse addSagCidr(shared_ptr<AddSagCidrRequest> request);
  DeleteSagStaticRouteResponse deleteSagStaticRouteWithOptions(shared_ptr<DeleteSagStaticRouteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSagStaticRouteResponse deleteSagStaticRoute(shared_ptr<DeleteSagStaticRouteRequest> request);
  DescribeGrantSagRulesResponse describeGrantSagRulesWithOptions(shared_ptr<DescribeGrantSagRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGrantSagRulesResponse describeGrantSagRules(shared_ptr<DescribeGrantSagRulesRequest> request);
  DescribeUserOnlineClientsResponse describeUserOnlineClientsWithOptions(shared_ptr<DescribeUserOnlineClientsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserOnlineClientsResponse describeUserOnlineClients(shared_ptr<DescribeUserOnlineClientsRequest> request);
  DiagnoseSmartAccessGatewayResponse diagnoseSmartAccessGatewayWithOptions(shared_ptr<DiagnoseSmartAccessGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DiagnoseSmartAccessGatewayResponse diagnoseSmartAccessGateway(shared_ptr<DiagnoseSmartAccessGatewayRequest> request);
  DescribeSagWifiResponse describeSagWifiWithOptions(shared_ptr<DescribeSagWifiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSagWifiResponse describeSagWifi(shared_ptr<DescribeSagWifiRequest> request);
  UnbindSerialNumberResponse unbindSerialNumberWithOptions(shared_ptr<UnbindSerialNumberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindSerialNumberResponse unbindSerialNumber(shared_ptr<UnbindSerialNumberRequest> request);
  DescribeSAGDeviceInfoResponse describeSAGDeviceInfoWithOptions(shared_ptr<DescribeSAGDeviceInfoRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSAGDeviceInfoResponse describeSAGDeviceInfo(shared_ptr<DescribeSAGDeviceInfoRequest> request);
  DescribeUserFlowStatisticsResponse describeUserFlowStatisticsWithOptions(shared_ptr<DescribeUserFlowStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserFlowStatisticsResponse describeUserFlowStatistics(shared_ptr<DescribeUserFlowStatisticsRequest> request);
  ModifySagLanResponse modifySagLanWithOptions(shared_ptr<ModifySagLanRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySagLanResponse modifySagLan(shared_ptr<ModifySagLanRequest> request);
  DescribeFlowLogsResponse describeFlowLogsWithOptions(shared_ptr<DescribeFlowLogsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFlowLogsResponse describeFlowLogs(shared_ptr<DescribeFlowLogsRequest> request);
  DescribeSmartAccessGatewayClientUsersResponse describeSmartAccessGatewayClientUsersWithOptions(shared_ptr<DescribeSmartAccessGatewayClientUsersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSmartAccessGatewayClientUsersResponse describeSmartAccessGatewayClientUsers(shared_ptr<DescribeSmartAccessGatewayClientUsersRequest> request);
  DescribeHealthCheckAttributeResponse describeHealthCheckAttributeWithOptions(shared_ptr<DescribeHealthCheckAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHealthCheckAttributeResponse describeHealthCheckAttribute(shared_ptr<DescribeHealthCheckAttributeRequest> request);
  ModifyQosPolicyResponse modifyQosPolicyWithOptions(shared_ptr<ModifyQosPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyQosPolicyResponse modifyQosPolicy(shared_ptr<ModifyQosPolicyRequest> request);
  ModifySagExpressConnectInterfaceResponse modifySagExpressConnectInterfaceWithOptions(shared_ptr<ModifySagExpressConnectInterfaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySagExpressConnectInterfaceResponse modifySagExpressConnectInterface(shared_ptr<ModifySagExpressConnectInterfaceRequest> request);
  UpdateSmartAGAccessPointResponse updateSmartAGAccessPointWithOptions(shared_ptr<UpdateSmartAGAccessPointRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSmartAGAccessPointResponse updateSmartAGAccessPoint(shared_ptr<UpdateSmartAGAccessPointRequest> request);
  BindSerialNumberResponse bindSerialNumberWithOptions(shared_ptr<BindSerialNumberRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindSerialNumberResponse bindSerialNumber(shared_ptr<BindSerialNumberRequest> request);
  ModifySagRouteProtocolOspfResponse modifySagRouteProtocolOspfWithOptions(shared_ptr<ModifySagRouteProtocolOspfRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySagRouteProtocolOspfResponse modifySagRouteProtocolOspf(shared_ptr<ModifySagRouteProtocolOspfRequest> request);
  AddDnatEntryResponse addDnatEntryWithOptions(shared_ptr<AddDnatEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddDnatEntryResponse addDnatEntry(shared_ptr<AddDnatEntryRequest> request);
  DeleteSagCidrResponse deleteSagCidrWithOptions(shared_ptr<DeleteSagCidrRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSagCidrResponse deleteSagCidr(shared_ptr<DeleteSagCidrRequest> request);
  DescribeSagRouteProtocolOspfResponse describeSagRouteProtocolOspfWithOptions(shared_ptr<DescribeSagRouteProtocolOspfRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSagRouteProtocolOspfResponse describeSagRouteProtocolOspf(shared_ptr<DescribeSagRouteProtocolOspfRequest> request);
  DescribeRouteDistributionStrategiesResponse describeRouteDistributionStrategiesWithOptions(shared_ptr<DescribeRouteDistributionStrategiesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRouteDistributionStrategiesResponse describeRouteDistributionStrategies(shared_ptr<DescribeRouteDistributionStrategiesRequest> request);
  DescribeSagHaResponse describeSagHaWithOptions(shared_ptr<DescribeSagHaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSagHaResponse describeSagHa(shared_ptr<DescribeSagHaRequest> request);
  AddACLRuleResponse addACLRuleWithOptions(shared_ptr<AddACLRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddACLRuleResponse addACLRule(shared_ptr<AddACLRuleRequest> request);
  AssociateFlowLogResponse associateFlowLogWithOptions(shared_ptr<AssociateFlowLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssociateFlowLogResponse associateFlowLog(shared_ptr<AssociateFlowLogRequest> request);
  BindSmartAccessGatewayResponse bindSmartAccessGatewayWithOptions(shared_ptr<BindSmartAccessGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindSmartAccessGatewayResponse bindSmartAccessGateway(shared_ptr<BindSmartAccessGatewayRequest> request);
  DisassociateACLResponse disassociateACLWithOptions(shared_ptr<DisassociateACLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisassociateACLResponse disassociateACL(shared_ptr<DisassociateACLRequest> request);
  DeactiveFlowLogResponse deactiveFlowLogWithOptions(shared_ptr<DeactiveFlowLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeactiveFlowLogResponse deactiveFlowLog(shared_ptr<DeactiveFlowLogRequest> request);
  ActiveFlowLogResponse activeFlowLogWithOptions(shared_ptr<ActiveFlowLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ActiveFlowLogResponse activeFlowLog(shared_ptr<ActiveFlowLogRequest> request);
  KickOutClientsResponse kickOutClientsWithOptions(shared_ptr<KickOutClientsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  KickOutClientsResponse kickOutClients(shared_ptr<KickOutClientsRequest> request);
  ModifySagPortRoleResponse modifySagPortRoleWithOptions(shared_ptr<ModifySagPortRoleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySagPortRoleResponse modifySagPortRole(shared_ptr<ModifySagPortRoleRequest> request);
  ModifySagWanSnatResponse modifySagWanSnatWithOptions(shared_ptr<ModifySagWanSnatRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySagWanSnatResponse modifySagWanSnat(shared_ptr<ModifySagWanSnatRequest> request);
  ListDpiConfigErrorResponse listDpiConfigErrorWithOptions(shared_ptr<ListDpiConfigErrorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDpiConfigErrorResponse listDpiConfigError(shared_ptr<ListDpiConfigErrorRequest> request);
  DeleteACLResponse deleteACLWithOptions(shared_ptr<DeleteACLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteACLResponse deleteACL(shared_ptr<DeleteACLRequest> request);
  UpdateSmartAGEnterpriseCodeResponse updateSmartAGEnterpriseCodeWithOptions(shared_ptr<UpdateSmartAGEnterpriseCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSmartAGEnterpriseCodeResponse updateSmartAGEnterpriseCode(shared_ptr<UpdateSmartAGEnterpriseCodeRequest> request);
  AssociateACLResponse associateACLWithOptions(shared_ptr<AssociateACLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AssociateACLResponse associateACL(shared_ptr<AssociateACLRequest> request);
  ModifyHealthCheckResponse modifyHealthCheckWithOptions(shared_ptr<ModifyHealthCheckRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyHealthCheckResponse modifyHealthCheck(shared_ptr<ModifyHealthCheckRequest> request);
  CreateEnterpriseCodeResponse createEnterpriseCodeWithOptions(shared_ptr<CreateEnterpriseCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateEnterpriseCodeResponse createEnterpriseCode(shared_ptr<CreateEnterpriseCodeRequest> request);
  DescribeACLsResponse describeACLsWithOptions(shared_ptr<DescribeACLsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeACLsResponse describeACLs(shared_ptr<DescribeACLsRequest> request);
  ResetSmartAccessGatewayClientUserPasswordResponse resetSmartAccessGatewayClientUserPasswordWithOptions(shared_ptr<ResetSmartAccessGatewayClientUserPasswordRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResetSmartAccessGatewayClientUserPasswordResponse resetSmartAccessGatewayClientUserPassword(shared_ptr<ResetSmartAccessGatewayClientUserPasswordRequest> request);
  UnlockSmartAccessGatewayResponse unlockSmartAccessGatewayWithOptions(shared_ptr<UnlockSmartAccessGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnlockSmartAccessGatewayResponse unlockSmartAccessGateway(shared_ptr<UnlockSmartAccessGatewayRequest> request);
  DescribeUnbindFlowLogSagsResponse describeUnbindFlowLogSagsWithOptions(shared_ptr<DescribeUnbindFlowLogSagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUnbindFlowLogSagsResponse describeUnbindFlowLogSags(shared_ptr<DescribeUnbindFlowLogSagsRequest> request);
  DisassociateFlowLogResponse disassociateFlowLogWithOptions(shared_ptr<DisassociateFlowLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisassociateFlowLogResponse disassociateFlowLog(shared_ptr<DisassociateFlowLogRequest> request);
  DescribeSagGlobalRouteProtocolResponse describeSagGlobalRouteProtocolWithOptions(shared_ptr<DescribeSagGlobalRouteProtocolRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSagGlobalRouteProtocolResponse describeSagGlobalRouteProtocol(shared_ptr<DescribeSagGlobalRouteProtocolRequest> request);
  DescribeSagExpressConnectInterfaceListResponse describeSagExpressConnectInterfaceListWithOptions(shared_ptr<DescribeSagExpressConnectInterfaceListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSagExpressConnectInterfaceListResponse describeSagExpressConnectInterfaceList(shared_ptr<DescribeSagExpressConnectInterfaceListRequest> request);
  CreateACLResponse createACLWithOptions(shared_ptr<CreateACLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateACLResponse createACL(shared_ptr<CreateACLRequest> request);
  RebootSmartAccessGatewayResponse rebootSmartAccessGatewayWithOptions(shared_ptr<RebootSmartAccessGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RebootSmartAccessGatewayResponse rebootSmartAccessGateway(shared_ptr<RebootSmartAccessGatewayRequest> request);
  ModifySagStaticRouteResponse modifySagStaticRouteWithOptions(shared_ptr<ModifySagStaticRouteRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySagStaticRouteResponse modifySagStaticRoute(shared_ptr<ModifySagStaticRouteRequest> request);
  RevokeInstanceFromVbrResponse revokeInstanceFromVbrWithOptions(shared_ptr<RevokeInstanceFromVbrRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeInstanceFromVbrResponse revokeInstanceFromVbr(shared_ptr<RevokeInstanceFromVbrRequest> request);
  DescribeCloudConnectNetworksResponse describeCloudConnectNetworksWithOptions(shared_ptr<DescribeCloudConnectNetworksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCloudConnectNetworksResponse describeCloudConnectNetworks(shared_ptr<DescribeCloudConnectNetworksRequest> request);
  ModifyACLRuleResponse modifyACLRuleWithOptions(shared_ptr<ModifyACLRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyACLRuleResponse modifyACLRule(shared_ptr<ModifyACLRuleRequest> request);
  ModifySmartAccessGatewayClientUserResponse modifySmartAccessGatewayClientUserWithOptions(shared_ptr<ModifySmartAccessGatewayClientUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySmartAccessGatewayClientUserResponse modifySmartAccessGatewayClientUser(shared_ptr<ModifySmartAccessGatewayClientUserRequest> request);
  DescribeSagManagementPortResponse describeSagManagementPortWithOptions(shared_ptr<DescribeSagManagementPortRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSagManagementPortResponse describeSagManagementPort(shared_ptr<DescribeSagManagementPortRequest> request);
  UpgradeSmartAccessGatewayResponse upgradeSmartAccessGatewayWithOptions(shared_ptr<UpgradeSmartAccessGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpgradeSmartAccessGatewayResponse upgradeSmartAccessGateway(shared_ptr<UpgradeSmartAccessGatewayRequest> request);
  GetSmartAGDpiAttributeResponse getSmartAGDpiAttributeWithOptions(shared_ptr<GetSmartAGDpiAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSmartAGDpiAttributeResponse getSmartAGDpiAttribute(shared_ptr<GetSmartAGDpiAttributeRequest> request);
  DisassociateQosResponse disassociateQosWithOptions(shared_ptr<DisassociateQosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisassociateQosResponse disassociateQos(shared_ptr<DisassociateQosRequest> request);
  ModifyRouteDistributionStrategyResponse modifyRouteDistributionStrategyWithOptions(shared_ptr<ModifyRouteDistributionStrategyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyRouteDistributionStrategyResponse modifyRouteDistributionStrategy(shared_ptr<ModifyRouteDistributionStrategyRequest> request);
  ModifySagPortRouteProtocolResponse modifySagPortRouteProtocolWithOptions(shared_ptr<ModifySagPortRouteProtocolRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySagPortRouteProtocolResponse modifySagPortRouteProtocol(shared_ptr<ModifySagPortRouteProtocolRequest> request);
  EnableSmartAccessGatewayUserResponse enableSmartAccessGatewayUserWithOptions(shared_ptr<EnableSmartAccessGatewayUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableSmartAccessGatewayUserResponse enableSmartAccessGatewayUser(shared_ptr<EnableSmartAccessGatewayUserRequest> request);
  ModifyQosResponse modifyQosWithOptions(shared_ptr<ModifyQosRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyQosResponse modifyQos(shared_ptr<ModifyQosRequest> request);
  GetAclAttributeResponse getAclAttributeWithOptions(shared_ptr<GetAclAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetAclAttributeResponse getAclAttribute(shared_ptr<GetAclAttributeRequest> request);
  DescribeSagWanListResponse describeSagWanListWithOptions(shared_ptr<DescribeSagWanListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSagWanListResponse describeSagWanList(shared_ptr<DescribeSagWanListRequest> request);
  ListSmartAGApiUnsupportedFeatureResponse listSmartAGApiUnsupportedFeatureWithOptions(shared_ptr<ListSmartAGApiUnsupportedFeatureRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSmartAGApiUnsupportedFeatureResponse listSmartAGApiUnsupportedFeature(shared_ptr<ListSmartAGApiUnsupportedFeatureRequest> request);
  EnableSmartAGDpiMonitorResponse enableSmartAGDpiMonitorWithOptions(shared_ptr<EnableSmartAGDpiMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EnableSmartAGDpiMonitorResponse enableSmartAGDpiMonitor(shared_ptr<EnableSmartAGDpiMonitorRequest> request);
  ActivateSmartAccessGatewayResponse activateSmartAccessGatewayWithOptions(shared_ptr<ActivateSmartAccessGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ActivateSmartAccessGatewayResponse activateSmartAccessGateway(shared_ptr<ActivateSmartAccessGatewayRequest> request);
  DeleteACLRuleResponse deleteACLRuleWithOptions(shared_ptr<DeleteACLRuleRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteACLRuleResponse deleteACLRule(shared_ptr<DeleteACLRuleRequest> request);
  MoveResourceGroupResponse moveResourceGroupWithOptions(shared_ptr<MoveResourceGroupRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MoveResourceGroupResponse moveResourceGroup(shared_ptr<MoveResourceGroupRequest> request);
  DescribeSagVbrRelationsResponse describeSagVbrRelationsWithOptions(shared_ptr<DescribeSagVbrRelationsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSagVbrRelationsResponse describeSagVbrRelations(shared_ptr<DescribeSagVbrRelationsRequest> request);
  CreateSmartAccessGatewayClientUserResponse createSmartAccessGatewayClientUserWithOptions(shared_ptr<CreateSmartAccessGatewayClientUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSmartAccessGatewayClientUserResponse createSmartAccessGatewayClientUser(shared_ptr<CreateSmartAccessGatewayClientUserRequest> request);
  GetQosAttributeResponse getQosAttributeWithOptions(shared_ptr<GetQosAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetQosAttributeResponse getQosAttribute(shared_ptr<GetQosAttributeRequest> request);
  CreateHealthCheckResponse createHealthCheckWithOptions(shared_ptr<CreateHealthCheckRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateHealthCheckResponse createHealthCheck(shared_ptr<CreateHealthCheckRequest> request);
  ModifySagRemoteAccessResponse modifySagRemoteAccessWithOptions(shared_ptr<ModifySagRemoteAccessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySagRemoteAccessResponse modifySagRemoteAccess(shared_ptr<ModifySagRemoteAccessRequest> request);
  RevokeSagInstanceFromCcnResponse revokeSagInstanceFromCcnWithOptions(shared_ptr<RevokeSagInstanceFromCcnRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeSagInstanceFromCcnResponse revokeSagInstanceFromCcn(shared_ptr<RevokeSagInstanceFromCcnRequest> request);
  DeleteEnterpriseCodeResponse deleteEnterpriseCodeWithOptions(shared_ptr<DeleteEnterpriseCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteEnterpriseCodeResponse deleteEnterpriseCode(shared_ptr<DeleteEnterpriseCodeRequest> request);
  DeleteSmartAccessGatewayClientUserResponse deleteSmartAccessGatewayClientUserWithOptions(shared_ptr<DeleteSmartAccessGatewayClientUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSmartAccessGatewayClientUserResponse deleteSmartAccessGatewayClientUser(shared_ptr<DeleteSmartAccessGatewayClientUserRequest> request);
  ListSmartAGByAccessPointResponse listSmartAGByAccessPointWithOptions(shared_ptr<ListSmartAGByAccessPointRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSmartAGByAccessPointResponse listSmartAGByAccessPoint(shared_ptr<ListSmartAGByAccessPointRequest> request);
  DescribeGrantRulesResponse describeGrantRulesWithOptions(shared_ptr<DescribeGrantRulesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeGrantRulesResponse describeGrantRules(shared_ptr<DescribeGrantRulesRequest> request);
  CreateSagExpressConnectInterfaceResponse createSagExpressConnectInterfaceWithOptions(shared_ptr<CreateSagExpressConnectInterfaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSagExpressConnectInterfaceResponse createSagExpressConnectInterface(shared_ptr<CreateSagExpressConnectInterfaceRequest> request);
  UnbindSmartAccessGatewayResponse unbindSmartAccessGatewayWithOptions(shared_ptr<UnbindSmartAccessGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindSmartAccessGatewayResponse unbindSmartAccessGateway(shared_ptr<UnbindSmartAccessGatewayRequest> request);
  CreateSmartAccessGatewayResponse createSmartAccessGatewayWithOptions(shared_ptr<CreateSmartAccessGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSmartAccessGatewayResponse createSmartAccessGateway(shared_ptr<CreateSmartAccessGatewayRequest> request);
  DeleteFlowLogResponse deleteFlowLogWithOptions(shared_ptr<DeleteFlowLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFlowLogResponse deleteFlowLog(shared_ptr<DeleteFlowLogRequest> request);
  DescribeSagOnlineClientStatisticsResponse describeSagOnlineClientStatisticsWithOptions(shared_ptr<DescribeSagOnlineClientStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSagOnlineClientStatisticsResponse describeSagOnlineClientStatistics(shared_ptr<DescribeSagOnlineClientStatisticsRequest> request);
  ModifyCloudConnectNetworkResponse modifyCloudConnectNetworkWithOptions(shared_ptr<ModifyCloudConnectNetworkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyCloudConnectNetworkResponse modifyCloudConnectNetwork(shared_ptr<ModifyCloudConnectNetworkRequest> request);
  ModifySmartAccessGatewayUpBandwidthResponse modifySmartAccessGatewayUpBandwidthWithOptions(shared_ptr<ModifySmartAccessGatewayUpBandwidthRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySmartAccessGatewayUpBandwidthResponse modifySmartAccessGatewayUpBandwidth(shared_ptr<ModifySmartAccessGatewayUpBandwidthRequest> request);
  GrantSagInstanceToCcnResponse grantSagInstanceToCcnWithOptions(shared_ptr<GrantSagInstanceToCcnRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GrantSagInstanceToCcnResponse grantSagInstanceToCcn(shared_ptr<GrantSagInstanceToCcnRequest> request);
  ModifySmartAccessGatewayResponse modifySmartAccessGatewayWithOptions(shared_ptr<ModifySmartAccessGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySmartAccessGatewayResponse modifySmartAccessGateway(shared_ptr<ModifySmartAccessGatewayRequest> request);
  UpdateSmartAccessGatewayVersionResponse updateSmartAccessGatewayVersionWithOptions(shared_ptr<UpdateSmartAccessGatewayVersionRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSmartAccessGatewayVersionResponse updateSmartAccessGatewayVersion(shared_ptr<UpdateSmartAccessGatewayVersionRequest> request);
  DescribeSagDropTopNResponse describeSagDropTopNWithOptions(shared_ptr<DescribeSagDropTopNRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSagDropTopNResponse describeSagDropTopN(shared_ptr<DescribeSagDropTopNRequest> request);
  DescribeSagLanListResponse describeSagLanListWithOptions(shared_ptr<DescribeSagLanListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSagLanListResponse describeSagLanList(shared_ptr<DescribeSagLanListRequest> request);
  DescribeACLAttributeResponse describeACLAttributeWithOptions(shared_ptr<DescribeACLAttributeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeACLAttributeResponse describeACLAttribute(shared_ptr<DescribeACLAttributeRequest> request);
  DeleteSagExpressConnectInterfaceResponse deleteSagExpressConnectInterfaceWithOptions(shared_ptr<DeleteSagExpressConnectInterfaceRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSagExpressConnectInterfaceResponse deleteSagExpressConnectInterface(shared_ptr<DeleteSagExpressConnectInterfaceRequest> request);
  ListEnterpriseCodeResponse listEnterpriseCodeWithOptions(shared_ptr<ListEnterpriseCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEnterpriseCodeResponse listEnterpriseCode(shared_ptr<ListEnterpriseCodeRequest> request);
  CreateSmartAccessGatewaySoftwareResponse createSmartAccessGatewaySoftwareWithOptions(shared_ptr<CreateSmartAccessGatewaySoftwareRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSmartAccessGatewaySoftwareResponse createSmartAccessGatewaySoftware(shared_ptr<CreateSmartAccessGatewaySoftwareRequest> request);
  DescribeQosesResponse describeQosesWithOptions(shared_ptr<DescribeQosesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeQosesResponse describeQoses(shared_ptr<DescribeQosesRequest> request);
  UpgradeSmartAccessGatewaySoftwareResponse upgradeSmartAccessGatewaySoftwareWithOptions(shared_ptr<UpgradeSmartAccessGatewaySoftwareRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpgradeSmartAccessGatewaySoftwareResponse upgradeSmartAccessGatewaySoftware(shared_ptr<UpgradeSmartAccessGatewaySoftwareRequest> request);
  DescribeSagCurrentDnsResponse describeSagCurrentDnsWithOptions(shared_ptr<DescribeSagCurrentDnsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSagCurrentDnsResponse describeSagCurrentDns(shared_ptr<DescribeSagCurrentDnsRequest> request);
  DescribeSmartAccessGatewaysResponse describeSmartAccessGatewaysWithOptions(shared_ptr<DescribeSmartAccessGatewaysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSmartAccessGatewaysResponse describeSmartAccessGateways(shared_ptr<DescribeSmartAccessGatewaysRequest> request);
  DescribeQosCarsResponse describeQosCarsWithOptions(shared_ptr<DescribeQosCarsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeQosCarsResponse describeQosCars(shared_ptr<DescribeQosCarsRequest> request);
  DescribeUserOnlineClientStatisticsResponse describeUserOnlineClientStatisticsWithOptions(shared_ptr<DescribeUserOnlineClientStatisticsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeUserOnlineClientStatisticsResponse describeUserOnlineClientStatistics(shared_ptr<DescribeUserOnlineClientStatisticsRequest> request);
  UpdateEnterpriseCodeResponse updateEnterpriseCodeWithOptions(shared_ptr<UpdateEnterpriseCodeRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateEnterpriseCodeResponse updateEnterpriseCode(shared_ptr<UpdateEnterpriseCodeRequest> request);
  BindVbrResponse bindVbrWithOptions(shared_ptr<BindVbrRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BindVbrResponse bindVbr(shared_ptr<BindVbrRequest> request);
  DescribeSagRouteProtocolBgpResponse describeSagRouteProtocolBgpWithOptions(shared_ptr<DescribeSagRouteProtocolBgpRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSagRouteProtocolBgpResponse describeSagRouteProtocolBgp(shared_ptr<DescribeSagRouteProtocolBgpRequest> request);
  DisableSmartAccessGatewayUserResponse disableSmartAccessGatewayUserWithOptions(shared_ptr<DisableSmartAccessGatewayUserRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableSmartAccessGatewayUserResponse disableSmartAccessGatewayUser(shared_ptr<DisableSmartAccessGatewayUserRequest> request);
  DeleteDnatEntryResponse deleteDnatEntryWithOptions(shared_ptr<DeleteDnatEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDnatEntryResponse deleteDnatEntry(shared_ptr<DeleteDnatEntryRequest> request);
  ModifyACLResponse modifyACLWithOptions(shared_ptr<ModifyACLRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyACLResponse modifyACL(shared_ptr<ModifyACLRequest> request);
  GetSmartAccessGatewayUseLimitResponse getSmartAccessGatewayUseLimitWithOptions(shared_ptr<GetSmartAccessGatewayUseLimitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSmartAccessGatewayUseLimitResponse getSmartAccessGatewayUseLimit(shared_ptr<GetSmartAccessGatewayUseLimitRequest> request);
  DeleteSmartAccessGatewayResponse deleteSmartAccessGatewayWithOptions(shared_ptr<DeleteSmartAccessGatewayRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSmartAccessGatewayResponse deleteSmartAccessGateway(shared_ptr<DeleteSmartAccessGatewayRequest> request);
  GrantInstanceToCbnResponse grantInstanceToCbnWithOptions(shared_ptr<GrantInstanceToCbnRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GrantInstanceToCbnResponse grantInstanceToCbn(shared_ptr<GrantInstanceToCbnRequest> request);
  AddSnatEntryResponse addSnatEntryWithOptions(shared_ptr<AddSnatEntryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddSnatEntryResponse addSnatEntry(shared_ptr<AddSnatEntryRequest> request);
  DisableSmartAGDpiMonitorResponse disableSmartAGDpiMonitorWithOptions(shared_ptr<DisableSmartAGDpiMonitorRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DisableSmartAGDpiMonitorResponse disableSmartAGDpiMonitor(shared_ptr<DisableSmartAGDpiMonitorRequest> request);
  DescribeSnatEntriesResponse describeSnatEntriesWithOptions(shared_ptr<DescribeSnatEntriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSnatEntriesResponse describeSnatEntries(shared_ptr<DescribeSnatEntriesRequest> request);
  ModifyClientUserDNSResponse modifyClientUserDNSWithOptions(shared_ptr<ModifyClientUserDNSRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyClientUserDNSResponse modifyClientUserDNS(shared_ptr<ModifyClientUserDNSRequest> request);
  ModifySagRouteProtocolBgpResponse modifySagRouteProtocolBgpWithOptions(shared_ptr<ModifySagRouteProtocolBgpRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySagRouteProtocolBgpResponse modifySagRouteProtocolBgp(shared_ptr<ModifySagRouteProtocolBgpRequest> request);
  ModifyQosCarResponse modifyQosCarWithOptions(shared_ptr<ModifyQosCarRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyQosCarResponse modifyQosCar(shared_ptr<ModifyQosCarRequest> request);
  CreateFlowLogResponse createFlowLogWithOptions(shared_ptr<CreateFlowLogRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFlowLogResponse createFlowLog(shared_ptr<CreateFlowLogRequest> request);
  ModifyDeviceAutoUpgradePolicyResponse modifyDeviceAutoUpgradePolicyWithOptions(shared_ptr<ModifyDeviceAutoUpgradePolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDeviceAutoUpgradePolicyResponse modifyDeviceAutoUpgradePolicy(shared_ptr<ModifyDeviceAutoUpgradePolicyRequest> request);
  DescribeClientUserDNSResponse describeClientUserDNSWithOptions(shared_ptr<DescribeClientUserDNSRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeClientUserDNSResponse describeClientUserDNS(shared_ptr<DescribeClientUserDNSRequest> request);
  ClearSagCipherResponse clearSagCipherWithOptions(shared_ptr<ClearSagCipherRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ClearSagCipherResponse clearSagCipher(shared_ptr<ClearSagCipherRequest> request);
  DescribeSagWan4GResponse describeSagWan4GWithOptions(shared_ptr<DescribeSagWan4GRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSagWan4GResponse describeSagWan4G(shared_ptr<DescribeSagWan4GRequest> request);
  ModifySagUserDnsResponse modifySagUserDnsWithOptions(shared_ptr<ModifySagUserDnsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySagUserDnsResponse modifySagUserDns(shared_ptr<ModifySagUserDnsRequest> request);
  ModifySagManagementPortResponse modifySagManagementPortWithOptions(shared_ptr<ModifySagManagementPortRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySagManagementPortResponse modifySagManagementPort(shared_ptr<ModifySagManagementPortRequest> request);
  DescribeDnatEntriesResponse describeDnatEntriesWithOptions(shared_ptr<DescribeDnatEntriesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDnatEntriesResponse describeDnatEntries(shared_ptr<DescribeDnatEntriesRequest> request);
  DescribeSmartAccessGatewayVersionsResponse describeSmartAccessGatewayVersionsWithOptions(shared_ptr<DescribeSmartAccessGatewayVersionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSmartAccessGatewayVersionsResponse describeSmartAccessGatewayVersions(shared_ptr<DescribeSmartAccessGatewayVersionsRequest> request);
  RevokeInstanceFromCbnResponse revokeInstanceFromCbnWithOptions(shared_ptr<RevokeInstanceFromCbnRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RevokeInstanceFromCbnResponse revokeInstanceFromCbn(shared_ptr<RevokeInstanceFromCbnRequest> request);
  DescribeSagRemoteAccessResponse describeSagRemoteAccessWithOptions(shared_ptr<DescribeSagRemoteAccessRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSagRemoteAccessResponse describeSagRemoteAccess(shared_ptr<DescribeSagRemoteAccessRequest> request);
  CreateQosPolicyResponse createQosPolicyWithOptions(shared_ptr<CreateQosPolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateQosPolicyResponse createQosPolicy(shared_ptr<CreateQosPolicyRequest> request);
  DescribeFlowLogSagsResponse describeFlowLogSagsWithOptions(shared_ptr<DescribeFlowLogSagsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeFlowLogSagsResponse describeFlowLogSags(shared_ptr<DescribeFlowLogSagsRequest> request);
  ModifySagWifiResponse modifySagWifiWithOptions(shared_ptr<ModifySagWifiRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySagWifiResponse modifySagWifi(shared_ptr<ModifySagWifiRequest> request);
  ModifySagWanResponse modifySagWanWithOptions(shared_ptr<ModifySagWanRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifySagWanResponse modifySagWan(shared_ptr<ModifySagWanRequest> request);
  DescribeSmartAccessGatewayHaResponse describeSmartAccessGatewayHaWithOptions(shared_ptr<DescribeSmartAccessGatewayHaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSmartAccessGatewayHaResponse describeSmartAccessGatewayHa(shared_ptr<DescribeSmartAccessGatewayHaRequest> request);
  DeleteCloudConnectNetworkResponse deleteCloudConnectNetworkWithOptions(shared_ptr<DeleteCloudConnectNetworkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCloudConnectNetworkResponse deleteCloudConnectNetwork(shared_ptr<DeleteCloudConnectNetworkRequest> request);
  DowngradeSmartAccessGatewaySoftwareResponse downgradeSmartAccessGatewaySoftwareWithOptions(shared_ptr<DowngradeSmartAccessGatewaySoftwareRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DowngradeSmartAccessGatewaySoftwareResponse downgradeSmartAccessGatewaySoftware(shared_ptr<DowngradeSmartAccessGatewaySoftwareRequest> request);
  DescribeRegionsResponse describeRegionsWithOptions(shared_ptr<DescribeRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRegionsResponse describeRegions(shared_ptr<DescribeRegionsRequest> request);
  DescribeHealthChecksResponse describeHealthChecksWithOptions(shared_ptr<DescribeHealthChecksRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeHealthChecksResponse describeHealthChecks(shared_ptr<DescribeHealthChecksRequest> request);
  GetCloudConnectNetworkUseLimitResponse getCloudConnectNetworkUseLimitWithOptions(shared_ptr<GetCloudConnectNetworkUseLimitRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetCloudConnectNetworkUseLimitResponse getCloudConnectNetworkUseLimit(shared_ptr<GetCloudConnectNetworkUseLimitRequest> request);
  ListAccessPointsResponse listAccessPointsWithOptions(shared_ptr<ListAccessPointsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAccessPointsResponse listAccessPoints(shared_ptr<ListAccessPointsRequest> request);
  DeleteQosCarResponse deleteQosCarWithOptions(shared_ptr<DeleteQosCarRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteQosCarResponse deleteQosCar(shared_ptr<DeleteQosCarRequest> request);
  DescribeDeviceAutoUpgradePolicyResponse describeDeviceAutoUpgradePolicyWithOptions(shared_ptr<DescribeDeviceAutoUpgradePolicyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDeviceAutoUpgradePolicyResponse describeDeviceAutoUpgradePolicy(shared_ptr<DescribeDeviceAutoUpgradePolicyRequest> request);
  ListDpiSignaturesResponse listDpiSignaturesWithOptions(shared_ptr<ListDpiSignaturesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDpiSignaturesResponse listDpiSignatures(shared_ptr<ListDpiSignaturesRequest> request);
  UnbindVbrResponse unbindVbrWithOptions(shared_ptr<UnbindVbrRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UnbindVbrResponse unbindVbr(shared_ptr<UnbindVbrRequest> request);
  DescribeBindableSmartAccessGatewaysResponse describeBindableSmartAccessGatewaysWithOptions(shared_ptr<DescribeBindableSmartAccessGatewaysRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeBindableSmartAccessGatewaysResponse describeBindableSmartAccessGateways(shared_ptr<DescribeBindableSmartAccessGatewaysRequest> request);
  DescribeSagPortListResponse describeSagPortListWithOptions(shared_ptr<DescribeSagPortListRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSagPortListResponse describeSagPortList(shared_ptr<DescribeSagPortListRequest> request);
  ListDpiGroupsResponse listDpiGroupsWithOptions(shared_ptr<ListDpiGroupsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDpiGroupsResponse listDpiGroups(shared_ptr<ListDpiGroupsRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Smartag20180313

#endif
