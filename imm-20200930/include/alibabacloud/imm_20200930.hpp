// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_IMM20200930_H_
#define ALIBABACLOUD_IMM20200930_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Imm20200930 {
class Address : public Darabonba::Model {
public:
  shared_ptr<string> addressLine{};
  shared_ptr<string> city{};
  shared_ptr<string> country{};
  shared_ptr<string> district{};
  shared_ptr<string> language{};
  shared_ptr<string> province{};
  shared_ptr<string> township{};

  Address() {}

  explicit Address(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressLine) {
      res["AddressLine"] = boost::any(*addressLine);
    }
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (district) {
      res["District"] = boost::any(*district);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (township) {
      res["Township"] = boost::any(*township);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AddressLine") != m.end() && !m["AddressLine"].empty()) {
      addressLine = make_shared<string>(boost::any_cast<string>(m["AddressLine"]));
    }
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("District") != m.end() && !m["District"].empty()) {
      district = make_shared<string>(boost::any_cast<string>(m["District"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("Township") != m.end() && !m["Township"].empty()) {
      township = make_shared<string>(boost::any_cast<string>(m["Township"]));
    }
  }


  virtual ~Address() = default;
};
class AddressForStory : public Darabonba::Model {
public:
  shared_ptr<string> city{};
  shared_ptr<string> country{};
  shared_ptr<string> district{};
  shared_ptr<string> province{};
  shared_ptr<string> township{};

  AddressForStory() {}

  explicit AddressForStory(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (city) {
      res["City"] = boost::any(*city);
    }
    if (country) {
      res["Country"] = boost::any(*country);
    }
    if (district) {
      res["District"] = boost::any(*district);
    }
    if (province) {
      res["Province"] = boost::any(*province);
    }
    if (township) {
      res["Township"] = boost::any(*township);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("City") != m.end() && !m["City"].empty()) {
      city = make_shared<string>(boost::any_cast<string>(m["City"]));
    }
    if (m.find("Country") != m.end() && !m["Country"].empty()) {
      country = make_shared<string>(boost::any_cast<string>(m["Country"]));
    }
    if (m.find("District") != m.end() && !m["District"].empty()) {
      district = make_shared<string>(boost::any_cast<string>(m["District"]));
    }
    if (m.find("Province") != m.end() && !m["Province"].empty()) {
      province = make_shared<string>(boost::any_cast<string>(m["Province"]));
    }
    if (m.find("Township") != m.end() && !m["Township"].empty()) {
      township = make_shared<string>(boost::any_cast<string>(m["Township"]));
    }
  }


  virtual ~AddressForStory() = default;
};
class MetaData : public Darabonba::Model {
public:
  shared_ptr<string> identifier{};
  shared_ptr<string> provider{};
  shared_ptr<string> version{};

  MetaData() {}

  explicit MetaData(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (identifier) {
      res["Identifier"] = boost::any(*identifier);
    }
    if (provider) {
      res["Provider"] = boost::any(*provider);
    }
    if (version) {
      res["Version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Identifier") != m.end() && !m["Identifier"].empty()) {
      identifier = make_shared<string>(boost::any_cast<string>(m["Identifier"]));
    }
    if (m.find("Provider") != m.end() && !m["Provider"].empty()) {
      provider = make_shared<string>(boost::any_cast<string>(m["Provider"]));
    }
    if (m.find("Version") != m.end() && !m["Version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["Version"]));
    }
  }


  virtual ~MetaData() = default;
};
class Property : public Darabonba::Model {
public:
  shared_ptr<string> itemsType{};
  shared_ptr<string> name{};
  shared_ptr<string> value{};
  shared_ptr<string> valueType{};

  Property() {}

  explicit Property(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (itemsType) {
      res["ItemsType"] = boost::any(*itemsType);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (valueType) {
      res["ValueType"] = boost::any(*valueType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ItemsType") != m.end() && !m["ItemsType"].empty()) {
      itemsType = make_shared<string>(boost::any_cast<string>(m["ItemsType"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("ValueType") != m.end() && !m["ValueType"].empty()) {
      valueType = make_shared<string>(boost::any_cast<string>(m["ValueType"]));
    }
  }


  virtual ~Property() = default;
};
class CustomParams : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<vector<Property>> properties{};

  CustomParams() {}

  explicit CustomParams(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (properties) {
      vector<boost::any> temp1;
      for(auto item1:*properties){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Properties"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Properties") != m.end() && !m["Properties"].empty()) {
      if (typeid(vector<boost::any>) == m["Properties"].type()) {
        vector<Property> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Properties"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Property model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        properties = make_shared<vector<Property>>(expect1);
      }
    }
  }


  virtual ~CustomParams() = default;
};
class Spec : public Darabonba::Model {
public:
  shared_ptr<CustomParams> backbone{};
  shared_ptr<long> classNum{};
  shared_ptr<CustomParams> head{};
  shared_ptr<long> inputChannel{};
  shared_ptr<CustomParams> loss{};
  shared_ptr<string> name{};
  shared_ptr<CustomParams> neck{};
  shared_ptr<long> numLandmarks{};
  shared_ptr<string> pretrainedPath{};

  Spec() {}

  explicit Spec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backbone) {
      res["Backbone"] = backbone ? boost::any(backbone->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (classNum) {
      res["ClassNum"] = boost::any(*classNum);
    }
    if (head) {
      res["Head"] = head ? boost::any(head->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (inputChannel) {
      res["InputChannel"] = boost::any(*inputChannel);
    }
    if (loss) {
      res["Loss"] = loss ? boost::any(loss->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (neck) {
      res["Neck"] = neck ? boost::any(neck->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (numLandmarks) {
      res["NumLandmarks"] = boost::any(*numLandmarks);
    }
    if (pretrainedPath) {
      res["PretrainedPath"] = boost::any(*pretrainedPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Backbone") != m.end() && !m["Backbone"].empty()) {
      if (typeid(map<string, boost::any>) == m["Backbone"].type()) {
        CustomParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Backbone"]));
        backbone = make_shared<CustomParams>(model1);
      }
    }
    if (m.find("ClassNum") != m.end() && !m["ClassNum"].empty()) {
      classNum = make_shared<long>(boost::any_cast<long>(m["ClassNum"]));
    }
    if (m.find("Head") != m.end() && !m["Head"].empty()) {
      if (typeid(map<string, boost::any>) == m["Head"].type()) {
        CustomParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Head"]));
        head = make_shared<CustomParams>(model1);
      }
    }
    if (m.find("InputChannel") != m.end() && !m["InputChannel"].empty()) {
      inputChannel = make_shared<long>(boost::any_cast<long>(m["InputChannel"]));
    }
    if (m.find("Loss") != m.end() && !m["Loss"].empty()) {
      if (typeid(map<string, boost::any>) == m["Loss"].type()) {
        CustomParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Loss"]));
        loss = make_shared<CustomParams>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Neck") != m.end() && !m["Neck"].empty()) {
      if (typeid(map<string, boost::any>) == m["Neck"].type()) {
        CustomParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Neck"]));
        neck = make_shared<CustomParams>(model1);
      }
    }
    if (m.find("NumLandmarks") != m.end() && !m["NumLandmarks"].empty()) {
      numLandmarks = make_shared<long>(boost::any_cast<long>(m["NumLandmarks"]));
    }
    if (m.find("PretrainedPath") != m.end() && !m["PretrainedPath"].empty()) {
      pretrainedPath = make_shared<string>(boost::any_cast<string>(m["PretrainedPath"]));
    }
  }


  virtual ~Spec() = default;
};
class ModelSpecification : public Darabonba::Model {
public:
  shared_ptr<MetaData> metaData{};
  shared_ptr<Spec> spec{};

  ModelSpecification() {}

  explicit ModelSpecification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (metaData) {
      res["MetaData"] = metaData ? boost::any(metaData->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spec) {
      res["Spec"] = spec ? boost::any(spec->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MetaData") != m.end() && !m["MetaData"].empty()) {
      if (typeid(map<string, boost::any>) == m["MetaData"].type()) {
        MetaData model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MetaData"]));
        metaData = make_shared<MetaData>(model1);
      }
    }
    if (m.find("Spec") != m.end() && !m["Spec"].empty()) {
      if (typeid(map<string, boost::any>) == m["Spec"].type()) {
        Spec model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Spec"]));
        spec = make_shared<Spec>(model1);
      }
    }
  }


  virtual ~ModelSpecification() = default;
};
class Optimization : public Darabonba::Model {
public:
  shared_ptr<double> learningRate{};
  shared_ptr<string> optimizer{};

  Optimization() {}

  explicit Optimization(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (learningRate) {
      res["LearningRate"] = boost::any(*learningRate);
    }
    if (optimizer) {
      res["Optimizer"] = boost::any(*optimizer);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LearningRate") != m.end() && !m["LearningRate"].empty()) {
      learningRate = make_shared<double>(boost::any_cast<double>(m["LearningRate"]));
    }
    if (m.find("Optimizer") != m.end() && !m["Optimizer"].empty()) {
      optimizer = make_shared<string>(boost::any_cast<string>(m["Optimizer"]));
    }
  }


  virtual ~Optimization() = default;
};
class Schedule : public Darabonba::Model {
public:
  shared_ptr<double> gamma{};
  shared_ptr<string> LRScheduler{};
  shared_ptr<long> stepSize{};

  Schedule() {}

  explicit Schedule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gamma) {
      res["Gamma"] = boost::any(*gamma);
    }
    if (LRScheduler) {
      res["LRScheduler"] = boost::any(*LRScheduler);
    }
    if (stepSize) {
      res["StepSize"] = boost::any(*stepSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Gamma") != m.end() && !m["Gamma"].empty()) {
      gamma = make_shared<double>(boost::any_cast<double>(m["Gamma"]));
    }
    if (m.find("LRScheduler") != m.end() && !m["LRScheduler"].empty()) {
      LRScheduler = make_shared<string>(boost::any_cast<string>(m["LRScheduler"]));
    }
    if (m.find("StepSize") != m.end() && !m["StepSize"].empty()) {
      stepSize = make_shared<long>(boost::any_cast<long>(m["StepSize"]));
    }
  }


  virtual ~Schedule() = default;
};
class Hyperparameters : public Darabonba::Model {
public:
  shared_ptr<long> backupInterval{};
  shared_ptr<long> batchSize{};
  shared_ptr<long> dataLoaderWorkers{};
  shared_ptr<CustomParams> evaluator{};
  shared_ptr<vector<long>> inputSize{};
  shared_ptr<long> maxEpoch{};
  shared_ptr<Optimization> optimization{};
  shared_ptr<Schedule> schedule{};

  Hyperparameters() {}

  explicit Hyperparameters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (backupInterval) {
      res["BackupInterval"] = boost::any(*backupInterval);
    }
    if (batchSize) {
      res["BatchSize"] = boost::any(*batchSize);
    }
    if (dataLoaderWorkers) {
      res["DataLoaderWorkers"] = boost::any(*dataLoaderWorkers);
    }
    if (evaluator) {
      res["Evaluator"] = evaluator ? boost::any(evaluator->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (inputSize) {
      res["InputSize"] = boost::any(*inputSize);
    }
    if (maxEpoch) {
      res["MaxEpoch"] = boost::any(*maxEpoch);
    }
    if (optimization) {
      res["Optimization"] = optimization ? boost::any(optimization->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (schedule) {
      res["Schedule"] = schedule ? boost::any(schedule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BackupInterval") != m.end() && !m["BackupInterval"].empty()) {
      backupInterval = make_shared<long>(boost::any_cast<long>(m["BackupInterval"]));
    }
    if (m.find("BatchSize") != m.end() && !m["BatchSize"].empty()) {
      batchSize = make_shared<long>(boost::any_cast<long>(m["BatchSize"]));
    }
    if (m.find("DataLoaderWorkers") != m.end() && !m["DataLoaderWorkers"].empty()) {
      dataLoaderWorkers = make_shared<long>(boost::any_cast<long>(m["DataLoaderWorkers"]));
    }
    if (m.find("Evaluator") != m.end() && !m["Evaluator"].empty()) {
      if (typeid(map<string, boost::any>) == m["Evaluator"].type()) {
        CustomParams model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Evaluator"]));
        evaluator = make_shared<CustomParams>(model1);
      }
    }
    if (m.find("InputSize") != m.end() && !m["InputSize"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["InputSize"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InputSize"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      inputSize = make_shared<vector<long>>(toVec1);
    }
    if (m.find("MaxEpoch") != m.end() && !m["MaxEpoch"].empty()) {
      maxEpoch = make_shared<long>(boost::any_cast<long>(m["MaxEpoch"]));
    }
    if (m.find("Optimization") != m.end() && !m["Optimization"].empty()) {
      if (typeid(map<string, boost::any>) == m["Optimization"].type()) {
        Optimization model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Optimization"]));
        optimization = make_shared<Optimization>(model1);
      }
    }
    if (m.find("Schedule") != m.end() && !m["Schedule"].empty()) {
      if (typeid(map<string, boost::any>) == m["Schedule"].type()) {
        Schedule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Schedule"]));
        schedule = make_shared<Schedule>(model1);
      }
    }
  }


  virtual ~Hyperparameters() = default;
};
class Resource : public Darabonba::Model {
public:
  shared_ptr<long> CPU{};
  shared_ptr<string> ECSInstance{};
  shared_ptr<string> GPUModel{};
  shared_ptr<long> GPUNum{};
  shared_ptr<string> name{};
  shared_ptr<long> RAM{};

  Resource() {}

  explicit Resource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (CPU) {
      res["CPU"] = boost::any(*CPU);
    }
    if (ECSInstance) {
      res["ECSInstance"] = boost::any(*ECSInstance);
    }
    if (GPUModel) {
      res["GPUModel"] = boost::any(*GPUModel);
    }
    if (GPUNum) {
      res["GPUNum"] = boost::any(*GPUNum);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (RAM) {
      res["RAM"] = boost::any(*RAM);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CPU") != m.end() && !m["CPU"].empty()) {
      CPU = make_shared<long>(boost::any_cast<long>(m["CPU"]));
    }
    if (m.find("ECSInstance") != m.end() && !m["ECSInstance"].empty()) {
      ECSInstance = make_shared<string>(boost::any_cast<string>(m["ECSInstance"]));
    }
    if (m.find("GPUModel") != m.end() && !m["GPUModel"].empty()) {
      GPUModel = make_shared<string>(boost::any_cast<string>(m["GPUModel"]));
    }
    if (m.find("GPUNum") != m.end() && !m["GPUNum"].empty()) {
      GPUNum = make_shared<long>(boost::any_cast<long>(m["GPUNum"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("RAM") != m.end() && !m["RAM"].empty()) {
      RAM = make_shared<long>(boost::any_cast<long>(m["RAM"]));
    }
  }


  virtual ~Resource() = default;
};
class Runtime : public Darabonba::Model {
public:
  shared_ptr<Hyperparameters> hyperparameters{};
  shared_ptr<Resource> resource{};

  Runtime() {}

  explicit Runtime(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (hyperparameters) {
      res["Hyperparameters"] = hyperparameters ? boost::any(hyperparameters->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resource) {
      res["Resource"] = resource ? boost::any(resource->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Hyperparameters") != m.end() && !m["Hyperparameters"].empty()) {
      if (typeid(map<string, boost::any>) == m["Hyperparameters"].type()) {
        Hyperparameters model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Hyperparameters"]));
        hyperparameters = make_shared<Hyperparameters>(model1);
      }
    }
    if (m.find("Resource") != m.end() && !m["Resource"].empty()) {
      if (typeid(map<string, boost::any>) == m["Resource"].type()) {
        Resource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Resource"]));
        resource = make_shared<Resource>(model1);
      }
    }
  }


  virtual ~Runtime() = default;
};
class TrainingSpecification : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> endpoint{};
  shared_ptr<ModelSpecification> modelSpecification{};
  shared_ptr<Runtime> runtime{};
  shared_ptr<string> sourceURI{};
  shared_ptr<string> targetURI{};
  shared_ptr<vector<CustomParams>> transforms{};
  shared_ptr<string> validationSourceURI{};
  shared_ptr<double> validationSplit{};

  TrainingSpecification() {}

  explicit TrainingSpecification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (modelSpecification) {
      res["ModelSpecification"] = modelSpecification ? boost::any(modelSpecification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (runtime) {
      res["Runtime"] = runtime ? boost::any(runtime->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    if (targetURI) {
      res["TargetURI"] = boost::any(*targetURI);
    }
    if (transforms) {
      vector<boost::any> temp1;
      for(auto item1:*transforms){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Transforms"] = boost::any(temp1);
    }
    if (validationSourceURI) {
      res["ValidationSourceURI"] = boost::any(*validationSourceURI);
    }
    if (validationSplit) {
      res["ValidationSplit"] = boost::any(*validationSplit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("ModelSpecification") != m.end() && !m["ModelSpecification"].empty()) {
      if (typeid(map<string, boost::any>) == m["ModelSpecification"].type()) {
        ModelSpecification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ModelSpecification"]));
        modelSpecification = make_shared<ModelSpecification>(model1);
      }
    }
    if (m.find("Runtime") != m.end() && !m["Runtime"].empty()) {
      if (typeid(map<string, boost::any>) == m["Runtime"].type()) {
        Runtime model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Runtime"]));
        runtime = make_shared<Runtime>(model1);
      }
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
    if (m.find("TargetURI") != m.end() && !m["TargetURI"].empty()) {
      targetURI = make_shared<string>(boost::any_cast<string>(m["TargetURI"]));
    }
    if (m.find("Transforms") != m.end() && !m["Transforms"].empty()) {
      if (typeid(vector<boost::any>) == m["Transforms"].type()) {
        vector<CustomParams> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Transforms"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CustomParams model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        transforms = make_shared<vector<CustomParams>>(expect1);
      }
    }
    if (m.find("ValidationSourceURI") != m.end() && !m["ValidationSourceURI"].empty()) {
      validationSourceURI = make_shared<string>(boost::any_cast<string>(m["ValidationSourceURI"]));
    }
    if (m.find("ValidationSplit") != m.end() && !m["ValidationSplit"].empty()) {
      validationSplit = make_shared<double>(boost::any_cast<double>(m["ValidationSplit"]));
    }
  }


  virtual ~TrainingSpecification() = default;
};
class AlgorithmDefinition : public Darabonba::Model {
public:
  shared_ptr<string> algorithmDefinitionId{};
  shared_ptr<string> createTime{};
  shared_ptr<vector<map<string, string>>> customLabels{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> projectName{};
  shared_ptr<TrainingSpecification> trainingSpecification{};
  shared_ptr<string> updateTime{};

  AlgorithmDefinition() {}

  explicit AlgorithmDefinition(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (algorithmDefinitionId) {
      res["AlgorithmDefinitionId"] = boost::any(*algorithmDefinitionId);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (customLabels) {
      res["CustomLabels"] = boost::any(*customLabels);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (trainingSpecification) {
      res["TrainingSpecification"] = trainingSpecification ? boost::any(trainingSpecification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlgorithmDefinitionId") != m.end() && !m["AlgorithmDefinitionId"].empty()) {
      algorithmDefinitionId = make_shared<string>(boost::any_cast<string>(m["AlgorithmDefinitionId"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CustomLabels") != m.end() && !m["CustomLabels"].empty()) {
      vector<map<string, string>> toVec1;
      if (typeid(vector<boost::any>) == m["CustomLabels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["CustomLabels"]);
        for (auto item:vec1) {
          map<string, string> map2 = boost::any_cast<map<string, string>>(item);
          map<string, string> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      customLabels = make_shared<vector<map<string, string>>>(toVec1);
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("TrainingSpecification") != m.end() && !m["TrainingSpecification"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrainingSpecification"].type()) {
        TrainingSpecification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrainingSpecification"]));
        trainingSpecification = make_shared<TrainingSpecification>(model1);
      }
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~AlgorithmDefinition() = default;
};
class ReferenceFile : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> objectId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> URI{};

  ReferenceFile() {}

  explicit ReferenceFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~ReferenceFile() = default;
};
class Answer : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<vector<ReferenceFile>> references{};

  Answer() {}

  explicit Answer(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (references) {
      vector<boost::any> temp1;
      for(auto item1:*references){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["References"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("References") != m.end() && !m["References"].empty()) {
      if (typeid(vector<boost::any>) == m["References"].type()) {
        vector<ReferenceFile> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["References"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ReferenceFile model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        references = make_shared<vector<ReferenceFile>>(expect1);
      }
    }
  }


  virtual ~Answer() = default;
};
class App : public Darabonba::Model {
public:
  shared_ptr<string> appDescription{};
  shared_ptr<string> appId{};
  shared_ptr<string> appKey{};
  shared_ptr<string> appName{};
  shared_ptr<long> appRegion{};
  shared_ptr<long> appType{};
  shared_ptr<string> englishName{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> packageName{};

  App() {}

  explicit App(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (appDescription) {
      res["AppDescription"] = boost::any(*appDescription);
    }
    if (appId) {
      res["AppId"] = boost::any(*appId);
    }
    if (appKey) {
      res["AppKey"] = boost::any(*appKey);
    }
    if (appName) {
      res["AppName"] = boost::any(*appName);
    }
    if (appRegion) {
      res["AppRegion"] = boost::any(*appRegion);
    }
    if (appType) {
      res["AppType"] = boost::any(*appType);
    }
    if (englishName) {
      res["EnglishName"] = boost::any(*englishName);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (packageName) {
      res["PackageName"] = boost::any(*packageName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AppDescription") != m.end() && !m["AppDescription"].empty()) {
      appDescription = make_shared<string>(boost::any_cast<string>(m["AppDescription"]));
    }
    if (m.find("AppId") != m.end() && !m["AppId"].empty()) {
      appId = make_shared<string>(boost::any_cast<string>(m["AppId"]));
    }
    if (m.find("AppKey") != m.end() && !m["AppKey"].empty()) {
      appKey = make_shared<string>(boost::any_cast<string>(m["AppKey"]));
    }
    if (m.find("AppName") != m.end() && !m["AppName"].empty()) {
      appName = make_shared<string>(boost::any_cast<string>(m["AppName"]));
    }
    if (m.find("AppRegion") != m.end() && !m["AppRegion"].empty()) {
      appRegion = make_shared<long>(boost::any_cast<long>(m["AppRegion"]));
    }
    if (m.find("AppType") != m.end() && !m["AppType"].empty()) {
      appType = make_shared<long>(boost::any_cast<long>(m["AppType"]));
    }
    if (m.find("EnglishName") != m.end() && !m["EnglishName"].empty()) {
      englishName = make_shared<string>(boost::any_cast<string>(m["EnglishName"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("PackageName") != m.end() && !m["PackageName"].empty()) {
      packageName = make_shared<string>(boost::any_cast<string>(m["PackageName"]));
    }
  }


  virtual ~App() = default;
};
class AssumeRoleChainNode : public Darabonba::Model {
public:
  shared_ptr<string> ownerId{};
  shared_ptr<string> role{};
  shared_ptr<string> type{};

  AssumeRoleChainNode() {}

  explicit AssumeRoleChainNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AssumeRoleChainNode() = default;
};
class AssumeRoleChain : public Darabonba::Model {
public:
  shared_ptr<vector<AssumeRoleChainNode>> chain{};
  shared_ptr<string> policy{};

  AssumeRoleChain() {}

  explicit AssumeRoleChain(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chain) {
      vector<boost::any> temp1;
      for(auto item1:*chain){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Chain"] = boost::any(temp1);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Chain") != m.end() && !m["Chain"].empty()) {
      if (typeid(vector<boost::any>) == m["Chain"].type()) {
        vector<AssumeRoleChainNode> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Chain"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AssumeRoleChainNode model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        chain = make_shared<vector<AssumeRoleChainNode>>(expect1);
      }
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
  }


  virtual ~AssumeRoleChain() = default;
};
class AudioStream : public Darabonba::Model {
public:
  shared_ptr<long> bitrate{};
  shared_ptr<string> channelLayout{};
  shared_ptr<long> channels{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<double> duration{};
  shared_ptr<long> frameCount{};
  shared_ptr<long> index{};
  shared_ptr<string> language{};
  shared_ptr<string> lyric{};
  shared_ptr<string> sampleFormat{};
  shared_ptr<long> sampleRate{};
  shared_ptr<double> startTime{};
  shared_ptr<string> timeBase{};

  AudioStream() {}

  explicit AudioStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (channelLayout) {
      res["ChannelLayout"] = boost::any(*channelLayout);
    }
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (frameCount) {
      res["FrameCount"] = boost::any(*frameCount);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (lyric) {
      res["Lyric"] = boost::any(*lyric);
    }
    if (sampleFormat) {
      res["SampleFormat"] = boost::any(*sampleFormat);
    }
    if (sampleRate) {
      res["SampleRate"] = boost::any(*sampleRate);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timeBase) {
      res["TimeBase"] = boost::any(*timeBase);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<long>(boost::any_cast<long>(m["Bitrate"]));
    }
    if (m.find("ChannelLayout") != m.end() && !m["ChannelLayout"].empty()) {
      channelLayout = make_shared<string>(boost::any_cast<string>(m["ChannelLayout"]));
    }
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<long>(boost::any_cast<long>(m["Channels"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("FrameCount") != m.end() && !m["FrameCount"].empty()) {
      frameCount = make_shared<long>(boost::any_cast<long>(m["FrameCount"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Lyric") != m.end() && !m["Lyric"].empty()) {
      lyric = make_shared<string>(boost::any_cast<string>(m["Lyric"]));
    }
    if (m.find("SampleFormat") != m.end() && !m["SampleFormat"].empty()) {
      sampleFormat = make_shared<string>(boost::any_cast<string>(m["SampleFormat"]));
    }
    if (m.find("SampleRate") != m.end() && !m["SampleRate"].empty()) {
      sampleRate = make_shared<long>(boost::any_cast<long>(m["SampleRate"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<double>(boost::any_cast<double>(m["StartTime"]));
    }
    if (m.find("TimeBase") != m.end() && !m["TimeBase"].empty()) {
      timeBase = make_shared<string>(boost::any_cast<string>(m["TimeBase"]));
    }
  }


  virtual ~AudioStream() = default;
};
class Binding : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> phase{};
  shared_ptr<string> projectName{};
  shared_ptr<string> reason{};
  shared_ptr<string> state{};
  shared_ptr<string> URI{};
  shared_ptr<string> updateTime{};

  Binding() {}

  explicit Binding(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~Binding() = default;
};
class PointInt64 : public Darabonba::Model {
public:
  shared_ptr<long> x{};
  shared_ptr<long> y{};

  PointInt64() {}

  explicit PointInt64(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (x) {
      res["X"] = boost::any(*x);
    }
    if (y) {
      res["Y"] = boost::any(*y);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("X") != m.end() && !m["X"].empty()) {
      x = make_shared<long>(boost::any_cast<long>(m["X"]));
    }
    if (m.find("Y") != m.end() && !m["Y"].empty()) {
      y = make_shared<long>(boost::any_cast<long>(m["Y"]));
    }
  }


  virtual ~PointInt64() = default;
};
class Boundary : public Darabonba::Model {
public:
  shared_ptr<long> height{};
  shared_ptr<long> left{};
  shared_ptr<vector<PointInt64>> polygon{};
  shared_ptr<long> top{};
  shared_ptr<long> width{};

  Boundary() {}

  explicit Boundary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (left) {
      res["Left"] = boost::any(*left);
    }
    if (polygon) {
      vector<boost::any> temp1;
      for(auto item1:*polygon){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Polygon"] = boost::any(temp1);
    }
    if (top) {
      res["Top"] = boost::any(*top);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Left") != m.end() && !m["Left"].empty()) {
      left = make_shared<long>(boost::any_cast<long>(m["Left"]));
    }
    if (m.find("Polygon") != m.end() && !m["Polygon"].empty()) {
      if (typeid(vector<boost::any>) == m["Polygon"].type()) {
        vector<PointInt64> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Polygon"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            PointInt64 model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        polygon = make_shared<vector<PointInt64>>(expect1);
      }
    }
    if (m.find("Top") != m.end() && !m["Top"].empty()) {
      top = make_shared<long>(boost::any_cast<long>(m["Top"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~Boundary() = default;
};
class Body : public Darabonba::Model {
public:
  shared_ptr<Boundary> boundary{};
  shared_ptr<double> confidence{};

  Body() {}

  explicit Body(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (boundary) {
      res["Boundary"] = boundary ? boost::any(boundary->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (confidence) {
      res["Confidence"] = boost::any(*confidence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Boundary") != m.end() && !m["Boundary"].empty()) {
      if (typeid(map<string, boost::any>) == m["Boundary"].type()) {
        Boundary model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Boundary"]));
        boundary = make_shared<Boundary>(model1);
      }
    }
    if (m.find("Confidence") != m.end() && !m["Confidence"].empty()) {
      confidence = make_shared<double>(boost::any_cast<double>(m["Confidence"]));
    }
  }


  virtual ~Body() = default;
};
class LicensePlate : public Darabonba::Model {
public:
  shared_ptr<Boundary> boundary{};
  shared_ptr<double> confidence{};
  shared_ptr<string> content{};

  LicensePlate() {}

  explicit LicensePlate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (boundary) {
      res["Boundary"] = boundary ? boost::any(boundary->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (confidence) {
      res["Confidence"] = boost::any(*confidence);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Boundary") != m.end() && !m["Boundary"].empty()) {
      if (typeid(map<string, boost::any>) == m["Boundary"].type()) {
        Boundary model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Boundary"]));
        boundary = make_shared<Boundary>(model1);
      }
    }
    if (m.find("Confidence") != m.end() && !m["Confidence"].empty()) {
      confidence = make_shared<double>(boost::any_cast<double>(m["Confidence"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
  }


  virtual ~LicensePlate() = default;
};
class Car : public Darabonba::Model {
public:
  shared_ptr<Boundary> boundary{};
  shared_ptr<string> carColor{};
  shared_ptr<double> carColorConfidence{};
  shared_ptr<string> carType{};
  shared_ptr<double> carTypeConfidence{};
  shared_ptr<double> confidence{};
  shared_ptr<vector<LicensePlate>> licensePlates{};

  Car() {}

  explicit Car(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (boundary) {
      res["Boundary"] = boundary ? boost::any(boundary->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (carColor) {
      res["CarColor"] = boost::any(*carColor);
    }
    if (carColorConfidence) {
      res["CarColorConfidence"] = boost::any(*carColorConfidence);
    }
    if (carType) {
      res["CarType"] = boost::any(*carType);
    }
    if (carTypeConfidence) {
      res["CarTypeConfidence"] = boost::any(*carTypeConfidence);
    }
    if (confidence) {
      res["Confidence"] = boost::any(*confidence);
    }
    if (licensePlates) {
      vector<boost::any> temp1;
      for(auto item1:*licensePlates){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LicensePlates"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Boundary") != m.end() && !m["Boundary"].empty()) {
      if (typeid(map<string, boost::any>) == m["Boundary"].type()) {
        Boundary model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Boundary"]));
        boundary = make_shared<Boundary>(model1);
      }
    }
    if (m.find("CarColor") != m.end() && !m["CarColor"].empty()) {
      carColor = make_shared<string>(boost::any_cast<string>(m["CarColor"]));
    }
    if (m.find("CarColorConfidence") != m.end() && !m["CarColorConfidence"].empty()) {
      carColorConfidence = make_shared<double>(boost::any_cast<double>(m["CarColorConfidence"]));
    }
    if (m.find("CarType") != m.end() && !m["CarType"].empty()) {
      carType = make_shared<string>(boost::any_cast<string>(m["CarType"]));
    }
    if (m.find("CarTypeConfidence") != m.end() && !m["CarTypeConfidence"].empty()) {
      carTypeConfidence = make_shared<double>(boost::any_cast<double>(m["CarTypeConfidence"]));
    }
    if (m.find("Confidence") != m.end() && !m["Confidence"].empty()) {
      confidence = make_shared<double>(boost::any_cast<double>(m["Confidence"]));
    }
    if (m.find("LicensePlates") != m.end() && !m["LicensePlates"].empty()) {
      if (typeid(vector<boost::any>) == m["LicensePlates"].type()) {
        vector<LicensePlate> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LicensePlates"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            LicensePlate model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        licensePlates = make_shared<vector<LicensePlate>>(expect1);
      }
    }
  }


  virtual ~Car() = default;
};
class ClusterForReqCoverFigures : public Darabonba::Model {
public:
  shared_ptr<string> figureId{};

  ClusterForReqCoverFigures() {}

  explicit ClusterForReqCoverFigures(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (figureId) {
      res["FigureId"] = boost::any(*figureId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FigureId") != m.end() && !m["FigureId"].empty()) {
      figureId = make_shared<string>(boost::any_cast<string>(m["FigureId"]));
    }
  }


  virtual ~ClusterForReqCoverFigures() = default;
};
class ClusterForReqCover : public Darabonba::Model {
public:
  shared_ptr<vector<ClusterForReqCoverFigures>> figures{};

  ClusterForReqCover() {}

  explicit ClusterForReqCover(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (figures) {
      vector<boost::any> temp1;
      for(auto item1:*figures){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Figures"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Figures") != m.end() && !m["Figures"].empty()) {
      if (typeid(vector<boost::any>) == m["Figures"].type()) {
        vector<ClusterForReqCoverFigures> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Figures"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ClusterForReqCoverFigures model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        figures = make_shared<vector<ClusterForReqCoverFigures>>(expect1);
      }
    }
  }


  virtual ~ClusterForReqCover() = default;
};
class ClusterForReq : public Darabonba::Model {
public:
  shared_ptr<ClusterForReqCover> cover{};
  shared_ptr<string> customId{};
  shared_ptr<map<string, boost::any>> customLabels{};
  shared_ptr<string> name{};
  shared_ptr<string> objectId{};

  ClusterForReq() {}

  explicit ClusterForReq(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cover) {
      res["Cover"] = cover ? boost::any(cover->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customId) {
      res["CustomId"] = boost::any(*customId);
    }
    if (customLabels) {
      res["CustomLabels"] = boost::any(*customLabels);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cover") != m.end() && !m["Cover"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cover"].type()) {
        ClusterForReqCover model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cover"]));
        cover = make_shared<ClusterForReqCover>(model1);
      }
    }
    if (m.find("CustomId") != m.end() && !m["CustomId"].empty()) {
      customId = make_shared<string>(boost::any_cast<string>(m["CustomId"]));
    }
    if (m.find("CustomLabels") != m.end() && !m["CustomLabels"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["CustomLabels"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customLabels = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
  }


  virtual ~ClusterForReq() = default;
};
class Codes : public Darabonba::Model {
public:
  shared_ptr<Boundary> boundary{};
  shared_ptr<double> confidence{};
  shared_ptr<string> content{};
  shared_ptr<string> type{};

  Codes() {}

  explicit Codes(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (boundary) {
      res["Boundary"] = boundary ? boost::any(boundary->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (confidence) {
      res["Confidence"] = boost::any(*confidence);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Boundary") != m.end() && !m["Boundary"].empty()) {
      if (typeid(map<string, boost::any>) == m["Boundary"].type()) {
        Boundary model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Boundary"]));
        boundary = make_shared<Boundary>(model1);
      }
    }
    if (m.find("Confidence") != m.end() && !m["Confidence"].empty()) {
      confidence = make_shared<double>(boost::any_cast<double>(m["Confidence"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~Codes() = default;
};
class ElementContent : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<vector<long>> timeRange{};
  shared_ptr<string> type{};
  shared_ptr<string> URL{};

  ElementContent() {}

  explicit ElementContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (timeRange) {
      res["TimeRange"] = boost::any(*timeRange);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (URL) {
      res["URL"] = boost::any(*URL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("TimeRange") != m.end() && !m["TimeRange"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["TimeRange"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TimeRange"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      timeRange = make_shared<vector<long>>(toVec1);
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("URL") != m.end() && !m["URL"].empty()) {
      URL = make_shared<string>(boost::any_cast<string>(m["URL"]));
    }
  }


  virtual ~ElementContent() = default;
};
class ElementRelation : public Darabonba::Model {
public:
  shared_ptr<string> objectId{};
  shared_ptr<string> type{};

  ElementRelation() {}

  explicit ElementRelation(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ElementRelation() = default;
};
class Element : public Darabonba::Model {
public:
  shared_ptr<vector<ElementContent>> elementContents{};
  shared_ptr<vector<ElementRelation>> elementRelations{};
  shared_ptr<string> elementType{};
  shared_ptr<string> objectId{};
  shared_ptr<double> semanticSimilarity{};

  Element() {}

  explicit Element(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (elementContents) {
      vector<boost::any> temp1;
      for(auto item1:*elementContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ElementContents"] = boost::any(temp1);
    }
    if (elementRelations) {
      vector<boost::any> temp1;
      for(auto item1:*elementRelations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ElementRelations"] = boost::any(temp1);
    }
    if (elementType) {
      res["ElementType"] = boost::any(*elementType);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (semanticSimilarity) {
      res["SemanticSimilarity"] = boost::any(*semanticSimilarity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ElementContents") != m.end() && !m["ElementContents"].empty()) {
      if (typeid(vector<boost::any>) == m["ElementContents"].type()) {
        vector<ElementContent> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ElementContents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ElementContent model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        elementContents = make_shared<vector<ElementContent>>(expect1);
      }
    }
    if (m.find("ElementRelations") != m.end() && !m["ElementRelations"].empty()) {
      if (typeid(vector<boost::any>) == m["ElementRelations"].type()) {
        vector<ElementRelation> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ElementRelations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ElementRelation model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        elementRelations = make_shared<vector<ElementRelation>>(expect1);
      }
    }
    if (m.find("ElementType") != m.end() && !m["ElementType"].empty()) {
      elementType = make_shared<string>(boost::any_cast<string>(m["ElementType"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("SemanticSimilarity") != m.end() && !m["SemanticSimilarity"].empty()) {
      semanticSimilarity = make_shared<double>(boost::any_cast<double>(m["SemanticSimilarity"]));
    }
  }


  virtual ~Element() = default;
};
class ContextualFile : public Darabonba::Model {
public:
  shared_ptr<string> contentType{};
  shared_ptr<string> datasetName{};
  shared_ptr<vector<Element>> elements{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> OSSURI{};
  shared_ptr<string> objectId{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> URI{};

  ContextualFile() {}

  explicit ContextualFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (elements) {
      vector<boost::any> temp1;
      for(auto item1:*elements){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Elements"] = boost::any(temp1);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (OSSURI) {
      res["OSSURI"] = boost::any(*OSSURI);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Elements") != m.end() && !m["Elements"].empty()) {
      if (typeid(vector<boost::any>) == m["Elements"].type()) {
        vector<Element> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Elements"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Element model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        elements = make_shared<vector<Element>>(expect1);
      }
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("OSSURI") != m.end() && !m["OSSURI"].empty()) {
      OSSURI = make_shared<string>(boost::any_cast<string>(m["OSSURI"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~ContextualFile() = default;
};
class ContextualMessage : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<vector<ContextualFile>> files{};
  shared_ptr<string> role{};

  ContextualMessage() {}

  explicit ContextualMessage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (files) {
      vector<boost::any> temp1;
      for(auto item1:*files){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Files"] = boost::any(temp1);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      if (typeid(vector<boost::any>) == m["Files"].type()) {
        vector<ContextualFile> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Files"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ContextualFile model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        files = make_shared<vector<ContextualFile>>(expect1);
      }
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
  }


  virtual ~ContextualMessage() = default;
};
class CredentialConfigChain : public Darabonba::Model {
public:
  shared_ptr<string> assumeRoleFor{};
  shared_ptr<string> role{};
  shared_ptr<string> roleType{};

  CredentialConfigChain() {}

  explicit CredentialConfigChain(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assumeRoleFor) {
      res["AssumeRoleFor"] = boost::any(*assumeRoleFor);
    }
    if (role) {
      res["Role"] = boost::any(*role);
    }
    if (roleType) {
      res["RoleType"] = boost::any(*roleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssumeRoleFor") != m.end() && !m["AssumeRoleFor"].empty()) {
      assumeRoleFor = make_shared<string>(boost::any_cast<string>(m["AssumeRoleFor"]));
    }
    if (m.find("Role") != m.end() && !m["Role"].empty()) {
      role = make_shared<string>(boost::any_cast<string>(m["Role"]));
    }
    if (m.find("RoleType") != m.end() && !m["RoleType"].empty()) {
      roleType = make_shared<string>(boost::any_cast<string>(m["RoleType"]));
    }
  }


  virtual ~CredentialConfigChain() = default;
};
class CredentialConfig : public Darabonba::Model {
public:
  shared_ptr<vector<CredentialConfigChain>> chain{};
  shared_ptr<string> policy{};
  shared_ptr<string> serviceRole{};

  CredentialConfig() {}

  explicit CredentialConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (chain) {
      vector<boost::any> temp1;
      for(auto item1:*chain){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Chain"] = boost::any(temp1);
    }
    if (policy) {
      res["Policy"] = boost::any(*policy);
    }
    if (serviceRole) {
      res["ServiceRole"] = boost::any(*serviceRole);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Chain") != m.end() && !m["Chain"].empty()) {
      if (typeid(vector<boost::any>) == m["Chain"].type()) {
        vector<CredentialConfigChain> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Chain"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CredentialConfigChain model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        chain = make_shared<vector<CredentialConfigChain>>(expect1);
      }
    }
    if (m.find("Policy") != m.end() && !m["Policy"].empty()) {
      policy = make_shared<string>(boost::any_cast<string>(m["Policy"]));
    }
    if (m.find("ServiceRole") != m.end() && !m["ServiceRole"].empty()) {
      serviceRole = make_shared<string>(boost::any_cast<string>(m["ServiceRole"]));
    }
  }


  virtual ~CredentialConfig() = default;
};
class CroppingSuggestion : public Darabonba::Model {
public:
  shared_ptr<string> aspectRatio{};
  shared_ptr<Boundary> boundary{};
  shared_ptr<double> confidence{};

  CroppingSuggestion() {}

  explicit CroppingSuggestion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aspectRatio) {
      res["AspectRatio"] = boost::any(*aspectRatio);
    }
    if (boundary) {
      res["Boundary"] = boundary ? boost::any(boundary->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (confidence) {
      res["Confidence"] = boost::any(*confidence);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AspectRatio") != m.end() && !m["AspectRatio"].empty()) {
      aspectRatio = make_shared<string>(boost::any_cast<string>(m["AspectRatio"]));
    }
    if (m.find("Boundary") != m.end() && !m["Boundary"].empty()) {
      if (typeid(map<string, boost::any>) == m["Boundary"].type()) {
        Boundary model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Boundary"]));
        boundary = make_shared<Boundary>(model1);
      }
    }
    if (m.find("Confidence") != m.end() && !m["Confidence"].empty()) {
      confidence = make_shared<double>(boost::any_cast<double>(m["Confidence"]));
    }
  }


  virtual ~CroppingSuggestion() = default;
};
class FastFailPolicy : public Darabonba::Model {
public:
  shared_ptr<string> action{};

  FastFailPolicy() {}

  explicit FastFailPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (action) {
      res["Action"] = boost::any(*action);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Action") != m.end() && !m["Action"].empty()) {
      action = make_shared<string>(boost::any_cast<string>(m["Action"]));
    }
  }


  virtual ~FastFailPolicy() = default;
};
class DataIngestionActions : public Darabonba::Model {
public:
  shared_ptr<FastFailPolicy> fastFailPolicy{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> parameters{};

  DataIngestionActions() {}

  explicit DataIngestionActions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fastFailPolicy) {
      res["FastFailPolicy"] = fastFailPolicy ? boost::any(fastFailPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FastFailPolicy") != m.end() && !m["FastFailPolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["FastFailPolicy"].type()) {
        FastFailPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FastFailPolicy"]));
        fastFailPolicy = make_shared<FastFailPolicy>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Parameters"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Parameters"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      parameters = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~DataIngestionActions() = default;
};
class MNS : public Darabonba::Model {
public:
  shared_ptr<string> topicName{};

  MNS() {}

  explicit MNS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (topicName) {
      res["TopicName"] = boost::any(*topicName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TopicName") != m.end() && !m["TopicName"].empty()) {
      topicName = make_shared<string>(boost::any_cast<string>(m["TopicName"]));
    }
  }


  virtual ~MNS() = default;
};
class RocketMQ : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> topicName{};

  RocketMQ() {}

  explicit RocketMQ(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (topicName) {
      res["TopicName"] = boost::any(*topicName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("TopicName") != m.end() && !m["TopicName"].empty()) {
      topicName = make_shared<string>(boost::any_cast<string>(m["TopicName"]));
    }
  }


  virtual ~RocketMQ() = default;
};
class DataIngestionNotification : public Darabonba::Model {
public:
  shared_ptr<string> endpoint{};
  shared_ptr<MNS> MNS{};
  shared_ptr<RocketMQ> rocketMQ{};
  shared_ptr<string> topic{};

  DataIngestionNotification() {}

  explicit DataIngestionNotification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpoint) {
      res["Endpoint"] = boost::any(*endpoint);
    }
    if (MNS) {
      res["MNS"] = MNS ? boost::any(MNS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rocketMQ) {
      res["RocketMQ"] = rocketMQ ? boost::any(rocketMQ->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Endpoint") != m.end() && !m["Endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["Endpoint"]));
    }
    if (m.find("MNS") != m.end() && !m["MNS"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNS"].type()) {
        MNS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNS"]));
        MNS = make_shared<MNS>(model1);
      }
    }
    if (m.find("RocketMQ") != m.end() && !m["RocketMQ"].empty()) {
      if (typeid(map<string, boost::any>) == m["RocketMQ"].type()) {
        RocketMQ model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RocketMQ"]));
        rocketMQ = make_shared<RocketMQ>(model1);
      }
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~DataIngestionNotification() = default;
};
class DataIngestionStatistic : public Darabonba::Model {
public:
  shared_ptr<long> skipFiles{};
  shared_ptr<long> submitFailure{};
  shared_ptr<long> submitSuccess{};

  DataIngestionStatistic() {}

  explicit DataIngestionStatistic(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (skipFiles) {
      res["SkipFiles"] = boost::any(*skipFiles);
    }
    if (submitFailure) {
      res["SubmitFailure"] = boost::any(*submitFailure);
    }
    if (submitSuccess) {
      res["SubmitSuccess"] = boost::any(*submitSuccess);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("SkipFiles") != m.end() && !m["SkipFiles"].empty()) {
      skipFiles = make_shared<long>(boost::any_cast<long>(m["SkipFiles"]));
    }
    if (m.find("SubmitFailure") != m.end() && !m["SubmitFailure"].empty()) {
      submitFailure = make_shared<long>(boost::any_cast<long>(m["SubmitFailure"]));
    }
    if (m.find("SubmitSuccess") != m.end() && !m["SubmitSuccess"].empty()) {
      submitSuccess = make_shared<long>(boost::any_cast<long>(m["SubmitSuccess"]));
    }
  }


  virtual ~DataIngestionStatistic() = default;
};
class InputOSS : public Darabonba::Model {
public:
  shared_ptr<string> bucket{};
  shared_ptr<vector<string>> matchExpressions{};
  shared_ptr<string> prefix{};

  InputOSS() {}

  explicit InputOSS(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucket) {
      res["Bucket"] = boost::any(*bucket);
    }
    if (matchExpressions) {
      res["MatchExpressions"] = boost::any(*matchExpressions);
    }
    if (prefix) {
      res["Prefix"] = boost::any(*prefix);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bucket") != m.end() && !m["Bucket"].empty()) {
      bucket = make_shared<string>(boost::any_cast<string>(m["Bucket"]));
    }
    if (m.find("MatchExpressions") != m.end() && !m["MatchExpressions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MatchExpressions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MatchExpressions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      matchExpressions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Prefix") != m.end() && !m["Prefix"].empty()) {
      prefix = make_shared<string>(boost::any_cast<string>(m["Prefix"]));
    }
  }


  virtual ~InputOSS() = default;
};
class Input : public Darabonba::Model {
public:
  shared_ptr<InputOSS> OSS{};

  Input() {}

  explicit Input(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (OSS) {
      res["OSS"] = OSS ? boost::any(OSS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OSS") != m.end() && !m["OSS"].empty()) {
      if (typeid(map<string, boost::any>) == m["OSS"].type()) {
        InputOSS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OSS"]));
        OSS = make_shared<InputOSS>(model1);
      }
    }
  }


  virtual ~Input() = default;
};
class DataIngestion : public Darabonba::Model {
public:
  shared_ptr<vector<DataIngestionActions>> actions{};
  shared_ptr<string> createTime{};
  shared_ptr<string> error{};
  shared_ptr<string> id{};
  shared_ptr<Input> input{};
  shared_ptr<string> marker{};
  shared_ptr<DataIngestionNotification> notification{};
  shared_ptr<string> phase{};
  shared_ptr<string> serviceRole{};
  shared_ptr<string> state{};
  shared_ptr<DataIngestionStatistic> statistic{};
  shared_ptr<map<string, boost::any>> tags{};
  shared_ptr<string> updateTime{};

  DataIngestion() {}

  explicit DataIngestion(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actions) {
      vector<boost::any> temp1;
      for(auto item1:*actions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Actions"] = boost::any(temp1);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (error) {
      res["Error"] = boost::any(*error);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (marker) {
      res["Marker"] = boost::any(*marker);
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (phase) {
      res["Phase"] = boost::any(*phase);
    }
    if (serviceRole) {
      res["ServiceRole"] = boost::any(*serviceRole);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (statistic) {
      res["Statistic"] = statistic ? boost::any(statistic->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Actions") != m.end() && !m["Actions"].empty()) {
      if (typeid(vector<boost::any>) == m["Actions"].type()) {
        vector<DataIngestionActions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Actions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataIngestionActions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        actions = make_shared<vector<DataIngestionActions>>(expect1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Error") != m.end() && !m["Error"].empty()) {
      error = make_shared<string>(boost::any_cast<string>(m["Error"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        Input model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<Input>(model1);
      }
    }
    if (m.find("Marker") != m.end() && !m["Marker"].empty()) {
      marker = make_shared<string>(boost::any_cast<string>(m["Marker"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        DataIngestionNotification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<DataIngestionNotification>(model1);
      }
    }
    if (m.find("Phase") != m.end() && !m["Phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["Phase"]));
    }
    if (m.find("ServiceRole") != m.end() && !m["ServiceRole"].empty()) {
      serviceRole = make_shared<string>(boost::any_cast<string>(m["ServiceRole"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("Statistic") != m.end() && !m["Statistic"].empty()) {
      if (typeid(map<string, boost::any>) == m["Statistic"].type()) {
        DataIngestionStatistic model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Statistic"]));
        statistic = make_shared<DataIngestionStatistic>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Tags"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~DataIngestion() = default;
};
class Dataset : public Darabonba::Model {
public:
  shared_ptr<long> bindCount{};
  shared_ptr<string> createTime{};
  shared_ptr<long> datasetMaxBindCount{};
  shared_ptr<long> datasetMaxEntityCount{};
  shared_ptr<long> datasetMaxFileCount{};
  shared_ptr<long> datasetMaxRelationCount{};
  shared_ptr<long> datasetMaxTotalFileSize{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> description{};
  shared_ptr<long> fileCount{};
  shared_ptr<string> projectName{};
  shared_ptr<string> templateId{};
  shared_ptr<long> totalFileSize{};
  shared_ptr<string> updateTime{};

  Dataset() {}

  explicit Dataset(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindCount) {
      res["BindCount"] = boost::any(*bindCount);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (datasetMaxBindCount) {
      res["DatasetMaxBindCount"] = boost::any(*datasetMaxBindCount);
    }
    if (datasetMaxEntityCount) {
      res["DatasetMaxEntityCount"] = boost::any(*datasetMaxEntityCount);
    }
    if (datasetMaxFileCount) {
      res["DatasetMaxFileCount"] = boost::any(*datasetMaxFileCount);
    }
    if (datasetMaxRelationCount) {
      res["DatasetMaxRelationCount"] = boost::any(*datasetMaxRelationCount);
    }
    if (datasetMaxTotalFileSize) {
      res["DatasetMaxTotalFileSize"] = boost::any(*datasetMaxTotalFileSize);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (fileCount) {
      res["FileCount"] = boost::any(*fileCount);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (totalFileSize) {
      res["TotalFileSize"] = boost::any(*totalFileSize);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BindCount") != m.end() && !m["BindCount"].empty()) {
      bindCount = make_shared<long>(boost::any_cast<long>(m["BindCount"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DatasetMaxBindCount") != m.end() && !m["DatasetMaxBindCount"].empty()) {
      datasetMaxBindCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxBindCount"]));
    }
    if (m.find("DatasetMaxEntityCount") != m.end() && !m["DatasetMaxEntityCount"].empty()) {
      datasetMaxEntityCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxEntityCount"]));
    }
    if (m.find("DatasetMaxFileCount") != m.end() && !m["DatasetMaxFileCount"].empty()) {
      datasetMaxFileCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxFileCount"]));
    }
    if (m.find("DatasetMaxRelationCount") != m.end() && !m["DatasetMaxRelationCount"].empty()) {
      datasetMaxRelationCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxRelationCount"]));
    }
    if (m.find("DatasetMaxTotalFileSize") != m.end() && !m["DatasetMaxTotalFileSize"].empty()) {
      datasetMaxTotalFileSize = make_shared<long>(boost::any_cast<long>(m["DatasetMaxTotalFileSize"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("FileCount") != m.end() && !m["FileCount"].empty()) {
      fileCount = make_shared<long>(boost::any_cast<long>(m["FileCount"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TotalFileSize") != m.end() && !m["TotalFileSize"].empty()) {
      totalFileSize = make_shared<long>(boost::any_cast<long>(m["TotalFileSize"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~Dataset() = default;
};
class DatasetTaskStatus : public Darabonba::Model {
public:
  shared_ptr<string> lastSucceededTime{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};

  DatasetTaskStatus() {}

  explicit DatasetTaskStatus(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lastSucceededTime) {
      res["LastSucceededTime"] = boost::any(*lastSucceededTime);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LastSucceededTime") != m.end() && !m["LastSucceededTime"].empty()) {
      lastSucceededTime = make_shared<string>(boost::any_cast<string>(m["LastSucceededTime"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
  }


  virtual ~DatasetTaskStatus() = default;
};
class HeadPose : public Darabonba::Model {
public:
  shared_ptr<double> pitch{};
  shared_ptr<double> roll{};
  shared_ptr<double> yaw{};

  HeadPose() {}

  explicit HeadPose(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pitch) {
      res["Pitch"] = boost::any(*pitch);
    }
    if (roll) {
      res["Roll"] = boost::any(*roll);
    }
    if (yaw) {
      res["Yaw"] = boost::any(*yaw);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Pitch") != m.end() && !m["Pitch"].empty()) {
      pitch = make_shared<double>(boost::any_cast<double>(m["Pitch"]));
    }
    if (m.find("Roll") != m.end() && !m["Roll"].empty()) {
      roll = make_shared<double>(boost::any_cast<double>(m["Roll"]));
    }
    if (m.find("Yaw") != m.end() && !m["Yaw"].empty()) {
      yaw = make_shared<double>(boost::any_cast<double>(m["Yaw"]));
    }
  }


  virtual ~HeadPose() = default;
};
class Figure : public Darabonba::Model {
public:
  shared_ptr<long> age{};
  shared_ptr<double> ageSD{};
  shared_ptr<double> attractive{};
  shared_ptr<string> beard{};
  shared_ptr<double> beardConfidence{};
  shared_ptr<Boundary> boundary{};
  shared_ptr<string> emotion{};
  shared_ptr<double> emotionConfidence{};
  shared_ptr<double> faceQuality{};
  shared_ptr<double> figureClusterConfidence{};
  shared_ptr<string> figureClusterId{};
  shared_ptr<double> figureConfidence{};
  shared_ptr<string> figureId{};
  shared_ptr<string> figureType{};
  shared_ptr<string> gender{};
  shared_ptr<double> genderConfidence{};
  shared_ptr<string> glasses{};
  shared_ptr<double> glassesConfidence{};
  shared_ptr<string> hat{};
  shared_ptr<double> hatConfidence{};
  shared_ptr<HeadPose> headPose{};
  shared_ptr<string> mask{};
  shared_ptr<double> maskConfidence{};
  shared_ptr<string> mouth{};
  shared_ptr<double> mouthConfidence{};
  shared_ptr<double> sharpness{};

  Figure() {}

  explicit Figure(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (age) {
      res["Age"] = boost::any(*age);
    }
    if (ageSD) {
      res["AgeSD"] = boost::any(*ageSD);
    }
    if (attractive) {
      res["Attractive"] = boost::any(*attractive);
    }
    if (beard) {
      res["Beard"] = boost::any(*beard);
    }
    if (beardConfidence) {
      res["BeardConfidence"] = boost::any(*beardConfidence);
    }
    if (boundary) {
      res["Boundary"] = boundary ? boost::any(boundary->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (emotion) {
      res["Emotion"] = boost::any(*emotion);
    }
    if (emotionConfidence) {
      res["EmotionConfidence"] = boost::any(*emotionConfidence);
    }
    if (faceQuality) {
      res["FaceQuality"] = boost::any(*faceQuality);
    }
    if (figureClusterConfidence) {
      res["FigureClusterConfidence"] = boost::any(*figureClusterConfidence);
    }
    if (figureClusterId) {
      res["FigureClusterId"] = boost::any(*figureClusterId);
    }
    if (figureConfidence) {
      res["FigureConfidence"] = boost::any(*figureConfidence);
    }
    if (figureId) {
      res["FigureId"] = boost::any(*figureId);
    }
    if (figureType) {
      res["FigureType"] = boost::any(*figureType);
    }
    if (gender) {
      res["Gender"] = boost::any(*gender);
    }
    if (genderConfidence) {
      res["GenderConfidence"] = boost::any(*genderConfidence);
    }
    if (glasses) {
      res["Glasses"] = boost::any(*glasses);
    }
    if (glassesConfidence) {
      res["GlassesConfidence"] = boost::any(*glassesConfidence);
    }
    if (hat) {
      res["Hat"] = boost::any(*hat);
    }
    if (hatConfidence) {
      res["HatConfidence"] = boost::any(*hatConfidence);
    }
    if (headPose) {
      res["HeadPose"] = headPose ? boost::any(headPose->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (mask) {
      res["Mask"] = boost::any(*mask);
    }
    if (maskConfidence) {
      res["MaskConfidence"] = boost::any(*maskConfidence);
    }
    if (mouth) {
      res["Mouth"] = boost::any(*mouth);
    }
    if (mouthConfidence) {
      res["MouthConfidence"] = boost::any(*mouthConfidence);
    }
    if (sharpness) {
      res["Sharpness"] = boost::any(*sharpness);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Age") != m.end() && !m["Age"].empty()) {
      age = make_shared<long>(boost::any_cast<long>(m["Age"]));
    }
    if (m.find("AgeSD") != m.end() && !m["AgeSD"].empty()) {
      ageSD = make_shared<double>(boost::any_cast<double>(m["AgeSD"]));
    }
    if (m.find("Attractive") != m.end() && !m["Attractive"].empty()) {
      attractive = make_shared<double>(boost::any_cast<double>(m["Attractive"]));
    }
    if (m.find("Beard") != m.end() && !m["Beard"].empty()) {
      beard = make_shared<string>(boost::any_cast<string>(m["Beard"]));
    }
    if (m.find("BeardConfidence") != m.end() && !m["BeardConfidence"].empty()) {
      beardConfidence = make_shared<double>(boost::any_cast<double>(m["BeardConfidence"]));
    }
    if (m.find("Boundary") != m.end() && !m["Boundary"].empty()) {
      if (typeid(map<string, boost::any>) == m["Boundary"].type()) {
        Boundary model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Boundary"]));
        boundary = make_shared<Boundary>(model1);
      }
    }
    if (m.find("Emotion") != m.end() && !m["Emotion"].empty()) {
      emotion = make_shared<string>(boost::any_cast<string>(m["Emotion"]));
    }
    if (m.find("EmotionConfidence") != m.end() && !m["EmotionConfidence"].empty()) {
      emotionConfidence = make_shared<double>(boost::any_cast<double>(m["EmotionConfidence"]));
    }
    if (m.find("FaceQuality") != m.end() && !m["FaceQuality"].empty()) {
      faceQuality = make_shared<double>(boost::any_cast<double>(m["FaceQuality"]));
    }
    if (m.find("FigureClusterConfidence") != m.end() && !m["FigureClusterConfidence"].empty()) {
      figureClusterConfidence = make_shared<double>(boost::any_cast<double>(m["FigureClusterConfidence"]));
    }
    if (m.find("FigureClusterId") != m.end() && !m["FigureClusterId"].empty()) {
      figureClusterId = make_shared<string>(boost::any_cast<string>(m["FigureClusterId"]));
    }
    if (m.find("FigureConfidence") != m.end() && !m["FigureConfidence"].empty()) {
      figureConfidence = make_shared<double>(boost::any_cast<double>(m["FigureConfidence"]));
    }
    if (m.find("FigureId") != m.end() && !m["FigureId"].empty()) {
      figureId = make_shared<string>(boost::any_cast<string>(m["FigureId"]));
    }
    if (m.find("FigureType") != m.end() && !m["FigureType"].empty()) {
      figureType = make_shared<string>(boost::any_cast<string>(m["FigureType"]));
    }
    if (m.find("Gender") != m.end() && !m["Gender"].empty()) {
      gender = make_shared<string>(boost::any_cast<string>(m["Gender"]));
    }
    if (m.find("GenderConfidence") != m.end() && !m["GenderConfidence"].empty()) {
      genderConfidence = make_shared<double>(boost::any_cast<double>(m["GenderConfidence"]));
    }
    if (m.find("Glasses") != m.end() && !m["Glasses"].empty()) {
      glasses = make_shared<string>(boost::any_cast<string>(m["Glasses"]));
    }
    if (m.find("GlassesConfidence") != m.end() && !m["GlassesConfidence"].empty()) {
      glassesConfidence = make_shared<double>(boost::any_cast<double>(m["GlassesConfidence"]));
    }
    if (m.find("Hat") != m.end() && !m["Hat"].empty()) {
      hat = make_shared<string>(boost::any_cast<string>(m["Hat"]));
    }
    if (m.find("HatConfidence") != m.end() && !m["HatConfidence"].empty()) {
      hatConfidence = make_shared<double>(boost::any_cast<double>(m["HatConfidence"]));
    }
    if (m.find("HeadPose") != m.end() && !m["HeadPose"].empty()) {
      if (typeid(map<string, boost::any>) == m["HeadPose"].type()) {
        HeadPose model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["HeadPose"]));
        headPose = make_shared<HeadPose>(model1);
      }
    }
    if (m.find("Mask") != m.end() && !m["Mask"].empty()) {
      mask = make_shared<string>(boost::any_cast<string>(m["Mask"]));
    }
    if (m.find("MaskConfidence") != m.end() && !m["MaskConfidence"].empty()) {
      maskConfidence = make_shared<double>(boost::any_cast<double>(m["MaskConfidence"]));
    }
    if (m.find("Mouth") != m.end() && !m["Mouth"].empty()) {
      mouth = make_shared<string>(boost::any_cast<string>(m["Mouth"]));
    }
    if (m.find("MouthConfidence") != m.end() && !m["MouthConfidence"].empty()) {
      mouthConfidence = make_shared<double>(boost::any_cast<double>(m["MouthConfidence"]));
    }
    if (m.find("Sharpness") != m.end() && !m["Sharpness"].empty()) {
      sharpness = make_shared<double>(boost::any_cast<double>(m["Sharpness"]));
    }
  }


  virtual ~Figure() = default;
};
class ImageScore : public Darabonba::Model {
public:
  shared_ptr<double> overallQualityScore{};

  ImageScore() {}

  explicit ImageScore(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overallQualityScore) {
      res["OverallQualityScore"] = boost::any(*overallQualityScore);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverallQualityScore") != m.end() && !m["OverallQualityScore"].empty()) {
      overallQualityScore = make_shared<double>(boost::any_cast<double>(m["OverallQualityScore"]));
    }
  }


  virtual ~ImageScore() = default;
};
class OCRContents : public Darabonba::Model {
public:
  shared_ptr<Boundary> boundary{};
  shared_ptr<double> confidence{};
  shared_ptr<string> contents{};
  shared_ptr<string> language{};

  OCRContents() {}

  explicit OCRContents(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (boundary) {
      res["Boundary"] = boundary ? boost::any(boundary->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (confidence) {
      res["Confidence"] = boost::any(*confidence);
    }
    if (contents) {
      res["Contents"] = boost::any(*contents);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Boundary") != m.end() && !m["Boundary"].empty()) {
      if (typeid(map<string, boost::any>) == m["Boundary"].type()) {
        Boundary model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Boundary"]));
        boundary = make_shared<Boundary>(model1);
      }
    }
    if (m.find("Confidence") != m.end() && !m["Confidence"].empty()) {
      confidence = make_shared<double>(boost::any_cast<double>(m["Confidence"]));
    }
    if (m.find("Contents") != m.end() && !m["Contents"].empty()) {
      contents = make_shared<string>(boost::any_cast<string>(m["Contents"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
  }


  virtual ~OCRContents() = default;
};
class Image : public Darabonba::Model {
public:
  shared_ptr<vector<CroppingSuggestion>> croppingSuggestions{};
  shared_ptr<string> EXIF{};
  shared_ptr<long> imageHeight{};
  shared_ptr<ImageScore> imageScore{};
  shared_ptr<long> imageWidth{};
  shared_ptr<vector<OCRContents>> OCRContents{};

  Image() {}

  explicit Image(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (croppingSuggestions) {
      vector<boost::any> temp1;
      for(auto item1:*croppingSuggestions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CroppingSuggestions"] = boost::any(temp1);
    }
    if (EXIF) {
      res["EXIF"] = boost::any(*EXIF);
    }
    if (imageHeight) {
      res["ImageHeight"] = boost::any(*imageHeight);
    }
    if (imageScore) {
      res["ImageScore"] = imageScore ? boost::any(imageScore->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageWidth) {
      res["ImageWidth"] = boost::any(*imageWidth);
    }
    if (OCRContents) {
      vector<boost::any> temp1;
      for(auto item1:*OCRContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OCRContents"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CroppingSuggestions") != m.end() && !m["CroppingSuggestions"].empty()) {
      if (typeid(vector<boost::any>) == m["CroppingSuggestions"].type()) {
        vector<CroppingSuggestion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CroppingSuggestions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CroppingSuggestion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        croppingSuggestions = make_shared<vector<CroppingSuggestion>>(expect1);
      }
    }
    if (m.find("EXIF") != m.end() && !m["EXIF"].empty()) {
      EXIF = make_shared<string>(boost::any_cast<string>(m["EXIF"]));
    }
    if (m.find("ImageHeight") != m.end() && !m["ImageHeight"].empty()) {
      imageHeight = make_shared<long>(boost::any_cast<long>(m["ImageHeight"]));
    }
    if (m.find("ImageScore") != m.end() && !m["ImageScore"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageScore"].type()) {
        ImageScore model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageScore"]));
        imageScore = make_shared<ImageScore>(model1);
      }
    }
    if (m.find("ImageWidth") != m.end() && !m["ImageWidth"].empty()) {
      imageWidth = make_shared<long>(boost::any_cast<long>(m["ImageWidth"]));
    }
    if (m.find("OCRContents") != m.end() && !m["OCRContents"].empty()) {
      if (typeid(vector<boost::any>) == m["OCRContents"].type()) {
        vector<OCRContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OCRContents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            OCRContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        OCRContents = make_shared<vector<OCRContents>>(expect1);
      }
    }
  }


  virtual ~Image() = default;
};
class Label : public Darabonba::Model {
public:
  shared_ptr<double> centricScore{};
  shared_ptr<double> labelConfidence{};
  shared_ptr<long> labelLevel{};
  shared_ptr<string> labelName{};
  shared_ptr<string> language{};
  shared_ptr<string> parentLabelName{};

  Label() {}

  explicit Label(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (centricScore) {
      res["CentricScore"] = boost::any(*centricScore);
    }
    if (labelConfidence) {
      res["LabelConfidence"] = boost::any(*labelConfidence);
    }
    if (labelLevel) {
      res["LabelLevel"] = boost::any(*labelLevel);
    }
    if (labelName) {
      res["LabelName"] = boost::any(*labelName);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (parentLabelName) {
      res["ParentLabelName"] = boost::any(*parentLabelName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CentricScore") != m.end() && !m["CentricScore"].empty()) {
      centricScore = make_shared<double>(boost::any_cast<double>(m["CentricScore"]));
    }
    if (m.find("LabelConfidence") != m.end() && !m["LabelConfidence"].empty()) {
      labelConfidence = make_shared<double>(boost::any_cast<double>(m["LabelConfidence"]));
    }
    if (m.find("LabelLevel") != m.end() && !m["LabelLevel"].empty()) {
      labelLevel = make_shared<long>(boost::any_cast<long>(m["LabelLevel"]));
    }
    if (m.find("LabelName") != m.end() && !m["LabelName"].empty()) {
      labelName = make_shared<string>(boost::any_cast<string>(m["LabelName"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("ParentLabelName") != m.end() && !m["ParentLabelName"].empty()) {
      parentLabelName = make_shared<string>(boost::any_cast<string>(m["ParentLabelName"]));
    }
  }


  virtual ~Label() = default;
};
class SceneElement : public Darabonba::Model {
public:
  shared_ptr<vector<long>> frameTimes{};
  shared_ptr<vector<long>> timeRange{};

  SceneElement() {}

  explicit SceneElement(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (frameTimes) {
      res["FrameTimes"] = boost::any(*frameTimes);
    }
    if (timeRange) {
      res["TimeRange"] = boost::any(*timeRange);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FrameTimes") != m.end() && !m["FrameTimes"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["FrameTimes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FrameTimes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      frameTimes = make_shared<vector<long>>(toVec1);
    }
    if (m.find("TimeRange") != m.end() && !m["TimeRange"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["TimeRange"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TimeRange"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      timeRange = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~SceneElement() = default;
};
class SubtitleStream : public Darabonba::Model {
public:
  shared_ptr<long> bitrate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> content{};
  shared_ptr<double> duration{};
  shared_ptr<long> height{};
  shared_ptr<long> index{};
  shared_ptr<string> language{};
  shared_ptr<double> startTime{};
  shared_ptr<long> width{};

  SubtitleStream() {}

  explicit SubtitleStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<long>(boost::any_cast<long>(m["Bitrate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<double>(boost::any_cast<double>(m["StartTime"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~SubtitleStream() = default;
};
class VideoStream : public Darabonba::Model {
public:
  shared_ptr<string> averageFrameRate{};
  shared_ptr<long> bitDepth{};
  shared_ptr<long> bitrate{};
  shared_ptr<string> codecLongName{};
  shared_ptr<string> codecName{};
  shared_ptr<string> codecTag{};
  shared_ptr<string> codecTagString{};
  shared_ptr<string> codecTimeBase{};
  shared_ptr<string> colorPrimaries{};
  shared_ptr<string> colorRange{};
  shared_ptr<string> colorSpace{};
  shared_ptr<string> colorTransfer{};
  shared_ptr<string> displayAspectRatio{};
  shared_ptr<double> duration{};
  shared_ptr<long> frameCount{};
  shared_ptr<string> frameRate{};
  shared_ptr<long> hasBFrames{};
  shared_ptr<long> height{};
  shared_ptr<long> index{};
  shared_ptr<string> language{};
  shared_ptr<long> level{};
  shared_ptr<string> pixelFormat{};
  shared_ptr<string> profile{};
  shared_ptr<string> rotate{};
  shared_ptr<string> sampleAspectRatio{};
  shared_ptr<double> startTime{};
  shared_ptr<string> timeBase{};
  shared_ptr<long> width{};

  VideoStream() {}

  explicit VideoStream(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageFrameRate) {
      res["AverageFrameRate"] = boost::any(*averageFrameRate);
    }
    if (bitDepth) {
      res["BitDepth"] = boost::any(*bitDepth);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (codecLongName) {
      res["CodecLongName"] = boost::any(*codecLongName);
    }
    if (codecName) {
      res["CodecName"] = boost::any(*codecName);
    }
    if (codecTag) {
      res["CodecTag"] = boost::any(*codecTag);
    }
    if (codecTagString) {
      res["CodecTagString"] = boost::any(*codecTagString);
    }
    if (codecTimeBase) {
      res["CodecTimeBase"] = boost::any(*codecTimeBase);
    }
    if (colorPrimaries) {
      res["ColorPrimaries"] = boost::any(*colorPrimaries);
    }
    if (colorRange) {
      res["ColorRange"] = boost::any(*colorRange);
    }
    if (colorSpace) {
      res["ColorSpace"] = boost::any(*colorSpace);
    }
    if (colorTransfer) {
      res["ColorTransfer"] = boost::any(*colorTransfer);
    }
    if (displayAspectRatio) {
      res["DisplayAspectRatio"] = boost::any(*displayAspectRatio);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (frameCount) {
      res["FrameCount"] = boost::any(*frameCount);
    }
    if (frameRate) {
      res["FrameRate"] = boost::any(*frameRate);
    }
    if (hasBFrames) {
      res["HasBFrames"] = boost::any(*hasBFrames);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (level) {
      res["Level"] = boost::any(*level);
    }
    if (pixelFormat) {
      res["PixelFormat"] = boost::any(*pixelFormat);
    }
    if (profile) {
      res["Profile"] = boost::any(*profile);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (sampleAspectRatio) {
      res["SampleAspectRatio"] = boost::any(*sampleAspectRatio);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (timeBase) {
      res["TimeBase"] = boost::any(*timeBase);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageFrameRate") != m.end() && !m["AverageFrameRate"].empty()) {
      averageFrameRate = make_shared<string>(boost::any_cast<string>(m["AverageFrameRate"]));
    }
    if (m.find("BitDepth") != m.end() && !m["BitDepth"].empty()) {
      bitDepth = make_shared<long>(boost::any_cast<long>(m["BitDepth"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<long>(boost::any_cast<long>(m["Bitrate"]));
    }
    if (m.find("CodecLongName") != m.end() && !m["CodecLongName"].empty()) {
      codecLongName = make_shared<string>(boost::any_cast<string>(m["CodecLongName"]));
    }
    if (m.find("CodecName") != m.end() && !m["CodecName"].empty()) {
      codecName = make_shared<string>(boost::any_cast<string>(m["CodecName"]));
    }
    if (m.find("CodecTag") != m.end() && !m["CodecTag"].empty()) {
      codecTag = make_shared<string>(boost::any_cast<string>(m["CodecTag"]));
    }
    if (m.find("CodecTagString") != m.end() && !m["CodecTagString"].empty()) {
      codecTagString = make_shared<string>(boost::any_cast<string>(m["CodecTagString"]));
    }
    if (m.find("CodecTimeBase") != m.end() && !m["CodecTimeBase"].empty()) {
      codecTimeBase = make_shared<string>(boost::any_cast<string>(m["CodecTimeBase"]));
    }
    if (m.find("ColorPrimaries") != m.end() && !m["ColorPrimaries"].empty()) {
      colorPrimaries = make_shared<string>(boost::any_cast<string>(m["ColorPrimaries"]));
    }
    if (m.find("ColorRange") != m.end() && !m["ColorRange"].empty()) {
      colorRange = make_shared<string>(boost::any_cast<string>(m["ColorRange"]));
    }
    if (m.find("ColorSpace") != m.end() && !m["ColorSpace"].empty()) {
      colorSpace = make_shared<string>(boost::any_cast<string>(m["ColorSpace"]));
    }
    if (m.find("ColorTransfer") != m.end() && !m["ColorTransfer"].empty()) {
      colorTransfer = make_shared<string>(boost::any_cast<string>(m["ColorTransfer"]));
    }
    if (m.find("DisplayAspectRatio") != m.end() && !m["DisplayAspectRatio"].empty()) {
      displayAspectRatio = make_shared<string>(boost::any_cast<string>(m["DisplayAspectRatio"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("FrameCount") != m.end() && !m["FrameCount"].empty()) {
      frameCount = make_shared<long>(boost::any_cast<long>(m["FrameCount"]));
    }
    if (m.find("FrameRate") != m.end() && !m["FrameRate"].empty()) {
      frameRate = make_shared<string>(boost::any_cast<string>(m["FrameRate"]));
    }
    if (m.find("HasBFrames") != m.end() && !m["HasBFrames"].empty()) {
      hasBFrames = make_shared<long>(boost::any_cast<long>(m["HasBFrames"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<long>(boost::any_cast<long>(m["Height"]));
    }
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Level") != m.end() && !m["Level"].empty()) {
      level = make_shared<long>(boost::any_cast<long>(m["Level"]));
    }
    if (m.find("PixelFormat") != m.end() && !m["PixelFormat"].empty()) {
      pixelFormat = make_shared<string>(boost::any_cast<string>(m["PixelFormat"]));
    }
    if (m.find("Profile") != m.end() && !m["Profile"].empty()) {
      profile = make_shared<string>(boost::any_cast<string>(m["Profile"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<string>(boost::any_cast<string>(m["Rotate"]));
    }
    if (m.find("SampleAspectRatio") != m.end() && !m["SampleAspectRatio"].empty()) {
      sampleAspectRatio = make_shared<string>(boost::any_cast<string>(m["SampleAspectRatio"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<double>(boost::any_cast<double>(m["StartTime"]));
    }
    if (m.find("TimeBase") != m.end() && !m["TimeBase"].empty()) {
      timeBase = make_shared<string>(boost::any_cast<string>(m["TimeBase"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<long>(boost::any_cast<long>(m["Width"]));
    }
  }


  virtual ~VideoStream() = default;
};
class File : public Darabonba::Model {
public:
  shared_ptr<string> accessControlAllowOrigin{};
  shared_ptr<string> accessControlRequestMethod{};
  shared_ptr<vector<Address>> addresses{};
  shared_ptr<string> album{};
  shared_ptr<string> albumArtist{};
  shared_ptr<string> artist{};
  shared_ptr<vector<Image>> audioCovers{};
  shared_ptr<vector<AudioStream>> audioStreams{};
  shared_ptr<long> bitrate{};
  shared_ptr<string> cacheControl{};
  shared_ptr<string> composer{};
  shared_ptr<string> contentDisposition{};
  shared_ptr<string> contentEncoding{};
  shared_ptr<string> contentLanguage{};
  shared_ptr<string> contentMd5{};
  shared_ptr<string> contentType{};
  shared_ptr<string> createTime{};
  shared_ptr<vector<CroppingSuggestion>> croppingSuggestions{};
  shared_ptr<string> customId{};
  shared_ptr<map<string, boost::any>> customLabels{};
  shared_ptr<string> datasetName{};
  shared_ptr<double> duration{};
  shared_ptr<string> ETag{};
  shared_ptr<string> EXIF{};
  shared_ptr<vector<Element>> elements{};
  shared_ptr<long> figureCount{};
  shared_ptr<vector<Figure>> figures{};
  shared_ptr<string> fileAccessTime{};
  shared_ptr<string> fileCreateTime{};
  shared_ptr<string> fileHash{};
  shared_ptr<string> fileModifiedTime{};
  shared_ptr<string> filename{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> formatName{};
  shared_ptr<long> imageHeight{};
  shared_ptr<ImageScore> imageScore{};
  shared_ptr<long> imageWidth{};
  shared_ptr<vector<Label>> labels{};
  shared_ptr<string> language{};
  shared_ptr<string> latLong{};
  shared_ptr<string> mediaType{};
  shared_ptr<vector<OCRContents>> OCRContents{};
  shared_ptr<string> OCRTexts{};
  shared_ptr<string> OSSCRC64{};
  shared_ptr<string> OSSDeleteMarker{};
  shared_ptr<string> OSSExpiration{};
  shared_ptr<string> OSSObjectType{};
  shared_ptr<string> OSSStorageClass{};
  shared_ptr<map<string, boost::any>> OSSTagging{};
  shared_ptr<long> OSSTaggingCount{};
  shared_ptr<string> OSSURI{};
  shared_ptr<map<string, boost::any>> OSSUserMeta{};
  shared_ptr<string> OSSVersionId{};
  shared_ptr<string> objectACL{};
  shared_ptr<string> objectId{};
  shared_ptr<string> objectStatus{};
  shared_ptr<string> objectType{};
  shared_ptr<long> orientation{};
  shared_ptr<string> ownerId{};
  shared_ptr<long> pageCount{};
  shared_ptr<string> performer{};
  shared_ptr<string> produceTime{};
  shared_ptr<long> programCount{};
  shared_ptr<string> projectName{};
  shared_ptr<string> reason{};
  shared_ptr<vector<SceneElement>> sceneElements{};
  shared_ptr<vector<string>> semanticTypes{};
  shared_ptr<string> serverSideDataEncryption{};
  shared_ptr<string> serverSideEncryption{};
  shared_ptr<string> serverSideEncryptionCustomerAlgorithm{};
  shared_ptr<string> serverSideEncryptionKeyId{};
  shared_ptr<long> size{};
  shared_ptr<double> startTime{};
  shared_ptr<long> streamCount{};
  shared_ptr<vector<SubtitleStream>> subtitles{};
  shared_ptr<string> timezone{};
  shared_ptr<string> title{};
  shared_ptr<string> travelClusterId{};
  shared_ptr<string> URI{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> videoHeight{};
  shared_ptr<vector<VideoStream>> videoStreams{};
  shared_ptr<long> videoWidth{};

  File() {}

  explicit File(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessControlAllowOrigin) {
      res["AccessControlAllowOrigin"] = boost::any(*accessControlAllowOrigin);
    }
    if (accessControlRequestMethod) {
      res["AccessControlRequestMethod"] = boost::any(*accessControlRequestMethod);
    }
    if (addresses) {
      vector<boost::any> temp1;
      for(auto item1:*addresses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Addresses"] = boost::any(temp1);
    }
    if (album) {
      res["Album"] = boost::any(*album);
    }
    if (albumArtist) {
      res["AlbumArtist"] = boost::any(*albumArtist);
    }
    if (artist) {
      res["Artist"] = boost::any(*artist);
    }
    if (audioCovers) {
      vector<boost::any> temp1;
      for(auto item1:*audioCovers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioCovers"] = boost::any(temp1);
    }
    if (audioStreams) {
      vector<boost::any> temp1;
      for(auto item1:*audioStreams){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStreams"] = boost::any(temp1);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (cacheControl) {
      res["CacheControl"] = boost::any(*cacheControl);
    }
    if (composer) {
      res["Composer"] = boost::any(*composer);
    }
    if (contentDisposition) {
      res["ContentDisposition"] = boost::any(*contentDisposition);
    }
    if (contentEncoding) {
      res["ContentEncoding"] = boost::any(*contentEncoding);
    }
    if (contentLanguage) {
      res["ContentLanguage"] = boost::any(*contentLanguage);
    }
    if (contentMd5) {
      res["ContentMd5"] = boost::any(*contentMd5);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (croppingSuggestions) {
      vector<boost::any> temp1;
      for(auto item1:*croppingSuggestions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CroppingSuggestions"] = boost::any(temp1);
    }
    if (customId) {
      res["CustomId"] = boost::any(*customId);
    }
    if (customLabels) {
      res["CustomLabels"] = boost::any(*customLabels);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (ETag) {
      res["ETag"] = boost::any(*ETag);
    }
    if (EXIF) {
      res["EXIF"] = boost::any(*EXIF);
    }
    if (elements) {
      vector<boost::any> temp1;
      for(auto item1:*elements){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Elements"] = boost::any(temp1);
    }
    if (figureCount) {
      res["FigureCount"] = boost::any(*figureCount);
    }
    if (figures) {
      vector<boost::any> temp1;
      for(auto item1:*figures){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Figures"] = boost::any(temp1);
    }
    if (fileAccessTime) {
      res["FileAccessTime"] = boost::any(*fileAccessTime);
    }
    if (fileCreateTime) {
      res["FileCreateTime"] = boost::any(*fileCreateTime);
    }
    if (fileHash) {
      res["FileHash"] = boost::any(*fileHash);
    }
    if (fileModifiedTime) {
      res["FileModifiedTime"] = boost::any(*fileModifiedTime);
    }
    if (filename) {
      res["Filename"] = boost::any(*filename);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (imageHeight) {
      res["ImageHeight"] = boost::any(*imageHeight);
    }
    if (imageScore) {
      res["ImageScore"] = imageScore ? boost::any(imageScore->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageWidth) {
      res["ImageWidth"] = boost::any(*imageWidth);
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (latLong) {
      res["LatLong"] = boost::any(*latLong);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (OCRContents) {
      vector<boost::any> temp1;
      for(auto item1:*OCRContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OCRContents"] = boost::any(temp1);
    }
    if (OCRTexts) {
      res["OCRTexts"] = boost::any(*OCRTexts);
    }
    if (OSSCRC64) {
      res["OSSCRC64"] = boost::any(*OSSCRC64);
    }
    if (OSSDeleteMarker) {
      res["OSSDeleteMarker"] = boost::any(*OSSDeleteMarker);
    }
    if (OSSExpiration) {
      res["OSSExpiration"] = boost::any(*OSSExpiration);
    }
    if (OSSObjectType) {
      res["OSSObjectType"] = boost::any(*OSSObjectType);
    }
    if (OSSStorageClass) {
      res["OSSStorageClass"] = boost::any(*OSSStorageClass);
    }
    if (OSSTagging) {
      res["OSSTagging"] = boost::any(*OSSTagging);
    }
    if (OSSTaggingCount) {
      res["OSSTaggingCount"] = boost::any(*OSSTaggingCount);
    }
    if (OSSURI) {
      res["OSSURI"] = boost::any(*OSSURI);
    }
    if (OSSUserMeta) {
      res["OSSUserMeta"] = boost::any(*OSSUserMeta);
    }
    if (OSSVersionId) {
      res["OSSVersionId"] = boost::any(*OSSVersionId);
    }
    if (objectACL) {
      res["ObjectACL"] = boost::any(*objectACL);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (objectStatus) {
      res["ObjectStatus"] = boost::any(*objectStatus);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (orientation) {
      res["Orientation"] = boost::any(*orientation);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (pageCount) {
      res["PageCount"] = boost::any(*pageCount);
    }
    if (performer) {
      res["Performer"] = boost::any(*performer);
    }
    if (produceTime) {
      res["ProduceTime"] = boost::any(*produceTime);
    }
    if (programCount) {
      res["ProgramCount"] = boost::any(*programCount);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (reason) {
      res["Reason"] = boost::any(*reason);
    }
    if (sceneElements) {
      vector<boost::any> temp1;
      for(auto item1:*sceneElements){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SceneElements"] = boost::any(temp1);
    }
    if (semanticTypes) {
      res["SemanticTypes"] = boost::any(*semanticTypes);
    }
    if (serverSideDataEncryption) {
      res["ServerSideDataEncryption"] = boost::any(*serverSideDataEncryption);
    }
    if (serverSideEncryption) {
      res["ServerSideEncryption"] = boost::any(*serverSideEncryption);
    }
    if (serverSideEncryptionCustomerAlgorithm) {
      res["ServerSideEncryptionCustomerAlgorithm"] = boost::any(*serverSideEncryptionCustomerAlgorithm);
    }
    if (serverSideEncryptionKeyId) {
      res["ServerSideEncryptionKeyId"] = boost::any(*serverSideEncryptionKeyId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamCount) {
      res["StreamCount"] = boost::any(*streamCount);
    }
    if (subtitles) {
      vector<boost::any> temp1;
      for(auto item1:*subtitles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitles"] = boost::any(temp1);
    }
    if (timezone) {
      res["Timezone"] = boost::any(*timezone);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (travelClusterId) {
      res["TravelClusterId"] = boost::any(*travelClusterId);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (videoHeight) {
      res["VideoHeight"] = boost::any(*videoHeight);
    }
    if (videoStreams) {
      vector<boost::any> temp1;
      for(auto item1:*videoStreams){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStreams"] = boost::any(temp1);
    }
    if (videoWidth) {
      res["VideoWidth"] = boost::any(*videoWidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessControlAllowOrigin") != m.end() && !m["AccessControlAllowOrigin"].empty()) {
      accessControlAllowOrigin = make_shared<string>(boost::any_cast<string>(m["AccessControlAllowOrigin"]));
    }
    if (m.find("AccessControlRequestMethod") != m.end() && !m["AccessControlRequestMethod"].empty()) {
      accessControlRequestMethod = make_shared<string>(boost::any_cast<string>(m["AccessControlRequestMethod"]));
    }
    if (m.find("Addresses") != m.end() && !m["Addresses"].empty()) {
      if (typeid(vector<boost::any>) == m["Addresses"].type()) {
        vector<Address> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Addresses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Address model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addresses = make_shared<vector<Address>>(expect1);
      }
    }
    if (m.find("Album") != m.end() && !m["Album"].empty()) {
      album = make_shared<string>(boost::any_cast<string>(m["Album"]));
    }
    if (m.find("AlbumArtist") != m.end() && !m["AlbumArtist"].empty()) {
      albumArtist = make_shared<string>(boost::any_cast<string>(m["AlbumArtist"]));
    }
    if (m.find("Artist") != m.end() && !m["Artist"].empty()) {
      artist = make_shared<string>(boost::any_cast<string>(m["Artist"]));
    }
    if (m.find("AudioCovers") != m.end() && !m["AudioCovers"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioCovers"].type()) {
        vector<Image> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioCovers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Image model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioCovers = make_shared<vector<Image>>(expect1);
      }
    }
    if (m.find("AudioStreams") != m.end() && !m["AudioStreams"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStreams"].type()) {
        vector<AudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStreams"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStreams = make_shared<vector<AudioStream>>(expect1);
      }
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<long>(boost::any_cast<long>(m["Bitrate"]));
    }
    if (m.find("CacheControl") != m.end() && !m["CacheControl"].empty()) {
      cacheControl = make_shared<string>(boost::any_cast<string>(m["CacheControl"]));
    }
    if (m.find("Composer") != m.end() && !m["Composer"].empty()) {
      composer = make_shared<string>(boost::any_cast<string>(m["Composer"]));
    }
    if (m.find("ContentDisposition") != m.end() && !m["ContentDisposition"].empty()) {
      contentDisposition = make_shared<string>(boost::any_cast<string>(m["ContentDisposition"]));
    }
    if (m.find("ContentEncoding") != m.end() && !m["ContentEncoding"].empty()) {
      contentEncoding = make_shared<string>(boost::any_cast<string>(m["ContentEncoding"]));
    }
    if (m.find("ContentLanguage") != m.end() && !m["ContentLanguage"].empty()) {
      contentLanguage = make_shared<string>(boost::any_cast<string>(m["ContentLanguage"]));
    }
    if (m.find("ContentMd5") != m.end() && !m["ContentMd5"].empty()) {
      contentMd5 = make_shared<string>(boost::any_cast<string>(m["ContentMd5"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CroppingSuggestions") != m.end() && !m["CroppingSuggestions"].empty()) {
      if (typeid(vector<boost::any>) == m["CroppingSuggestions"].type()) {
        vector<CroppingSuggestion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CroppingSuggestions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CroppingSuggestion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        croppingSuggestions = make_shared<vector<CroppingSuggestion>>(expect1);
      }
    }
    if (m.find("CustomId") != m.end() && !m["CustomId"].empty()) {
      customId = make_shared<string>(boost::any_cast<string>(m["CustomId"]));
    }
    if (m.find("CustomLabels") != m.end() && !m["CustomLabels"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["CustomLabels"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customLabels = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("ETag") != m.end() && !m["ETag"].empty()) {
      ETag = make_shared<string>(boost::any_cast<string>(m["ETag"]));
    }
    if (m.find("EXIF") != m.end() && !m["EXIF"].empty()) {
      EXIF = make_shared<string>(boost::any_cast<string>(m["EXIF"]));
    }
    if (m.find("Elements") != m.end() && !m["Elements"].empty()) {
      if (typeid(vector<boost::any>) == m["Elements"].type()) {
        vector<Element> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Elements"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Element model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        elements = make_shared<vector<Element>>(expect1);
      }
    }
    if (m.find("FigureCount") != m.end() && !m["FigureCount"].empty()) {
      figureCount = make_shared<long>(boost::any_cast<long>(m["FigureCount"]));
    }
    if (m.find("Figures") != m.end() && !m["Figures"].empty()) {
      if (typeid(vector<boost::any>) == m["Figures"].type()) {
        vector<Figure> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Figures"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Figure model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        figures = make_shared<vector<Figure>>(expect1);
      }
    }
    if (m.find("FileAccessTime") != m.end() && !m["FileAccessTime"].empty()) {
      fileAccessTime = make_shared<string>(boost::any_cast<string>(m["FileAccessTime"]));
    }
    if (m.find("FileCreateTime") != m.end() && !m["FileCreateTime"].empty()) {
      fileCreateTime = make_shared<string>(boost::any_cast<string>(m["FileCreateTime"]));
    }
    if (m.find("FileHash") != m.end() && !m["FileHash"].empty()) {
      fileHash = make_shared<string>(boost::any_cast<string>(m["FileHash"]));
    }
    if (m.find("FileModifiedTime") != m.end() && !m["FileModifiedTime"].empty()) {
      fileModifiedTime = make_shared<string>(boost::any_cast<string>(m["FileModifiedTime"]));
    }
    if (m.find("Filename") != m.end() && !m["Filename"].empty()) {
      filename = make_shared<string>(boost::any_cast<string>(m["Filename"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("ImageHeight") != m.end() && !m["ImageHeight"].empty()) {
      imageHeight = make_shared<long>(boost::any_cast<long>(m["ImageHeight"]));
    }
    if (m.find("ImageScore") != m.end() && !m["ImageScore"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageScore"].type()) {
        ImageScore model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageScore"]));
        imageScore = make_shared<ImageScore>(model1);
      }
    }
    if (m.find("ImageWidth") != m.end() && !m["ImageWidth"].empty()) {
      imageWidth = make_shared<long>(boost::any_cast<long>(m["ImageWidth"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<Label> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Label model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<Label>>(expect1);
      }
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("LatLong") != m.end() && !m["LatLong"].empty()) {
      latLong = make_shared<string>(boost::any_cast<string>(m["LatLong"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("OCRContents") != m.end() && !m["OCRContents"].empty()) {
      if (typeid(vector<boost::any>) == m["OCRContents"].type()) {
        vector<OCRContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OCRContents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            OCRContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        OCRContents = make_shared<vector<OCRContents>>(expect1);
      }
    }
    if (m.find("OCRTexts") != m.end() && !m["OCRTexts"].empty()) {
      OCRTexts = make_shared<string>(boost::any_cast<string>(m["OCRTexts"]));
    }
    if (m.find("OSSCRC64") != m.end() && !m["OSSCRC64"].empty()) {
      OSSCRC64 = make_shared<string>(boost::any_cast<string>(m["OSSCRC64"]));
    }
    if (m.find("OSSDeleteMarker") != m.end() && !m["OSSDeleteMarker"].empty()) {
      OSSDeleteMarker = make_shared<string>(boost::any_cast<string>(m["OSSDeleteMarker"]));
    }
    if (m.find("OSSExpiration") != m.end() && !m["OSSExpiration"].empty()) {
      OSSExpiration = make_shared<string>(boost::any_cast<string>(m["OSSExpiration"]));
    }
    if (m.find("OSSObjectType") != m.end() && !m["OSSObjectType"].empty()) {
      OSSObjectType = make_shared<string>(boost::any_cast<string>(m["OSSObjectType"]));
    }
    if (m.find("OSSStorageClass") != m.end() && !m["OSSStorageClass"].empty()) {
      OSSStorageClass = make_shared<string>(boost::any_cast<string>(m["OSSStorageClass"]));
    }
    if (m.find("OSSTagging") != m.end() && !m["OSSTagging"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["OSSTagging"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      OSSTagging = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("OSSTaggingCount") != m.end() && !m["OSSTaggingCount"].empty()) {
      OSSTaggingCount = make_shared<long>(boost::any_cast<long>(m["OSSTaggingCount"]));
    }
    if (m.find("OSSURI") != m.end() && !m["OSSURI"].empty()) {
      OSSURI = make_shared<string>(boost::any_cast<string>(m["OSSURI"]));
    }
    if (m.find("OSSUserMeta") != m.end() && !m["OSSUserMeta"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["OSSUserMeta"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      OSSUserMeta = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("OSSVersionId") != m.end() && !m["OSSVersionId"].empty()) {
      OSSVersionId = make_shared<string>(boost::any_cast<string>(m["OSSVersionId"]));
    }
    if (m.find("ObjectACL") != m.end() && !m["ObjectACL"].empty()) {
      objectACL = make_shared<string>(boost::any_cast<string>(m["ObjectACL"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ObjectStatus") != m.end() && !m["ObjectStatus"].empty()) {
      objectStatus = make_shared<string>(boost::any_cast<string>(m["ObjectStatus"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("Orientation") != m.end() && !m["Orientation"].empty()) {
      orientation = make_shared<long>(boost::any_cast<long>(m["Orientation"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("PageCount") != m.end() && !m["PageCount"].empty()) {
      pageCount = make_shared<long>(boost::any_cast<long>(m["PageCount"]));
    }
    if (m.find("Performer") != m.end() && !m["Performer"].empty()) {
      performer = make_shared<string>(boost::any_cast<string>(m["Performer"]));
    }
    if (m.find("ProduceTime") != m.end() && !m["ProduceTime"].empty()) {
      produceTime = make_shared<string>(boost::any_cast<string>(m["ProduceTime"]));
    }
    if (m.find("ProgramCount") != m.end() && !m["ProgramCount"].empty()) {
      programCount = make_shared<long>(boost::any_cast<long>(m["ProgramCount"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Reason") != m.end() && !m["Reason"].empty()) {
      reason = make_shared<string>(boost::any_cast<string>(m["Reason"]));
    }
    if (m.find("SceneElements") != m.end() && !m["SceneElements"].empty()) {
      if (typeid(vector<boost::any>) == m["SceneElements"].type()) {
        vector<SceneElement> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SceneElements"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SceneElement model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sceneElements = make_shared<vector<SceneElement>>(expect1);
      }
    }
    if (m.find("SemanticTypes") != m.end() && !m["SemanticTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SemanticTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SemanticTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      semanticTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ServerSideDataEncryption") != m.end() && !m["ServerSideDataEncryption"].empty()) {
      serverSideDataEncryption = make_shared<string>(boost::any_cast<string>(m["ServerSideDataEncryption"]));
    }
    if (m.find("ServerSideEncryption") != m.end() && !m["ServerSideEncryption"].empty()) {
      serverSideEncryption = make_shared<string>(boost::any_cast<string>(m["ServerSideEncryption"]));
    }
    if (m.find("ServerSideEncryptionCustomerAlgorithm") != m.end() && !m["ServerSideEncryptionCustomerAlgorithm"].empty()) {
      serverSideEncryptionCustomerAlgorithm = make_shared<string>(boost::any_cast<string>(m["ServerSideEncryptionCustomerAlgorithm"]));
    }
    if (m.find("ServerSideEncryptionKeyId") != m.end() && !m["ServerSideEncryptionKeyId"].empty()) {
      serverSideEncryptionKeyId = make_shared<string>(boost::any_cast<string>(m["ServerSideEncryptionKeyId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<double>(boost::any_cast<double>(m["StartTime"]));
    }
    if (m.find("StreamCount") != m.end() && !m["StreamCount"].empty()) {
      streamCount = make_shared<long>(boost::any_cast<long>(m["StreamCount"]));
    }
    if (m.find("Subtitles") != m.end() && !m["Subtitles"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitles"].type()) {
        vector<SubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitles = make_shared<vector<SubtitleStream>>(expect1);
      }
    }
    if (m.find("Timezone") != m.end() && !m["Timezone"].empty()) {
      timezone = make_shared<string>(boost::any_cast<string>(m["Timezone"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("TravelClusterId") != m.end() && !m["TravelClusterId"].empty()) {
      travelClusterId = make_shared<string>(boost::any_cast<string>(m["TravelClusterId"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("VideoHeight") != m.end() && !m["VideoHeight"].empty()) {
      videoHeight = make_shared<long>(boost::any_cast<long>(m["VideoHeight"]));
    }
    if (m.find("VideoStreams") != m.end() && !m["VideoStreams"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStreams"].type()) {
        vector<VideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStreams"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            VideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStreams = make_shared<vector<VideoStream>>(expect1);
      }
    }
    if (m.find("VideoWidth") != m.end() && !m["VideoWidth"].empty()) {
      videoWidth = make_shared<long>(boost::any_cast<long>(m["VideoWidth"]));
    }
  }


  virtual ~File() = default;
};
class FigureCluster : public Darabonba::Model {
public:
  shared_ptr<double> averageAge{};
  shared_ptr<File> cover{};
  shared_ptr<string> createTime{};
  shared_ptr<string> customId{};
  shared_ptr<map<string, boost::any>> customLabels{};
  shared_ptr<string> datasetName{};
  shared_ptr<long> faceCount{};
  shared_ptr<string> gender{};
  shared_ptr<long> imageCount{};
  shared_ptr<double> maxAge{};
  shared_ptr<long> metaLockVersion{};
  shared_ptr<double> minAge{};
  shared_ptr<string> name{};
  shared_ptr<string> objectId{};
  shared_ptr<string> objectType{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> updateTime{};
  shared_ptr<long> videoCount{};

  FigureCluster() {}

  explicit FigureCluster(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageAge) {
      res["AverageAge"] = boost::any(*averageAge);
    }
    if (cover) {
      res["Cover"] = cover ? boost::any(cover->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (customId) {
      res["CustomId"] = boost::any(*customId);
    }
    if (customLabels) {
      res["CustomLabels"] = boost::any(*customLabels);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (faceCount) {
      res["FaceCount"] = boost::any(*faceCount);
    }
    if (gender) {
      res["Gender"] = boost::any(*gender);
    }
    if (imageCount) {
      res["ImageCount"] = boost::any(*imageCount);
    }
    if (maxAge) {
      res["MaxAge"] = boost::any(*maxAge);
    }
    if (metaLockVersion) {
      res["MetaLockVersion"] = boost::any(*metaLockVersion);
    }
    if (minAge) {
      res["MinAge"] = boost::any(*minAge);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    if (videoCount) {
      res["VideoCount"] = boost::any(*videoCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AverageAge") != m.end() && !m["AverageAge"].empty()) {
      averageAge = make_shared<double>(boost::any_cast<double>(m["AverageAge"]));
    }
    if (m.find("Cover") != m.end() && !m["Cover"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cover"].type()) {
        File model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cover"]));
        cover = make_shared<File>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CustomId") != m.end() && !m["CustomId"].empty()) {
      customId = make_shared<string>(boost::any_cast<string>(m["CustomId"]));
    }
    if (m.find("CustomLabels") != m.end() && !m["CustomLabels"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["CustomLabels"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customLabels = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("FaceCount") != m.end() && !m["FaceCount"].empty()) {
      faceCount = make_shared<long>(boost::any_cast<long>(m["FaceCount"]));
    }
    if (m.find("Gender") != m.end() && !m["Gender"].empty()) {
      gender = make_shared<string>(boost::any_cast<string>(m["Gender"]));
    }
    if (m.find("ImageCount") != m.end() && !m["ImageCount"].empty()) {
      imageCount = make_shared<long>(boost::any_cast<long>(m["ImageCount"]));
    }
    if (m.find("MaxAge") != m.end() && !m["MaxAge"].empty()) {
      maxAge = make_shared<double>(boost::any_cast<double>(m["MaxAge"]));
    }
    if (m.find("MetaLockVersion") != m.end() && !m["MetaLockVersion"].empty()) {
      metaLockVersion = make_shared<long>(boost::any_cast<long>(m["MetaLockVersion"]));
    }
    if (m.find("MinAge") != m.end() && !m["MinAge"].empty()) {
      minAge = make_shared<double>(boost::any_cast<double>(m["MinAge"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
    if (m.find("VideoCount") != m.end() && !m["VideoCount"].empty()) {
      videoCount = make_shared<long>(boost::any_cast<long>(m["VideoCount"]));
    }
  }


  virtual ~FigureCluster() = default;
};
class FigureClusterForReqCoverFigures : public Darabonba::Model {
public:
  shared_ptr<string> figureId{};

  FigureClusterForReqCoverFigures() {}

  explicit FigureClusterForReqCoverFigures(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (figureId) {
      res["FigureId"] = boost::any(*figureId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FigureId") != m.end() && !m["FigureId"].empty()) {
      figureId = make_shared<string>(boost::any_cast<string>(m["FigureId"]));
    }
  }


  virtual ~FigureClusterForReqCoverFigures() = default;
};
class FigureClusterForReqCover : public Darabonba::Model {
public:
  shared_ptr<vector<FigureClusterForReqCoverFigures>> figures{};

  FigureClusterForReqCover() {}

  explicit FigureClusterForReqCover(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (figures) {
      vector<boost::any> temp1;
      for(auto item1:*figures){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Figures"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Figures") != m.end() && !m["Figures"].empty()) {
      if (typeid(vector<boost::any>) == m["Figures"].type()) {
        vector<FigureClusterForReqCoverFigures> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Figures"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FigureClusterForReqCoverFigures model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        figures = make_shared<vector<FigureClusterForReqCoverFigures>>(expect1);
      }
    }
  }


  virtual ~FigureClusterForReqCover() = default;
};
class FigureClusterForReq : public Darabonba::Model {
public:
  shared_ptr<FigureClusterForReqCover> cover{};
  shared_ptr<string> customId{};
  shared_ptr<map<string, boost::any>> customLabels{};
  shared_ptr<long> metaLockVersion{};
  shared_ptr<string> name{};
  shared_ptr<string> objectId{};

  FigureClusterForReq() {}

  explicit FigureClusterForReq(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cover) {
      res["Cover"] = cover ? boost::any(cover->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customId) {
      res["CustomId"] = boost::any(*customId);
    }
    if (customLabels) {
      res["CustomLabels"] = boost::any(*customLabels);
    }
    if (metaLockVersion) {
      res["MetaLockVersion"] = boost::any(*metaLockVersion);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cover") != m.end() && !m["Cover"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cover"].type()) {
        FigureClusterForReqCover model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cover"]));
        cover = make_shared<FigureClusterForReqCover>(model1);
      }
    }
    if (m.find("CustomId") != m.end() && !m["CustomId"].empty()) {
      customId = make_shared<string>(boost::any_cast<string>(m["CustomId"]));
    }
    if (m.find("CustomLabels") != m.end() && !m["CustomLabels"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["CustomLabels"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customLabels = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("MetaLockVersion") != m.end() && !m["MetaLockVersion"].empty()) {
      metaLockVersion = make_shared<long>(boost::any_cast<long>(m["MetaLockVersion"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
  }


  virtual ~FigureClusterForReq() = default;
};
class FileSmartCluster : public Darabonba::Model {
public:
  shared_ptr<double> similarity{};
  shared_ptr<string> smartClusterId{};

  FileSmartCluster() {}

  explicit FileSmartCluster(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (similarity) {
      res["Similarity"] = boost::any(*similarity);
    }
    if (smartClusterId) {
      res["SmartClusterId"] = boost::any(*smartClusterId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Similarity") != m.end() && !m["Similarity"].empty()) {
      similarity = make_shared<double>(boost::any_cast<double>(m["Similarity"]));
    }
    if (m.find("SmartClusterId") != m.end() && !m["SmartClusterId"].empty()) {
      smartClusterId = make_shared<string>(boost::any_cast<string>(m["SmartClusterId"]));
    }
  }


  virtual ~FileSmartCluster() = default;
};
class FunctionCall : public Darabonba::Model {
public:
  shared_ptr<string> arguments{};
  shared_ptr<string> name{};

  FunctionCall() {}

  explicit FunctionCall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (arguments) {
      res["Arguments"] = boost::any(*arguments);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Arguments") != m.end() && !m["Arguments"].empty()) {
      arguments = make_shared<string>(boost::any_cast<string>(m["Arguments"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~FunctionCall() = default;
};
class InputFileFigures : public Darabonba::Model {
public:
  shared_ptr<string> figureClusterId{};
  shared_ptr<string> figureId{};
  shared_ptr<string> figureType{};

  InputFileFigures() {}

  explicit InputFileFigures(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (figureClusterId) {
      res["FigureClusterId"] = boost::any(*figureClusterId);
    }
    if (figureId) {
      res["FigureId"] = boost::any(*figureId);
    }
    if (figureType) {
      res["FigureType"] = boost::any(*figureType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FigureClusterId") != m.end() && !m["FigureClusterId"].empty()) {
      figureClusterId = make_shared<string>(boost::any_cast<string>(m["FigureClusterId"]));
    }
    if (m.find("FigureId") != m.end() && !m["FigureId"].empty()) {
      figureId = make_shared<string>(boost::any_cast<string>(m["FigureId"]));
    }
    if (m.find("FigureType") != m.end() && !m["FigureType"].empty()) {
      figureType = make_shared<string>(boost::any_cast<string>(m["FigureType"]));
    }
  }


  virtual ~InputFileFigures() = default;
};
class InputFile : public Darabonba::Model {
public:
  shared_ptr<vector<Address>> addresses{};
  shared_ptr<string> album{};
  shared_ptr<string> albumArtist{};
  shared_ptr<string> artist{};
  shared_ptr<string> composer{};
  shared_ptr<string> contentType{};
  shared_ptr<string> customId{};
  shared_ptr<map<string, boost::any>> customLabels{};
  shared_ptr<vector<InputFileFigures>> figures{};
  shared_ptr<string> fileHash{};
  shared_ptr<vector<Label>> labels{};
  shared_ptr<string> latLong{};
  shared_ptr<string> mediaType{};
  shared_ptr<string> OSSURI{};
  shared_ptr<string> performer{};
  shared_ptr<string> produceTime{};
  shared_ptr<string> title{};
  shared_ptr<string> URI{};

  InputFile() {}

  explicit InputFile(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addresses) {
      vector<boost::any> temp1;
      for(auto item1:*addresses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Addresses"] = boost::any(temp1);
    }
    if (album) {
      res["Album"] = boost::any(*album);
    }
    if (albumArtist) {
      res["AlbumArtist"] = boost::any(*albumArtist);
    }
    if (artist) {
      res["Artist"] = boost::any(*artist);
    }
    if (composer) {
      res["Composer"] = boost::any(*composer);
    }
    if (contentType) {
      res["ContentType"] = boost::any(*contentType);
    }
    if (customId) {
      res["CustomId"] = boost::any(*customId);
    }
    if (customLabels) {
      res["CustomLabels"] = boost::any(*customLabels);
    }
    if (figures) {
      vector<boost::any> temp1;
      for(auto item1:*figures){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Figures"] = boost::any(temp1);
    }
    if (fileHash) {
      res["FileHash"] = boost::any(*fileHash);
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (latLong) {
      res["LatLong"] = boost::any(*latLong);
    }
    if (mediaType) {
      res["MediaType"] = boost::any(*mediaType);
    }
    if (OSSURI) {
      res["OSSURI"] = boost::any(*OSSURI);
    }
    if (performer) {
      res["Performer"] = boost::any(*performer);
    }
    if (produceTime) {
      res["ProduceTime"] = boost::any(*produceTime);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Addresses") != m.end() && !m["Addresses"].empty()) {
      if (typeid(vector<boost::any>) == m["Addresses"].type()) {
        vector<Address> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Addresses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Address model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addresses = make_shared<vector<Address>>(expect1);
      }
    }
    if (m.find("Album") != m.end() && !m["Album"].empty()) {
      album = make_shared<string>(boost::any_cast<string>(m["Album"]));
    }
    if (m.find("AlbumArtist") != m.end() && !m["AlbumArtist"].empty()) {
      albumArtist = make_shared<string>(boost::any_cast<string>(m["AlbumArtist"]));
    }
    if (m.find("Artist") != m.end() && !m["Artist"].empty()) {
      artist = make_shared<string>(boost::any_cast<string>(m["Artist"]));
    }
    if (m.find("Composer") != m.end() && !m["Composer"].empty()) {
      composer = make_shared<string>(boost::any_cast<string>(m["Composer"]));
    }
    if (m.find("ContentType") != m.end() && !m["ContentType"].empty()) {
      contentType = make_shared<string>(boost::any_cast<string>(m["ContentType"]));
    }
    if (m.find("CustomId") != m.end() && !m["CustomId"].empty()) {
      customId = make_shared<string>(boost::any_cast<string>(m["CustomId"]));
    }
    if (m.find("CustomLabels") != m.end() && !m["CustomLabels"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["CustomLabels"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customLabels = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Figures") != m.end() && !m["Figures"].empty()) {
      if (typeid(vector<boost::any>) == m["Figures"].type()) {
        vector<InputFileFigures> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Figures"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InputFileFigures model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        figures = make_shared<vector<InputFileFigures>>(expect1);
      }
    }
    if (m.find("FileHash") != m.end() && !m["FileHash"].empty()) {
      fileHash = make_shared<string>(boost::any_cast<string>(m["FileHash"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<Label> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Label model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<Label>>(expect1);
      }
    }
    if (m.find("LatLong") != m.end() && !m["LatLong"].empty()) {
      latLong = make_shared<string>(boost::any_cast<string>(m["LatLong"]));
    }
    if (m.find("MediaType") != m.end() && !m["MediaType"].empty()) {
      mediaType = make_shared<string>(boost::any_cast<string>(m["MediaType"]));
    }
    if (m.find("OSSURI") != m.end() && !m["OSSURI"].empty()) {
      OSSURI = make_shared<string>(boost::any_cast<string>(m["OSSURI"]));
    }
    if (m.find("Performer") != m.end() && !m["Performer"].empty()) {
      performer = make_shared<string>(boost::any_cast<string>(m["Performer"]));
    }
    if (m.find("ProduceTime") != m.end() && !m["ProduceTime"].empty()) {
      produceTime = make_shared<string>(boost::any_cast<string>(m["ProduceTime"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~InputFile() = default;
};
class KdtreeOption : public Darabonba::Model {
public:
  shared_ptr<long> compressionLevel{};
  shared_ptr<string> libraryName{};
  shared_ptr<long> quantizationBits{};

  KdtreeOption() {}

  explicit KdtreeOption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compressionLevel) {
      res["CompressionLevel"] = boost::any(*compressionLevel);
    }
    if (libraryName) {
      res["LibraryName"] = boost::any(*libraryName);
    }
    if (quantizationBits) {
      res["QuantizationBits"] = boost::any(*quantizationBits);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompressionLevel") != m.end() && !m["CompressionLevel"].empty()) {
      compressionLevel = make_shared<long>(boost::any_cast<long>(m["CompressionLevel"]));
    }
    if (m.find("LibraryName") != m.end() && !m["LibraryName"].empty()) {
      libraryName = make_shared<string>(boost::any_cast<string>(m["LibraryName"]));
    }
    if (m.find("QuantizationBits") != m.end() && !m["QuantizationBits"].empty()) {
      quantizationBits = make_shared<long>(boost::any_cast<long>(m["QuantizationBits"]));
    }
  }


  virtual ~KdtreeOption() = default;
};
class KeyValuePair : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  KeyValuePair() {}

  explicit KeyValuePair(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~KeyValuePair() = default;
};
class LocationDateCluster : public Darabonba::Model {
public:
  shared_ptr<vector<Address>> addresses{};
  shared_ptr<string> createTime{};
  shared_ptr<string> customId{};
  shared_ptr<map<string, boost::any>> customLabels{};
  shared_ptr<string> locationDateClusterEndTime{};
  shared_ptr<string> locationDateClusterLevel{};
  shared_ptr<string> locationDateClusterStartTime{};
  shared_ptr<string> objectId{};
  shared_ptr<string> title{};
  shared_ptr<string> updateTime{};

  LocationDateCluster() {}

  explicit LocationDateCluster(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addresses) {
      vector<boost::any> temp1;
      for(auto item1:*addresses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Addresses"] = boost::any(temp1);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (customId) {
      res["CustomId"] = boost::any(*customId);
    }
    if (customLabels) {
      res["CustomLabels"] = boost::any(*customLabels);
    }
    if (locationDateClusterEndTime) {
      res["LocationDateClusterEndTime"] = boost::any(*locationDateClusterEndTime);
    }
    if (locationDateClusterLevel) {
      res["LocationDateClusterLevel"] = boost::any(*locationDateClusterLevel);
    }
    if (locationDateClusterStartTime) {
      res["LocationDateClusterStartTime"] = boost::any(*locationDateClusterStartTime);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Addresses") != m.end() && !m["Addresses"].empty()) {
      if (typeid(vector<boost::any>) == m["Addresses"].type()) {
        vector<Address> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Addresses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Address model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addresses = make_shared<vector<Address>>(expect1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CustomId") != m.end() && !m["CustomId"].empty()) {
      customId = make_shared<string>(boost::any_cast<string>(m["CustomId"]));
    }
    if (m.find("CustomLabels") != m.end() && !m["CustomLabels"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["CustomLabels"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customLabels = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("LocationDateClusterEndTime") != m.end() && !m["LocationDateClusterEndTime"].empty()) {
      locationDateClusterEndTime = make_shared<string>(boost::any_cast<string>(m["LocationDateClusterEndTime"]));
    }
    if (m.find("LocationDateClusterLevel") != m.end() && !m["LocationDateClusterLevel"].empty()) {
      locationDateClusterLevel = make_shared<string>(boost::any_cast<string>(m["LocationDateClusterLevel"]));
    }
    if (m.find("LocationDateClusterStartTime") != m.end() && !m["LocationDateClusterStartTime"].empty()) {
      locationDateClusterStartTime = make_shared<string>(boost::any_cast<string>(m["LocationDateClusterStartTime"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~LocationDateCluster() = default;
};
class Message : public Darabonba::Model {
public:
  shared_ptr<string> assistantType{};
  shared_ptr<string> content{};
  shared_ptr<string> createTime{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> language{};
  shared_ptr<bool> regenerate{};
  shared_ptr<string> reply{};
  shared_ptr<double> score{};
  shared_ptr<string> sourceURI{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> tone{};
  shared_ptr<string> topic{};

  Message() {}

  explicit Message(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (assistantType) {
      res["AssistantType"] = boost::any(*assistantType);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (regenerate) {
      res["Regenerate"] = boost::any(*regenerate);
    }
    if (reply) {
      res["Reply"] = boost::any(*reply);
    }
    if (score) {
      res["Score"] = boost::any(*score);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (tone) {
      res["Tone"] = boost::any(*tone);
    }
    if (topic) {
      res["Topic"] = boost::any(*topic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AssistantType") != m.end() && !m["AssistantType"].empty()) {
      assistantType = make_shared<string>(boost::any_cast<string>(m["AssistantType"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Regenerate") != m.end() && !m["Regenerate"].empty()) {
      regenerate = make_shared<bool>(boost::any_cast<bool>(m["Regenerate"]));
    }
    if (m.find("Reply") != m.end() && !m["Reply"].empty()) {
      reply = make_shared<string>(boost::any_cast<string>(m["Reply"]));
    }
    if (m.find("Score") != m.end() && !m["Score"].empty()) {
      score = make_shared<double>(boost::any_cast<double>(m["Score"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("Tone") != m.end() && !m["Tone"].empty()) {
      tone = make_shared<string>(boost::any_cast<string>(m["Tone"]));
    }
    if (m.find("Topic") != m.end() && !m["Topic"].empty()) {
      topic = make_shared<string>(boost::any_cast<string>(m["Topic"]));
    }
  }


  virtual ~Message() = default;
};
class Notification : public Darabonba::Model {
public:
  shared_ptr<string> extendedMessageURI{};
  shared_ptr<MNS> MNS{};
  shared_ptr<RocketMQ> rocketMQ{};

  Notification() {}

  explicit Notification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extendedMessageURI) {
      res["ExtendedMessageURI"] = boost::any(*extendedMessageURI);
    }
    if (MNS) {
      res["MNS"] = MNS ? boost::any(MNS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (rocketMQ) {
      res["RocketMQ"] = rocketMQ ? boost::any(rocketMQ->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtendedMessageURI") != m.end() && !m["ExtendedMessageURI"].empty()) {
      extendedMessageURI = make_shared<string>(boost::any_cast<string>(m["ExtendedMessageURI"]));
    }
    if (m.find("MNS") != m.end() && !m["MNS"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNS"].type()) {
        MNS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNS"]));
        MNS = make_shared<MNS>(model1);
      }
    }
    if (m.find("RocketMQ") != m.end() && !m["RocketMQ"].empty()) {
      if (typeid(map<string, boost::any>) == m["RocketMQ"].type()) {
        RocketMQ model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["RocketMQ"]));
        rocketMQ = make_shared<RocketMQ>(model1);
      }
    }
  }


  virtual ~Notification() = default;
};
class OctreeOption : public Darabonba::Model {
public:
  shared_ptr<bool> doVoxelGridDownDownSampling{};
  shared_ptr<string> libraryName{};
  shared_ptr<double> octreeResolution{};
  shared_ptr<double> pointResolution{};

  OctreeOption() {}

  explicit OctreeOption(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (doVoxelGridDownDownSampling) {
      res["DoVoxelGridDownDownSampling"] = boost::any(*doVoxelGridDownDownSampling);
    }
    if (libraryName) {
      res["LibraryName"] = boost::any(*libraryName);
    }
    if (octreeResolution) {
      res["OctreeResolution"] = boost::any(*octreeResolution);
    }
    if (pointResolution) {
      res["PointResolution"] = boost::any(*pointResolution);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DoVoxelGridDownDownSampling") != m.end() && !m["DoVoxelGridDownDownSampling"].empty()) {
      doVoxelGridDownDownSampling = make_shared<bool>(boost::any_cast<bool>(m["DoVoxelGridDownDownSampling"]));
    }
    if (m.find("LibraryName") != m.end() && !m["LibraryName"].empty()) {
      libraryName = make_shared<string>(boost::any_cast<string>(m["LibraryName"]));
    }
    if (m.find("OctreeResolution") != m.end() && !m["OctreeResolution"].empty()) {
      octreeResolution = make_shared<double>(boost::any_cast<double>(m["OctreeResolution"]));
    }
    if (m.find("PointResolution") != m.end() && !m["PointResolution"].empty()) {
      pointResolution = make_shared<double>(boost::any_cast<double>(m["PointResolution"]));
    }
  }


  virtual ~OctreeOption() = default;
};
class ProjectTags : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ProjectTags() {}

  explicit ProjectTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ProjectTags() = default;
};
class Project : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<long> datasetCount{};
  shared_ptr<long> datasetMaxBindCount{};
  shared_ptr<long> datasetMaxEntityCount{};
  shared_ptr<long> datasetMaxFileCount{};
  shared_ptr<long> datasetMaxRelationCount{};
  shared_ptr<long> datasetMaxTotalFileSize{};
  shared_ptr<string> description{};
  shared_ptr<long> engineConcurrency{};
  shared_ptr<long> fileCount{};
  shared_ptr<long> projectMaxDatasetCount{};
  shared_ptr<string> projectName{};
  shared_ptr<long> projectQueriesPerSecond{};
  shared_ptr<string> serviceRole{};
  shared_ptr<vector<ProjectTags>> tags{};
  shared_ptr<string> templateId{};
  shared_ptr<long> totalFileSize{};
  shared_ptr<string> updateTime{};

  Project() {}

  explicit Project(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (datasetCount) {
      res["DatasetCount"] = boost::any(*datasetCount);
    }
    if (datasetMaxBindCount) {
      res["DatasetMaxBindCount"] = boost::any(*datasetMaxBindCount);
    }
    if (datasetMaxEntityCount) {
      res["DatasetMaxEntityCount"] = boost::any(*datasetMaxEntityCount);
    }
    if (datasetMaxFileCount) {
      res["DatasetMaxFileCount"] = boost::any(*datasetMaxFileCount);
    }
    if (datasetMaxRelationCount) {
      res["DatasetMaxRelationCount"] = boost::any(*datasetMaxRelationCount);
    }
    if (datasetMaxTotalFileSize) {
      res["DatasetMaxTotalFileSize"] = boost::any(*datasetMaxTotalFileSize);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (engineConcurrency) {
      res["EngineConcurrency"] = boost::any(*engineConcurrency);
    }
    if (fileCount) {
      res["FileCount"] = boost::any(*fileCount);
    }
    if (projectMaxDatasetCount) {
      res["ProjectMaxDatasetCount"] = boost::any(*projectMaxDatasetCount);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (projectQueriesPerSecond) {
      res["ProjectQueriesPerSecond"] = boost::any(*projectQueriesPerSecond);
    }
    if (serviceRole) {
      res["ServiceRole"] = boost::any(*serviceRole);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    if (totalFileSize) {
      res["TotalFileSize"] = boost::any(*totalFileSize);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DatasetCount") != m.end() && !m["DatasetCount"].empty()) {
      datasetCount = make_shared<long>(boost::any_cast<long>(m["DatasetCount"]));
    }
    if (m.find("DatasetMaxBindCount") != m.end() && !m["DatasetMaxBindCount"].empty()) {
      datasetMaxBindCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxBindCount"]));
    }
    if (m.find("DatasetMaxEntityCount") != m.end() && !m["DatasetMaxEntityCount"].empty()) {
      datasetMaxEntityCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxEntityCount"]));
    }
    if (m.find("DatasetMaxFileCount") != m.end() && !m["DatasetMaxFileCount"].empty()) {
      datasetMaxFileCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxFileCount"]));
    }
    if (m.find("DatasetMaxRelationCount") != m.end() && !m["DatasetMaxRelationCount"].empty()) {
      datasetMaxRelationCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxRelationCount"]));
    }
    if (m.find("DatasetMaxTotalFileSize") != m.end() && !m["DatasetMaxTotalFileSize"].empty()) {
      datasetMaxTotalFileSize = make_shared<long>(boost::any_cast<long>(m["DatasetMaxTotalFileSize"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("EngineConcurrency") != m.end() && !m["EngineConcurrency"].empty()) {
      engineConcurrency = make_shared<long>(boost::any_cast<long>(m["EngineConcurrency"]));
    }
    if (m.find("FileCount") != m.end() && !m["FileCount"].empty()) {
      fileCount = make_shared<long>(boost::any_cast<long>(m["FileCount"]));
    }
    if (m.find("ProjectMaxDatasetCount") != m.end() && !m["ProjectMaxDatasetCount"].empty()) {
      projectMaxDatasetCount = make_shared<long>(boost::any_cast<long>(m["ProjectMaxDatasetCount"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProjectQueriesPerSecond") != m.end() && !m["ProjectQueriesPerSecond"].empty()) {
      projectQueriesPerSecond = make_shared<long>(boost::any_cast<long>(m["ProjectQueriesPerSecond"]));
    }
    if (m.find("ServiceRole") != m.end() && !m["ServiceRole"].empty()) {
      serviceRole = make_shared<string>(boost::any_cast<string>(m["ServiceRole"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ProjectTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ProjectTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ProjectTags>>(expect1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
    if (m.find("TotalFileSize") != m.end() && !m["TotalFileSize"].empty()) {
      totalFileSize = make_shared<long>(boost::any_cast<long>(m["TotalFileSize"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~Project() = default;
};
class RegionType : public Darabonba::Model {
public:
  shared_ptr<string> localName{};
  shared_ptr<string> regionId{};

  RegionType() {}

  explicit RegionType(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (localName) {
      res["LocalName"] = boost::any(*localName);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocalName") != m.end() && !m["LocalName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["LocalName"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
  }


  virtual ~RegionType() = default;
};
class Row : public Darabonba::Model {
public:
  shared_ptr<vector<KeyValuePair>> customLabels{};
  shared_ptr<string> URI{};

  Row() {}

  explicit Row(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customLabels) {
      vector<boost::any> temp1;
      for(auto item1:*customLabels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["CustomLabels"] = boost::any(temp1);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomLabels") != m.end() && !m["CustomLabels"].empty()) {
      if (typeid(vector<boost::any>) == m["CustomLabels"].type()) {
        vector<KeyValuePair> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["CustomLabels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            KeyValuePair model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        customLabels = make_shared<vector<KeyValuePair>>(expect1);
      }
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~Row() = default;
};
class SimilarImage : public Darabonba::Model {
public:
  shared_ptr<double> imageScore{};
  shared_ptr<string> URI{};

  SimilarImage() {}

  explicit SimilarImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageScore) {
      res["ImageScore"] = boost::any(*imageScore);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageScore") != m.end() && !m["ImageScore"].empty()) {
      imageScore = make_shared<double>(boost::any_cast<double>(m["ImageScore"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~SimilarImage() = default;
};
class SimilarImageCluster : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<map<string, boost::any>> customLabels{};
  shared_ptr<vector<SimilarImage>> files{};
  shared_ptr<string> objectId{};
  shared_ptr<string> updateTime{};

  SimilarImageCluster() {}

  explicit SimilarImageCluster(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (customLabels) {
      res["CustomLabels"] = boost::any(*customLabels);
    }
    if (files) {
      vector<boost::any> temp1;
      for(auto item1:*files){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Files"] = boost::any(temp1);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CustomLabels") != m.end() && !m["CustomLabels"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["CustomLabels"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customLabels = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      if (typeid(vector<boost::any>) == m["Files"].type()) {
        vector<SimilarImage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Files"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SimilarImage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        files = make_shared<vector<SimilarImage>>(expect1);
      }
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~SimilarImageCluster() = default;
};
class SimpleQuery : public Darabonba::Model {
public:
  shared_ptr<string> field{};
  shared_ptr<string> operation{};
  shared_ptr<vector<SimpleQuery>> subQueries{};
  shared_ptr<string> value{};

  SimpleQuery() {}

  explicit SimpleQuery(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (subQueries) {
      vector<boost::any> temp1;
      for(auto item1:*subQueries){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubQueries"] = boost::any(temp1);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("SubQueries") != m.end() && !m["SubQueries"].empty()) {
      if (typeid(vector<boost::any>) == m["SubQueries"].type()) {
        vector<SimpleQuery> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubQueries"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SimpleQuery model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subQueries = make_shared<vector<SimpleQuery>>(expect1);
      }
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SimpleQuery() = default;
};
class SmartClusterRule : public Darabonba::Model {
public:
  shared_ptr<vector<string>> keywords{};
  shared_ptr<double> sensitivity{};

  SmartClusterRule() {}

  explicit SmartClusterRule(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keywords) {
      res["Keywords"] = boost::any(*keywords);
    }
    if (sensitivity) {
      res["Sensitivity"] = boost::any(*sensitivity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Keywords") != m.end() && !m["Keywords"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Keywords"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Keywords"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      keywords = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Sensitivity") != m.end() && !m["Sensitivity"].empty()) {
      sensitivity = make_shared<double>(boost::any_cast<double>(m["Sensitivity"]));
    }
  }


  virtual ~SmartClusterRule() = default;
};
class SmartCluster : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> objectId{};
  shared_ptr<string> objectStatus{};
  shared_ptr<string> objectType{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> projectName{};
  shared_ptr<SmartClusterRule> rule{};
  shared_ptr<string> updateTime{};

  SmartCluster() {}

  explicit SmartCluster(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (objectStatus) {
      res["ObjectStatus"] = boost::any(*objectStatus);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (rule) {
      res["Rule"] = rule ? boost::any(rule->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ObjectStatus") != m.end() && !m["ObjectStatus"].empty()) {
      objectStatus = make_shared<string>(boost::any_cast<string>(m["ObjectStatus"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Rule") != m.end() && !m["Rule"].empty()) {
      if (typeid(map<string, boost::any>) == m["Rule"].type()) {
        SmartClusterRule model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Rule"]));
        rule = make_shared<SmartClusterRule>(model1);
      }
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~SmartCluster() = default;
};
class Story : public Darabonba::Model {
public:
  shared_ptr<vector<Address>> addresses{};
  shared_ptr<File> cover{};
  shared_ptr<string> createTime{};
  shared_ptr<string> customId{};
  shared_ptr<map<string, boost::any>> customLabels{};
  shared_ptr<string> datasetName{};
  shared_ptr<vector<string>> figureClusterIds{};
  shared_ptr<vector<File>> files{};
  shared_ptr<string> objectId{};
  shared_ptr<string> objectType{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> storyEndTime{};
  shared_ptr<string> storyName{};
  shared_ptr<string> storyStartTime{};
  shared_ptr<string> storySubType{};
  shared_ptr<string> storyType{};
  shared_ptr<string> updateTime{};

  Story() {}

  explicit Story(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addresses) {
      vector<boost::any> temp1;
      for(auto item1:*addresses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Addresses"] = boost::any(temp1);
    }
    if (cover) {
      res["Cover"] = cover ? boost::any(cover->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (customId) {
      res["CustomId"] = boost::any(*customId);
    }
    if (customLabels) {
      res["CustomLabels"] = boost::any(*customLabels);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (figureClusterIds) {
      res["FigureClusterIds"] = boost::any(*figureClusterIds);
    }
    if (files) {
      vector<boost::any> temp1;
      for(auto item1:*files){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Files"] = boost::any(temp1);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (objectType) {
      res["ObjectType"] = boost::any(*objectType);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (storyEndTime) {
      res["StoryEndTime"] = boost::any(*storyEndTime);
    }
    if (storyName) {
      res["StoryName"] = boost::any(*storyName);
    }
    if (storyStartTime) {
      res["StoryStartTime"] = boost::any(*storyStartTime);
    }
    if (storySubType) {
      res["StorySubType"] = boost::any(*storySubType);
    }
    if (storyType) {
      res["StoryType"] = boost::any(*storyType);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Addresses") != m.end() && !m["Addresses"].empty()) {
      if (typeid(vector<boost::any>) == m["Addresses"].type()) {
        vector<Address> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Addresses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Address model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addresses = make_shared<vector<Address>>(expect1);
      }
    }
    if (m.find("Cover") != m.end() && !m["Cover"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cover"].type()) {
        File model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cover"]));
        cover = make_shared<File>(model1);
      }
    }
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("CustomId") != m.end() && !m["CustomId"].empty()) {
      customId = make_shared<string>(boost::any_cast<string>(m["CustomId"]));
    }
    if (m.find("CustomLabels") != m.end() && !m["CustomLabels"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["CustomLabels"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customLabels = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("FigureClusterIds") != m.end() && !m["FigureClusterIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FigureClusterIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FigureClusterIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      figureClusterIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      if (typeid(vector<boost::any>) == m["Files"].type()) {
        vector<File> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Files"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            File model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        files = make_shared<vector<File>>(expect1);
      }
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ObjectType") != m.end() && !m["ObjectType"].empty()) {
      objectType = make_shared<string>(boost::any_cast<string>(m["ObjectType"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("StoryEndTime") != m.end() && !m["StoryEndTime"].empty()) {
      storyEndTime = make_shared<string>(boost::any_cast<string>(m["StoryEndTime"]));
    }
    if (m.find("StoryName") != m.end() && !m["StoryName"].empty()) {
      storyName = make_shared<string>(boost::any_cast<string>(m["StoryName"]));
    }
    if (m.find("StoryStartTime") != m.end() && !m["StoryStartTime"].empty()) {
      storyStartTime = make_shared<string>(boost::any_cast<string>(m["StoryStartTime"]));
    }
    if (m.find("StorySubType") != m.end() && !m["StorySubType"].empty()) {
      storySubType = make_shared<string>(boost::any_cast<string>(m["StorySubType"]));
    }
    if (m.find("StoryType") != m.end() && !m["StoryType"].empty()) {
      storyType = make_shared<string>(boost::any_cast<string>(m["StoryType"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~Story() = default;
};
class StreamOptions : public Darabonba::Model {
public:
  shared_ptr<bool> incrementalOutput{};

  StreamOptions() {}

  explicit StreamOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (incrementalOutput) {
      res["IncrementalOutput"] = boost::any(*incrementalOutput);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("IncrementalOutput") != m.end() && !m["IncrementalOutput"].empty()) {
      incrementalOutput = make_shared<bool>(boost::any_cast<bool>(m["IncrementalOutput"]));
    }
  }


  virtual ~StreamOptions() = default;
};
class TargetAudioFilterAudio : public Darabonba::Model {
public:
  shared_ptr<bool> mixing{};

  TargetAudioFilterAudio() {}

  explicit TargetAudioFilterAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (mixing) {
      res["Mixing"] = boost::any(*mixing);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Mixing") != m.end() && !m["Mixing"].empty()) {
      mixing = make_shared<bool>(boost::any_cast<bool>(m["Mixing"]));
    }
  }


  virtual ~TargetAudioFilterAudio() = default;
};
class TargetAudioTranscodeAudio : public Darabonba::Model {
public:
  shared_ptr<long> bitrate{};
  shared_ptr<string> bitrateOption{};
  shared_ptr<long> bitsPerSample{};
  shared_ptr<long> channel{};
  shared_ptr<string> codec{};
  shared_ptr<long> quality{};
  shared_ptr<long> sampleRate{};
  shared_ptr<string> sampleRateOption{};

  TargetAudioTranscodeAudio() {}

  explicit TargetAudioTranscodeAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bitrateOption) {
      res["BitrateOption"] = boost::any(*bitrateOption);
    }
    if (bitsPerSample) {
      res["BitsPerSample"] = boost::any(*bitsPerSample);
    }
    if (channel) {
      res["Channel"] = boost::any(*channel);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (quality) {
      res["Quality"] = boost::any(*quality);
    }
    if (sampleRate) {
      res["SampleRate"] = boost::any(*sampleRate);
    }
    if (sampleRateOption) {
      res["SampleRateOption"] = boost::any(*sampleRateOption);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<long>(boost::any_cast<long>(m["Bitrate"]));
    }
    if (m.find("BitrateOption") != m.end() && !m["BitrateOption"].empty()) {
      bitrateOption = make_shared<string>(boost::any_cast<string>(m["BitrateOption"]));
    }
    if (m.find("BitsPerSample") != m.end() && !m["BitsPerSample"].empty()) {
      bitsPerSample = make_shared<long>(boost::any_cast<long>(m["BitsPerSample"]));
    }
    if (m.find("Channel") != m.end() && !m["Channel"].empty()) {
      channel = make_shared<long>(boost::any_cast<long>(m["Channel"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("Quality") != m.end() && !m["Quality"].empty()) {
      quality = make_shared<long>(boost::any_cast<long>(m["Quality"]));
    }
    if (m.find("SampleRate") != m.end() && !m["SampleRate"].empty()) {
      sampleRate = make_shared<long>(boost::any_cast<long>(m["SampleRate"]));
    }
    if (m.find("SampleRateOption") != m.end() && !m["SampleRateOption"].empty()) {
      sampleRateOption = make_shared<string>(boost::any_cast<string>(m["SampleRateOption"]));
    }
  }


  virtual ~TargetAudioTranscodeAudio() = default;
};
class TargetAudio : public Darabonba::Model {
public:
  shared_ptr<bool> disableAudio{};
  shared_ptr<TargetAudioFilterAudio> filterAudio{};
  shared_ptr<vector<long>> stream{};
  shared_ptr<TargetAudioTranscodeAudio> transcodeAudio{};

  TargetAudio() {}

  explicit TargetAudio(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disableAudio) {
      res["DisableAudio"] = boost::any(*disableAudio);
    }
    if (filterAudio) {
      res["FilterAudio"] = filterAudio ? boost::any(filterAudio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    if (transcodeAudio) {
      res["TranscodeAudio"] = transcodeAudio ? boost::any(transcodeAudio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisableAudio") != m.end() && !m["DisableAudio"].empty()) {
      disableAudio = make_shared<bool>(boost::any_cast<bool>(m["DisableAudio"]));
    }
    if (m.find("FilterAudio") != m.end() && !m["FilterAudio"].empty()) {
      if (typeid(map<string, boost::any>) == m["FilterAudio"].type()) {
        TargetAudioFilterAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FilterAudio"]));
        filterAudio = make_shared<TargetAudioFilterAudio>(model1);
      }
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Stream"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Stream"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      stream = make_shared<vector<long>>(toVec1);
    }
    if (m.find("TranscodeAudio") != m.end() && !m["TranscodeAudio"].empty()) {
      if (typeid(map<string, boost::any>) == m["TranscodeAudio"].type()) {
        TargetAudioTranscodeAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TranscodeAudio"]));
        transcodeAudio = make_shared<TargetAudioTranscodeAudio>(model1);
      }
    }
  }


  virtual ~TargetAudio() = default;
};
class TargetImageAnimations : public Darabonba::Model {
public:
  shared_ptr<string> format{};
  shared_ptr<double> frameRate{};
  shared_ptr<double> height{};
  shared_ptr<double> interval{};
  shared_ptr<long> number{};
  shared_ptr<string> scaleType{};
  shared_ptr<double> startTime{};
  shared_ptr<string> URI{};
  shared_ptr<double> width{};

  TargetImageAnimations() {}

  explicit TargetImageAnimations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (frameRate) {
      res["FrameRate"] = boost::any(*frameRate);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (scaleType) {
      res["ScaleType"] = boost::any(*scaleType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("FrameRate") != m.end() && !m["FrameRate"].empty()) {
      frameRate = make_shared<double>(boost::any_cast<double>(m["FrameRate"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<double>(boost::any_cast<double>(m["Height"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<double>(boost::any_cast<double>(m["Interval"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<long>(boost::any_cast<long>(m["Number"]));
    }
    if (m.find("ScaleType") != m.end() && !m["ScaleType"].empty()) {
      scaleType = make_shared<string>(boost::any_cast<string>(m["ScaleType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<double>(boost::any_cast<double>(m["StartTime"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<double>(boost::any_cast<double>(m["Width"]));
    }
  }


  virtual ~TargetImageAnimations() = default;
};
class TargetImageSnapshots : public Darabonba::Model {
public:
  shared_ptr<string> format{};
  shared_ptr<double> height{};
  shared_ptr<double> interval{};
  shared_ptr<long> number{};
  shared_ptr<string> scaleType{};
  shared_ptr<double> startTime{};
  shared_ptr<string> URI{};
  shared_ptr<double> width{};

  TargetImageSnapshots() {}

  explicit TargetImageSnapshots(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (scaleType) {
      res["ScaleType"] = boost::any(*scaleType);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<double>(boost::any_cast<double>(m["Height"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<double>(boost::any_cast<double>(m["Interval"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<long>(boost::any_cast<long>(m["Number"]));
    }
    if (m.find("ScaleType") != m.end() && !m["ScaleType"].empty()) {
      scaleType = make_shared<string>(boost::any_cast<string>(m["ScaleType"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<double>(boost::any_cast<double>(m["StartTime"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<double>(boost::any_cast<double>(m["Width"]));
    }
  }


  virtual ~TargetImageSnapshots() = default;
};
class TargetImageSprites : public Darabonba::Model {
public:
  shared_ptr<string> format{};
  shared_ptr<double> interval{};
  shared_ptr<long> margin{};
  shared_ptr<long> number{};
  shared_ptr<long> pad{};
  shared_ptr<double> scaleHeight{};
  shared_ptr<string> scaleType{};
  shared_ptr<double> scaleWidth{};
  shared_ptr<double> startTime{};
  shared_ptr<long> tileHeight{};
  shared_ptr<long> tileWidth{};
  shared_ptr<string> URI{};

  TargetImageSprites() {}

  explicit TargetImageSprites(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (margin) {
      res["Margin"] = boost::any(*margin);
    }
    if (number) {
      res["Number"] = boost::any(*number);
    }
    if (pad) {
      res["Pad"] = boost::any(*pad);
    }
    if (scaleHeight) {
      res["ScaleHeight"] = boost::any(*scaleHeight);
    }
    if (scaleType) {
      res["ScaleType"] = boost::any(*scaleType);
    }
    if (scaleWidth) {
      res["ScaleWidth"] = boost::any(*scaleWidth);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (tileHeight) {
      res["TileHeight"] = boost::any(*tileHeight);
    }
    if (tileWidth) {
      res["TileWidth"] = boost::any(*tileWidth);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<double>(boost::any_cast<double>(m["Interval"]));
    }
    if (m.find("Margin") != m.end() && !m["Margin"].empty()) {
      margin = make_shared<long>(boost::any_cast<long>(m["Margin"]));
    }
    if (m.find("Number") != m.end() && !m["Number"].empty()) {
      number = make_shared<long>(boost::any_cast<long>(m["Number"]));
    }
    if (m.find("Pad") != m.end() && !m["Pad"].empty()) {
      pad = make_shared<long>(boost::any_cast<long>(m["Pad"]));
    }
    if (m.find("ScaleHeight") != m.end() && !m["ScaleHeight"].empty()) {
      scaleHeight = make_shared<double>(boost::any_cast<double>(m["ScaleHeight"]));
    }
    if (m.find("ScaleType") != m.end() && !m["ScaleType"].empty()) {
      scaleType = make_shared<string>(boost::any_cast<string>(m["ScaleType"]));
    }
    if (m.find("ScaleWidth") != m.end() && !m["ScaleWidth"].empty()) {
      scaleWidth = make_shared<double>(boost::any_cast<double>(m["ScaleWidth"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<double>(boost::any_cast<double>(m["StartTime"]));
    }
    if (m.find("TileHeight") != m.end() && !m["TileHeight"].empty()) {
      tileHeight = make_shared<long>(boost::any_cast<long>(m["TileHeight"]));
    }
    if (m.find("TileWidth") != m.end() && !m["TileWidth"].empty()) {
      tileWidth = make_shared<long>(boost::any_cast<long>(m["TileWidth"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~TargetImageSprites() = default;
};
class TargetImage : public Darabonba::Model {
public:
  shared_ptr<vector<TargetImageAnimations>> animations{};
  shared_ptr<vector<TargetImageSnapshots>> snapshots{};
  shared_ptr<vector<TargetImageSprites>> sprites{};

  TargetImage() {}

  explicit TargetImage(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (animations) {
      vector<boost::any> temp1;
      for(auto item1:*animations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Animations"] = boost::any(temp1);
    }
    if (snapshots) {
      vector<boost::any> temp1;
      for(auto item1:*snapshots){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Snapshots"] = boost::any(temp1);
    }
    if (sprites) {
      vector<boost::any> temp1;
      for(auto item1:*sprites){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sprites"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Animations") != m.end() && !m["Animations"].empty()) {
      if (typeid(vector<boost::any>) == m["Animations"].type()) {
        vector<TargetImageAnimations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Animations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TargetImageAnimations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        animations = make_shared<vector<TargetImageAnimations>>(expect1);
      }
    }
    if (m.find("Snapshots") != m.end() && !m["Snapshots"].empty()) {
      if (typeid(vector<boost::any>) == m["Snapshots"].type()) {
        vector<TargetImageSnapshots> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Snapshots"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TargetImageSnapshots model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        snapshots = make_shared<vector<TargetImageSnapshots>>(expect1);
      }
    }
    if (m.find("Sprites") != m.end() && !m["Sprites"].empty()) {
      if (typeid(vector<boost::any>) == m["Sprites"].type()) {
        vector<TargetImageSprites> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sprites"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TargetImageSprites model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sprites = make_shared<vector<TargetImageSprites>>(expect1);
      }
    }
  }


  virtual ~TargetImage() = default;
};
class TargetSubtitleExtractSubtitle : public Darabonba::Model {
public:
  shared_ptr<string> format{};
  shared_ptr<string> URI{};

  TargetSubtitleExtractSubtitle() {}

  explicit TargetSubtitleExtractSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~TargetSubtitleExtractSubtitle() = default;
};
class TargetSubtitle : public Darabonba::Model {
public:
  shared_ptr<bool> disableSubtitle{};
  shared_ptr<TargetSubtitleExtractSubtitle> extractSubtitle{};
  shared_ptr<vector<long>> stream{};

  TargetSubtitle() {}

  explicit TargetSubtitle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disableSubtitle) {
      res["DisableSubtitle"] = boost::any(*disableSubtitle);
    }
    if (extractSubtitle) {
      res["ExtractSubtitle"] = extractSubtitle ? boost::any(extractSubtitle->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisableSubtitle") != m.end() && !m["DisableSubtitle"].empty()) {
      disableSubtitle = make_shared<bool>(boost::any_cast<bool>(m["DisableSubtitle"]));
    }
    if (m.find("ExtractSubtitle") != m.end() && !m["ExtractSubtitle"].empty()) {
      if (typeid(map<string, boost::any>) == m["ExtractSubtitle"].type()) {
        TargetSubtitleExtractSubtitle model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ExtractSubtitle"]));
        extractSubtitle = make_shared<TargetSubtitleExtractSubtitle>(model1);
      }
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Stream"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Stream"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      stream = make_shared<vector<long>>(toVec1);
    }
  }


  virtual ~TargetSubtitle() = default;
};
class TargetVideoFilterVideoDelogos : public Darabonba::Model {
public:
  shared_ptr<double> duration{};
  shared_ptr<double> dx{};
  shared_ptr<double> dy{};
  shared_ptr<double> height{};
  shared_ptr<string> referPos{};
  shared_ptr<double> startTime{};
  shared_ptr<double> width{};

  TargetVideoFilterVideoDelogos() {}

  explicit TargetVideoFilterVideoDelogos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<double>(boost::any_cast<double>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<double>(boost::any_cast<double>(m["Dy"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<double>(boost::any_cast<double>(m["Height"]));
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<double>(boost::any_cast<double>(m["StartTime"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<double>(boost::any_cast<double>(m["Width"]));
    }
  }


  virtual ~TargetVideoFilterVideoDelogos() = default;
};
class TargetVideoFilterVideoWatermarks : public Darabonba::Model {
public:
  shared_ptr<string> borderColor{};
  shared_ptr<long> borderWidth{};
  shared_ptr<string> content{};
  shared_ptr<double> duration{};
  shared_ptr<double> dx{};
  shared_ptr<double> dy{};
  shared_ptr<double> fontApha{};
  shared_ptr<string> fontColor{};
  shared_ptr<string> fontName{};
  shared_ptr<long> fontSize{};
  shared_ptr<double> height{};
  shared_ptr<string> referPos{};
  shared_ptr<double> startTime{};
  shared_ptr<string> type{};
  shared_ptr<string> URI{};
  shared_ptr<double> width{};

  TargetVideoFilterVideoWatermarks() {}

  explicit TargetVideoFilterVideoWatermarks(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (borderColor) {
      res["BorderColor"] = boost::any(*borderColor);
    }
    if (borderWidth) {
      res["BorderWidth"] = boost::any(*borderWidth);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (dx) {
      res["Dx"] = boost::any(*dx);
    }
    if (dy) {
      res["Dy"] = boost::any(*dy);
    }
    if (fontApha) {
      res["FontApha"] = boost::any(*fontApha);
    }
    if (fontColor) {
      res["FontColor"] = boost::any(*fontColor);
    }
    if (fontName) {
      res["FontName"] = boost::any(*fontName);
    }
    if (fontSize) {
      res["FontSize"] = boost::any(*fontSize);
    }
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BorderColor") != m.end() && !m["BorderColor"].empty()) {
      borderColor = make_shared<string>(boost::any_cast<string>(m["BorderColor"]));
    }
    if (m.find("BorderWidth") != m.end() && !m["BorderWidth"].empty()) {
      borderWidth = make_shared<long>(boost::any_cast<long>(m["BorderWidth"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("Dx") != m.end() && !m["Dx"].empty()) {
      dx = make_shared<double>(boost::any_cast<double>(m["Dx"]));
    }
    if (m.find("Dy") != m.end() && !m["Dy"].empty()) {
      dy = make_shared<double>(boost::any_cast<double>(m["Dy"]));
    }
    if (m.find("FontApha") != m.end() && !m["FontApha"].empty()) {
      fontApha = make_shared<double>(boost::any_cast<double>(m["FontApha"]));
    }
    if (m.find("FontColor") != m.end() && !m["FontColor"].empty()) {
      fontColor = make_shared<string>(boost::any_cast<string>(m["FontColor"]));
    }
    if (m.find("FontName") != m.end() && !m["FontName"].empty()) {
      fontName = make_shared<string>(boost::any_cast<string>(m["FontName"]));
    }
    if (m.find("FontSize") != m.end() && !m["FontSize"].empty()) {
      fontSize = make_shared<long>(boost::any_cast<long>(m["FontSize"]));
    }
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<double>(boost::any_cast<double>(m["Height"]));
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<double>(boost::any_cast<double>(m["StartTime"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<double>(boost::any_cast<double>(m["Width"]));
    }
  }


  virtual ~TargetVideoFilterVideoWatermarks() = default;
};
class TargetVideoFilterVideo : public Darabonba::Model {
public:
  shared_ptr<vector<TargetVideoFilterVideoDelogos>> delogos{};
  shared_ptr<vector<TargetVideoFilterVideoWatermarks>> watermarks{};

  TargetVideoFilterVideo() {}

  explicit TargetVideoFilterVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (delogos) {
      vector<boost::any> temp1;
      for(auto item1:*delogos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Delogos"] = boost::any(temp1);
    }
    if (watermarks) {
      vector<boost::any> temp1;
      for(auto item1:*watermarks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Watermarks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Delogos") != m.end() && !m["Delogos"].empty()) {
      if (typeid(vector<boost::any>) == m["Delogos"].type()) {
        vector<TargetVideoFilterVideoDelogos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Delogos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TargetVideoFilterVideoDelogos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        delogos = make_shared<vector<TargetVideoFilterVideoDelogos>>(expect1);
      }
    }
    if (m.find("Watermarks") != m.end() && !m["Watermarks"].empty()) {
      if (typeid(vector<boost::any>) == m["Watermarks"].type()) {
        vector<TargetVideoFilterVideoWatermarks> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Watermarks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TargetVideoFilterVideoWatermarks model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        watermarks = make_shared<vector<TargetVideoFilterVideoWatermarks>>(expect1);
      }
    }
  }


  virtual ~TargetVideoFilterVideo() = default;
};
class TargetVideoTranscodeVideo : public Darabonba::Model {
public:
  shared_ptr<bool> adaptiveResolutionDirection{};
  shared_ptr<long> BFrames{};
  shared_ptr<long> bitrate{};
  shared_ptr<string> bitrateOption{};
  shared_ptr<long> bufferSize{};
  shared_ptr<double> CRF{};
  shared_ptr<string> codec{};
  shared_ptr<double> frameRate{};
  shared_ptr<string> frameRateOption{};
  shared_ptr<long> GOPSize{};
  shared_ptr<long> maxBitrate{};
  shared_ptr<string> pixelFormat{};
  shared_ptr<long> refs{};
  shared_ptr<string> resolution{};
  shared_ptr<string> resolutionOption{};
  shared_ptr<long> rotation{};
  shared_ptr<string> scaleType{};

  TargetVideoTranscodeVideo() {}

  explicit TargetVideoTranscodeVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (adaptiveResolutionDirection) {
      res["AdaptiveResolutionDirection"] = boost::any(*adaptiveResolutionDirection);
    }
    if (BFrames) {
      res["BFrames"] = boost::any(*BFrames);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (bitrateOption) {
      res["BitrateOption"] = boost::any(*bitrateOption);
    }
    if (bufferSize) {
      res["BufferSize"] = boost::any(*bufferSize);
    }
    if (CRF) {
      res["CRF"] = boost::any(*CRF);
    }
    if (codec) {
      res["Codec"] = boost::any(*codec);
    }
    if (frameRate) {
      res["FrameRate"] = boost::any(*frameRate);
    }
    if (frameRateOption) {
      res["FrameRateOption"] = boost::any(*frameRateOption);
    }
    if (GOPSize) {
      res["GOPSize"] = boost::any(*GOPSize);
    }
    if (maxBitrate) {
      res["MaxBitrate"] = boost::any(*maxBitrate);
    }
    if (pixelFormat) {
      res["PixelFormat"] = boost::any(*pixelFormat);
    }
    if (refs) {
      res["Refs"] = boost::any(*refs);
    }
    if (resolution) {
      res["Resolution"] = boost::any(*resolution);
    }
    if (resolutionOption) {
      res["ResolutionOption"] = boost::any(*resolutionOption);
    }
    if (rotation) {
      res["Rotation"] = boost::any(*rotation);
    }
    if (scaleType) {
      res["ScaleType"] = boost::any(*scaleType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AdaptiveResolutionDirection") != m.end() && !m["AdaptiveResolutionDirection"].empty()) {
      adaptiveResolutionDirection = make_shared<bool>(boost::any_cast<bool>(m["AdaptiveResolutionDirection"]));
    }
    if (m.find("BFrames") != m.end() && !m["BFrames"].empty()) {
      BFrames = make_shared<long>(boost::any_cast<long>(m["BFrames"]));
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<long>(boost::any_cast<long>(m["Bitrate"]));
    }
    if (m.find("BitrateOption") != m.end() && !m["BitrateOption"].empty()) {
      bitrateOption = make_shared<string>(boost::any_cast<string>(m["BitrateOption"]));
    }
    if (m.find("BufferSize") != m.end() && !m["BufferSize"].empty()) {
      bufferSize = make_shared<long>(boost::any_cast<long>(m["BufferSize"]));
    }
    if (m.find("CRF") != m.end() && !m["CRF"].empty()) {
      CRF = make_shared<double>(boost::any_cast<double>(m["CRF"]));
    }
    if (m.find("Codec") != m.end() && !m["Codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["Codec"]));
    }
    if (m.find("FrameRate") != m.end() && !m["FrameRate"].empty()) {
      frameRate = make_shared<double>(boost::any_cast<double>(m["FrameRate"]));
    }
    if (m.find("FrameRateOption") != m.end() && !m["FrameRateOption"].empty()) {
      frameRateOption = make_shared<string>(boost::any_cast<string>(m["FrameRateOption"]));
    }
    if (m.find("GOPSize") != m.end() && !m["GOPSize"].empty()) {
      GOPSize = make_shared<long>(boost::any_cast<long>(m["GOPSize"]));
    }
    if (m.find("MaxBitrate") != m.end() && !m["MaxBitrate"].empty()) {
      maxBitrate = make_shared<long>(boost::any_cast<long>(m["MaxBitrate"]));
    }
    if (m.find("PixelFormat") != m.end() && !m["PixelFormat"].empty()) {
      pixelFormat = make_shared<string>(boost::any_cast<string>(m["PixelFormat"]));
    }
    if (m.find("Refs") != m.end() && !m["Refs"].empty()) {
      refs = make_shared<long>(boost::any_cast<long>(m["Refs"]));
    }
    if (m.find("Resolution") != m.end() && !m["Resolution"].empty()) {
      resolution = make_shared<string>(boost::any_cast<string>(m["Resolution"]));
    }
    if (m.find("ResolutionOption") != m.end() && !m["ResolutionOption"].empty()) {
      resolutionOption = make_shared<string>(boost::any_cast<string>(m["ResolutionOption"]));
    }
    if (m.find("Rotation") != m.end() && !m["Rotation"].empty()) {
      rotation = make_shared<long>(boost::any_cast<long>(m["Rotation"]));
    }
    if (m.find("ScaleType") != m.end() && !m["ScaleType"].empty()) {
      scaleType = make_shared<string>(boost::any_cast<string>(m["ScaleType"]));
    }
  }


  virtual ~TargetVideoTranscodeVideo() = default;
};
class TargetVideo : public Darabonba::Model {
public:
  shared_ptr<bool> disableVideo{};
  shared_ptr<TargetVideoFilterVideo> filterVideo{};
  shared_ptr<vector<long>> stream{};
  shared_ptr<TargetVideoTranscodeVideo> transcodeVideo{};

  TargetVideo() {}

  explicit TargetVideo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disableVideo) {
      res["DisableVideo"] = boost::any(*disableVideo);
    }
    if (filterVideo) {
      res["FilterVideo"] = filterVideo ? boost::any(filterVideo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (stream) {
      res["Stream"] = boost::any(*stream);
    }
    if (transcodeVideo) {
      res["TranscodeVideo"] = transcodeVideo ? boost::any(transcodeVideo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisableVideo") != m.end() && !m["DisableVideo"].empty()) {
      disableVideo = make_shared<bool>(boost::any_cast<bool>(m["DisableVideo"]));
    }
    if (m.find("FilterVideo") != m.end() && !m["FilterVideo"].empty()) {
      if (typeid(map<string, boost::any>) == m["FilterVideo"].type()) {
        TargetVideoFilterVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FilterVideo"]));
        filterVideo = make_shared<TargetVideoFilterVideo>(model1);
      }
    }
    if (m.find("Stream") != m.end() && !m["Stream"].empty()) {
      vector<long> toVec1;
      if (typeid(vector<boost::any>) == m["Stream"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Stream"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<long>(item));
        }
      }
      stream = make_shared<vector<long>>(toVec1);
    }
    if (m.find("TranscodeVideo") != m.end() && !m["TranscodeVideo"].empty()) {
      if (typeid(map<string, boost::any>) == m["TranscodeVideo"].type()) {
        TargetVideoTranscodeVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TranscodeVideo"]));
        transcodeVideo = make_shared<TargetVideoTranscodeVideo>(model1);
      }
    }
  }


  virtual ~TargetVideo() = default;
};
class TaskInfo : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> endTime{};
  shared_ptr<string> message{};
  shared_ptr<long> progress{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<map<string, boost::any>> tags{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskRequestDefinition{};
  shared_ptr<string> taskType{};
  shared_ptr<string> userData{};

  TaskInfo() {}

  explicit TaskInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskRequestDefinition) {
      res["TaskRequestDefinition"] = boost::any(*taskRequestDefinition);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Tags"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskRequestDefinition") != m.end() && !m["TaskRequestDefinition"].empty()) {
      taskRequestDefinition = make_shared<string>(boost::any_cast<string>(m["TaskRequestDefinition"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~TaskInfo() = default;
};
class TimeRange : public Darabonba::Model {
public:
  shared_ptr<string> end{};
  shared_ptr<string> start{};

  TimeRange() {}

  explicit TimeRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (end) {
      res["End"] = boost::any(*end);
    }
    if (start) {
      res["Start"] = boost::any(*start);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("End") != m.end() && !m["End"].empty()) {
      end = make_shared<string>(boost::any_cast<string>(m["End"]));
    }
    if (m.find("Start") != m.end() && !m["Start"].empty()) {
      start = make_shared<string>(boost::any_cast<string>(m["Start"]));
    }
  }


  virtual ~TimeRange() = default;
};
class ToolCall : public Darabonba::Model {
public:
  shared_ptr<FunctionCall> function{};
  shared_ptr<string> type{};

  ToolCall() {}

  explicit ToolCall(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (function) {
      res["Function"] = function ? boost::any(function->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Function") != m.end() && !m["Function"].empty()) {
      if (typeid(map<string, boost::any>) == m["Function"].type()) {
        FunctionCall model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Function"]));
        function = make_shared<FunctionCall>(model1);
      }
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~ToolCall() = default;
};
class TrimPolicy : public Darabonba::Model {
public:
  shared_ptr<bool> disableDeleteEmptyCell{};
  shared_ptr<bool> disableDeleteRepeatedStyle{};
  shared_ptr<bool> disableDeleteUnusedPicture{};
  shared_ptr<bool> disableDeleteUnusedShape{};

  TrimPolicy() {}

  explicit TrimPolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disableDeleteEmptyCell) {
      res["DisableDeleteEmptyCell"] = boost::any(*disableDeleteEmptyCell);
    }
    if (disableDeleteRepeatedStyle) {
      res["DisableDeleteRepeatedStyle"] = boost::any(*disableDeleteRepeatedStyle);
    }
    if (disableDeleteUnusedPicture) {
      res["DisableDeleteUnusedPicture"] = boost::any(*disableDeleteUnusedPicture);
    }
    if (disableDeleteUnusedShape) {
      res["DisableDeleteUnusedShape"] = boost::any(*disableDeleteUnusedShape);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DisableDeleteEmptyCell") != m.end() && !m["DisableDeleteEmptyCell"].empty()) {
      disableDeleteEmptyCell = make_shared<bool>(boost::any_cast<bool>(m["DisableDeleteEmptyCell"]));
    }
    if (m.find("DisableDeleteRepeatedStyle") != m.end() && !m["DisableDeleteRepeatedStyle"].empty()) {
      disableDeleteRepeatedStyle = make_shared<bool>(boost::any_cast<bool>(m["DisableDeleteRepeatedStyle"]));
    }
    if (m.find("DisableDeleteUnusedPicture") != m.end() && !m["DisableDeleteUnusedPicture"].empty()) {
      disableDeleteUnusedPicture = make_shared<bool>(boost::any_cast<bool>(m["DisableDeleteUnusedPicture"]));
    }
    if (m.find("DisableDeleteUnusedShape") != m.end() && !m["DisableDeleteUnusedShape"].empty()) {
      disableDeleteUnusedShape = make_shared<bool>(boost::any_cast<bool>(m["DisableDeleteUnusedShape"]));
    }
  }


  virtual ~TrimPolicy() = default;
};
class WebofficePermission : public Darabonba::Model {
public:
  shared_ptr<bool> copy{};
  shared_ptr<bool> export_{};
  shared_ptr<bool> history{};
  shared_ptr<bool> print{};
  shared_ptr<bool> readonly{};
  shared_ptr<bool> rename{};

  WebofficePermission() {}

  explicit WebofficePermission(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (copy) {
      res["Copy"] = boost::any(*copy);
    }
    if (export_) {
      res["Export"] = boost::any(*export_);
    }
    if (history) {
      res["History"] = boost::any(*history);
    }
    if (print) {
      res["Print"] = boost::any(*print);
    }
    if (readonly) {
      res["Readonly"] = boost::any(*readonly);
    }
    if (rename) {
      res["Rename"] = boost::any(*rename);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Copy") != m.end() && !m["Copy"].empty()) {
      copy = make_shared<bool>(boost::any_cast<bool>(m["Copy"]));
    }
    if (m.find("Export") != m.end() && !m["Export"].empty()) {
      export_ = make_shared<bool>(boost::any_cast<bool>(m["Export"]));
    }
    if (m.find("History") != m.end() && !m["History"].empty()) {
      history = make_shared<bool>(boost::any_cast<bool>(m["History"]));
    }
    if (m.find("Print") != m.end() && !m["Print"].empty()) {
      print = make_shared<bool>(boost::any_cast<bool>(m["Print"]));
    }
    if (m.find("Readonly") != m.end() && !m["Readonly"].empty()) {
      readonly = make_shared<bool>(boost::any_cast<bool>(m["Readonly"]));
    }
    if (m.find("Rename") != m.end() && !m["Rename"].empty()) {
      rename = make_shared<bool>(boost::any_cast<bool>(m["Rename"]));
    }
  }


  virtual ~WebofficePermission() = default;
};
class WebofficeUser : public Darabonba::Model {
public:
  shared_ptr<string> avatar{};
  shared_ptr<string> id{};
  shared_ptr<string> name{};

  WebofficeUser() {}

  explicit WebofficeUser(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (avatar) {
      res["Avatar"] = boost::any(*avatar);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Avatar") != m.end() && !m["Avatar"].empty()) {
      avatar = make_shared<string>(boost::any_cast<string>(m["Avatar"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
  }


  virtual ~WebofficeUser() = default;
};
class WebofficeWatermark : public Darabonba::Model {
public:
  shared_ptr<string> fillStyle{};
  shared_ptr<string> font{};
  shared_ptr<long> horizontal{};
  shared_ptr<double> rotate{};
  shared_ptr<long> type{};
  shared_ptr<string> value{};
  shared_ptr<long> vertical{};

  WebofficeWatermark() {}

  explicit WebofficeWatermark(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fillStyle) {
      res["FillStyle"] = boost::any(*fillStyle);
    }
    if (font) {
      res["Font"] = boost::any(*font);
    }
    if (horizontal) {
      res["Horizontal"] = boost::any(*horizontal);
    }
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    if (vertical) {
      res["Vertical"] = boost::any(*vertical);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FillStyle") != m.end() && !m["FillStyle"].empty()) {
      fillStyle = make_shared<string>(boost::any_cast<string>(m["FillStyle"]));
    }
    if (m.find("Font") != m.end() && !m["Font"].empty()) {
      font = make_shared<string>(boost::any_cast<string>(m["Font"]));
    }
    if (m.find("Horizontal") != m.end() && !m["Horizontal"].empty()) {
      horizontal = make_shared<long>(boost::any_cast<long>(m["Horizontal"]));
    }
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<double>(boost::any_cast<double>(m["Rotate"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<long>(boost::any_cast<long>(m["Type"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
    if (m.find("Vertical") != m.end() && !m["Vertical"].empty()) {
      vertical = make_shared<long>(boost::any_cast<long>(m["Vertical"]));
    }
  }


  virtual ~WebofficeWatermark() = default;
};
class AddImageMosaicRequestTargetsBoundary : public Darabonba::Model {
public:
  shared_ptr<double> height{};
  shared_ptr<string> referPos{};
  shared_ptr<double> width{};
  shared_ptr<double> x{};
  shared_ptr<double> y{};

  AddImageMosaicRequestTargetsBoundary() {}

  explicit AddImageMosaicRequestTargetsBoundary(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (height) {
      res["Height"] = boost::any(*height);
    }
    if (referPos) {
      res["ReferPos"] = boost::any(*referPos);
    }
    if (width) {
      res["Width"] = boost::any(*width);
    }
    if (x) {
      res["X"] = boost::any(*x);
    }
    if (y) {
      res["Y"] = boost::any(*y);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Height") != m.end() && !m["Height"].empty()) {
      height = make_shared<double>(boost::any_cast<double>(m["Height"]));
    }
    if (m.find("ReferPos") != m.end() && !m["ReferPos"].empty()) {
      referPos = make_shared<string>(boost::any_cast<string>(m["ReferPos"]));
    }
    if (m.find("Width") != m.end() && !m["Width"].empty()) {
      width = make_shared<double>(boost::any_cast<double>(m["Width"]));
    }
    if (m.find("X") != m.end() && !m["X"].empty()) {
      x = make_shared<double>(boost::any_cast<double>(m["X"]));
    }
    if (m.find("Y") != m.end() && !m["Y"].empty()) {
      y = make_shared<double>(boost::any_cast<double>(m["Y"]));
    }
  }


  virtual ~AddImageMosaicRequestTargetsBoundary() = default;
};
class AddImageMosaicRequestTargets : public Darabonba::Model {
public:
  shared_ptr<long> blurRadius{};
  shared_ptr<AddImageMosaicRequestTargetsBoundary> boundary{};
  shared_ptr<string> color{};
  shared_ptr<long> mosaicRadius{};
  shared_ptr<long> sigma{};
  shared_ptr<string> type{};

  AddImageMosaicRequestTargets() {}

  explicit AddImageMosaicRequestTargets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blurRadius) {
      res["BlurRadius"] = boost::any(*blurRadius);
    }
    if (boundary) {
      res["Boundary"] = boundary ? boost::any(boundary->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (color) {
      res["Color"] = boost::any(*color);
    }
    if (mosaicRadius) {
      res["MosaicRadius"] = boost::any(*mosaicRadius);
    }
    if (sigma) {
      res["Sigma"] = boost::any(*sigma);
    }
    if (type) {
      res["Type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlurRadius") != m.end() && !m["BlurRadius"].empty()) {
      blurRadius = make_shared<long>(boost::any_cast<long>(m["BlurRadius"]));
    }
    if (m.find("Boundary") != m.end() && !m["Boundary"].empty()) {
      if (typeid(map<string, boost::any>) == m["Boundary"].type()) {
        AddImageMosaicRequestTargetsBoundary model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Boundary"]));
        boundary = make_shared<AddImageMosaicRequestTargetsBoundary>(model1);
      }
    }
    if (m.find("Color") != m.end() && !m["Color"].empty()) {
      color = make_shared<string>(boost::any_cast<string>(m["Color"]));
    }
    if (m.find("MosaicRadius") != m.end() && !m["MosaicRadius"].empty()) {
      mosaicRadius = make_shared<long>(boost::any_cast<long>(m["MosaicRadius"]));
    }
    if (m.find("Sigma") != m.end() && !m["Sigma"].empty()) {
      sigma = make_shared<long>(boost::any_cast<long>(m["Sigma"]));
    }
    if (m.find("Type") != m.end() && !m["Type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["Type"]));
    }
  }


  virtual ~AddImageMosaicRequestTargets() = default;
};
class AddImageMosaicRequest : public Darabonba::Model {
public:
  shared_ptr<CredentialConfig> credentialConfig{};
  shared_ptr<string> imageFormat{};
  shared_ptr<string> projectName{};
  shared_ptr<long> quality{};
  shared_ptr<string> sourceURI{};
  shared_ptr<string> targetURI{};
  shared_ptr<vector<AddImageMosaicRequestTargets>> targets{};

  AddImageMosaicRequest() {}

  explicit AddImageMosaicRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfig) {
      res["CredentialConfig"] = credentialConfig ? boost::any(credentialConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (imageFormat) {
      res["ImageFormat"] = boost::any(*imageFormat);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (quality) {
      res["Quality"] = boost::any(*quality);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    if (targetURI) {
      res["TargetURI"] = boost::any(*targetURI);
    }
    if (targets) {
      vector<boost::any> temp1;
      for(auto item1:*targets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Targets"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CredentialConfig"].type()) {
        CredentialConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CredentialConfig"]));
        credentialConfig = make_shared<CredentialConfig>(model1);
      }
    }
    if (m.find("ImageFormat") != m.end() && !m["ImageFormat"].empty()) {
      imageFormat = make_shared<string>(boost::any_cast<string>(m["ImageFormat"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Quality") != m.end() && !m["Quality"].empty()) {
      quality = make_shared<long>(boost::any_cast<long>(m["Quality"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
    if (m.find("TargetURI") != m.end() && !m["TargetURI"].empty()) {
      targetURI = make_shared<string>(boost::any_cast<string>(m["TargetURI"]));
    }
    if (m.find("Targets") != m.end() && !m["Targets"].empty()) {
      if (typeid(vector<boost::any>) == m["Targets"].type()) {
        vector<AddImageMosaicRequestTargets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Targets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddImageMosaicRequestTargets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targets = make_shared<vector<AddImageMosaicRequestTargets>>(expect1);
      }
    }
  }


  virtual ~AddImageMosaicRequest() = default;
};
class AddImageMosaicShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> credentialConfigShrink{};
  shared_ptr<string> imageFormat{};
  shared_ptr<string> projectName{};
  shared_ptr<long> quality{};
  shared_ptr<string> sourceURI{};
  shared_ptr<string> targetURI{};
  shared_ptr<string> targetsShrink{};

  AddImageMosaicShrinkRequest() {}

  explicit AddImageMosaicShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfigShrink) {
      res["CredentialConfig"] = boost::any(*credentialConfigShrink);
    }
    if (imageFormat) {
      res["ImageFormat"] = boost::any(*imageFormat);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (quality) {
      res["Quality"] = boost::any(*quality);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    if (targetURI) {
      res["TargetURI"] = boost::any(*targetURI);
    }
    if (targetsShrink) {
      res["Targets"] = boost::any(*targetsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      credentialConfigShrink = make_shared<string>(boost::any_cast<string>(m["CredentialConfig"]));
    }
    if (m.find("ImageFormat") != m.end() && !m["ImageFormat"].empty()) {
      imageFormat = make_shared<string>(boost::any_cast<string>(m["ImageFormat"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Quality") != m.end() && !m["Quality"].empty()) {
      quality = make_shared<long>(boost::any_cast<long>(m["Quality"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
    if (m.find("TargetURI") != m.end() && !m["TargetURI"].empty()) {
      targetURI = make_shared<string>(boost::any_cast<string>(m["TargetURI"]));
    }
    if (m.find("Targets") != m.end() && !m["Targets"].empty()) {
      targetsShrink = make_shared<string>(boost::any_cast<string>(m["Targets"]));
    }
  }


  virtual ~AddImageMosaicShrinkRequest() = default;
};
class AddImageMosaicResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AddImageMosaicResponseBody() {}

  explicit AddImageMosaicResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddImageMosaicResponseBody() = default;
};
class AddImageMosaicResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddImageMosaicResponseBody> body{};

  AddImageMosaicResponse() {}

  explicit AddImageMosaicResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddImageMosaicResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddImageMosaicResponseBody>(model1);
      }
    }
  }


  virtual ~AddImageMosaicResponse() = default;
};
class AddStoryFilesRequestFiles : public Darabonba::Model {
public:
  shared_ptr<string> URI{};

  AddStoryFilesRequestFiles() {}

  explicit AddStoryFilesRequestFiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~AddStoryFilesRequestFiles() = default;
};
class AddStoryFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<vector<AddStoryFilesRequestFiles>> files{};
  shared_ptr<string> objectId{};
  shared_ptr<string> projectName{};

  AddStoryFilesRequest() {}

  explicit AddStoryFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (files) {
      vector<boost::any> temp1;
      for(auto item1:*files){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Files"] = boost::any(temp1);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      if (typeid(vector<boost::any>) == m["Files"].type()) {
        vector<AddStoryFilesRequestFiles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Files"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddStoryFilesRequestFiles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        files = make_shared<vector<AddStoryFilesRequestFiles>>(expect1);
      }
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~AddStoryFilesRequest() = default;
};
class AddStoryFilesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> filesShrink{};
  shared_ptr<string> objectId{};
  shared_ptr<string> projectName{};

  AddStoryFilesShrinkRequest() {}

  explicit AddStoryFilesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (filesShrink) {
      res["Files"] = boost::any(*filesShrink);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      filesShrink = make_shared<string>(boost::any_cast<string>(m["Files"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~AddStoryFilesShrinkRequest() = default;
};
class AddStoryFilesResponseBodyFiles : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMessage{};
  shared_ptr<string> URI{};

  AddStoryFilesResponseBodyFiles() {}

  explicit AddStoryFilesResponseBodyFiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["ErrorCode"] = boost::any(*errorCode);
    }
    if (errorMessage) {
      res["ErrorMessage"] = boost::any(*errorMessage);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ErrorCode") != m.end() && !m["ErrorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["ErrorCode"]));
    }
    if (m.find("ErrorMessage") != m.end() && !m["ErrorMessage"].empty()) {
      errorMessage = make_shared<string>(boost::any_cast<string>(m["ErrorMessage"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~AddStoryFilesResponseBodyFiles() = default;
};
class AddStoryFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<AddStoryFilesResponseBodyFiles>> files{};
  shared_ptr<string> requestId{};

  AddStoryFilesResponseBody() {}

  explicit AddStoryFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (files) {
      vector<boost::any> temp1;
      for(auto item1:*files){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Files"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      if (typeid(vector<boost::any>) == m["Files"].type()) {
        vector<AddStoryFilesResponseBodyFiles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Files"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AddStoryFilesResponseBodyFiles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        files = make_shared<vector<AddStoryFilesResponseBodyFiles>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AddStoryFilesResponseBody() = default;
};
class AddStoryFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddStoryFilesResponseBody> body{};

  AddStoryFilesResponse() {}

  explicit AddStoryFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddStoryFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddStoryFilesResponseBody>(model1);
      }
    }
  }


  virtual ~AddStoryFilesResponse() = default;
};
class AttachOSSBucketRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> OSSBucket{};
  shared_ptr<string> projectName{};

  AttachOSSBucketRequest() {}

  explicit AttachOSSBucketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (OSSBucket) {
      res["OSSBucket"] = boost::any(*OSSBucket);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("OSSBucket") != m.end() && !m["OSSBucket"].empty()) {
      OSSBucket = make_shared<string>(boost::any_cast<string>(m["OSSBucket"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~AttachOSSBucketRequest() = default;
};
class AttachOSSBucketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  AttachOSSBucketResponseBody() {}

  explicit AttachOSSBucketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~AttachOSSBucketResponseBody() = default;
};
class AttachOSSBucketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AttachOSSBucketResponseBody> body{};

  AttachOSSBucketResponse() {}

  explicit AttachOSSBucketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AttachOSSBucketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AttachOSSBucketResponseBody>(model1);
      }
    }
  }


  virtual ~AttachOSSBucketResponse() = default;
};
class BatchDeleteFileMetaRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> projectName{};
  shared_ptr<vector<string>> URIs{};

  BatchDeleteFileMetaRequest() {}

  explicit BatchDeleteFileMetaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (URIs) {
      res["URIs"] = boost::any(*URIs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("URIs") != m.end() && !m["URIs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["URIs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["URIs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      URIs = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchDeleteFileMetaRequest() = default;
};
class BatchDeleteFileMetaShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> projectName{};
  shared_ptr<string> URIsShrink{};

  BatchDeleteFileMetaShrinkRequest() {}

  explicit BatchDeleteFileMetaShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (URIsShrink) {
      res["URIs"] = boost::any(*URIsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("URIs") != m.end() && !m["URIs"].empty()) {
      URIsShrink = make_shared<string>(boost::any_cast<string>(m["URIs"]));
    }
  }


  virtual ~BatchDeleteFileMetaShrinkRequest() = default;
};
class BatchDeleteFileMetaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  BatchDeleteFileMetaResponseBody() {}

  explicit BatchDeleteFileMetaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchDeleteFileMetaResponseBody() = default;
};
class BatchDeleteFileMetaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchDeleteFileMetaResponseBody> body{};

  BatchDeleteFileMetaResponse() {}

  explicit BatchDeleteFileMetaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchDeleteFileMetaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchDeleteFileMetaResponseBody>(model1);
      }
    }
  }


  virtual ~BatchDeleteFileMetaResponse() = default;
};
class BatchGetFigureClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<vector<string>> objectIds{};
  shared_ptr<string> projectName{};

  BatchGetFigureClusterRequest() {}

  explicit BatchGetFigureClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (objectIds) {
      res["ObjectIds"] = boost::any(*objectIds);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("ObjectIds") != m.end() && !m["ObjectIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ObjectIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ObjectIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      objectIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~BatchGetFigureClusterRequest() = default;
};
class BatchGetFigureClusterShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> objectIdsShrink{};
  shared_ptr<string> projectName{};

  BatchGetFigureClusterShrinkRequest() {}

  explicit BatchGetFigureClusterShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (objectIdsShrink) {
      res["ObjectIds"] = boost::any(*objectIdsShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("ObjectIds") != m.end() && !m["ObjectIds"].empty()) {
      objectIdsShrink = make_shared<string>(boost::any_cast<string>(m["ObjectIds"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~BatchGetFigureClusterShrinkRequest() = default;
};
class BatchGetFigureClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<FigureCluster>> figureClusters{};
  shared_ptr<string> requestId{};

  BatchGetFigureClusterResponseBody() {}

  explicit BatchGetFigureClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (figureClusters) {
      vector<boost::any> temp1;
      for(auto item1:*figureClusters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FigureClusters"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FigureClusters") != m.end() && !m["FigureClusters"].empty()) {
      if (typeid(vector<boost::any>) == m["FigureClusters"].type()) {
        vector<FigureCluster> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FigureClusters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FigureCluster model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        figureClusters = make_shared<vector<FigureCluster>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchGetFigureClusterResponseBody() = default;
};
class BatchGetFigureClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchGetFigureClusterResponseBody> body{};

  BatchGetFigureClusterResponse() {}

  explicit BatchGetFigureClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchGetFigureClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchGetFigureClusterResponseBody>(model1);
      }
    }
  }


  virtual ~BatchGetFigureClusterResponse() = default;
};
class BatchGetFileMetaRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> projectName{};
  shared_ptr<vector<string>> URIs{};
  shared_ptr<vector<string>> withFields{};

  BatchGetFileMetaRequest() {}

  explicit BatchGetFileMetaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (URIs) {
      res["URIs"] = boost::any(*URIs);
    }
    if (withFields) {
      res["WithFields"] = boost::any(*withFields);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("URIs") != m.end() && !m["URIs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["URIs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["URIs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      URIs = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WithFields") != m.end() && !m["WithFields"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WithFields"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WithFields"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      withFields = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~BatchGetFileMetaRequest() = default;
};
class BatchGetFileMetaShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> projectName{};
  shared_ptr<string> URIsShrink{};
  shared_ptr<string> withFieldsShrink{};

  BatchGetFileMetaShrinkRequest() {}

  explicit BatchGetFileMetaShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (URIsShrink) {
      res["URIs"] = boost::any(*URIsShrink);
    }
    if (withFieldsShrink) {
      res["WithFields"] = boost::any(*withFieldsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("URIs") != m.end() && !m["URIs"].empty()) {
      URIsShrink = make_shared<string>(boost::any_cast<string>(m["URIs"]));
    }
    if (m.find("WithFields") != m.end() && !m["WithFields"].empty()) {
      withFieldsShrink = make_shared<string>(boost::any_cast<string>(m["WithFields"]));
    }
  }


  virtual ~BatchGetFileMetaShrinkRequest() = default;
};
class BatchGetFileMetaResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<File>> files{};
  shared_ptr<string> requestId{};

  BatchGetFileMetaResponseBody() {}

  explicit BatchGetFileMetaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (files) {
      vector<boost::any> temp1;
      for(auto item1:*files){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Files"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      if (typeid(vector<boost::any>) == m["Files"].type()) {
        vector<File> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Files"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            File model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        files = make_shared<vector<File>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchGetFileMetaResponseBody() = default;
};
class BatchGetFileMetaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchGetFileMetaResponseBody> body{};

  BatchGetFileMetaResponse() {}

  explicit BatchGetFileMetaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchGetFileMetaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchGetFileMetaResponseBody>(model1);
      }
    }
  }


  virtual ~BatchGetFileMetaResponse() = default;
};
class BatchIndexFileMetaRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<vector<InputFile>> files{};
  shared_ptr<Notification> notification{};
  shared_ptr<string> projectName{};
  shared_ptr<string> userData{};

  BatchIndexFileMetaRequest() {}

  explicit BatchIndexFileMetaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (files) {
      vector<boost::any> temp1;
      for(auto item1:*files){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Files"] = boost::any(temp1);
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      if (typeid(vector<boost::any>) == m["Files"].type()) {
        vector<InputFile> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Files"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InputFile model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        files = make_shared<vector<InputFile>>(expect1);
      }
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        Notification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<Notification>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~BatchIndexFileMetaRequest() = default;
};
class BatchIndexFileMetaShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> filesShrink{};
  shared_ptr<string> notificationShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> userData{};

  BatchIndexFileMetaShrinkRequest() {}

  explicit BatchIndexFileMetaShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (filesShrink) {
      res["Files"] = boost::any(*filesShrink);
    }
    if (notificationShrink) {
      res["Notification"] = boost::any(*notificationShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      filesShrink = make_shared<string>(boost::any_cast<string>(m["Files"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      notificationShrink = make_shared<string>(boost::any_cast<string>(m["Notification"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~BatchIndexFileMetaShrinkRequest() = default;
};
class BatchIndexFileMetaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> eventId{};
  shared_ptr<string> requestId{};

  BatchIndexFileMetaResponseBody() {}

  explicit BatchIndexFileMetaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchIndexFileMetaResponseBody() = default;
};
class BatchIndexFileMetaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchIndexFileMetaResponseBody> body{};

  BatchIndexFileMetaResponse() {}

  explicit BatchIndexFileMetaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchIndexFileMetaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchIndexFileMetaResponseBody>(model1);
      }
    }
  }


  virtual ~BatchIndexFileMetaResponse() = default;
};
class BatchUpdateFileMetaRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<vector<InputFile>> files{};
  shared_ptr<string> projectName{};

  BatchUpdateFileMetaRequest() {}

  explicit BatchUpdateFileMetaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (files) {
      vector<boost::any> temp1;
      for(auto item1:*files){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Files"] = boost::any(temp1);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      if (typeid(vector<boost::any>) == m["Files"].type()) {
        vector<InputFile> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Files"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            InputFile model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        files = make_shared<vector<InputFile>>(expect1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~BatchUpdateFileMetaRequest() = default;
};
class BatchUpdateFileMetaShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> filesShrink{};
  shared_ptr<string> projectName{};

  BatchUpdateFileMetaShrinkRequest() {}

  explicit BatchUpdateFileMetaShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (filesShrink) {
      res["Files"] = boost::any(*filesShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      filesShrink = make_shared<string>(boost::any_cast<string>(m["Files"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~BatchUpdateFileMetaShrinkRequest() = default;
};
class BatchUpdateFileMetaResponseBodyFiles : public Darabonba::Model {
public:
  shared_ptr<string> message{};
  shared_ptr<bool> success{};
  shared_ptr<string> URI{};

  BatchUpdateFileMetaResponseBodyFiles() {}

  explicit BatchUpdateFileMetaResponseBodyFiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~BatchUpdateFileMetaResponseBodyFiles() = default;
};
class BatchUpdateFileMetaResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<BatchUpdateFileMetaResponseBodyFiles>> files{};
  shared_ptr<string> requestId{};

  BatchUpdateFileMetaResponseBody() {}

  explicit BatchUpdateFileMetaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (files) {
      vector<boost::any> temp1;
      for(auto item1:*files){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Files"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      if (typeid(vector<boost::any>) == m["Files"].type()) {
        vector<BatchUpdateFileMetaResponseBodyFiles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Files"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            BatchUpdateFileMetaResponseBodyFiles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        files = make_shared<vector<BatchUpdateFileMetaResponseBodyFiles>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~BatchUpdateFileMetaResponseBody() = default;
};
class BatchUpdateFileMetaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<BatchUpdateFileMetaResponseBody> body{};

  BatchUpdateFileMetaResponse() {}

  explicit BatchUpdateFileMetaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        BatchUpdateFileMetaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<BatchUpdateFileMetaResponseBody>(model1);
      }
    }
  }


  virtual ~BatchUpdateFileMetaResponse() = default;
};
class CompareImageFacesRequestSource : public Darabonba::Model {
public:
  shared_ptr<string> URI1{};
  shared_ptr<string> URI2{};

  CompareImageFacesRequestSource() {}

  explicit CompareImageFacesRequestSource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (URI1) {
      res["URI1"] = boost::any(*URI1);
    }
    if (URI2) {
      res["URI2"] = boost::any(*URI2);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("URI1") != m.end() && !m["URI1"].empty()) {
      URI1 = make_shared<string>(boost::any_cast<string>(m["URI1"]));
    }
    if (m.find("URI2") != m.end() && !m["URI2"].empty()) {
      URI2 = make_shared<string>(boost::any_cast<string>(m["URI2"]));
    }
  }


  virtual ~CompareImageFacesRequestSource() = default;
};
class CompareImageFacesRequest : public Darabonba::Model {
public:
  shared_ptr<CredentialConfig> credentialConfig{};
  shared_ptr<string> projectName{};
  shared_ptr<CompareImageFacesRequestSource> source{};

  CompareImageFacesRequest() {}

  explicit CompareImageFacesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfig) {
      res["CredentialConfig"] = credentialConfig ? boost::any(credentialConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (source) {
      res["Source"] = source ? boost::any(source->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CredentialConfig"].type()) {
        CredentialConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CredentialConfig"]));
        credentialConfig = make_shared<CredentialConfig>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      if (typeid(map<string, boost::any>) == m["Source"].type()) {
        CompareImageFacesRequestSource model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Source"]));
        source = make_shared<CompareImageFacesRequestSource>(model1);
      }
    }
  }


  virtual ~CompareImageFacesRequest() = default;
};
class CompareImageFacesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> credentialConfigShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceShrink{};

  CompareImageFacesShrinkRequest() {}

  explicit CompareImageFacesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfigShrink) {
      res["CredentialConfig"] = boost::any(*credentialConfigShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceShrink) {
      res["Source"] = boost::any(*sourceShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      credentialConfigShrink = make_shared<string>(boost::any_cast<string>(m["CredentialConfig"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Source") != m.end() && !m["Source"].empty()) {
      sourceShrink = make_shared<string>(boost::any_cast<string>(m["Source"]));
    }
  }


  virtual ~CompareImageFacesShrinkRequest() = default;
};
class CompareImageFacesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<double> similarity{};

  CompareImageFacesResponseBody() {}

  explicit CompareImageFacesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (similarity) {
      res["Similarity"] = boost::any(*similarity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Similarity") != m.end() && !m["Similarity"].empty()) {
      similarity = make_shared<double>(boost::any_cast<double>(m["Similarity"]));
    }
  }


  virtual ~CompareImageFacesResponseBody() = default;
};
class CompareImageFacesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CompareImageFacesResponseBody> body{};

  CompareImageFacesResponse() {}

  explicit CompareImageFacesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CompareImageFacesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CompareImageFacesResponseBody>(model1);
      }
    }
  }


  virtual ~CompareImageFacesResponse() = default;
};
class ContextualAnswerRequest : public Darabonba::Model {
public:
  shared_ptr<vector<ContextualFile>> files{};
  shared_ptr<vector<ContextualMessage>> messages{};
  shared_ptr<string> projectName{};

  ContextualAnswerRequest() {}

  explicit ContextualAnswerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (files) {
      vector<boost::any> temp1;
      for(auto item1:*files){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Files"] = boost::any(temp1);
    }
    if (messages) {
      vector<boost::any> temp1;
      for(auto item1:*messages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Messages"] = boost::any(temp1);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      if (typeid(vector<boost::any>) == m["Files"].type()) {
        vector<ContextualFile> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Files"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ContextualFile model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        files = make_shared<vector<ContextualFile>>(expect1);
      }
    }
    if (m.find("Messages") != m.end() && !m["Messages"].empty()) {
      if (typeid(vector<boost::any>) == m["Messages"].type()) {
        vector<ContextualMessage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Messages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ContextualMessage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        messages = make_shared<vector<ContextualMessage>>(expect1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~ContextualAnswerRequest() = default;
};
class ContextualAnswerShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> filesShrink{};
  shared_ptr<string> messagesShrink{};
  shared_ptr<string> projectName{};

  ContextualAnswerShrinkRequest() {}

  explicit ContextualAnswerShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filesShrink) {
      res["Files"] = boost::any(*filesShrink);
    }
    if (messagesShrink) {
      res["Messages"] = boost::any(*messagesShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      filesShrink = make_shared<string>(boost::any_cast<string>(m["Files"]));
    }
    if (m.find("Messages") != m.end() && !m["Messages"].empty()) {
      messagesShrink = make_shared<string>(boost::any_cast<string>(m["Messages"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~ContextualAnswerShrinkRequest() = default;
};
class ContextualAnswerResponseBody : public Darabonba::Model {
public:
  shared_ptr<Answer> answer{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};

  ContextualAnswerResponseBody() {}

  explicit ContextualAnswerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (answer) {
      res["Answer"] = answer ? boost::any(answer->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Answer") != m.end() && !m["Answer"].empty()) {
      if (typeid(map<string, boost::any>) == m["Answer"].type()) {
        Answer model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Answer"]));
        answer = make_shared<Answer>(model1);
      }
    }
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ContextualAnswerResponseBody() = default;
};
class ContextualAnswerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ContextualAnswerResponseBody> body{};

  ContextualAnswerResponse() {}

  explicit ContextualAnswerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ContextualAnswerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ContextualAnswerResponseBody>(model1);
      }
    }
  }


  virtual ~ContextualAnswerResponse() = default;
};
class ContextualRetrievalRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<vector<ContextualMessage>> messages{};
  shared_ptr<string> projectName{};
  shared_ptr<bool> recallOnly{};
  shared_ptr<vector<string>> smartClusterIds{};

  ContextualRetrievalRequest() {}

  explicit ContextualRetrievalRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (messages) {
      vector<boost::any> temp1;
      for(auto item1:*messages){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Messages"] = boost::any(temp1);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (recallOnly) {
      res["RecallOnly"] = boost::any(*recallOnly);
    }
    if (smartClusterIds) {
      res["SmartClusterIds"] = boost::any(*smartClusterIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Messages") != m.end() && !m["Messages"].empty()) {
      if (typeid(vector<boost::any>) == m["Messages"].type()) {
        vector<ContextualMessage> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Messages"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ContextualMessage model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        messages = make_shared<vector<ContextualMessage>>(expect1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("RecallOnly") != m.end() && !m["RecallOnly"].empty()) {
      recallOnly = make_shared<bool>(boost::any_cast<bool>(m["RecallOnly"]));
    }
    if (m.find("SmartClusterIds") != m.end() && !m["SmartClusterIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SmartClusterIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SmartClusterIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      smartClusterIds = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ContextualRetrievalRequest() = default;
};
class ContextualRetrievalShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> messagesShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<bool> recallOnly{};
  shared_ptr<string> smartClusterIdsShrink{};

  ContextualRetrievalShrinkRequest() {}

  explicit ContextualRetrievalShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (messagesShrink) {
      res["Messages"] = boost::any(*messagesShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (recallOnly) {
      res["RecallOnly"] = boost::any(*recallOnly);
    }
    if (smartClusterIdsShrink) {
      res["SmartClusterIds"] = boost::any(*smartClusterIdsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Messages") != m.end() && !m["Messages"].empty()) {
      messagesShrink = make_shared<string>(boost::any_cast<string>(m["Messages"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("RecallOnly") != m.end() && !m["RecallOnly"].empty()) {
      recallOnly = make_shared<bool>(boost::any_cast<bool>(m["RecallOnly"]));
    }
    if (m.find("SmartClusterIds") != m.end() && !m["SmartClusterIds"].empty()) {
      smartClusterIdsShrink = make_shared<string>(boost::any_cast<string>(m["SmartClusterIds"]));
    }
  }


  virtual ~ContextualRetrievalShrinkRequest() = default;
};
class ContextualRetrievalResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<File>> results{};

  ContextualRetrievalResponseBody() {}

  explicit ContextualRetrievalResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (results) {
      vector<boost::any> temp1;
      for(auto item1:*results){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Results"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Results") != m.end() && !m["Results"].empty()) {
      if (typeid(vector<boost::any>) == m["Results"].type()) {
        vector<File> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Results"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            File model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        results = make_shared<vector<File>>(expect1);
      }
    }
  }


  virtual ~ContextualRetrievalResponseBody() = default;
};
class ContextualRetrievalResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ContextualRetrievalResponseBody> body{};

  ContextualRetrievalResponse() {}

  explicit ContextualRetrievalResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ContextualRetrievalResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ContextualRetrievalResponseBody>(model1);
      }
    }
  }


  virtual ~ContextualRetrievalResponse() = default;
};
class CreateArchiveFileInspectionTaskRequest : public Darabonba::Model {
public:
  shared_ptr<CredentialConfig> credentialConfig{};
  shared_ptr<Notification> notification{};
  shared_ptr<string> password{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceURI{};
  shared_ptr<string> userData{};

  CreateArchiveFileInspectionTaskRequest() {}

  explicit CreateArchiveFileInspectionTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfig) {
      res["CredentialConfig"] = credentialConfig ? boost::any(credentialConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CredentialConfig"].type()) {
        CredentialConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CredentialConfig"]));
        credentialConfig = make_shared<CredentialConfig>(model1);
      }
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        Notification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<Notification>(model1);
      }
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateArchiveFileInspectionTaskRequest() = default;
};
class CreateArchiveFileInspectionTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> credentialConfigShrink{};
  shared_ptr<string> notificationShrink{};
  shared_ptr<string> password{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceURI{};
  shared_ptr<string> userData{};

  CreateArchiveFileInspectionTaskShrinkRequest() {}

  explicit CreateArchiveFileInspectionTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfigShrink) {
      res["CredentialConfig"] = boost::any(*credentialConfigShrink);
    }
    if (notificationShrink) {
      res["Notification"] = boost::any(*notificationShrink);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      credentialConfigShrink = make_shared<string>(boost::any_cast<string>(m["CredentialConfig"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      notificationShrink = make_shared<string>(boost::any_cast<string>(m["Notification"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateArchiveFileInspectionTaskShrinkRequest() = default;
};
class CreateArchiveFileInspectionTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> eventId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  CreateArchiveFileInspectionTaskResponseBody() {}

  explicit CreateArchiveFileInspectionTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateArchiveFileInspectionTaskResponseBody() = default;
};
class CreateArchiveFileInspectionTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateArchiveFileInspectionTaskResponseBody> body{};

  CreateArchiveFileInspectionTaskResponse() {}

  explicit CreateArchiveFileInspectionTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateArchiveFileInspectionTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateArchiveFileInspectionTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateArchiveFileInspectionTaskResponse() = default;
};
class CreateBatchRequestActions : public Darabonba::Model {
public:
  shared_ptr<FastFailPolicy> fastFailPolicy{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> parameters{};

  CreateBatchRequestActions() {}

  explicit CreateBatchRequestActions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fastFailPolicy) {
      res["FastFailPolicy"] = fastFailPolicy ? boost::any(fastFailPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FastFailPolicy") != m.end() && !m["FastFailPolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["FastFailPolicy"].type()) {
        FastFailPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FastFailPolicy"]));
        fastFailPolicy = make_shared<FastFailPolicy>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Parameters"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Parameters"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      parameters = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateBatchRequestActions() = default;
};
class CreateBatchRequestNotification : public Darabonba::Model {
public:
  shared_ptr<MNS> MNS{};

  CreateBatchRequestNotification() {}

  explicit CreateBatchRequestNotification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (MNS) {
      res["MNS"] = MNS ? boost::any(MNS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MNS") != m.end() && !m["MNS"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNS"].type()) {
        MNS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNS"]));
        MNS = make_shared<MNS>(model1);
      }
    }
  }


  virtual ~CreateBatchRequestNotification() = default;
};
class CreateBatchRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateBatchRequestActions>> actions{};
  shared_ptr<Input> input{};
  shared_ptr<CreateBatchRequestNotification> notification{};
  shared_ptr<string> projectName{};
  shared_ptr<string> serviceRole{};
  shared_ptr<map<string, boost::any>> tags{};

  CreateBatchRequest() {}

  explicit CreateBatchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actions) {
      vector<boost::any> temp1;
      for(auto item1:*actions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Actions"] = boost::any(temp1);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (serviceRole) {
      res["ServiceRole"] = boost::any(*serviceRole);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Actions") != m.end() && !m["Actions"].empty()) {
      if (typeid(vector<boost::any>) == m["Actions"].type()) {
        vector<CreateBatchRequestActions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Actions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateBatchRequestActions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        actions = make_shared<vector<CreateBatchRequestActions>>(expect1);
      }
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        Input model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<Input>(model1);
      }
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        CreateBatchRequestNotification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<CreateBatchRequestNotification>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ServiceRole") != m.end() && !m["ServiceRole"].empty()) {
      serviceRole = make_shared<string>(boost::any_cast<string>(m["ServiceRole"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Tags"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~CreateBatchRequest() = default;
};
class CreateBatchShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> actionsShrink{};
  shared_ptr<string> inputShrink{};
  shared_ptr<string> notificationShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> serviceRole{};
  shared_ptr<string> tagsShrink{};

  CreateBatchShrinkRequest() {}

  explicit CreateBatchShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionsShrink) {
      res["Actions"] = boost::any(*actionsShrink);
    }
    if (inputShrink) {
      res["Input"] = boost::any(*inputShrink);
    }
    if (notificationShrink) {
      res["Notification"] = boost::any(*notificationShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (serviceRole) {
      res["ServiceRole"] = boost::any(*serviceRole);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Actions") != m.end() && !m["Actions"].empty()) {
      actionsShrink = make_shared<string>(boost::any_cast<string>(m["Actions"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      inputShrink = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      notificationShrink = make_shared<string>(boost::any_cast<string>(m["Notification"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ServiceRole") != m.end() && !m["ServiceRole"].empty()) {
      serviceRole = make_shared<string>(boost::any_cast<string>(m["ServiceRole"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~CreateBatchShrinkRequest() = default;
};
class CreateBatchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  CreateBatchResponseBody() {}

  explicit CreateBatchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateBatchResponseBody() = default;
};
class CreateBatchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBatchResponseBody> body{};

  CreateBatchResponse() {}

  explicit CreateBatchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBatchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBatchResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBatchResponse() = default;
};
class CreateBindingRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> projectName{};
  shared_ptr<string> URI{};

  CreateBindingRequest() {}

  explicit CreateBindingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~CreateBindingRequest() = default;
};
class CreateBindingResponseBody : public Darabonba::Model {
public:
  shared_ptr<Binding> binding{};
  shared_ptr<string> requestId{};

  CreateBindingResponseBody() {}

  explicit CreateBindingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (binding) {
      res["Binding"] = binding ? boost::any(binding->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Binding") != m.end() && !m["Binding"].empty()) {
      if (typeid(map<string, boost::any>) == m["Binding"].type()) {
        Binding model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Binding"]));
        binding = make_shared<Binding>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateBindingResponseBody() = default;
};
class CreateBindingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateBindingResponseBody> body{};

  CreateBindingResponse() {}

  explicit CreateBindingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateBindingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateBindingResponseBody>(model1);
      }
    }
  }


  virtual ~CreateBindingResponse() = default;
};
class CreateCompressPointCloudTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> compressMethod{};
  shared_ptr<CredentialConfig> credentialConfig{};
  shared_ptr<KdtreeOption> kdtreeOption{};
  shared_ptr<Notification> notification{};
  shared_ptr<OctreeOption> octreeOption{};
  shared_ptr<vector<string>> pointCloudFields{};
  shared_ptr<string> pointCloudFileFormat{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceURI{};
  shared_ptr<map<string, boost::any>> tags{};
  shared_ptr<string> targetURI{};
  shared_ptr<string> userData{};

  CreateCompressPointCloudTaskRequest() {}

  explicit CreateCompressPointCloudTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compressMethod) {
      res["CompressMethod"] = boost::any(*compressMethod);
    }
    if (credentialConfig) {
      res["CredentialConfig"] = credentialConfig ? boost::any(credentialConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (kdtreeOption) {
      res["KdtreeOption"] = kdtreeOption ? boost::any(kdtreeOption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (octreeOption) {
      res["OctreeOption"] = octreeOption ? boost::any(octreeOption->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pointCloudFields) {
      res["PointCloudFields"] = boost::any(*pointCloudFields);
    }
    if (pointCloudFileFormat) {
      res["PointCloudFileFormat"] = boost::any(*pointCloudFileFormat);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (targetURI) {
      res["TargetURI"] = boost::any(*targetURI);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompressMethod") != m.end() && !m["CompressMethod"].empty()) {
      compressMethod = make_shared<string>(boost::any_cast<string>(m["CompressMethod"]));
    }
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CredentialConfig"].type()) {
        CredentialConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CredentialConfig"]));
        credentialConfig = make_shared<CredentialConfig>(model1);
      }
    }
    if (m.find("KdtreeOption") != m.end() && !m["KdtreeOption"].empty()) {
      if (typeid(map<string, boost::any>) == m["KdtreeOption"].type()) {
        KdtreeOption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["KdtreeOption"]));
        kdtreeOption = make_shared<KdtreeOption>(model1);
      }
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        Notification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<Notification>(model1);
      }
    }
    if (m.find("OctreeOption") != m.end() && !m["OctreeOption"].empty()) {
      if (typeid(map<string, boost::any>) == m["OctreeOption"].type()) {
        OctreeOption model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["OctreeOption"]));
        octreeOption = make_shared<OctreeOption>(model1);
      }
    }
    if (m.find("PointCloudFields") != m.end() && !m["PointCloudFields"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["PointCloudFields"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["PointCloudFields"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      pointCloudFields = make_shared<vector<string>>(toVec1);
    }
    if (m.find("PointCloudFileFormat") != m.end() && !m["PointCloudFileFormat"].empty()) {
      pointCloudFileFormat = make_shared<string>(boost::any_cast<string>(m["PointCloudFileFormat"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Tags"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("TargetURI") != m.end() && !m["TargetURI"].empty()) {
      targetURI = make_shared<string>(boost::any_cast<string>(m["TargetURI"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateCompressPointCloudTaskRequest() = default;
};
class CreateCompressPointCloudTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> compressMethod{};
  shared_ptr<string> credentialConfigShrink{};
  shared_ptr<string> kdtreeOptionShrink{};
  shared_ptr<string> notificationShrink{};
  shared_ptr<string> octreeOptionShrink{};
  shared_ptr<string> pointCloudFieldsShrink{};
  shared_ptr<string> pointCloudFileFormat{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceURI{};
  shared_ptr<string> tagsShrink{};
  shared_ptr<string> targetURI{};
  shared_ptr<string> userData{};

  CreateCompressPointCloudTaskShrinkRequest() {}

  explicit CreateCompressPointCloudTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compressMethod) {
      res["CompressMethod"] = boost::any(*compressMethod);
    }
    if (credentialConfigShrink) {
      res["CredentialConfig"] = boost::any(*credentialConfigShrink);
    }
    if (kdtreeOptionShrink) {
      res["KdtreeOption"] = boost::any(*kdtreeOptionShrink);
    }
    if (notificationShrink) {
      res["Notification"] = boost::any(*notificationShrink);
    }
    if (octreeOptionShrink) {
      res["OctreeOption"] = boost::any(*octreeOptionShrink);
    }
    if (pointCloudFieldsShrink) {
      res["PointCloudFields"] = boost::any(*pointCloudFieldsShrink);
    }
    if (pointCloudFileFormat) {
      res["PointCloudFileFormat"] = boost::any(*pointCloudFileFormat);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    if (targetURI) {
      res["TargetURI"] = boost::any(*targetURI);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompressMethod") != m.end() && !m["CompressMethod"].empty()) {
      compressMethod = make_shared<string>(boost::any_cast<string>(m["CompressMethod"]));
    }
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      credentialConfigShrink = make_shared<string>(boost::any_cast<string>(m["CredentialConfig"]));
    }
    if (m.find("KdtreeOption") != m.end() && !m["KdtreeOption"].empty()) {
      kdtreeOptionShrink = make_shared<string>(boost::any_cast<string>(m["KdtreeOption"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      notificationShrink = make_shared<string>(boost::any_cast<string>(m["Notification"]));
    }
    if (m.find("OctreeOption") != m.end() && !m["OctreeOption"].empty()) {
      octreeOptionShrink = make_shared<string>(boost::any_cast<string>(m["OctreeOption"]));
    }
    if (m.find("PointCloudFields") != m.end() && !m["PointCloudFields"].empty()) {
      pointCloudFieldsShrink = make_shared<string>(boost::any_cast<string>(m["PointCloudFields"]));
    }
    if (m.find("PointCloudFileFormat") != m.end() && !m["PointCloudFileFormat"].empty()) {
      pointCloudFileFormat = make_shared<string>(boost::any_cast<string>(m["PointCloudFileFormat"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("TargetURI") != m.end() && !m["TargetURI"].empty()) {
      targetURI = make_shared<string>(boost::any_cast<string>(m["TargetURI"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateCompressPointCloudTaskShrinkRequest() = default;
};
class CreateCompressPointCloudTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> eventId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  CreateCompressPointCloudTaskResponseBody() {}

  explicit CreateCompressPointCloudTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateCompressPointCloudTaskResponseBody() = default;
};
class CreateCompressPointCloudTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCompressPointCloudTaskResponseBody> body{};

  CreateCompressPointCloudTaskResponse() {}

  explicit CreateCompressPointCloudTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCompressPointCloudTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCompressPointCloudTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCompressPointCloudTaskResponse() = default;
};
class CreateCustomizedStoryRequestCover : public Darabonba::Model {
public:
  shared_ptr<string> URI{};

  CreateCustomizedStoryRequestCover() {}

  explicit CreateCustomizedStoryRequestCover(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~CreateCustomizedStoryRequestCover() = default;
};
class CreateCustomizedStoryRequestFiles : public Darabonba::Model {
public:
  shared_ptr<string> URI{};

  CreateCustomizedStoryRequestFiles() {}

  explicit CreateCustomizedStoryRequestFiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~CreateCustomizedStoryRequestFiles() = default;
};
class CreateCustomizedStoryRequest : public Darabonba::Model {
public:
  shared_ptr<CreateCustomizedStoryRequestCover> cover{};
  shared_ptr<map<string, boost::any>> customLabels{};
  shared_ptr<string> datasetName{};
  shared_ptr<vector<CreateCustomizedStoryRequestFiles>> files{};
  shared_ptr<string> projectName{};
  shared_ptr<string> storyName{};
  shared_ptr<string> storySubType{};
  shared_ptr<string> storyType{};

  CreateCustomizedStoryRequest() {}

  explicit CreateCustomizedStoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cover) {
      res["Cover"] = cover ? boost::any(cover->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customLabels) {
      res["CustomLabels"] = boost::any(*customLabels);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (files) {
      vector<boost::any> temp1;
      for(auto item1:*files){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Files"] = boost::any(temp1);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (storyName) {
      res["StoryName"] = boost::any(*storyName);
    }
    if (storySubType) {
      res["StorySubType"] = boost::any(*storySubType);
    }
    if (storyType) {
      res["StoryType"] = boost::any(*storyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cover") != m.end() && !m["Cover"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cover"].type()) {
        CreateCustomizedStoryRequestCover model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cover"]));
        cover = make_shared<CreateCustomizedStoryRequestCover>(model1);
      }
    }
    if (m.find("CustomLabels") != m.end() && !m["CustomLabels"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["CustomLabels"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customLabels = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      if (typeid(vector<boost::any>) == m["Files"].type()) {
        vector<CreateCustomizedStoryRequestFiles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Files"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateCustomizedStoryRequestFiles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        files = make_shared<vector<CreateCustomizedStoryRequestFiles>>(expect1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("StoryName") != m.end() && !m["StoryName"].empty()) {
      storyName = make_shared<string>(boost::any_cast<string>(m["StoryName"]));
    }
    if (m.find("StorySubType") != m.end() && !m["StorySubType"].empty()) {
      storySubType = make_shared<string>(boost::any_cast<string>(m["StorySubType"]));
    }
    if (m.find("StoryType") != m.end() && !m["StoryType"].empty()) {
      storyType = make_shared<string>(boost::any_cast<string>(m["StoryType"]));
    }
  }


  virtual ~CreateCustomizedStoryRequest() = default;
};
class CreateCustomizedStoryShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> coverShrink{};
  shared_ptr<string> customLabelsShrink{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> filesShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> storyName{};
  shared_ptr<string> storySubType{};
  shared_ptr<string> storyType{};

  CreateCustomizedStoryShrinkRequest() {}

  explicit CreateCustomizedStoryShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverShrink) {
      res["Cover"] = boost::any(*coverShrink);
    }
    if (customLabelsShrink) {
      res["CustomLabels"] = boost::any(*customLabelsShrink);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (filesShrink) {
      res["Files"] = boost::any(*filesShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (storyName) {
      res["StoryName"] = boost::any(*storyName);
    }
    if (storySubType) {
      res["StorySubType"] = boost::any(*storySubType);
    }
    if (storyType) {
      res["StoryType"] = boost::any(*storyType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cover") != m.end() && !m["Cover"].empty()) {
      coverShrink = make_shared<string>(boost::any_cast<string>(m["Cover"]));
    }
    if (m.find("CustomLabels") != m.end() && !m["CustomLabels"].empty()) {
      customLabelsShrink = make_shared<string>(boost::any_cast<string>(m["CustomLabels"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      filesShrink = make_shared<string>(boost::any_cast<string>(m["Files"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("StoryName") != m.end() && !m["StoryName"].empty()) {
      storyName = make_shared<string>(boost::any_cast<string>(m["StoryName"]));
    }
    if (m.find("StorySubType") != m.end() && !m["StorySubType"].empty()) {
      storySubType = make_shared<string>(boost::any_cast<string>(m["StorySubType"]));
    }
    if (m.find("StoryType") != m.end() && !m["StoryType"].empty()) {
      storyType = make_shared<string>(boost::any_cast<string>(m["StoryType"]));
    }
  }


  virtual ~CreateCustomizedStoryShrinkRequest() = default;
};
class CreateCustomizedStoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> objectId{};
  shared_ptr<string> requestId{};

  CreateCustomizedStoryResponseBody() {}

  explicit CreateCustomizedStoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateCustomizedStoryResponseBody() = default;
};
class CreateCustomizedStoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCustomizedStoryResponseBody> body{};

  CreateCustomizedStoryResponse() {}

  explicit CreateCustomizedStoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCustomizedStoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCustomizedStoryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCustomizedStoryResponse() = default;
};
class CreateDatasetRequest : public Darabonba::Model {
public:
  shared_ptr<long> datasetMaxBindCount{};
  shared_ptr<long> datasetMaxEntityCount{};
  shared_ptr<long> datasetMaxFileCount{};
  shared_ptr<long> datasetMaxRelationCount{};
  shared_ptr<long> datasetMaxTotalFileSize{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> description{};
  shared_ptr<string> projectName{};
  shared_ptr<string> templateId{};

  CreateDatasetRequest() {}

  explicit CreateDatasetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetMaxBindCount) {
      res["DatasetMaxBindCount"] = boost::any(*datasetMaxBindCount);
    }
    if (datasetMaxEntityCount) {
      res["DatasetMaxEntityCount"] = boost::any(*datasetMaxEntityCount);
    }
    if (datasetMaxFileCount) {
      res["DatasetMaxFileCount"] = boost::any(*datasetMaxFileCount);
    }
    if (datasetMaxRelationCount) {
      res["DatasetMaxRelationCount"] = boost::any(*datasetMaxRelationCount);
    }
    if (datasetMaxTotalFileSize) {
      res["DatasetMaxTotalFileSize"] = boost::any(*datasetMaxTotalFileSize);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetMaxBindCount") != m.end() && !m["DatasetMaxBindCount"].empty()) {
      datasetMaxBindCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxBindCount"]));
    }
    if (m.find("DatasetMaxEntityCount") != m.end() && !m["DatasetMaxEntityCount"].empty()) {
      datasetMaxEntityCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxEntityCount"]));
    }
    if (m.find("DatasetMaxFileCount") != m.end() && !m["DatasetMaxFileCount"].empty()) {
      datasetMaxFileCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxFileCount"]));
    }
    if (m.find("DatasetMaxRelationCount") != m.end() && !m["DatasetMaxRelationCount"].empty()) {
      datasetMaxRelationCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxRelationCount"]));
    }
    if (m.find("DatasetMaxTotalFileSize") != m.end() && !m["DatasetMaxTotalFileSize"].empty()) {
      datasetMaxTotalFileSize = make_shared<long>(boost::any_cast<long>(m["DatasetMaxTotalFileSize"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~CreateDatasetRequest() = default;
};
class CreateDatasetResponseBody : public Darabonba::Model {
public:
  shared_ptr<Dataset> dataset{};
  shared_ptr<string> requestId{};

  CreateDatasetResponseBody() {}

  explicit CreateDatasetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataset) {
      res["Dataset"] = dataset ? boost::any(dataset->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dataset") != m.end() && !m["Dataset"].empty()) {
      if (typeid(map<string, boost::any>) == m["Dataset"].type()) {
        Dataset model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Dataset"]));
        dataset = make_shared<Dataset>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateDatasetResponseBody() = default;
};
class CreateDatasetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDatasetResponseBody> body{};

  CreateDatasetResponse() {}

  explicit CreateDatasetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDatasetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDatasetResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDatasetResponse() = default;
};
class CreateDecodeBlindWatermarkTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> imageQuality{};
  shared_ptr<string> model{};
  shared_ptr<Notification> notification{};
  shared_ptr<string> originalImageURI{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceURI{};
  shared_ptr<string> strengthLevel{};
  shared_ptr<string> targetURI{};
  shared_ptr<string> watermarkType{};

  CreateDecodeBlindWatermarkTaskRequest() {}

  explicit CreateDecodeBlindWatermarkTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageQuality) {
      res["ImageQuality"] = boost::any(*imageQuality);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (originalImageURI) {
      res["OriginalImageURI"] = boost::any(*originalImageURI);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    if (strengthLevel) {
      res["StrengthLevel"] = boost::any(*strengthLevel);
    }
    if (targetURI) {
      res["TargetURI"] = boost::any(*targetURI);
    }
    if (watermarkType) {
      res["WatermarkType"] = boost::any(*watermarkType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageQuality") != m.end() && !m["ImageQuality"].empty()) {
      imageQuality = make_shared<long>(boost::any_cast<long>(m["ImageQuality"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        Notification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<Notification>(model1);
      }
    }
    if (m.find("OriginalImageURI") != m.end() && !m["OriginalImageURI"].empty()) {
      originalImageURI = make_shared<string>(boost::any_cast<string>(m["OriginalImageURI"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
    if (m.find("StrengthLevel") != m.end() && !m["StrengthLevel"].empty()) {
      strengthLevel = make_shared<string>(boost::any_cast<string>(m["StrengthLevel"]));
    }
    if (m.find("TargetURI") != m.end() && !m["TargetURI"].empty()) {
      targetURI = make_shared<string>(boost::any_cast<string>(m["TargetURI"]));
    }
    if (m.find("WatermarkType") != m.end() && !m["WatermarkType"].empty()) {
      watermarkType = make_shared<string>(boost::any_cast<string>(m["WatermarkType"]));
    }
  }


  virtual ~CreateDecodeBlindWatermarkTaskRequest() = default;
};
class CreateDecodeBlindWatermarkTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> imageQuality{};
  shared_ptr<string> model{};
  shared_ptr<string> notificationShrink{};
  shared_ptr<string> originalImageURI{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceURI{};
  shared_ptr<string> strengthLevel{};
  shared_ptr<string> targetURI{};
  shared_ptr<string> watermarkType{};

  CreateDecodeBlindWatermarkTaskShrinkRequest() {}

  explicit CreateDecodeBlindWatermarkTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageQuality) {
      res["ImageQuality"] = boost::any(*imageQuality);
    }
    if (model) {
      res["Model"] = boost::any(*model);
    }
    if (notificationShrink) {
      res["Notification"] = boost::any(*notificationShrink);
    }
    if (originalImageURI) {
      res["OriginalImageURI"] = boost::any(*originalImageURI);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    if (strengthLevel) {
      res["StrengthLevel"] = boost::any(*strengthLevel);
    }
    if (targetURI) {
      res["TargetURI"] = boost::any(*targetURI);
    }
    if (watermarkType) {
      res["WatermarkType"] = boost::any(*watermarkType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageQuality") != m.end() && !m["ImageQuality"].empty()) {
      imageQuality = make_shared<long>(boost::any_cast<long>(m["ImageQuality"]));
    }
    if (m.find("Model") != m.end() && !m["Model"].empty()) {
      model = make_shared<string>(boost::any_cast<string>(m["Model"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      notificationShrink = make_shared<string>(boost::any_cast<string>(m["Notification"]));
    }
    if (m.find("OriginalImageURI") != m.end() && !m["OriginalImageURI"].empty()) {
      originalImageURI = make_shared<string>(boost::any_cast<string>(m["OriginalImageURI"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
    if (m.find("StrengthLevel") != m.end() && !m["StrengthLevel"].empty()) {
      strengthLevel = make_shared<string>(boost::any_cast<string>(m["StrengthLevel"]));
    }
    if (m.find("TargetURI") != m.end() && !m["TargetURI"].empty()) {
      targetURI = make_shared<string>(boost::any_cast<string>(m["TargetURI"]));
    }
    if (m.find("WatermarkType") != m.end() && !m["WatermarkType"].empty()) {
      watermarkType = make_shared<string>(boost::any_cast<string>(m["WatermarkType"]));
    }
  }


  virtual ~CreateDecodeBlindWatermarkTaskShrinkRequest() = default;
};
class CreateDecodeBlindWatermarkTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> eventId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  CreateDecodeBlindWatermarkTaskResponseBody() {}

  explicit CreateDecodeBlindWatermarkTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateDecodeBlindWatermarkTaskResponseBody() = default;
};
class CreateDecodeBlindWatermarkTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDecodeBlindWatermarkTaskResponseBody> body{};

  CreateDecodeBlindWatermarkTaskResponse() {}

  explicit CreateDecodeBlindWatermarkTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDecodeBlindWatermarkTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDecodeBlindWatermarkTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDecodeBlindWatermarkTaskResponse() = default;
};
class CreateFacesSearchingTaskRequestSources : public Darabonba::Model {
public:
  shared_ptr<string> URI{};

  CreateFacesSearchingTaskRequestSources() {}

  explicit CreateFacesSearchingTaskRequestSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~CreateFacesSearchingTaskRequestSources() = default;
};
class CreateFacesSearchingTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<long> maxResult{};
  shared_ptr<Notification> notification{};
  shared_ptr<string> projectName{};
  shared_ptr<vector<CreateFacesSearchingTaskRequestSources>> sources{};
  shared_ptr<string> userData{};

  CreateFacesSearchingTaskRequest() {}

  explicit CreateFacesSearchingTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (maxResult) {
      res["MaxResult"] = boost::any(*maxResult);
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sources) {
      vector<boost::any> temp1;
      for(auto item1:*sources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sources"] = boost::any(temp1);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("MaxResult") != m.end() && !m["MaxResult"].empty()) {
      maxResult = make_shared<long>(boost::any_cast<long>(m["MaxResult"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        Notification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<Notification>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      if (typeid(vector<boost::any>) == m["Sources"].type()) {
        vector<CreateFacesSearchingTaskRequestSources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateFacesSearchingTaskRequestSources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sources = make_shared<vector<CreateFacesSearchingTaskRequestSources>>(expect1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateFacesSearchingTaskRequest() = default;
};
class CreateFacesSearchingTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<long> maxResult{};
  shared_ptr<string> notificationShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourcesShrink{};
  shared_ptr<string> userData{};

  CreateFacesSearchingTaskShrinkRequest() {}

  explicit CreateFacesSearchingTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (maxResult) {
      res["MaxResult"] = boost::any(*maxResult);
    }
    if (notificationShrink) {
      res["Notification"] = boost::any(*notificationShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourcesShrink) {
      res["Sources"] = boost::any(*sourcesShrink);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("MaxResult") != m.end() && !m["MaxResult"].empty()) {
      maxResult = make_shared<long>(boost::any_cast<long>(m["MaxResult"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      notificationShrink = make_shared<string>(boost::any_cast<string>(m["Notification"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      sourcesShrink = make_shared<string>(boost::any_cast<string>(m["Sources"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateFacesSearchingTaskShrinkRequest() = default;
};
class CreateFacesSearchingTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> eventId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  CreateFacesSearchingTaskResponseBody() {}

  explicit CreateFacesSearchingTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateFacesSearchingTaskResponseBody() = default;
};
class CreateFacesSearchingTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFacesSearchingTaskResponseBody> body{};

  CreateFacesSearchingTaskResponse() {}

  explicit CreateFacesSearchingTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFacesSearchingTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFacesSearchingTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFacesSearchingTaskResponse() = default;
};
class CreateFigureClusteringTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<Notification> notification{};
  shared_ptr<string> projectName{};
  shared_ptr<map<string, boost::any>> tags{};
  shared_ptr<string> userData{};

  CreateFigureClusteringTaskRequest() {}

  explicit CreateFigureClusteringTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        Notification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<Notification>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Tags"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateFigureClusteringTaskRequest() = default;
};
class CreateFigureClusteringTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> notificationShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> tagsShrink{};
  shared_ptr<string> userData{};

  CreateFigureClusteringTaskShrinkRequest() {}

  explicit CreateFigureClusteringTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (notificationShrink) {
      res["Notification"] = boost::any(*notificationShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      notificationShrink = make_shared<string>(boost::any_cast<string>(m["Notification"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateFigureClusteringTaskShrinkRequest() = default;
};
class CreateFigureClusteringTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> eventId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  CreateFigureClusteringTaskResponseBody() {}

  explicit CreateFigureClusteringTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateFigureClusteringTaskResponseBody() = default;
};
class CreateFigureClusteringTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFigureClusteringTaskResponseBody> body{};

  CreateFigureClusteringTaskResponse() {}

  explicit CreateFigureClusteringTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFigureClusteringTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFigureClusteringTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFigureClusteringTaskResponse() = default;
};
class CreateFigureClustersMergingTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> from{};
  shared_ptr<vector<string>> froms{};
  shared_ptr<Notification> notification{};
  shared_ptr<string> projectName{};
  shared_ptr<map<string, boost::any>> tags{};
  shared_ptr<string> to{};
  shared_ptr<string> userData{};

  CreateFigureClustersMergingTaskRequest() {}

  explicit CreateFigureClustersMergingTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (froms) {
      res["Froms"] = boost::any(*froms);
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("Froms") != m.end() && !m["Froms"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Froms"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Froms"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      froms = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        Notification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<Notification>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Tags"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<string>(boost::any_cast<string>(m["To"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateFigureClustersMergingTaskRequest() = default;
};
class CreateFigureClustersMergingTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> from{};
  shared_ptr<string> fromsShrink{};
  shared_ptr<string> notificationShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> tagsShrink{};
  shared_ptr<string> to{};
  shared_ptr<string> userData{};

  CreateFigureClustersMergingTaskShrinkRequest() {}

  explicit CreateFigureClustersMergingTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (from) {
      res["From"] = boost::any(*from);
    }
    if (fromsShrink) {
      res["Froms"] = boost::any(*fromsShrink);
    }
    if (notificationShrink) {
      res["Notification"] = boost::any(*notificationShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    if (to) {
      res["To"] = boost::any(*to);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("From") != m.end() && !m["From"].empty()) {
      from = make_shared<string>(boost::any_cast<string>(m["From"]));
    }
    if (m.find("Froms") != m.end() && !m["Froms"].empty()) {
      fromsShrink = make_shared<string>(boost::any_cast<string>(m["Froms"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      notificationShrink = make_shared<string>(boost::any_cast<string>(m["Notification"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("To") != m.end() && !m["To"].empty()) {
      to = make_shared<string>(boost::any_cast<string>(m["To"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateFigureClustersMergingTaskShrinkRequest() = default;
};
class CreateFigureClustersMergingTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> eventId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  CreateFigureClustersMergingTaskResponseBody() {}

  explicit CreateFigureClustersMergingTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateFigureClustersMergingTaskResponseBody() = default;
};
class CreateFigureClustersMergingTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFigureClustersMergingTaskResponseBody> body{};

  CreateFigureClustersMergingTaskResponse() {}

  explicit CreateFigureClustersMergingTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFigureClustersMergingTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFigureClustersMergingTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFigureClustersMergingTaskResponse() = default;
};
class CreateFileCompressionTaskRequestSources : public Darabonba::Model {
public:
  shared_ptr<string> alias{};
  shared_ptr<string> mode{};
  shared_ptr<string> URI{};

  CreateFileCompressionTaskRequestSources() {}

  explicit CreateFileCompressionTaskRequestSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alias) {
      res["Alias"] = boost::any(*alias);
    }
    if (mode) {
      res["Mode"] = boost::any(*mode);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Alias") != m.end() && !m["Alias"].empty()) {
      alias = make_shared<string>(boost::any_cast<string>(m["Alias"]));
    }
    if (m.find("Mode") != m.end() && !m["Mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["Mode"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~CreateFileCompressionTaskRequestSources() = default;
};
class CreateFileCompressionTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> compressedFormat{};
  shared_ptr<CredentialConfig> credentialConfig{};
  shared_ptr<Notification> notification{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceManifestURI{};
  shared_ptr<vector<CreateFileCompressionTaskRequestSources>> sources{};
  shared_ptr<string> targetURI{};
  shared_ptr<string> userData{};

  CreateFileCompressionTaskRequest() {}

  explicit CreateFileCompressionTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compressedFormat) {
      res["CompressedFormat"] = boost::any(*compressedFormat);
    }
    if (credentialConfig) {
      res["CredentialConfig"] = credentialConfig ? boost::any(credentialConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceManifestURI) {
      res["SourceManifestURI"] = boost::any(*sourceManifestURI);
    }
    if (sources) {
      vector<boost::any> temp1;
      for(auto item1:*sources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sources"] = boost::any(temp1);
    }
    if (targetURI) {
      res["TargetURI"] = boost::any(*targetURI);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompressedFormat") != m.end() && !m["CompressedFormat"].empty()) {
      compressedFormat = make_shared<string>(boost::any_cast<string>(m["CompressedFormat"]));
    }
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CredentialConfig"].type()) {
        CredentialConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CredentialConfig"]));
        credentialConfig = make_shared<CredentialConfig>(model1);
      }
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        Notification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<Notification>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceManifestURI") != m.end() && !m["SourceManifestURI"].empty()) {
      sourceManifestURI = make_shared<string>(boost::any_cast<string>(m["SourceManifestURI"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      if (typeid(vector<boost::any>) == m["Sources"].type()) {
        vector<CreateFileCompressionTaskRequestSources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateFileCompressionTaskRequestSources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sources = make_shared<vector<CreateFileCompressionTaskRequestSources>>(expect1);
      }
    }
    if (m.find("TargetURI") != m.end() && !m["TargetURI"].empty()) {
      targetURI = make_shared<string>(boost::any_cast<string>(m["TargetURI"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateFileCompressionTaskRequest() = default;
};
class CreateFileCompressionTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> compressedFormat{};
  shared_ptr<string> credentialConfigShrink{};
  shared_ptr<string> notificationShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceManifestURI{};
  shared_ptr<string> sourcesShrink{};
  shared_ptr<string> targetURI{};
  shared_ptr<string> userData{};

  CreateFileCompressionTaskShrinkRequest() {}

  explicit CreateFileCompressionTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (compressedFormat) {
      res["CompressedFormat"] = boost::any(*compressedFormat);
    }
    if (credentialConfigShrink) {
      res["CredentialConfig"] = boost::any(*credentialConfigShrink);
    }
    if (notificationShrink) {
      res["Notification"] = boost::any(*notificationShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceManifestURI) {
      res["SourceManifestURI"] = boost::any(*sourceManifestURI);
    }
    if (sourcesShrink) {
      res["Sources"] = boost::any(*sourcesShrink);
    }
    if (targetURI) {
      res["TargetURI"] = boost::any(*targetURI);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CompressedFormat") != m.end() && !m["CompressedFormat"].empty()) {
      compressedFormat = make_shared<string>(boost::any_cast<string>(m["CompressedFormat"]));
    }
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      credentialConfigShrink = make_shared<string>(boost::any_cast<string>(m["CredentialConfig"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      notificationShrink = make_shared<string>(boost::any_cast<string>(m["Notification"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceManifestURI") != m.end() && !m["SourceManifestURI"].empty()) {
      sourceManifestURI = make_shared<string>(boost::any_cast<string>(m["SourceManifestURI"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      sourcesShrink = make_shared<string>(boost::any_cast<string>(m["Sources"]));
    }
    if (m.find("TargetURI") != m.end() && !m["TargetURI"].empty()) {
      targetURI = make_shared<string>(boost::any_cast<string>(m["TargetURI"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateFileCompressionTaskShrinkRequest() = default;
};
class CreateFileCompressionTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> eventId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  CreateFileCompressionTaskResponseBody() {}

  explicit CreateFileCompressionTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateFileCompressionTaskResponseBody() = default;
};
class CreateFileCompressionTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFileCompressionTaskResponseBody> body{};

  CreateFileCompressionTaskResponse() {}

  explicit CreateFileCompressionTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFileCompressionTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFileCompressionTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFileCompressionTaskResponse() = default;
};
class CreateFileUncompressionTaskRequest : public Darabonba::Model {
public:
  shared_ptr<CredentialConfig> credentialConfig{};
  shared_ptr<Notification> notification{};
  shared_ptr<string> password{};
  shared_ptr<string> projectName{};
  shared_ptr<vector<string>> selectedFiles{};
  shared_ptr<string> sourceURI{};
  shared_ptr<string> targetURI{};
  shared_ptr<string> userData{};

  CreateFileUncompressionTaskRequest() {}

  explicit CreateFileUncompressionTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfig) {
      res["CredentialConfig"] = credentialConfig ? boost::any(credentialConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (selectedFiles) {
      res["SelectedFiles"] = boost::any(*selectedFiles);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    if (targetURI) {
      res["TargetURI"] = boost::any(*targetURI);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CredentialConfig"].type()) {
        CredentialConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CredentialConfig"]));
        credentialConfig = make_shared<CredentialConfig>(model1);
      }
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        Notification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<Notification>(model1);
      }
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SelectedFiles") != m.end() && !m["SelectedFiles"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["SelectedFiles"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["SelectedFiles"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      selectedFiles = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
    if (m.find("TargetURI") != m.end() && !m["TargetURI"].empty()) {
      targetURI = make_shared<string>(boost::any_cast<string>(m["TargetURI"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateFileUncompressionTaskRequest() = default;
};
class CreateFileUncompressionTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> credentialConfigShrink{};
  shared_ptr<string> notificationShrink{};
  shared_ptr<string> password{};
  shared_ptr<string> projectName{};
  shared_ptr<string> selectedFilesShrink{};
  shared_ptr<string> sourceURI{};
  shared_ptr<string> targetURI{};
  shared_ptr<string> userData{};

  CreateFileUncompressionTaskShrinkRequest() {}

  explicit CreateFileUncompressionTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfigShrink) {
      res["CredentialConfig"] = boost::any(*credentialConfigShrink);
    }
    if (notificationShrink) {
      res["Notification"] = boost::any(*notificationShrink);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (selectedFilesShrink) {
      res["SelectedFiles"] = boost::any(*selectedFilesShrink);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    if (targetURI) {
      res["TargetURI"] = boost::any(*targetURI);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      credentialConfigShrink = make_shared<string>(boost::any_cast<string>(m["CredentialConfig"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      notificationShrink = make_shared<string>(boost::any_cast<string>(m["Notification"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SelectedFiles") != m.end() && !m["SelectedFiles"].empty()) {
      selectedFilesShrink = make_shared<string>(boost::any_cast<string>(m["SelectedFiles"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
    if (m.find("TargetURI") != m.end() && !m["TargetURI"].empty()) {
      targetURI = make_shared<string>(boost::any_cast<string>(m["TargetURI"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateFileUncompressionTaskShrinkRequest() = default;
};
class CreateFileUncompressionTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> eventId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  CreateFileUncompressionTaskResponseBody() {}

  explicit CreateFileUncompressionTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateFileUncompressionTaskResponseBody() = default;
};
class CreateFileUncompressionTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateFileUncompressionTaskResponseBody> body{};

  CreateFileUncompressionTaskResponse() {}

  explicit CreateFileUncompressionTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateFileUncompressionTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateFileUncompressionTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateFileUncompressionTaskResponse() = default;
};
class CreateImageModerationTaskRequest : public Darabonba::Model {
public:
  shared_ptr<CredentialConfig> credentialConfig{};
  shared_ptr<long> interval{};
  shared_ptr<long> maxFrames{};
  shared_ptr<Notification> notification{};
  shared_ptr<string> projectName{};
  shared_ptr<vector<string>> scenes{};
  shared_ptr<string> sourceURI{};
  shared_ptr<map<string, boost::any>> tags{};
  shared_ptr<string> userData{};

  CreateImageModerationTaskRequest() {}

  explicit CreateImageModerationTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfig) {
      res["CredentialConfig"] = credentialConfig ? boost::any(credentialConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (maxFrames) {
      res["MaxFrames"] = boost::any(*maxFrames);
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (scenes) {
      res["Scenes"] = boost::any(*scenes);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CredentialConfig"].type()) {
        CredentialConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CredentialConfig"]));
        credentialConfig = make_shared<CredentialConfig>(model1);
      }
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("MaxFrames") != m.end() && !m["MaxFrames"].empty()) {
      maxFrames = make_shared<long>(boost::any_cast<long>(m["MaxFrames"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        Notification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<Notification>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Scenes") != m.end() && !m["Scenes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Scenes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Scenes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scenes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Tags"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateImageModerationTaskRequest() = default;
};
class CreateImageModerationTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> credentialConfigShrink{};
  shared_ptr<long> interval{};
  shared_ptr<long> maxFrames{};
  shared_ptr<string> notificationShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> scenesShrink{};
  shared_ptr<string> sourceURI{};
  shared_ptr<string> tagsShrink{};
  shared_ptr<string> userData{};

  CreateImageModerationTaskShrinkRequest() {}

  explicit CreateImageModerationTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfigShrink) {
      res["CredentialConfig"] = boost::any(*credentialConfigShrink);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (maxFrames) {
      res["MaxFrames"] = boost::any(*maxFrames);
    }
    if (notificationShrink) {
      res["Notification"] = boost::any(*notificationShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (scenesShrink) {
      res["Scenes"] = boost::any(*scenesShrink);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      credentialConfigShrink = make_shared<string>(boost::any_cast<string>(m["CredentialConfig"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("MaxFrames") != m.end() && !m["MaxFrames"].empty()) {
      maxFrames = make_shared<long>(boost::any_cast<long>(m["MaxFrames"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      notificationShrink = make_shared<string>(boost::any_cast<string>(m["Notification"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Scenes") != m.end() && !m["Scenes"].empty()) {
      scenesShrink = make_shared<string>(boost::any_cast<string>(m["Scenes"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateImageModerationTaskShrinkRequest() = default;
};
class CreateImageModerationTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> eventId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  CreateImageModerationTaskResponseBody() {}

  explicit CreateImageModerationTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateImageModerationTaskResponseBody() = default;
};
class CreateImageModerationTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateImageModerationTaskResponseBody> body{};

  CreateImageModerationTaskResponse() {}

  explicit CreateImageModerationTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateImageModerationTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateImageModerationTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateImageModerationTaskResponse() = default;
};
class CreateImageSplicingTaskRequestSources : public Darabonba::Model {
public:
  shared_ptr<long> rotate{};
  shared_ptr<string> URI{};

  CreateImageSplicingTaskRequestSources() {}

  explicit CreateImageSplicingTaskRequestSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<long>(boost::any_cast<long>(m["Rotate"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~CreateImageSplicingTaskRequestSources() = default;
};
class CreateImageSplicingTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> align{};
  shared_ptr<string> backgroundColor{};
  shared_ptr<CredentialConfig> credentialConfig{};
  shared_ptr<string> direction{};
  shared_ptr<string> imageFormat{};
  shared_ptr<long> margin{};
  shared_ptr<Notification> notification{};
  shared_ptr<long> padding{};
  shared_ptr<string> projectName{};
  shared_ptr<long> quality{};
  shared_ptr<string> scaleType{};
  shared_ptr<vector<CreateImageSplicingTaskRequestSources>> sources{};
  shared_ptr<map<string, boost::any>> tags{};
  shared_ptr<string> targetURI{};
  shared_ptr<string> userData{};

  CreateImageSplicingTaskRequest() {}

  explicit CreateImageSplicingTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (align) {
      res["Align"] = boost::any(*align);
    }
    if (backgroundColor) {
      res["BackgroundColor"] = boost::any(*backgroundColor);
    }
    if (credentialConfig) {
      res["CredentialConfig"] = credentialConfig ? boost::any(credentialConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (imageFormat) {
      res["ImageFormat"] = boost::any(*imageFormat);
    }
    if (margin) {
      res["Margin"] = boost::any(*margin);
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (padding) {
      res["Padding"] = boost::any(*padding);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (quality) {
      res["Quality"] = boost::any(*quality);
    }
    if (scaleType) {
      res["ScaleType"] = boost::any(*scaleType);
    }
    if (sources) {
      vector<boost::any> temp1;
      for(auto item1:*sources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sources"] = boost::any(temp1);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (targetURI) {
      res["TargetURI"] = boost::any(*targetURI);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Align") != m.end() && !m["Align"].empty()) {
      align = make_shared<long>(boost::any_cast<long>(m["Align"]));
    }
    if (m.find("BackgroundColor") != m.end() && !m["BackgroundColor"].empty()) {
      backgroundColor = make_shared<string>(boost::any_cast<string>(m["BackgroundColor"]));
    }
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CredentialConfig"].type()) {
        CredentialConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CredentialConfig"]));
        credentialConfig = make_shared<CredentialConfig>(model1);
      }
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("ImageFormat") != m.end() && !m["ImageFormat"].empty()) {
      imageFormat = make_shared<string>(boost::any_cast<string>(m["ImageFormat"]));
    }
    if (m.find("Margin") != m.end() && !m["Margin"].empty()) {
      margin = make_shared<long>(boost::any_cast<long>(m["Margin"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        Notification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<Notification>(model1);
      }
    }
    if (m.find("Padding") != m.end() && !m["Padding"].empty()) {
      padding = make_shared<long>(boost::any_cast<long>(m["Padding"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Quality") != m.end() && !m["Quality"].empty()) {
      quality = make_shared<long>(boost::any_cast<long>(m["Quality"]));
    }
    if (m.find("ScaleType") != m.end() && !m["ScaleType"].empty()) {
      scaleType = make_shared<string>(boost::any_cast<string>(m["ScaleType"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      if (typeid(vector<boost::any>) == m["Sources"].type()) {
        vector<CreateImageSplicingTaskRequestSources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateImageSplicingTaskRequestSources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sources = make_shared<vector<CreateImageSplicingTaskRequestSources>>(expect1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Tags"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("TargetURI") != m.end() && !m["TargetURI"].empty()) {
      targetURI = make_shared<string>(boost::any_cast<string>(m["TargetURI"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateImageSplicingTaskRequest() = default;
};
class CreateImageSplicingTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> align{};
  shared_ptr<string> backgroundColor{};
  shared_ptr<string> credentialConfigShrink{};
  shared_ptr<string> direction{};
  shared_ptr<string> imageFormat{};
  shared_ptr<long> margin{};
  shared_ptr<string> notificationShrink{};
  shared_ptr<long> padding{};
  shared_ptr<string> projectName{};
  shared_ptr<long> quality{};
  shared_ptr<string> scaleType{};
  shared_ptr<string> sourcesShrink{};
  shared_ptr<string> tagsShrink{};
  shared_ptr<string> targetURI{};
  shared_ptr<string> userData{};

  CreateImageSplicingTaskShrinkRequest() {}

  explicit CreateImageSplicingTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (align) {
      res["Align"] = boost::any(*align);
    }
    if (backgroundColor) {
      res["BackgroundColor"] = boost::any(*backgroundColor);
    }
    if (credentialConfigShrink) {
      res["CredentialConfig"] = boost::any(*credentialConfigShrink);
    }
    if (direction) {
      res["Direction"] = boost::any(*direction);
    }
    if (imageFormat) {
      res["ImageFormat"] = boost::any(*imageFormat);
    }
    if (margin) {
      res["Margin"] = boost::any(*margin);
    }
    if (notificationShrink) {
      res["Notification"] = boost::any(*notificationShrink);
    }
    if (padding) {
      res["Padding"] = boost::any(*padding);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (quality) {
      res["Quality"] = boost::any(*quality);
    }
    if (scaleType) {
      res["ScaleType"] = boost::any(*scaleType);
    }
    if (sourcesShrink) {
      res["Sources"] = boost::any(*sourcesShrink);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    if (targetURI) {
      res["TargetURI"] = boost::any(*targetURI);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Align") != m.end() && !m["Align"].empty()) {
      align = make_shared<long>(boost::any_cast<long>(m["Align"]));
    }
    if (m.find("BackgroundColor") != m.end() && !m["BackgroundColor"].empty()) {
      backgroundColor = make_shared<string>(boost::any_cast<string>(m["BackgroundColor"]));
    }
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      credentialConfigShrink = make_shared<string>(boost::any_cast<string>(m["CredentialConfig"]));
    }
    if (m.find("Direction") != m.end() && !m["Direction"].empty()) {
      direction = make_shared<string>(boost::any_cast<string>(m["Direction"]));
    }
    if (m.find("ImageFormat") != m.end() && !m["ImageFormat"].empty()) {
      imageFormat = make_shared<string>(boost::any_cast<string>(m["ImageFormat"]));
    }
    if (m.find("Margin") != m.end() && !m["Margin"].empty()) {
      margin = make_shared<long>(boost::any_cast<long>(m["Margin"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      notificationShrink = make_shared<string>(boost::any_cast<string>(m["Notification"]));
    }
    if (m.find("Padding") != m.end() && !m["Padding"].empty()) {
      padding = make_shared<long>(boost::any_cast<long>(m["Padding"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Quality") != m.end() && !m["Quality"].empty()) {
      quality = make_shared<long>(boost::any_cast<long>(m["Quality"]));
    }
    if (m.find("ScaleType") != m.end() && !m["ScaleType"].empty()) {
      scaleType = make_shared<string>(boost::any_cast<string>(m["ScaleType"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      sourcesShrink = make_shared<string>(boost::any_cast<string>(m["Sources"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("TargetURI") != m.end() && !m["TargetURI"].empty()) {
      targetURI = make_shared<string>(boost::any_cast<string>(m["TargetURI"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateImageSplicingTaskShrinkRequest() = default;
};
class CreateImageSplicingTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> eventId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  CreateImageSplicingTaskResponseBody() {}

  explicit CreateImageSplicingTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateImageSplicingTaskResponseBody() = default;
};
class CreateImageSplicingTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateImageSplicingTaskResponseBody> body{};

  CreateImageSplicingTaskResponse() {}

  explicit CreateImageSplicingTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateImageSplicingTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateImageSplicingTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateImageSplicingTaskResponse() = default;
};
class CreateImageToPDFTaskRequestSources : public Darabonba::Model {
public:
  shared_ptr<long> rotate{};
  shared_ptr<string> URI{};

  CreateImageToPDFTaskRequestSources() {}

  explicit CreateImageToPDFTaskRequestSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<long>(boost::any_cast<long>(m["Rotate"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~CreateImageToPDFTaskRequestSources() = default;
};
class CreateImageToPDFTaskRequest : public Darabonba::Model {
public:
  shared_ptr<CredentialConfig> credentialConfig{};
  shared_ptr<Notification> notification{};
  shared_ptr<string> projectName{};
  shared_ptr<vector<CreateImageToPDFTaskRequestSources>> sources{};
  shared_ptr<map<string, boost::any>> tags{};
  shared_ptr<string> targetURI{};
  shared_ptr<string> userData{};

  CreateImageToPDFTaskRequest() {}

  explicit CreateImageToPDFTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfig) {
      res["CredentialConfig"] = credentialConfig ? boost::any(credentialConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sources) {
      vector<boost::any> temp1;
      for(auto item1:*sources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sources"] = boost::any(temp1);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (targetURI) {
      res["TargetURI"] = boost::any(*targetURI);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CredentialConfig"].type()) {
        CredentialConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CredentialConfig"]));
        credentialConfig = make_shared<CredentialConfig>(model1);
      }
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        Notification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<Notification>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      if (typeid(vector<boost::any>) == m["Sources"].type()) {
        vector<CreateImageToPDFTaskRequestSources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateImageToPDFTaskRequestSources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sources = make_shared<vector<CreateImageToPDFTaskRequestSources>>(expect1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Tags"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("TargetURI") != m.end() && !m["TargetURI"].empty()) {
      targetURI = make_shared<string>(boost::any_cast<string>(m["TargetURI"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateImageToPDFTaskRequest() = default;
};
class CreateImageToPDFTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> credentialConfigShrink{};
  shared_ptr<string> notificationShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourcesShrink{};
  shared_ptr<string> tagsShrink{};
  shared_ptr<string> targetURI{};
  shared_ptr<string> userData{};

  CreateImageToPDFTaskShrinkRequest() {}

  explicit CreateImageToPDFTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfigShrink) {
      res["CredentialConfig"] = boost::any(*credentialConfigShrink);
    }
    if (notificationShrink) {
      res["Notification"] = boost::any(*notificationShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourcesShrink) {
      res["Sources"] = boost::any(*sourcesShrink);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    if (targetURI) {
      res["TargetURI"] = boost::any(*targetURI);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      credentialConfigShrink = make_shared<string>(boost::any_cast<string>(m["CredentialConfig"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      notificationShrink = make_shared<string>(boost::any_cast<string>(m["Notification"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      sourcesShrink = make_shared<string>(boost::any_cast<string>(m["Sources"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("TargetURI") != m.end() && !m["TargetURI"].empty()) {
      targetURI = make_shared<string>(boost::any_cast<string>(m["TargetURI"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateImageToPDFTaskShrinkRequest() = default;
};
class CreateImageToPDFTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> eventId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  CreateImageToPDFTaskResponseBody() {}

  explicit CreateImageToPDFTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateImageToPDFTaskResponseBody() = default;
};
class CreateImageToPDFTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateImageToPDFTaskResponseBody> body{};

  CreateImageToPDFTaskResponse() {}

  explicit CreateImageToPDFTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateImageToPDFTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateImageToPDFTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateImageToPDFTaskResponse() = default;
};
class CreateLocationDateClusteringTaskRequestDateOptions : public Darabonba::Model {
public:
  shared_ptr<long> gapDays{};
  shared_ptr<long> maxDays{};
  shared_ptr<long> minDays{};

  CreateLocationDateClusteringTaskRequestDateOptions() {}

  explicit CreateLocationDateClusteringTaskRequestDateOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gapDays) {
      res["GapDays"] = boost::any(*gapDays);
    }
    if (maxDays) {
      res["MaxDays"] = boost::any(*maxDays);
    }
    if (minDays) {
      res["MinDays"] = boost::any(*minDays);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("GapDays") != m.end() && !m["GapDays"].empty()) {
      gapDays = make_shared<long>(boost::any_cast<long>(m["GapDays"]));
    }
    if (m.find("MaxDays") != m.end() && !m["MaxDays"].empty()) {
      maxDays = make_shared<long>(boost::any_cast<long>(m["MaxDays"]));
    }
    if (m.find("MinDays") != m.end() && !m["MinDays"].empty()) {
      minDays = make_shared<long>(boost::any_cast<long>(m["MinDays"]));
    }
  }


  virtual ~CreateLocationDateClusteringTaskRequestDateOptions() = default;
};
class CreateLocationDateClusteringTaskRequestLocationOptions : public Darabonba::Model {
public:
  shared_ptr<vector<string>> locationDateClusterLevels{};

  CreateLocationDateClusteringTaskRequestLocationOptions() {}

  explicit CreateLocationDateClusteringTaskRequestLocationOptions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (locationDateClusterLevels) {
      res["LocationDateClusterLevels"] = boost::any(*locationDateClusterLevels);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocationDateClusterLevels") != m.end() && !m["LocationDateClusterLevels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LocationDateClusterLevels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LocationDateClusterLevels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      locationDateClusterLevels = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateLocationDateClusteringTaskRequestLocationOptions() = default;
};
class CreateLocationDateClusteringTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<CreateLocationDateClusteringTaskRequestDateOptions> dateOptions{};
  shared_ptr<CreateLocationDateClusteringTaskRequestLocationOptions> locationOptions{};
  shared_ptr<Notification> notification{};
  shared_ptr<string> projectName{};
  shared_ptr<map<string, boost::any>> tags{};
  shared_ptr<string> userData{};

  CreateLocationDateClusteringTaskRequest() {}

  explicit CreateLocationDateClusteringTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (dateOptions) {
      res["DateOptions"] = dateOptions ? boost::any(dateOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (locationOptions) {
      res["LocationOptions"] = locationOptions ? boost::any(locationOptions->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("DateOptions") != m.end() && !m["DateOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["DateOptions"].type()) {
        CreateLocationDateClusteringTaskRequestDateOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["DateOptions"]));
        dateOptions = make_shared<CreateLocationDateClusteringTaskRequestDateOptions>(model1);
      }
    }
    if (m.find("LocationOptions") != m.end() && !m["LocationOptions"].empty()) {
      if (typeid(map<string, boost::any>) == m["LocationOptions"].type()) {
        CreateLocationDateClusteringTaskRequestLocationOptions model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LocationOptions"]));
        locationOptions = make_shared<CreateLocationDateClusteringTaskRequestLocationOptions>(model1);
      }
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        Notification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<Notification>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Tags"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateLocationDateClusteringTaskRequest() = default;
};
class CreateLocationDateClusteringTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> dateOptionsShrink{};
  shared_ptr<string> locationOptionsShrink{};
  shared_ptr<string> notificationShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> tagsShrink{};
  shared_ptr<string> userData{};

  CreateLocationDateClusteringTaskShrinkRequest() {}

  explicit CreateLocationDateClusteringTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (dateOptionsShrink) {
      res["DateOptions"] = boost::any(*dateOptionsShrink);
    }
    if (locationOptionsShrink) {
      res["LocationOptions"] = boost::any(*locationOptionsShrink);
    }
    if (notificationShrink) {
      res["Notification"] = boost::any(*notificationShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("DateOptions") != m.end() && !m["DateOptions"].empty()) {
      dateOptionsShrink = make_shared<string>(boost::any_cast<string>(m["DateOptions"]));
    }
    if (m.find("LocationOptions") != m.end() && !m["LocationOptions"].empty()) {
      locationOptionsShrink = make_shared<string>(boost::any_cast<string>(m["LocationOptions"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      notificationShrink = make_shared<string>(boost::any_cast<string>(m["Notification"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateLocationDateClusteringTaskShrinkRequest() = default;
};
class CreateLocationDateClusteringTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> eventId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  CreateLocationDateClusteringTaskResponseBody() {}

  explicit CreateLocationDateClusteringTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateLocationDateClusteringTaskResponseBody() = default;
};
class CreateLocationDateClusteringTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLocationDateClusteringTaskResponseBody> body{};

  CreateLocationDateClusteringTaskResponse() {}

  explicit CreateLocationDateClusteringTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLocationDateClusteringTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLocationDateClusteringTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLocationDateClusteringTaskResponse() = default;
};
class CreateMediaConvertTaskRequestSourcesSubtitles : public Darabonba::Model {
public:
  shared_ptr<string> language{};
  shared_ptr<double> timeOffset{};
  shared_ptr<string> URI{};

  CreateMediaConvertTaskRequestSourcesSubtitles() {}

  explicit CreateMediaConvertTaskRequestSourcesSubtitles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (timeOffset) {
      res["TimeOffset"] = boost::any(*timeOffset);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("TimeOffset") != m.end() && !m["TimeOffset"].empty()) {
      timeOffset = make_shared<double>(boost::any_cast<double>(m["TimeOffset"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~CreateMediaConvertTaskRequestSourcesSubtitles() = default;
};
class CreateMediaConvertTaskRequestSources : public Darabonba::Model {
public:
  shared_ptr<double> duration{};
  shared_ptr<double> startTime{};
  shared_ptr<vector<CreateMediaConvertTaskRequestSourcesSubtitles>> subtitles{};
  shared_ptr<string> URI{};

  CreateMediaConvertTaskRequestSources() {}

  explicit CreateMediaConvertTaskRequestSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (subtitles) {
      vector<boost::any> temp1;
      for(auto item1:*subtitles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitles"] = boost::any(temp1);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<double>(boost::any_cast<double>(m["StartTime"]));
    }
    if (m.find("Subtitles") != m.end() && !m["Subtitles"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitles"].type()) {
        vector<CreateMediaConvertTaskRequestSourcesSubtitles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMediaConvertTaskRequestSourcesSubtitles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitles = make_shared<vector<CreateMediaConvertTaskRequestSourcesSubtitles>>(expect1);
      }
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~CreateMediaConvertTaskRequestSources() = default;
};
class CreateMediaConvertTaskRequestTargetsSegment : public Darabonba::Model {
public:
  shared_ptr<double> duration{};
  shared_ptr<string> format{};
  shared_ptr<long> startNumber{};

  CreateMediaConvertTaskRequestTargetsSegment() {}

  explicit CreateMediaConvertTaskRequestTargetsSegment(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (format) {
      res["Format"] = boost::any(*format);
    }
    if (startNumber) {
      res["StartNumber"] = boost::any(*startNumber);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("Format") != m.end() && !m["Format"].empty()) {
      format = make_shared<string>(boost::any_cast<string>(m["Format"]));
    }
    if (m.find("StartNumber") != m.end() && !m["StartNumber"].empty()) {
      startNumber = make_shared<long>(boost::any_cast<long>(m["StartNumber"]));
    }
  }


  virtual ~CreateMediaConvertTaskRequestTargetsSegment() = default;
};
class CreateMediaConvertTaskRequestTargets : public Darabonba::Model {
public:
  shared_ptr<TargetAudio> audio{};
  shared_ptr<string> container{};
  shared_ptr<TargetImage> image{};
  shared_ptr<CreateMediaConvertTaskRequestTargetsSegment> segment{};
  shared_ptr<double> speed{};
  shared_ptr<bool> stripMetadata{};
  shared_ptr<TargetSubtitle> subtitle{};
  shared_ptr<string> URI{};
  shared_ptr<TargetVideo> video{};

  CreateMediaConvertTaskRequestTargets() {}

  explicit CreateMediaConvertTaskRequestTargets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (container) {
      res["Container"] = boost::any(*container);
    }
    if (image) {
      res["Image"] = image ? boost::any(image->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (segment) {
      res["Segment"] = segment ? boost::any(segment->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (speed) {
      res["Speed"] = boost::any(*speed);
    }
    if (stripMetadata) {
      res["StripMetadata"] = boost::any(*stripMetadata);
    }
    if (subtitle) {
      res["Subtitle"] = subtitle ? boost::any(subtitle->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        TargetAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<TargetAudio>(model1);
      }
    }
    if (m.find("Container") != m.end() && !m["Container"].empty()) {
      container = make_shared<string>(boost::any_cast<string>(m["Container"]));
    }
    if (m.find("Image") != m.end() && !m["Image"].empty()) {
      if (typeid(map<string, boost::any>) == m["Image"].type()) {
        TargetImage model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Image"]));
        image = make_shared<TargetImage>(model1);
      }
    }
    if (m.find("Segment") != m.end() && !m["Segment"].empty()) {
      if (typeid(map<string, boost::any>) == m["Segment"].type()) {
        CreateMediaConvertTaskRequestTargetsSegment model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Segment"]));
        segment = make_shared<CreateMediaConvertTaskRequestTargetsSegment>(model1);
      }
    }
    if (m.find("Speed") != m.end() && !m["Speed"].empty()) {
      speed = make_shared<double>(boost::any_cast<double>(m["Speed"]));
    }
    if (m.find("StripMetadata") != m.end() && !m["StripMetadata"].empty()) {
      stripMetadata = make_shared<bool>(boost::any_cast<bool>(m["StripMetadata"]));
    }
    if (m.find("Subtitle") != m.end() && !m["Subtitle"].empty()) {
      if (typeid(map<string, boost::any>) == m["Subtitle"].type()) {
        TargetSubtitle model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Subtitle"]));
        subtitle = make_shared<TargetSubtitle>(model1);
      }
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        TargetVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<TargetVideo>(model1);
      }
    }
  }


  virtual ~CreateMediaConvertTaskRequestTargets() = default;
};
class CreateMediaConvertTaskRequest : public Darabonba::Model {
public:
  shared_ptr<long> alignmentIndex{};
  shared_ptr<CredentialConfig> credentialConfig{};
  shared_ptr<Notification> notification{};
  shared_ptr<string> projectName{};
  shared_ptr<vector<CreateMediaConvertTaskRequestSources>> sources{};
  shared_ptr<map<string, boost::any>> tags{};
  shared_ptr<vector<CreateMediaConvertTaskRequestTargets>> targets{};
  shared_ptr<string> userData{};

  CreateMediaConvertTaskRequest() {}

  explicit CreateMediaConvertTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alignmentIndex) {
      res["AlignmentIndex"] = boost::any(*alignmentIndex);
    }
    if (credentialConfig) {
      res["CredentialConfig"] = credentialConfig ? boost::any(credentialConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sources) {
      vector<boost::any> temp1;
      for(auto item1:*sources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sources"] = boost::any(temp1);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (targets) {
      vector<boost::any> temp1;
      for(auto item1:*targets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Targets"] = boost::any(temp1);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlignmentIndex") != m.end() && !m["AlignmentIndex"].empty()) {
      alignmentIndex = make_shared<long>(boost::any_cast<long>(m["AlignmentIndex"]));
    }
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CredentialConfig"].type()) {
        CredentialConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CredentialConfig"]));
        credentialConfig = make_shared<CredentialConfig>(model1);
      }
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        Notification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<Notification>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      if (typeid(vector<boost::any>) == m["Sources"].type()) {
        vector<CreateMediaConvertTaskRequestSources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMediaConvertTaskRequestSources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sources = make_shared<vector<CreateMediaConvertTaskRequestSources>>(expect1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Tags"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("Targets") != m.end() && !m["Targets"].empty()) {
      if (typeid(vector<boost::any>) == m["Targets"].type()) {
        vector<CreateMediaConvertTaskRequestTargets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Targets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateMediaConvertTaskRequestTargets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targets = make_shared<vector<CreateMediaConvertTaskRequestTargets>>(expect1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateMediaConvertTaskRequest() = default;
};
class CreateMediaConvertTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> alignmentIndex{};
  shared_ptr<string> credentialConfigShrink{};
  shared_ptr<string> notificationShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourcesShrink{};
  shared_ptr<string> tagsShrink{};
  shared_ptr<string> targetsShrink{};
  shared_ptr<string> userData{};

  CreateMediaConvertTaskShrinkRequest() {}

  explicit CreateMediaConvertTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alignmentIndex) {
      res["AlignmentIndex"] = boost::any(*alignmentIndex);
    }
    if (credentialConfigShrink) {
      res["CredentialConfig"] = boost::any(*credentialConfigShrink);
    }
    if (notificationShrink) {
      res["Notification"] = boost::any(*notificationShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourcesShrink) {
      res["Sources"] = boost::any(*sourcesShrink);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    if (targetsShrink) {
      res["Targets"] = boost::any(*targetsShrink);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AlignmentIndex") != m.end() && !m["AlignmentIndex"].empty()) {
      alignmentIndex = make_shared<long>(boost::any_cast<long>(m["AlignmentIndex"]));
    }
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      credentialConfigShrink = make_shared<string>(boost::any_cast<string>(m["CredentialConfig"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      notificationShrink = make_shared<string>(boost::any_cast<string>(m["Notification"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      sourcesShrink = make_shared<string>(boost::any_cast<string>(m["Sources"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Targets") != m.end() && !m["Targets"].empty()) {
      targetsShrink = make_shared<string>(boost::any_cast<string>(m["Targets"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateMediaConvertTaskShrinkRequest() = default;
};
class CreateMediaConvertTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> eventId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  CreateMediaConvertTaskResponseBody() {}

  explicit CreateMediaConvertTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateMediaConvertTaskResponseBody() = default;
};
class CreateMediaConvertTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateMediaConvertTaskResponseBody> body{};

  CreateMediaConvertTaskResponse() {}

  explicit CreateMediaConvertTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateMediaConvertTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateMediaConvertTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateMediaConvertTaskResponse() = default;
};
class CreateOfficeConversionTaskRequestSources : public Darabonba::Model {
public:
  shared_ptr<long> rotate{};
  shared_ptr<string> URI{};

  CreateOfficeConversionTaskRequestSources() {}

  explicit CreateOfficeConversionTaskRequestSources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (rotate) {
      res["Rotate"] = boost::any(*rotate);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Rotate") != m.end() && !m["Rotate"].empty()) {
      rotate = make_shared<long>(boost::any_cast<long>(m["Rotate"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~CreateOfficeConversionTaskRequestSources() = default;
};
class CreateOfficeConversionTaskRequest : public Darabonba::Model {
public:
  shared_ptr<CredentialConfig> credentialConfig{};
  shared_ptr<long> endPage{};
  shared_ptr<bool> firstPage{};
  shared_ptr<bool> fitToHeight{};
  shared_ptr<bool> fitToWidth{};
  shared_ptr<bool> holdLineFeed{};
  shared_ptr<long> imageDPI{};
  shared_ptr<bool> longPicture{};
  shared_ptr<bool> longText{};
  shared_ptr<long> maxSheetColumn{};
  shared_ptr<long> maxSheetRow{};
  shared_ptr<Notification> notification{};
  shared_ptr<string> pages{};
  shared_ptr<bool> paperHorizontal{};
  shared_ptr<string> paperSize{};
  shared_ptr<string> password{};
  shared_ptr<string> projectName{};
  shared_ptr<long> quality{};
  shared_ptr<long> scalePercentage{};
  shared_ptr<long> sheetCount{};
  shared_ptr<long> sheetIndex{};
  shared_ptr<bool> showComments{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> sourceURI{};
  shared_ptr<vector<CreateOfficeConversionTaskRequestSources>> sources{};
  shared_ptr<long> startPage{};
  shared_ptr<map<string, boost::any>> tags{};
  shared_ptr<string> targetType{};
  shared_ptr<string> targetURI{};
  shared_ptr<string> targetURIPrefix{};
  shared_ptr<TrimPolicy> trimPolicy{};
  shared_ptr<string> userData{};

  CreateOfficeConversionTaskRequest() {}

  explicit CreateOfficeConversionTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfig) {
      res["CredentialConfig"] = credentialConfig ? boost::any(credentialConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (endPage) {
      res["EndPage"] = boost::any(*endPage);
    }
    if (firstPage) {
      res["FirstPage"] = boost::any(*firstPage);
    }
    if (fitToHeight) {
      res["FitToHeight"] = boost::any(*fitToHeight);
    }
    if (fitToWidth) {
      res["FitToWidth"] = boost::any(*fitToWidth);
    }
    if (holdLineFeed) {
      res["HoldLineFeed"] = boost::any(*holdLineFeed);
    }
    if (imageDPI) {
      res["ImageDPI"] = boost::any(*imageDPI);
    }
    if (longPicture) {
      res["LongPicture"] = boost::any(*longPicture);
    }
    if (longText) {
      res["LongText"] = boost::any(*longText);
    }
    if (maxSheetColumn) {
      res["MaxSheetColumn"] = boost::any(*maxSheetColumn);
    }
    if (maxSheetRow) {
      res["MaxSheetRow"] = boost::any(*maxSheetRow);
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pages) {
      res["Pages"] = boost::any(*pages);
    }
    if (paperHorizontal) {
      res["PaperHorizontal"] = boost::any(*paperHorizontal);
    }
    if (paperSize) {
      res["PaperSize"] = boost::any(*paperSize);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (quality) {
      res["Quality"] = boost::any(*quality);
    }
    if (scalePercentage) {
      res["ScalePercentage"] = boost::any(*scalePercentage);
    }
    if (sheetCount) {
      res["SheetCount"] = boost::any(*sheetCount);
    }
    if (sheetIndex) {
      res["SheetIndex"] = boost::any(*sheetIndex);
    }
    if (showComments) {
      res["ShowComments"] = boost::any(*showComments);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    if (sources) {
      vector<boost::any> temp1;
      for(auto item1:*sources){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Sources"] = boost::any(temp1);
    }
    if (startPage) {
      res["StartPage"] = boost::any(*startPage);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (targetURI) {
      res["TargetURI"] = boost::any(*targetURI);
    }
    if (targetURIPrefix) {
      res["TargetURIPrefix"] = boost::any(*targetURIPrefix);
    }
    if (trimPolicy) {
      res["TrimPolicy"] = trimPolicy ? boost::any(trimPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CredentialConfig"].type()) {
        CredentialConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CredentialConfig"]));
        credentialConfig = make_shared<CredentialConfig>(model1);
      }
    }
    if (m.find("EndPage") != m.end() && !m["EndPage"].empty()) {
      endPage = make_shared<long>(boost::any_cast<long>(m["EndPage"]));
    }
    if (m.find("FirstPage") != m.end() && !m["FirstPage"].empty()) {
      firstPage = make_shared<bool>(boost::any_cast<bool>(m["FirstPage"]));
    }
    if (m.find("FitToHeight") != m.end() && !m["FitToHeight"].empty()) {
      fitToHeight = make_shared<bool>(boost::any_cast<bool>(m["FitToHeight"]));
    }
    if (m.find("FitToWidth") != m.end() && !m["FitToWidth"].empty()) {
      fitToWidth = make_shared<bool>(boost::any_cast<bool>(m["FitToWidth"]));
    }
    if (m.find("HoldLineFeed") != m.end() && !m["HoldLineFeed"].empty()) {
      holdLineFeed = make_shared<bool>(boost::any_cast<bool>(m["HoldLineFeed"]));
    }
    if (m.find("ImageDPI") != m.end() && !m["ImageDPI"].empty()) {
      imageDPI = make_shared<long>(boost::any_cast<long>(m["ImageDPI"]));
    }
    if (m.find("LongPicture") != m.end() && !m["LongPicture"].empty()) {
      longPicture = make_shared<bool>(boost::any_cast<bool>(m["LongPicture"]));
    }
    if (m.find("LongText") != m.end() && !m["LongText"].empty()) {
      longText = make_shared<bool>(boost::any_cast<bool>(m["LongText"]));
    }
    if (m.find("MaxSheetColumn") != m.end() && !m["MaxSheetColumn"].empty()) {
      maxSheetColumn = make_shared<long>(boost::any_cast<long>(m["MaxSheetColumn"]));
    }
    if (m.find("MaxSheetRow") != m.end() && !m["MaxSheetRow"].empty()) {
      maxSheetRow = make_shared<long>(boost::any_cast<long>(m["MaxSheetRow"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        Notification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<Notification>(model1);
      }
    }
    if (m.find("Pages") != m.end() && !m["Pages"].empty()) {
      pages = make_shared<string>(boost::any_cast<string>(m["Pages"]));
    }
    if (m.find("PaperHorizontal") != m.end() && !m["PaperHorizontal"].empty()) {
      paperHorizontal = make_shared<bool>(boost::any_cast<bool>(m["PaperHorizontal"]));
    }
    if (m.find("PaperSize") != m.end() && !m["PaperSize"].empty()) {
      paperSize = make_shared<string>(boost::any_cast<string>(m["PaperSize"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Quality") != m.end() && !m["Quality"].empty()) {
      quality = make_shared<long>(boost::any_cast<long>(m["Quality"]));
    }
    if (m.find("ScalePercentage") != m.end() && !m["ScalePercentage"].empty()) {
      scalePercentage = make_shared<long>(boost::any_cast<long>(m["ScalePercentage"]));
    }
    if (m.find("SheetCount") != m.end() && !m["SheetCount"].empty()) {
      sheetCount = make_shared<long>(boost::any_cast<long>(m["SheetCount"]));
    }
    if (m.find("SheetIndex") != m.end() && !m["SheetIndex"].empty()) {
      sheetIndex = make_shared<long>(boost::any_cast<long>(m["SheetIndex"]));
    }
    if (m.find("ShowComments") != m.end() && !m["ShowComments"].empty()) {
      showComments = make_shared<bool>(boost::any_cast<bool>(m["ShowComments"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      if (typeid(vector<boost::any>) == m["Sources"].type()) {
        vector<CreateOfficeConversionTaskRequestSources> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Sources"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateOfficeConversionTaskRequestSources model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sources = make_shared<vector<CreateOfficeConversionTaskRequestSources>>(expect1);
      }
    }
    if (m.find("StartPage") != m.end() && !m["StartPage"].empty()) {
      startPage = make_shared<long>(boost::any_cast<long>(m["StartPage"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Tags"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("TargetURI") != m.end() && !m["TargetURI"].empty()) {
      targetURI = make_shared<string>(boost::any_cast<string>(m["TargetURI"]));
    }
    if (m.find("TargetURIPrefix") != m.end() && !m["TargetURIPrefix"].empty()) {
      targetURIPrefix = make_shared<string>(boost::any_cast<string>(m["TargetURIPrefix"]));
    }
    if (m.find("TrimPolicy") != m.end() && !m["TrimPolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["TrimPolicy"].type()) {
        TrimPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TrimPolicy"]));
        trimPolicy = make_shared<TrimPolicy>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateOfficeConversionTaskRequest() = default;
};
class CreateOfficeConversionTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> credentialConfigShrink{};
  shared_ptr<long> endPage{};
  shared_ptr<bool> firstPage{};
  shared_ptr<bool> fitToHeight{};
  shared_ptr<bool> fitToWidth{};
  shared_ptr<bool> holdLineFeed{};
  shared_ptr<long> imageDPI{};
  shared_ptr<bool> longPicture{};
  shared_ptr<bool> longText{};
  shared_ptr<long> maxSheetColumn{};
  shared_ptr<long> maxSheetRow{};
  shared_ptr<string> notificationShrink{};
  shared_ptr<string> pages{};
  shared_ptr<bool> paperHorizontal{};
  shared_ptr<string> paperSize{};
  shared_ptr<string> password{};
  shared_ptr<string> projectName{};
  shared_ptr<long> quality{};
  shared_ptr<long> scalePercentage{};
  shared_ptr<long> sheetCount{};
  shared_ptr<long> sheetIndex{};
  shared_ptr<bool> showComments{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> sourceURI{};
  shared_ptr<string> sourcesShrink{};
  shared_ptr<long> startPage{};
  shared_ptr<string> tagsShrink{};
  shared_ptr<string> targetType{};
  shared_ptr<string> targetURI{};
  shared_ptr<string> targetURIPrefix{};
  shared_ptr<string> trimPolicyShrink{};
  shared_ptr<string> userData{};

  CreateOfficeConversionTaskShrinkRequest() {}

  explicit CreateOfficeConversionTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfigShrink) {
      res["CredentialConfig"] = boost::any(*credentialConfigShrink);
    }
    if (endPage) {
      res["EndPage"] = boost::any(*endPage);
    }
    if (firstPage) {
      res["FirstPage"] = boost::any(*firstPage);
    }
    if (fitToHeight) {
      res["FitToHeight"] = boost::any(*fitToHeight);
    }
    if (fitToWidth) {
      res["FitToWidth"] = boost::any(*fitToWidth);
    }
    if (holdLineFeed) {
      res["HoldLineFeed"] = boost::any(*holdLineFeed);
    }
    if (imageDPI) {
      res["ImageDPI"] = boost::any(*imageDPI);
    }
    if (longPicture) {
      res["LongPicture"] = boost::any(*longPicture);
    }
    if (longText) {
      res["LongText"] = boost::any(*longText);
    }
    if (maxSheetColumn) {
      res["MaxSheetColumn"] = boost::any(*maxSheetColumn);
    }
    if (maxSheetRow) {
      res["MaxSheetRow"] = boost::any(*maxSheetRow);
    }
    if (notificationShrink) {
      res["Notification"] = boost::any(*notificationShrink);
    }
    if (pages) {
      res["Pages"] = boost::any(*pages);
    }
    if (paperHorizontal) {
      res["PaperHorizontal"] = boost::any(*paperHorizontal);
    }
    if (paperSize) {
      res["PaperSize"] = boost::any(*paperSize);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (quality) {
      res["Quality"] = boost::any(*quality);
    }
    if (scalePercentage) {
      res["ScalePercentage"] = boost::any(*scalePercentage);
    }
    if (sheetCount) {
      res["SheetCount"] = boost::any(*sheetCount);
    }
    if (sheetIndex) {
      res["SheetIndex"] = boost::any(*sheetIndex);
    }
    if (showComments) {
      res["ShowComments"] = boost::any(*showComments);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    if (sourcesShrink) {
      res["Sources"] = boost::any(*sourcesShrink);
    }
    if (startPage) {
      res["StartPage"] = boost::any(*startPage);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    if (targetType) {
      res["TargetType"] = boost::any(*targetType);
    }
    if (targetURI) {
      res["TargetURI"] = boost::any(*targetURI);
    }
    if (targetURIPrefix) {
      res["TargetURIPrefix"] = boost::any(*targetURIPrefix);
    }
    if (trimPolicyShrink) {
      res["TrimPolicy"] = boost::any(*trimPolicyShrink);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      credentialConfigShrink = make_shared<string>(boost::any_cast<string>(m["CredentialConfig"]));
    }
    if (m.find("EndPage") != m.end() && !m["EndPage"].empty()) {
      endPage = make_shared<long>(boost::any_cast<long>(m["EndPage"]));
    }
    if (m.find("FirstPage") != m.end() && !m["FirstPage"].empty()) {
      firstPage = make_shared<bool>(boost::any_cast<bool>(m["FirstPage"]));
    }
    if (m.find("FitToHeight") != m.end() && !m["FitToHeight"].empty()) {
      fitToHeight = make_shared<bool>(boost::any_cast<bool>(m["FitToHeight"]));
    }
    if (m.find("FitToWidth") != m.end() && !m["FitToWidth"].empty()) {
      fitToWidth = make_shared<bool>(boost::any_cast<bool>(m["FitToWidth"]));
    }
    if (m.find("HoldLineFeed") != m.end() && !m["HoldLineFeed"].empty()) {
      holdLineFeed = make_shared<bool>(boost::any_cast<bool>(m["HoldLineFeed"]));
    }
    if (m.find("ImageDPI") != m.end() && !m["ImageDPI"].empty()) {
      imageDPI = make_shared<long>(boost::any_cast<long>(m["ImageDPI"]));
    }
    if (m.find("LongPicture") != m.end() && !m["LongPicture"].empty()) {
      longPicture = make_shared<bool>(boost::any_cast<bool>(m["LongPicture"]));
    }
    if (m.find("LongText") != m.end() && !m["LongText"].empty()) {
      longText = make_shared<bool>(boost::any_cast<bool>(m["LongText"]));
    }
    if (m.find("MaxSheetColumn") != m.end() && !m["MaxSheetColumn"].empty()) {
      maxSheetColumn = make_shared<long>(boost::any_cast<long>(m["MaxSheetColumn"]));
    }
    if (m.find("MaxSheetRow") != m.end() && !m["MaxSheetRow"].empty()) {
      maxSheetRow = make_shared<long>(boost::any_cast<long>(m["MaxSheetRow"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      notificationShrink = make_shared<string>(boost::any_cast<string>(m["Notification"]));
    }
    if (m.find("Pages") != m.end() && !m["Pages"].empty()) {
      pages = make_shared<string>(boost::any_cast<string>(m["Pages"]));
    }
    if (m.find("PaperHorizontal") != m.end() && !m["PaperHorizontal"].empty()) {
      paperHorizontal = make_shared<bool>(boost::any_cast<bool>(m["PaperHorizontal"]));
    }
    if (m.find("PaperSize") != m.end() && !m["PaperSize"].empty()) {
      paperSize = make_shared<string>(boost::any_cast<string>(m["PaperSize"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Quality") != m.end() && !m["Quality"].empty()) {
      quality = make_shared<long>(boost::any_cast<long>(m["Quality"]));
    }
    if (m.find("ScalePercentage") != m.end() && !m["ScalePercentage"].empty()) {
      scalePercentage = make_shared<long>(boost::any_cast<long>(m["ScalePercentage"]));
    }
    if (m.find("SheetCount") != m.end() && !m["SheetCount"].empty()) {
      sheetCount = make_shared<long>(boost::any_cast<long>(m["SheetCount"]));
    }
    if (m.find("SheetIndex") != m.end() && !m["SheetIndex"].empty()) {
      sheetIndex = make_shared<long>(boost::any_cast<long>(m["SheetIndex"]));
    }
    if (m.find("ShowComments") != m.end() && !m["ShowComments"].empty()) {
      showComments = make_shared<bool>(boost::any_cast<bool>(m["ShowComments"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
    if (m.find("Sources") != m.end() && !m["Sources"].empty()) {
      sourcesShrink = make_shared<string>(boost::any_cast<string>(m["Sources"]));
    }
    if (m.find("StartPage") != m.end() && !m["StartPage"].empty()) {
      startPage = make_shared<long>(boost::any_cast<long>(m["StartPage"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("TargetType") != m.end() && !m["TargetType"].empty()) {
      targetType = make_shared<string>(boost::any_cast<string>(m["TargetType"]));
    }
    if (m.find("TargetURI") != m.end() && !m["TargetURI"].empty()) {
      targetURI = make_shared<string>(boost::any_cast<string>(m["TargetURI"]));
    }
    if (m.find("TargetURIPrefix") != m.end() && !m["TargetURIPrefix"].empty()) {
      targetURIPrefix = make_shared<string>(boost::any_cast<string>(m["TargetURIPrefix"]));
    }
    if (m.find("TrimPolicy") != m.end() && !m["TrimPolicy"].empty()) {
      trimPolicyShrink = make_shared<string>(boost::any_cast<string>(m["TrimPolicy"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateOfficeConversionTaskShrinkRequest() = default;
};
class CreateOfficeConversionTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> eventId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  CreateOfficeConversionTaskResponseBody() {}

  explicit CreateOfficeConversionTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateOfficeConversionTaskResponseBody() = default;
};
class CreateOfficeConversionTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateOfficeConversionTaskResponseBody> body{};

  CreateOfficeConversionTaskResponse() {}

  explicit CreateOfficeConversionTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateOfficeConversionTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateOfficeConversionTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateOfficeConversionTaskResponse() = default;
};
class CreateProjectRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  CreateProjectRequestTag() {}

  explicit CreateProjectRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~CreateProjectRequestTag() = default;
};
class CreateProjectRequest : public Darabonba::Model {
public:
  shared_ptr<long> datasetMaxBindCount{};
  shared_ptr<long> datasetMaxEntityCount{};
  shared_ptr<long> datasetMaxFileCount{};
  shared_ptr<long> datasetMaxRelationCount{};
  shared_ptr<long> datasetMaxTotalFileSize{};
  shared_ptr<string> description{};
  shared_ptr<long> projectMaxDatasetCount{};
  shared_ptr<string> projectName{};
  shared_ptr<string> serviceRole{};
  shared_ptr<vector<CreateProjectRequestTag>> tag{};
  shared_ptr<string> templateId{};

  CreateProjectRequest() {}

  explicit CreateProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetMaxBindCount) {
      res["DatasetMaxBindCount"] = boost::any(*datasetMaxBindCount);
    }
    if (datasetMaxEntityCount) {
      res["DatasetMaxEntityCount"] = boost::any(*datasetMaxEntityCount);
    }
    if (datasetMaxFileCount) {
      res["DatasetMaxFileCount"] = boost::any(*datasetMaxFileCount);
    }
    if (datasetMaxRelationCount) {
      res["DatasetMaxRelationCount"] = boost::any(*datasetMaxRelationCount);
    }
    if (datasetMaxTotalFileSize) {
      res["DatasetMaxTotalFileSize"] = boost::any(*datasetMaxTotalFileSize);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (projectMaxDatasetCount) {
      res["ProjectMaxDatasetCount"] = boost::any(*projectMaxDatasetCount);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (serviceRole) {
      res["ServiceRole"] = boost::any(*serviceRole);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetMaxBindCount") != m.end() && !m["DatasetMaxBindCount"].empty()) {
      datasetMaxBindCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxBindCount"]));
    }
    if (m.find("DatasetMaxEntityCount") != m.end() && !m["DatasetMaxEntityCount"].empty()) {
      datasetMaxEntityCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxEntityCount"]));
    }
    if (m.find("DatasetMaxFileCount") != m.end() && !m["DatasetMaxFileCount"].empty()) {
      datasetMaxFileCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxFileCount"]));
    }
    if (m.find("DatasetMaxRelationCount") != m.end() && !m["DatasetMaxRelationCount"].empty()) {
      datasetMaxRelationCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxRelationCount"]));
    }
    if (m.find("DatasetMaxTotalFileSize") != m.end() && !m["DatasetMaxTotalFileSize"].empty()) {
      datasetMaxTotalFileSize = make_shared<long>(boost::any_cast<long>(m["DatasetMaxTotalFileSize"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ProjectMaxDatasetCount") != m.end() && !m["ProjectMaxDatasetCount"].empty()) {
      projectMaxDatasetCount = make_shared<long>(boost::any_cast<long>(m["ProjectMaxDatasetCount"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ServiceRole") != m.end() && !m["ServiceRole"].empty()) {
      serviceRole = make_shared<string>(boost::any_cast<string>(m["ServiceRole"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<CreateProjectRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateProjectRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<CreateProjectRequestTag>>(expect1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~CreateProjectRequest() = default;
};
class CreateProjectShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> datasetMaxBindCount{};
  shared_ptr<long> datasetMaxEntityCount{};
  shared_ptr<long> datasetMaxFileCount{};
  shared_ptr<long> datasetMaxRelationCount{};
  shared_ptr<long> datasetMaxTotalFileSize{};
  shared_ptr<string> description{};
  shared_ptr<long> projectMaxDatasetCount{};
  shared_ptr<string> projectName{};
  shared_ptr<string> serviceRole{};
  shared_ptr<string> tagShrink{};
  shared_ptr<string> templateId{};

  CreateProjectShrinkRequest() {}

  explicit CreateProjectShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetMaxBindCount) {
      res["DatasetMaxBindCount"] = boost::any(*datasetMaxBindCount);
    }
    if (datasetMaxEntityCount) {
      res["DatasetMaxEntityCount"] = boost::any(*datasetMaxEntityCount);
    }
    if (datasetMaxFileCount) {
      res["DatasetMaxFileCount"] = boost::any(*datasetMaxFileCount);
    }
    if (datasetMaxRelationCount) {
      res["DatasetMaxRelationCount"] = boost::any(*datasetMaxRelationCount);
    }
    if (datasetMaxTotalFileSize) {
      res["DatasetMaxTotalFileSize"] = boost::any(*datasetMaxTotalFileSize);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (projectMaxDatasetCount) {
      res["ProjectMaxDatasetCount"] = boost::any(*projectMaxDatasetCount);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (serviceRole) {
      res["ServiceRole"] = boost::any(*serviceRole);
    }
    if (tagShrink) {
      res["Tag"] = boost::any(*tagShrink);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetMaxBindCount") != m.end() && !m["DatasetMaxBindCount"].empty()) {
      datasetMaxBindCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxBindCount"]));
    }
    if (m.find("DatasetMaxEntityCount") != m.end() && !m["DatasetMaxEntityCount"].empty()) {
      datasetMaxEntityCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxEntityCount"]));
    }
    if (m.find("DatasetMaxFileCount") != m.end() && !m["DatasetMaxFileCount"].empty()) {
      datasetMaxFileCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxFileCount"]));
    }
    if (m.find("DatasetMaxRelationCount") != m.end() && !m["DatasetMaxRelationCount"].empty()) {
      datasetMaxRelationCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxRelationCount"]));
    }
    if (m.find("DatasetMaxTotalFileSize") != m.end() && !m["DatasetMaxTotalFileSize"].empty()) {
      datasetMaxTotalFileSize = make_shared<long>(boost::any_cast<long>(m["DatasetMaxTotalFileSize"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ProjectMaxDatasetCount") != m.end() && !m["ProjectMaxDatasetCount"].empty()) {
      projectMaxDatasetCount = make_shared<long>(boost::any_cast<long>(m["ProjectMaxDatasetCount"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ServiceRole") != m.end() && !m["ServiceRole"].empty()) {
      serviceRole = make_shared<string>(boost::any_cast<string>(m["ServiceRole"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tagShrink = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~CreateProjectShrinkRequest() = default;
};
class CreateProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<Project> project{};
  shared_ptr<string> requestId{};

  CreateProjectResponseBody() {}

  explicit CreateProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (project) {
      res["Project"] = project ? boost::any(project->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      if (typeid(map<string, boost::any>) == m["Project"].type()) {
        Project model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Project"]));
        project = make_shared<Project>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateProjectResponseBody() = default;
};
class CreateProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateProjectResponseBody> body{};

  CreateProjectResponse() {}

  explicit CreateProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateProjectResponseBody>(model1);
      }
    }
  }


  virtual ~CreateProjectResponse() = default;
};
class CreateSimilarImageClusteringTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<Notification> notification{};
  shared_ptr<string> projectName{};
  shared_ptr<map<string, boost::any>> tags{};
  shared_ptr<string> userData{};

  CreateSimilarImageClusteringTaskRequest() {}

  explicit CreateSimilarImageClusteringTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        Notification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<Notification>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Tags"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateSimilarImageClusteringTaskRequest() = default;
};
class CreateSimilarImageClusteringTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> notificationShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> tagsShrink{};
  shared_ptr<string> userData{};

  CreateSimilarImageClusteringTaskShrinkRequest() {}

  explicit CreateSimilarImageClusteringTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (notificationShrink) {
      res["Notification"] = boost::any(*notificationShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      notificationShrink = make_shared<string>(boost::any_cast<string>(m["Notification"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateSimilarImageClusteringTaskShrinkRequest() = default;
};
class CreateSimilarImageClusteringTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> eventId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  CreateSimilarImageClusteringTaskResponseBody() {}

  explicit CreateSimilarImageClusteringTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateSimilarImageClusteringTaskResponseBody() = default;
};
class CreateSimilarImageClusteringTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSimilarImageClusteringTaskResponseBody> body{};

  CreateSimilarImageClusteringTaskResponse() {}

  explicit CreateSimilarImageClusteringTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSimilarImageClusteringTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSimilarImageClusteringTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSimilarImageClusteringTaskResponse() = default;
};
class CreateStoryRequest : public Darabonba::Model {
public:
  shared_ptr<AddressForStory> address{};
  shared_ptr<string> customId{};
  shared_ptr<map<string, boost::any>> customLabels{};
  shared_ptr<string> datasetName{};
  shared_ptr<long> maxFileCount{};
  shared_ptr<long> minFileCount{};
  shared_ptr<Notification> notification{};
  shared_ptr<string> notifyTopicName{};
  shared_ptr<string> objectId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> storyEndTime{};
  shared_ptr<string> storyName{};
  shared_ptr<string> storyStartTime{};
  shared_ptr<string> storySubType{};
  shared_ptr<string> storyType{};
  shared_ptr<map<string, boost::any>> tags{};
  shared_ptr<string> userData{};

  CreateStoryRequest() {}

  explicit CreateStoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = address ? boost::any(address->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customId) {
      res["CustomId"] = boost::any(*customId);
    }
    if (customLabels) {
      res["CustomLabels"] = boost::any(*customLabels);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (maxFileCount) {
      res["MaxFileCount"] = boost::any(*maxFileCount);
    }
    if (minFileCount) {
      res["MinFileCount"] = boost::any(*minFileCount);
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (notifyTopicName) {
      res["NotifyTopicName"] = boost::any(*notifyTopicName);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (storyEndTime) {
      res["StoryEndTime"] = boost::any(*storyEndTime);
    }
    if (storyName) {
      res["StoryName"] = boost::any(*storyName);
    }
    if (storyStartTime) {
      res["StoryStartTime"] = boost::any(*storyStartTime);
    }
    if (storySubType) {
      res["StorySubType"] = boost::any(*storySubType);
    }
    if (storyType) {
      res["StoryType"] = boost::any(*storyType);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      if (typeid(map<string, boost::any>) == m["Address"].type()) {
        AddressForStory model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Address"]));
        address = make_shared<AddressForStory>(model1);
      }
    }
    if (m.find("CustomId") != m.end() && !m["CustomId"].empty()) {
      customId = make_shared<string>(boost::any_cast<string>(m["CustomId"]));
    }
    if (m.find("CustomLabels") != m.end() && !m["CustomLabels"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["CustomLabels"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customLabels = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("MaxFileCount") != m.end() && !m["MaxFileCount"].empty()) {
      maxFileCount = make_shared<long>(boost::any_cast<long>(m["MaxFileCount"]));
    }
    if (m.find("MinFileCount") != m.end() && !m["MinFileCount"].empty()) {
      minFileCount = make_shared<long>(boost::any_cast<long>(m["MinFileCount"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        Notification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<Notification>(model1);
      }
    }
    if (m.find("NotifyTopicName") != m.end() && !m["NotifyTopicName"].empty()) {
      notifyTopicName = make_shared<string>(boost::any_cast<string>(m["NotifyTopicName"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("StoryEndTime") != m.end() && !m["StoryEndTime"].empty()) {
      storyEndTime = make_shared<string>(boost::any_cast<string>(m["StoryEndTime"]));
    }
    if (m.find("StoryName") != m.end() && !m["StoryName"].empty()) {
      storyName = make_shared<string>(boost::any_cast<string>(m["StoryName"]));
    }
    if (m.find("StoryStartTime") != m.end() && !m["StoryStartTime"].empty()) {
      storyStartTime = make_shared<string>(boost::any_cast<string>(m["StoryStartTime"]));
    }
    if (m.find("StorySubType") != m.end() && !m["StorySubType"].empty()) {
      storySubType = make_shared<string>(boost::any_cast<string>(m["StorySubType"]));
    }
    if (m.find("StoryType") != m.end() && !m["StoryType"].empty()) {
      storyType = make_shared<string>(boost::any_cast<string>(m["StoryType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Tags"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateStoryRequest() = default;
};
class CreateStoryShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> addressShrink{};
  shared_ptr<string> customId{};
  shared_ptr<string> customLabelsShrink{};
  shared_ptr<string> datasetName{};
  shared_ptr<long> maxFileCount{};
  shared_ptr<long> minFileCount{};
  shared_ptr<string> notificationShrink{};
  shared_ptr<string> notifyTopicName{};
  shared_ptr<string> objectId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> storyEndTime{};
  shared_ptr<string> storyName{};
  shared_ptr<string> storyStartTime{};
  shared_ptr<string> storySubType{};
  shared_ptr<string> storyType{};
  shared_ptr<string> tagsShrink{};
  shared_ptr<string> userData{};

  CreateStoryShrinkRequest() {}

  explicit CreateStoryShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressShrink) {
      res["Address"] = boost::any(*addressShrink);
    }
    if (customId) {
      res["CustomId"] = boost::any(*customId);
    }
    if (customLabelsShrink) {
      res["CustomLabels"] = boost::any(*customLabelsShrink);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (maxFileCount) {
      res["MaxFileCount"] = boost::any(*maxFileCount);
    }
    if (minFileCount) {
      res["MinFileCount"] = boost::any(*minFileCount);
    }
    if (notificationShrink) {
      res["Notification"] = boost::any(*notificationShrink);
    }
    if (notifyTopicName) {
      res["NotifyTopicName"] = boost::any(*notifyTopicName);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (storyEndTime) {
      res["StoryEndTime"] = boost::any(*storyEndTime);
    }
    if (storyName) {
      res["StoryName"] = boost::any(*storyName);
    }
    if (storyStartTime) {
      res["StoryStartTime"] = boost::any(*storyStartTime);
    }
    if (storySubType) {
      res["StorySubType"] = boost::any(*storySubType);
    }
    if (storyType) {
      res["StoryType"] = boost::any(*storyType);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      addressShrink = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("CustomId") != m.end() && !m["CustomId"].empty()) {
      customId = make_shared<string>(boost::any_cast<string>(m["CustomId"]));
    }
    if (m.find("CustomLabels") != m.end() && !m["CustomLabels"].empty()) {
      customLabelsShrink = make_shared<string>(boost::any_cast<string>(m["CustomLabels"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("MaxFileCount") != m.end() && !m["MaxFileCount"].empty()) {
      maxFileCount = make_shared<long>(boost::any_cast<long>(m["MaxFileCount"]));
    }
    if (m.find("MinFileCount") != m.end() && !m["MinFileCount"].empty()) {
      minFileCount = make_shared<long>(boost::any_cast<long>(m["MinFileCount"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      notificationShrink = make_shared<string>(boost::any_cast<string>(m["Notification"]));
    }
    if (m.find("NotifyTopicName") != m.end() && !m["NotifyTopicName"].empty()) {
      notifyTopicName = make_shared<string>(boost::any_cast<string>(m["NotifyTopicName"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("StoryEndTime") != m.end() && !m["StoryEndTime"].empty()) {
      storyEndTime = make_shared<string>(boost::any_cast<string>(m["StoryEndTime"]));
    }
    if (m.find("StoryName") != m.end() && !m["StoryName"].empty()) {
      storyName = make_shared<string>(boost::any_cast<string>(m["StoryName"]));
    }
    if (m.find("StoryStartTime") != m.end() && !m["StoryStartTime"].empty()) {
      storyStartTime = make_shared<string>(boost::any_cast<string>(m["StoryStartTime"]));
    }
    if (m.find("StorySubType") != m.end() && !m["StorySubType"].empty()) {
      storySubType = make_shared<string>(boost::any_cast<string>(m["StorySubType"]));
    }
    if (m.find("StoryType") != m.end() && !m["StoryType"].empty()) {
      storyType = make_shared<string>(boost::any_cast<string>(m["StoryType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateStoryShrinkRequest() = default;
};
class CreateStoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> eventId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  CreateStoryResponseBody() {}

  explicit CreateStoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateStoryResponseBody() = default;
};
class CreateStoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateStoryResponseBody> body{};

  CreateStoryResponse() {}

  explicit CreateStoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateStoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateStoryResponseBody>(model1);
      }
    }
  }


  virtual ~CreateStoryResponse() = default;
};
class CreateTriggerRequestActions : public Darabonba::Model {
public:
  shared_ptr<FastFailPolicy> fastFailPolicy{};
  shared_ptr<string> name{};
  shared_ptr<vector<string>> parameters{};

  CreateTriggerRequestActions() {}

  explicit CreateTriggerRequestActions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fastFailPolicy) {
      res["FastFailPolicy"] = fastFailPolicy ? boost::any(fastFailPolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FastFailPolicy") != m.end() && !m["FastFailPolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["FastFailPolicy"].type()) {
        FastFailPolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FastFailPolicy"]));
        fastFailPolicy = make_shared<FastFailPolicy>(model1);
      }
    }
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Parameters"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Parameters"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      parameters = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~CreateTriggerRequestActions() = default;
};
class CreateTriggerRequestNotification : public Darabonba::Model {
public:
  shared_ptr<MNS> MNS{};

  CreateTriggerRequestNotification() {}

  explicit CreateTriggerRequestNotification(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (MNS) {
      res["MNS"] = MNS ? boost::any(MNS->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MNS") != m.end() && !m["MNS"].empty()) {
      if (typeid(map<string, boost::any>) == m["MNS"].type()) {
        MNS model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["MNS"]));
        MNS = make_shared<MNS>(model1);
      }
    }
  }


  virtual ~CreateTriggerRequestNotification() = default;
};
class CreateTriggerRequest : public Darabonba::Model {
public:
  shared_ptr<vector<CreateTriggerRequestActions>> actions{};
  shared_ptr<Input> input{};
  shared_ptr<CreateTriggerRequestNotification> notification{};
  shared_ptr<string> projectName{};
  shared_ptr<string> serviceRole{};
  shared_ptr<map<string, boost::any>> tags{};

  CreateTriggerRequest() {}

  explicit CreateTriggerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actions) {
      vector<boost::any> temp1;
      for(auto item1:*actions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Actions"] = boost::any(temp1);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (serviceRole) {
      res["ServiceRole"] = boost::any(*serviceRole);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Actions") != m.end() && !m["Actions"].empty()) {
      if (typeid(vector<boost::any>) == m["Actions"].type()) {
        vector<CreateTriggerRequestActions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Actions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateTriggerRequestActions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        actions = make_shared<vector<CreateTriggerRequestActions>>(expect1);
      }
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        Input model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<Input>(model1);
      }
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        CreateTriggerRequestNotification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<CreateTriggerRequestNotification>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ServiceRole") != m.end() && !m["ServiceRole"].empty()) {
      serviceRole = make_shared<string>(boost::any_cast<string>(m["ServiceRole"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Tags"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~CreateTriggerRequest() = default;
};
class CreateTriggerShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> actionsShrink{};
  shared_ptr<string> inputShrink{};
  shared_ptr<string> notificationShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> serviceRole{};
  shared_ptr<string> tagsShrink{};

  CreateTriggerShrinkRequest() {}

  explicit CreateTriggerShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionsShrink) {
      res["Actions"] = boost::any(*actionsShrink);
    }
    if (inputShrink) {
      res["Input"] = boost::any(*inputShrink);
    }
    if (notificationShrink) {
      res["Notification"] = boost::any(*notificationShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (serviceRole) {
      res["ServiceRole"] = boost::any(*serviceRole);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Actions") != m.end() && !m["Actions"].empty()) {
      actionsShrink = make_shared<string>(boost::any_cast<string>(m["Actions"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      inputShrink = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      notificationShrink = make_shared<string>(boost::any_cast<string>(m["Notification"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ServiceRole") != m.end() && !m["ServiceRole"].empty()) {
      serviceRole = make_shared<string>(boost::any_cast<string>(m["ServiceRole"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~CreateTriggerShrinkRequest() = default;
};
class CreateTriggerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> requestId{};

  CreateTriggerResponseBody() {}

  explicit CreateTriggerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~CreateTriggerResponseBody() = default;
};
class CreateTriggerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateTriggerResponseBody> body{};

  CreateTriggerResponse() {}

  explicit CreateTriggerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateTriggerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateTriggerResponseBody>(model1);
      }
    }
  }


  virtual ~CreateTriggerResponse() = default;
};
class CreateVideoLabelClassificationTaskRequest : public Darabonba::Model {
public:
  shared_ptr<CredentialConfig> credentialConfig{};
  shared_ptr<Notification> notification{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceURI{};
  shared_ptr<map<string, boost::any>> tags{};
  shared_ptr<string> userData{};

  CreateVideoLabelClassificationTaskRequest() {}

  explicit CreateVideoLabelClassificationTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfig) {
      res["CredentialConfig"] = credentialConfig ? boost::any(credentialConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CredentialConfig"].type()) {
        CredentialConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CredentialConfig"]));
        credentialConfig = make_shared<CredentialConfig>(model1);
      }
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        Notification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<Notification>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Tags"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateVideoLabelClassificationTaskRequest() = default;
};
class CreateVideoLabelClassificationTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> credentialConfigShrink{};
  shared_ptr<string> notificationShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceURI{};
  shared_ptr<string> tagsShrink{};
  shared_ptr<string> userData{};

  CreateVideoLabelClassificationTaskShrinkRequest() {}

  explicit CreateVideoLabelClassificationTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfigShrink) {
      res["CredentialConfig"] = boost::any(*credentialConfigShrink);
    }
    if (notificationShrink) {
      res["Notification"] = boost::any(*notificationShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      credentialConfigShrink = make_shared<string>(boost::any_cast<string>(m["CredentialConfig"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      notificationShrink = make_shared<string>(boost::any_cast<string>(m["Notification"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateVideoLabelClassificationTaskShrinkRequest() = default;
};
class CreateVideoLabelClassificationTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> eventId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  CreateVideoLabelClassificationTaskResponseBody() {}

  explicit CreateVideoLabelClassificationTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateVideoLabelClassificationTaskResponseBody() = default;
};
class CreateVideoLabelClassificationTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateVideoLabelClassificationTaskResponseBody> body{};

  CreateVideoLabelClassificationTaskResponse() {}

  explicit CreateVideoLabelClassificationTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVideoLabelClassificationTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVideoLabelClassificationTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVideoLabelClassificationTaskResponse() = default;
};
class CreateVideoModerationTaskRequest : public Darabonba::Model {
public:
  shared_ptr<CredentialConfig> credentialConfig{};
  shared_ptr<long> interval{};
  shared_ptr<long> maxFrames{};
  shared_ptr<Notification> notification{};
  shared_ptr<string> projectName{};
  shared_ptr<vector<string>> scenes{};
  shared_ptr<string> sourceURI{};
  shared_ptr<map<string, boost::any>> tags{};
  shared_ptr<string> userData{};

  CreateVideoModerationTaskRequest() {}

  explicit CreateVideoModerationTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfig) {
      res["CredentialConfig"] = credentialConfig ? boost::any(credentialConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (maxFrames) {
      res["MaxFrames"] = boost::any(*maxFrames);
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (scenes) {
      res["Scenes"] = boost::any(*scenes);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CredentialConfig"].type()) {
        CredentialConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CredentialConfig"]));
        credentialConfig = make_shared<CredentialConfig>(model1);
      }
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("MaxFrames") != m.end() && !m["MaxFrames"].empty()) {
      maxFrames = make_shared<long>(boost::any_cast<long>(m["MaxFrames"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        Notification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<Notification>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Scenes") != m.end() && !m["Scenes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Scenes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Scenes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      scenes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Tags"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateVideoModerationTaskRequest() = default;
};
class CreateVideoModerationTaskShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> credentialConfigShrink{};
  shared_ptr<long> interval{};
  shared_ptr<long> maxFrames{};
  shared_ptr<string> notificationShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> scenesShrink{};
  shared_ptr<string> sourceURI{};
  shared_ptr<string> tagsShrink{};
  shared_ptr<string> userData{};

  CreateVideoModerationTaskShrinkRequest() {}

  explicit CreateVideoModerationTaskShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfigShrink) {
      res["CredentialConfig"] = boost::any(*credentialConfigShrink);
    }
    if (interval) {
      res["Interval"] = boost::any(*interval);
    }
    if (maxFrames) {
      res["MaxFrames"] = boost::any(*maxFrames);
    }
    if (notificationShrink) {
      res["Notification"] = boost::any(*notificationShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (scenesShrink) {
      res["Scenes"] = boost::any(*scenesShrink);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      credentialConfigShrink = make_shared<string>(boost::any_cast<string>(m["CredentialConfig"]));
    }
    if (m.find("Interval") != m.end() && !m["Interval"].empty()) {
      interval = make_shared<long>(boost::any_cast<long>(m["Interval"]));
    }
    if (m.find("MaxFrames") != m.end() && !m["MaxFrames"].empty()) {
      maxFrames = make_shared<long>(boost::any_cast<long>(m["MaxFrames"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      notificationShrink = make_shared<string>(boost::any_cast<string>(m["Notification"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Scenes") != m.end() && !m["Scenes"].empty()) {
      scenesShrink = make_shared<string>(boost::any_cast<string>(m["Scenes"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~CreateVideoModerationTaskShrinkRequest() = default;
};
class CreateVideoModerationTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> eventId{};
  shared_ptr<string> requestId{};
  shared_ptr<string> taskId{};

  CreateVideoModerationTaskResponseBody() {}

  explicit CreateVideoModerationTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
  }


  virtual ~CreateVideoModerationTaskResponseBody() = default;
};
class CreateVideoModerationTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateVideoModerationTaskResponseBody> body{};

  CreateVideoModerationTaskResponse() {}

  explicit CreateVideoModerationTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVideoModerationTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVideoModerationTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVideoModerationTaskResponse() = default;
};
class DeleteBatchRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> projectName{};

  DeleteBatchRequest() {}

  explicit DeleteBatchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~DeleteBatchRequest() = default;
};
class DeleteBatchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteBatchResponseBody() {}

  explicit DeleteBatchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteBatchResponseBody() = default;
};
class DeleteBatchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteBatchResponseBody> body{};

  DeleteBatchResponse() {}

  explicit DeleteBatchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBatchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBatchResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBatchResponse() = default;
};
class DeleteBindingRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> projectName{};
  shared_ptr<string> URI{};

  DeleteBindingRequest() {}

  explicit DeleteBindingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~DeleteBindingRequest() = default;
};
class DeleteBindingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteBindingResponseBody() {}

  explicit DeleteBindingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteBindingResponseBody() = default;
};
class DeleteBindingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteBindingResponseBody> body{};

  DeleteBindingResponse() {}

  explicit DeleteBindingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteBindingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteBindingResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteBindingResponse() = default;
};
class DeleteDatasetRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> projectName{};

  DeleteDatasetRequest() {}

  explicit DeleteDatasetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~DeleteDatasetRequest() = default;
};
class DeleteDatasetResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteDatasetResponseBody() {}

  explicit DeleteDatasetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteDatasetResponseBody() = default;
};
class DeleteDatasetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDatasetResponseBody> body{};

  DeleteDatasetResponse() {}

  explicit DeleteDatasetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDatasetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDatasetResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDatasetResponse() = default;
};
class DeleteFileMetaRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> projectName{};
  shared_ptr<string> URI{};

  DeleteFileMetaRequest() {}

  explicit DeleteFileMetaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~DeleteFileMetaRequest() = default;
};
class DeleteFileMetaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteFileMetaResponseBody() {}

  explicit DeleteFileMetaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteFileMetaResponseBody() = default;
};
class DeleteFileMetaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteFileMetaResponseBody> body{};

  DeleteFileMetaResponse() {}

  explicit DeleteFileMetaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteFileMetaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteFileMetaResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteFileMetaResponse() = default;
};
class DeleteLocationDateClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> objectId{};
  shared_ptr<string> projectName{};

  DeleteLocationDateClusterRequest() {}

  explicit DeleteLocationDateClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~DeleteLocationDateClusterRequest() = default;
};
class DeleteLocationDateClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLocationDateClusterResponseBody() {}

  explicit DeleteLocationDateClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLocationDateClusterResponseBody() = default;
};
class DeleteLocationDateClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLocationDateClusterResponseBody> body{};

  DeleteLocationDateClusterResponse() {}

  explicit DeleteLocationDateClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLocationDateClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLocationDateClusterResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLocationDateClusterResponse() = default;
};
class DeleteProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};

  DeleteProjectRequest() {}

  explicit DeleteProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~DeleteProjectRequest() = default;
};
class DeleteProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteProjectResponseBody() {}

  explicit DeleteProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteProjectResponseBody() = default;
};
class DeleteProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteProjectResponseBody> body{};

  DeleteProjectResponse() {}

  explicit DeleteProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteProjectResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteProjectResponse() = default;
};
class DeleteStoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> objectId{};
  shared_ptr<string> projectName{};

  DeleteStoryRequest() {}

  explicit DeleteStoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~DeleteStoryRequest() = default;
};
class DeleteStoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteStoryResponseBody() {}

  explicit DeleteStoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteStoryResponseBody() = default;
};
class DeleteStoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteStoryResponseBody> body{};

  DeleteStoryResponse() {}

  explicit DeleteStoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteStoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteStoryResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteStoryResponse() = default;
};
class DeleteTriggerRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> projectName{};

  DeleteTriggerRequest() {}

  explicit DeleteTriggerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~DeleteTriggerRequest() = default;
};
class DeleteTriggerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteTriggerResponseBody() {}

  explicit DeleteTriggerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteTriggerResponseBody() = default;
};
class DeleteTriggerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteTriggerResponseBody> body{};

  DeleteTriggerResponse() {}

  explicit DeleteTriggerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteTriggerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteTriggerResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteTriggerResponse() = default;
};
class DetachOSSBucketRequest : public Darabonba::Model {
public:
  shared_ptr<string> OSSBucket{};

  DetachOSSBucketRequest() {}

  explicit DetachOSSBucketRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (OSSBucket) {
      res["OSSBucket"] = boost::any(*OSSBucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OSSBucket") != m.end() && !m["OSSBucket"].empty()) {
      OSSBucket = make_shared<string>(boost::any_cast<string>(m["OSSBucket"]));
    }
  }


  virtual ~DetachOSSBucketRequest() = default;
};
class DetachOSSBucketResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DetachOSSBucketResponseBody() {}

  explicit DetachOSSBucketResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetachOSSBucketResponseBody() = default;
};
class DetachOSSBucketResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetachOSSBucketResponseBody> body{};

  DetachOSSBucketResponse() {}

  explicit DetachOSSBucketResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetachOSSBucketResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetachOSSBucketResponseBody>(model1);
      }
    }
  }


  virtual ~DetachOSSBucketResponse() = default;
};
class DetectImageBodiesRequest : public Darabonba::Model {
public:
  shared_ptr<CredentialConfig> credentialConfig{};
  shared_ptr<string> projectName{};
  shared_ptr<double> sensitivity{};
  shared_ptr<string> sourceURI{};

  DetectImageBodiesRequest() {}

  explicit DetectImageBodiesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfig) {
      res["CredentialConfig"] = credentialConfig ? boost::any(credentialConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sensitivity) {
      res["Sensitivity"] = boost::any(*sensitivity);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CredentialConfig"].type()) {
        CredentialConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CredentialConfig"]));
        credentialConfig = make_shared<CredentialConfig>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Sensitivity") != m.end() && !m["Sensitivity"].empty()) {
      sensitivity = make_shared<double>(boost::any_cast<double>(m["Sensitivity"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
  }


  virtual ~DetectImageBodiesRequest() = default;
};
class DetectImageBodiesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> credentialConfigShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<double> sensitivity{};
  shared_ptr<string> sourceURI{};

  DetectImageBodiesShrinkRequest() {}

  explicit DetectImageBodiesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfigShrink) {
      res["CredentialConfig"] = boost::any(*credentialConfigShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sensitivity) {
      res["Sensitivity"] = boost::any(*sensitivity);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      credentialConfigShrink = make_shared<string>(boost::any_cast<string>(m["CredentialConfig"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Sensitivity") != m.end() && !m["Sensitivity"].empty()) {
      sensitivity = make_shared<double>(boost::any_cast<double>(m["Sensitivity"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
  }


  virtual ~DetectImageBodiesShrinkRequest() = default;
};
class DetectImageBodiesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<Body>> bodies{};
  shared_ptr<string> requestId{};

  DetectImageBodiesResponseBody() {}

  explicit DetectImageBodiesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bodies) {
      vector<boost::any> temp1;
      for(auto item1:*bodies){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Bodies"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bodies") != m.end() && !m["Bodies"].empty()) {
      if (typeid(vector<boost::any>) == m["Bodies"].type()) {
        vector<Body> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Bodies"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Body model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bodies = make_shared<vector<Body>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetectImageBodiesResponseBody() = default;
};
class DetectImageBodiesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetectImageBodiesResponseBody> body{};

  DetectImageBodiesResponse() {}

  explicit DetectImageBodiesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetectImageBodiesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetectImageBodiesResponseBody>(model1);
      }
    }
  }


  virtual ~DetectImageBodiesResponse() = default;
};
class DetectImageCarsRequest : public Darabonba::Model {
public:
  shared_ptr<CredentialConfig> credentialConfig{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceURI{};

  DetectImageCarsRequest() {}

  explicit DetectImageCarsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfig) {
      res["CredentialConfig"] = credentialConfig ? boost::any(credentialConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CredentialConfig"].type()) {
        CredentialConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CredentialConfig"]));
        credentialConfig = make_shared<CredentialConfig>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
  }


  virtual ~DetectImageCarsRequest() = default;
};
class DetectImageCarsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> credentialConfigShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceURI{};

  DetectImageCarsShrinkRequest() {}

  explicit DetectImageCarsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfigShrink) {
      res["CredentialConfig"] = boost::any(*credentialConfigShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      credentialConfigShrink = make_shared<string>(boost::any_cast<string>(m["CredentialConfig"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
  }


  virtual ~DetectImageCarsShrinkRequest() = default;
};
class DetectImageCarsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<Car>> cars{};
  shared_ptr<string> requestId{};

  DetectImageCarsResponseBody() {}

  explicit DetectImageCarsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cars) {
      vector<boost::any> temp1;
      for(auto item1:*cars){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Cars"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cars") != m.end() && !m["Cars"].empty()) {
      if (typeid(vector<boost::any>) == m["Cars"].type()) {
        vector<Car> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Cars"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Car model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        cars = make_shared<vector<Car>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetectImageCarsResponseBody() = default;
};
class DetectImageCarsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetectImageCarsResponseBody> body{};

  DetectImageCarsResponse() {}

  explicit DetectImageCarsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetectImageCarsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetectImageCarsResponseBody>(model1);
      }
    }
  }


  virtual ~DetectImageCarsResponse() = default;
};
class DetectImageCodesRequest : public Darabonba::Model {
public:
  shared_ptr<CredentialConfig> credentialConfig{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceURI{};

  DetectImageCodesRequest() {}

  explicit DetectImageCodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfig) {
      res["CredentialConfig"] = credentialConfig ? boost::any(credentialConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CredentialConfig"].type()) {
        CredentialConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CredentialConfig"]));
        credentialConfig = make_shared<CredentialConfig>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
  }


  virtual ~DetectImageCodesRequest() = default;
};
class DetectImageCodesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> credentialConfigShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceURI{};

  DetectImageCodesShrinkRequest() {}

  explicit DetectImageCodesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfigShrink) {
      res["CredentialConfig"] = boost::any(*credentialConfigShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      credentialConfigShrink = make_shared<string>(boost::any_cast<string>(m["CredentialConfig"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
  }


  virtual ~DetectImageCodesShrinkRequest() = default;
};
class DetectImageCodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<Codes>> codes{};
  shared_ptr<string> requestId{};

  DetectImageCodesResponseBody() {}

  explicit DetectImageCodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codes) {
      vector<boost::any> temp1;
      for(auto item1:*codes){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Codes"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Codes") != m.end() && !m["Codes"].empty()) {
      if (typeid(vector<boost::any>) == m["Codes"].type()) {
        vector<Codes> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Codes"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Codes model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        codes = make_shared<vector<Codes>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetectImageCodesResponseBody() = default;
};
class DetectImageCodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetectImageCodesResponseBody> body{};

  DetectImageCodesResponse() {}

  explicit DetectImageCodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetectImageCodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetectImageCodesResponseBody>(model1);
      }
    }
  }


  virtual ~DetectImageCodesResponse() = default;
};
class DetectImageCroppingRequest : public Darabonba::Model {
public:
  shared_ptr<string> aspectRatios{};
  shared_ptr<CredentialConfig> credentialConfig{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceURI{};

  DetectImageCroppingRequest() {}

  explicit DetectImageCroppingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aspectRatios) {
      res["AspectRatios"] = boost::any(*aspectRatios);
    }
    if (credentialConfig) {
      res["CredentialConfig"] = credentialConfig ? boost::any(credentialConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AspectRatios") != m.end() && !m["AspectRatios"].empty()) {
      aspectRatios = make_shared<string>(boost::any_cast<string>(m["AspectRatios"]));
    }
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CredentialConfig"].type()) {
        CredentialConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CredentialConfig"]));
        credentialConfig = make_shared<CredentialConfig>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
  }


  virtual ~DetectImageCroppingRequest() = default;
};
class DetectImageCroppingShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> aspectRatios{};
  shared_ptr<string> credentialConfigShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceURI{};

  DetectImageCroppingShrinkRequest() {}

  explicit DetectImageCroppingShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aspectRatios) {
      res["AspectRatios"] = boost::any(*aspectRatios);
    }
    if (credentialConfigShrink) {
      res["CredentialConfig"] = boost::any(*credentialConfigShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AspectRatios") != m.end() && !m["AspectRatios"].empty()) {
      aspectRatios = make_shared<string>(boost::any_cast<string>(m["AspectRatios"]));
    }
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      credentialConfigShrink = make_shared<string>(boost::any_cast<string>(m["CredentialConfig"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
  }


  virtual ~DetectImageCroppingShrinkRequest() = default;
};
class DetectImageCroppingResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<CroppingSuggestion>> croppings{};
  shared_ptr<string> requestId{};

  DetectImageCroppingResponseBody() {}

  explicit DetectImageCroppingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (croppings) {
      vector<boost::any> temp1;
      for(auto item1:*croppings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Croppings"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Croppings") != m.end() && !m["Croppings"].empty()) {
      if (typeid(vector<boost::any>) == m["Croppings"].type()) {
        vector<CroppingSuggestion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Croppings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CroppingSuggestion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        croppings = make_shared<vector<CroppingSuggestion>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetectImageCroppingResponseBody() = default;
};
class DetectImageCroppingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetectImageCroppingResponseBody> body{};

  DetectImageCroppingResponse() {}

  explicit DetectImageCroppingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetectImageCroppingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetectImageCroppingResponseBody>(model1);
      }
    }
  }


  virtual ~DetectImageCroppingResponse() = default;
};
class DetectImageFacesRequest : public Darabonba::Model {
public:
  shared_ptr<CredentialConfig> credentialConfig{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceURI{};

  DetectImageFacesRequest() {}

  explicit DetectImageFacesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfig) {
      res["CredentialConfig"] = credentialConfig ? boost::any(credentialConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CredentialConfig"].type()) {
        CredentialConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CredentialConfig"]));
        credentialConfig = make_shared<CredentialConfig>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
  }


  virtual ~DetectImageFacesRequest() = default;
};
class DetectImageFacesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> credentialConfigShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceURI{};

  DetectImageFacesShrinkRequest() {}

  explicit DetectImageFacesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfigShrink) {
      res["CredentialConfig"] = boost::any(*credentialConfigShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      credentialConfigShrink = make_shared<string>(boost::any_cast<string>(m["CredentialConfig"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
  }


  virtual ~DetectImageFacesShrinkRequest() = default;
};
class DetectImageFacesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<Figure>> faces{};
  shared_ptr<string> requestId{};

  DetectImageFacesResponseBody() {}

  explicit DetectImageFacesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (faces) {
      vector<boost::any> temp1;
      for(auto item1:*faces){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Faces"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Faces") != m.end() && !m["Faces"].empty()) {
      if (typeid(vector<boost::any>) == m["Faces"].type()) {
        vector<Figure> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Faces"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Figure model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        faces = make_shared<vector<Figure>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetectImageFacesResponseBody() = default;
};
class DetectImageFacesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetectImageFacesResponseBody> body{};

  DetectImageFacesResponse() {}

  explicit DetectImageFacesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetectImageFacesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetectImageFacesResponseBody>(model1);
      }
    }
  }


  virtual ~DetectImageFacesResponse() = default;
};
class DetectImageLabelsRequest : public Darabonba::Model {
public:
  shared_ptr<CredentialConfig> credentialConfig{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceURI{};
  shared_ptr<double> threshold{};

  DetectImageLabelsRequest() {}

  explicit DetectImageLabelsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfig) {
      res["CredentialConfig"] = credentialConfig ? boost::any(credentialConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CredentialConfig"].type()) {
        CredentialConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CredentialConfig"]));
        credentialConfig = make_shared<CredentialConfig>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<double>(boost::any_cast<double>(m["Threshold"]));
    }
  }


  virtual ~DetectImageLabelsRequest() = default;
};
class DetectImageLabelsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> credentialConfigShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceURI{};
  shared_ptr<double> threshold{};

  DetectImageLabelsShrinkRequest() {}

  explicit DetectImageLabelsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfigShrink) {
      res["CredentialConfig"] = boost::any(*credentialConfigShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    if (threshold) {
      res["Threshold"] = boost::any(*threshold);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      credentialConfigShrink = make_shared<string>(boost::any_cast<string>(m["CredentialConfig"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
    if (m.find("Threshold") != m.end() && !m["Threshold"].empty()) {
      threshold = make_shared<double>(boost::any_cast<double>(m["Threshold"]));
    }
  }


  virtual ~DetectImageLabelsShrinkRequest() = default;
};
class DetectImageLabelsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<Label>> labels{};
  shared_ptr<string> requestId{};

  DetectImageLabelsResponseBody() {}

  explicit DetectImageLabelsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<Label> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Label model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<Label>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetectImageLabelsResponseBody() = default;
};
class DetectImageLabelsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetectImageLabelsResponseBody> body{};

  DetectImageLabelsResponse() {}

  explicit DetectImageLabelsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetectImageLabelsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetectImageLabelsResponseBody>(model1);
      }
    }
  }


  virtual ~DetectImageLabelsResponse() = default;
};
class DetectImageScoreRequest : public Darabonba::Model {
public:
  shared_ptr<CredentialConfig> credentialConfig{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceURI{};

  DetectImageScoreRequest() {}

  explicit DetectImageScoreRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfig) {
      res["CredentialConfig"] = credentialConfig ? boost::any(credentialConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CredentialConfig"].type()) {
        CredentialConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CredentialConfig"]));
        credentialConfig = make_shared<CredentialConfig>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
  }


  virtual ~DetectImageScoreRequest() = default;
};
class DetectImageScoreShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> credentialConfigShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceURI{};

  DetectImageScoreShrinkRequest() {}

  explicit DetectImageScoreShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfigShrink) {
      res["CredentialConfig"] = boost::any(*credentialConfigShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      credentialConfigShrink = make_shared<string>(boost::any_cast<string>(m["CredentialConfig"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
  }


  virtual ~DetectImageScoreShrinkRequest() = default;
};
class DetectImageScoreResponseBodyImageScore : public Darabonba::Model {
public:
  shared_ptr<double> overallQualityScore{};

  DetectImageScoreResponseBodyImageScore() {}

  explicit DetectImageScoreResponseBodyImageScore(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (overallQualityScore) {
      res["OverallQualityScore"] = boost::any(*overallQualityScore);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OverallQualityScore") != m.end() && !m["OverallQualityScore"].empty()) {
      overallQualityScore = make_shared<double>(boost::any_cast<double>(m["OverallQualityScore"]));
    }
  }


  virtual ~DetectImageScoreResponseBodyImageScore() = default;
};
class DetectImageScoreResponseBody : public Darabonba::Model {
public:
  shared_ptr<DetectImageScoreResponseBodyImageScore> imageScore{};
  shared_ptr<string> requestId{};

  DetectImageScoreResponseBody() {}

  explicit DetectImageScoreResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (imageScore) {
      res["ImageScore"] = imageScore ? boost::any(imageScore->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ImageScore") != m.end() && !m["ImageScore"].empty()) {
      if (typeid(map<string, boost::any>) == m["ImageScore"].type()) {
        DetectImageScoreResponseBodyImageScore model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ImageScore"]));
        imageScore = make_shared<DetectImageScoreResponseBodyImageScore>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetectImageScoreResponseBody() = default;
};
class DetectImageScoreResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetectImageScoreResponseBody> body{};

  DetectImageScoreResponse() {}

  explicit DetectImageScoreResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetectImageScoreResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetectImageScoreResponseBody>(model1);
      }
    }
  }


  virtual ~DetectImageScoreResponse() = default;
};
class DetectImageTextsRequest : public Darabonba::Model {
public:
  shared_ptr<CredentialConfig> credentialConfig{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceURI{};

  DetectImageTextsRequest() {}

  explicit DetectImageTextsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfig) {
      res["CredentialConfig"] = credentialConfig ? boost::any(credentialConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CredentialConfig"].type()) {
        CredentialConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CredentialConfig"]));
        credentialConfig = make_shared<CredentialConfig>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
  }


  virtual ~DetectImageTextsRequest() = default;
};
class DetectImageTextsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> credentialConfigShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceURI{};

  DetectImageTextsShrinkRequest() {}

  explicit DetectImageTextsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfigShrink) {
      res["CredentialConfig"] = boost::any(*credentialConfigShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      credentialConfigShrink = make_shared<string>(boost::any_cast<string>(m["CredentialConfig"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
  }


  virtual ~DetectImageTextsShrinkRequest() = default;
};
class DetectImageTextsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<OCRContents>> OCRContents{};
  shared_ptr<string> OCRTexts{};
  shared_ptr<string> requestId{};

  DetectImageTextsResponseBody() {}

  explicit DetectImageTextsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (OCRContents) {
      vector<boost::any> temp1;
      for(auto item1:*OCRContents){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["OCRContents"] = boost::any(temp1);
    }
    if (OCRTexts) {
      res["OCRTexts"] = boost::any(*OCRTexts);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OCRContents") != m.end() && !m["OCRContents"].empty()) {
      if (typeid(vector<boost::any>) == m["OCRContents"].type()) {
        vector<OCRContents> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["OCRContents"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            OCRContents model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        OCRContents = make_shared<vector<OCRContents>>(expect1);
      }
    }
    if (m.find("OCRTexts") != m.end() && !m["OCRTexts"].empty()) {
      OCRTexts = make_shared<string>(boost::any_cast<string>(m["OCRTexts"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DetectImageTextsResponseBody() = default;
};
class DetectImageTextsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetectImageTextsResponseBody> body{};

  DetectImageTextsResponse() {}

  explicit DetectImageTextsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetectImageTextsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetectImageTextsResponseBody>(model1);
      }
    }
  }


  virtual ~DetectImageTextsResponse() = default;
};
class DetectMediaMetaRequest : public Darabonba::Model {
public:
  shared_ptr<CredentialConfig> credentialConfig{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceURI{};

  DetectMediaMetaRequest() {}

  explicit DetectMediaMetaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfig) {
      res["CredentialConfig"] = credentialConfig ? boost::any(credentialConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CredentialConfig"].type()) {
        CredentialConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CredentialConfig"]));
        credentialConfig = make_shared<CredentialConfig>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
  }


  virtual ~DetectMediaMetaRequest() = default;
};
class DetectMediaMetaShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> credentialConfigShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceURI{};

  DetectMediaMetaShrinkRequest() {}

  explicit DetectMediaMetaShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfigShrink) {
      res["CredentialConfig"] = boost::any(*credentialConfigShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      credentialConfigShrink = make_shared<string>(boost::any_cast<string>(m["CredentialConfig"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
  }


  virtual ~DetectMediaMetaShrinkRequest() = default;
};
class DetectMediaMetaResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<Address>> addresses{};
  shared_ptr<string> album{};
  shared_ptr<string> albumArtist{};
  shared_ptr<string> artist{};
  shared_ptr<vector<AudioStream>> audioStreams{};
  shared_ptr<long> bitrate{};
  shared_ptr<string> composer{};
  shared_ptr<double> duration{};
  shared_ptr<string> formatLongName{};
  shared_ptr<string> formatName{};
  shared_ptr<string> language{};
  shared_ptr<string> latLong{};
  shared_ptr<string> performer{};
  shared_ptr<string> produceTime{};
  shared_ptr<long> programCount{};
  shared_ptr<string> requestId{};
  shared_ptr<long> size{};
  shared_ptr<double> startTime{};
  shared_ptr<long> streamCount{};
  shared_ptr<vector<SubtitleStream>> subtitles{};
  shared_ptr<string> title{};
  shared_ptr<long> videoHeight{};
  shared_ptr<vector<VideoStream>> videoStreams{};
  shared_ptr<long> videoWidth{};

  DetectMediaMetaResponseBody() {}

  explicit DetectMediaMetaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addresses) {
      vector<boost::any> temp1;
      for(auto item1:*addresses){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Addresses"] = boost::any(temp1);
    }
    if (album) {
      res["Album"] = boost::any(*album);
    }
    if (albumArtist) {
      res["AlbumArtist"] = boost::any(*albumArtist);
    }
    if (artist) {
      res["Artist"] = boost::any(*artist);
    }
    if (audioStreams) {
      vector<boost::any> temp1;
      for(auto item1:*audioStreams){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioStreams"] = boost::any(temp1);
    }
    if (bitrate) {
      res["Bitrate"] = boost::any(*bitrate);
    }
    if (composer) {
      res["Composer"] = boost::any(*composer);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (formatLongName) {
      res["FormatLongName"] = boost::any(*formatLongName);
    }
    if (formatName) {
      res["FormatName"] = boost::any(*formatName);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (latLong) {
      res["LatLong"] = boost::any(*latLong);
    }
    if (performer) {
      res["Performer"] = boost::any(*performer);
    }
    if (produceTime) {
      res["ProduceTime"] = boost::any(*produceTime);
    }
    if (programCount) {
      res["ProgramCount"] = boost::any(*programCount);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (streamCount) {
      res["StreamCount"] = boost::any(*streamCount);
    }
    if (subtitles) {
      vector<boost::any> temp1;
      for(auto item1:*subtitles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Subtitles"] = boost::any(temp1);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (videoHeight) {
      res["VideoHeight"] = boost::any(*videoHeight);
    }
    if (videoStreams) {
      vector<boost::any> temp1;
      for(auto item1:*videoStreams){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoStreams"] = boost::any(temp1);
    }
    if (videoWidth) {
      res["VideoWidth"] = boost::any(*videoWidth);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Addresses") != m.end() && !m["Addresses"].empty()) {
      if (typeid(vector<boost::any>) == m["Addresses"].type()) {
        vector<Address> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Addresses"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Address model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        addresses = make_shared<vector<Address>>(expect1);
      }
    }
    if (m.find("Album") != m.end() && !m["Album"].empty()) {
      album = make_shared<string>(boost::any_cast<string>(m["Album"]));
    }
    if (m.find("AlbumArtist") != m.end() && !m["AlbumArtist"].empty()) {
      albumArtist = make_shared<string>(boost::any_cast<string>(m["AlbumArtist"]));
    }
    if (m.find("Artist") != m.end() && !m["Artist"].empty()) {
      artist = make_shared<string>(boost::any_cast<string>(m["Artist"]));
    }
    if (m.find("AudioStreams") != m.end() && !m["AudioStreams"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioStreams"].type()) {
        vector<AudioStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioStreams"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            AudioStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioStreams = make_shared<vector<AudioStream>>(expect1);
      }
    }
    if (m.find("Bitrate") != m.end() && !m["Bitrate"].empty()) {
      bitrate = make_shared<long>(boost::any_cast<long>(m["Bitrate"]));
    }
    if (m.find("Composer") != m.end() && !m["Composer"].empty()) {
      composer = make_shared<string>(boost::any_cast<string>(m["Composer"]));
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("FormatLongName") != m.end() && !m["FormatLongName"].empty()) {
      formatLongName = make_shared<string>(boost::any_cast<string>(m["FormatLongName"]));
    }
    if (m.find("FormatName") != m.end() && !m["FormatName"].empty()) {
      formatName = make_shared<string>(boost::any_cast<string>(m["FormatName"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("LatLong") != m.end() && !m["LatLong"].empty()) {
      latLong = make_shared<string>(boost::any_cast<string>(m["LatLong"]));
    }
    if (m.find("Performer") != m.end() && !m["Performer"].empty()) {
      performer = make_shared<string>(boost::any_cast<string>(m["Performer"]));
    }
    if (m.find("ProduceTime") != m.end() && !m["ProduceTime"].empty()) {
      produceTime = make_shared<string>(boost::any_cast<string>(m["ProduceTime"]));
    }
    if (m.find("ProgramCount") != m.end() && !m["ProgramCount"].empty()) {
      programCount = make_shared<long>(boost::any_cast<long>(m["ProgramCount"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<double>(boost::any_cast<double>(m["StartTime"]));
    }
    if (m.find("StreamCount") != m.end() && !m["StreamCount"].empty()) {
      streamCount = make_shared<long>(boost::any_cast<long>(m["StreamCount"]));
    }
    if (m.find("Subtitles") != m.end() && !m["Subtitles"].empty()) {
      if (typeid(vector<boost::any>) == m["Subtitles"].type()) {
        vector<SubtitleStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Subtitles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SubtitleStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitles = make_shared<vector<SubtitleStream>>(expect1);
      }
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("VideoHeight") != m.end() && !m["VideoHeight"].empty()) {
      videoHeight = make_shared<long>(boost::any_cast<long>(m["VideoHeight"]));
    }
    if (m.find("VideoStreams") != m.end() && !m["VideoStreams"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoStreams"].type()) {
        vector<VideoStream> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoStreams"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            VideoStream model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoStreams = make_shared<vector<VideoStream>>(expect1);
      }
    }
    if (m.find("VideoWidth") != m.end() && !m["VideoWidth"].empty()) {
      videoWidth = make_shared<long>(boost::any_cast<long>(m["VideoWidth"]));
    }
  }


  virtual ~DetectMediaMetaResponseBody() = default;
};
class DetectMediaMetaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetectMediaMetaResponseBody> body{};

  DetectMediaMetaResponse() {}

  explicit DetectMediaMetaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetectMediaMetaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetectMediaMetaResponseBody>(model1);
      }
    }
  }


  virtual ~DetectMediaMetaResponse() = default;
};
class DetectTextAnomalyRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> projectName{};

  DetectTextAnomalyRequest() {}

  explicit DetectTextAnomalyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~DetectTextAnomalyRequest() = default;
};
class DetectTextAnomalyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> suggestion{};

  DetectTextAnomalyResponseBody() {}

  explicit DetectTextAnomalyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
  }


  virtual ~DetectTextAnomalyResponseBody() = default;
};
class DetectTextAnomalyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DetectTextAnomalyResponseBody> body{};

  DetectTextAnomalyResponse() {}

  explicit DetectTextAnomalyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DetectTextAnomalyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DetectTextAnomalyResponseBody>(model1);
      }
    }
  }


  virtual ~DetectTextAnomalyResponse() = default;
};
class EncodeBlindWatermarkRequest : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<long> imageQuality{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceURI{};
  shared_ptr<string> strengthLevel{};
  shared_ptr<string> targetURI{};

  EncodeBlindWatermarkRequest() {}

  explicit EncodeBlindWatermarkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (imageQuality) {
      res["ImageQuality"] = boost::any(*imageQuality);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    if (strengthLevel) {
      res["StrengthLevel"] = boost::any(*strengthLevel);
    }
    if (targetURI) {
      res["TargetURI"] = boost::any(*targetURI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("ImageQuality") != m.end() && !m["ImageQuality"].empty()) {
      imageQuality = make_shared<long>(boost::any_cast<long>(m["ImageQuality"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
    if (m.find("StrengthLevel") != m.end() && !m["StrengthLevel"].empty()) {
      strengthLevel = make_shared<string>(boost::any_cast<string>(m["StrengthLevel"]));
    }
    if (m.find("TargetURI") != m.end() && !m["TargetURI"].empty()) {
      targetURI = make_shared<string>(boost::any_cast<string>(m["TargetURI"]));
    }
  }


  virtual ~EncodeBlindWatermarkRequest() = default;
};
class EncodeBlindWatermarkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  EncodeBlindWatermarkResponseBody() {}

  explicit EncodeBlindWatermarkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~EncodeBlindWatermarkResponseBody() = default;
};
class EncodeBlindWatermarkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EncodeBlindWatermarkResponseBody> body{};

  EncodeBlindWatermarkResponse() {}

  explicit EncodeBlindWatermarkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EncodeBlindWatermarkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EncodeBlindWatermarkResponseBody>(model1);
      }
    }
  }


  virtual ~EncodeBlindWatermarkResponse() = default;
};
class ExtractDocumentTextRequest : public Darabonba::Model {
public:
  shared_ptr<CredentialConfig> credentialConfig{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> sourceURI{};

  ExtractDocumentTextRequest() {}

  explicit ExtractDocumentTextRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfig) {
      res["CredentialConfig"] = credentialConfig ? boost::any(credentialConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CredentialConfig"].type()) {
        CredentialConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CredentialConfig"]));
        credentialConfig = make_shared<CredentialConfig>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
  }


  virtual ~ExtractDocumentTextRequest() = default;
};
class ExtractDocumentTextShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> credentialConfigShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> sourceURI{};

  ExtractDocumentTextShrinkRequest() {}

  explicit ExtractDocumentTextShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfigShrink) {
      res["CredentialConfig"] = boost::any(*credentialConfigShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceType) {
      res["SourceType"] = boost::any(*sourceType);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      credentialConfigShrink = make_shared<string>(boost::any_cast<string>(m["CredentialConfig"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceType") != m.end() && !m["SourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["SourceType"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
  }


  virtual ~ExtractDocumentTextShrinkRequest() = default;
};
class ExtractDocumentTextResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> documentText{};
  shared_ptr<string> requestId{};

  ExtractDocumentTextResponseBody() {}

  explicit ExtractDocumentTextResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (documentText) {
      res["DocumentText"] = boost::any(*documentText);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DocumentText") != m.end() && !m["DocumentText"].empty()) {
      documentText = make_shared<string>(boost::any_cast<string>(m["DocumentText"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ExtractDocumentTextResponseBody() = default;
};
class ExtractDocumentTextResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ExtractDocumentTextResponseBody> body{};

  ExtractDocumentTextResponse() {}

  explicit ExtractDocumentTextResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ExtractDocumentTextResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ExtractDocumentTextResponseBody>(model1);
      }
    }
  }


  virtual ~ExtractDocumentTextResponse() = default;
};
class FuzzyQueryRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> order{};
  shared_ptr<string> projectName{};
  shared_ptr<string> query{};
  shared_ptr<string> sort{};
  shared_ptr<vector<string>> withFields{};

  FuzzyQueryRequest() {}

  explicit FuzzyQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (withFields) {
      res["WithFields"] = boost::any(*withFields);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["Sort"]));
    }
    if (m.find("WithFields") != m.end() && !m["WithFields"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WithFields"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WithFields"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      withFields = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~FuzzyQueryRequest() = default;
};
class FuzzyQueryShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> order{};
  shared_ptr<string> projectName{};
  shared_ptr<string> query{};
  shared_ptr<string> sort{};
  shared_ptr<string> withFieldsShrink{};

  FuzzyQueryShrinkRequest() {}

  explicit FuzzyQueryShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (withFieldsShrink) {
      res["WithFields"] = boost::any(*withFieldsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["Sort"]));
    }
    if (m.find("WithFields") != m.end() && !m["WithFields"].empty()) {
      withFieldsShrink = make_shared<string>(boost::any_cast<string>(m["WithFields"]));
    }
  }


  virtual ~FuzzyQueryShrinkRequest() = default;
};
class FuzzyQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<File>> files{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalHits{};

  FuzzyQueryResponseBody() {}

  explicit FuzzyQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (files) {
      vector<boost::any> temp1;
      for(auto item1:*files){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Files"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalHits) {
      res["TotalHits"] = boost::any(*totalHits);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      if (typeid(vector<boost::any>) == m["Files"].type()) {
        vector<File> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Files"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            File model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        files = make_shared<vector<File>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalHits") != m.end() && !m["TotalHits"].empty()) {
      totalHits = make_shared<long>(boost::any_cast<long>(m["TotalHits"]));
    }
  }


  virtual ~FuzzyQueryResponseBody() = default;
};
class FuzzyQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<FuzzyQueryResponseBody> body{};

  FuzzyQueryResponse() {}

  explicit FuzzyQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        FuzzyQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<FuzzyQueryResponseBody>(model1);
      }
    }
  }


  virtual ~FuzzyQueryResponse() = default;
};
class GenerateVideoPlaylistRequestSourceSubtitles : public Darabonba::Model {
public:
  shared_ptr<string> language{};
  shared_ptr<string> URI{};

  GenerateVideoPlaylistRequestSourceSubtitles() {}

  explicit GenerateVideoPlaylistRequestSourceSubtitles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~GenerateVideoPlaylistRequestSourceSubtitles() = default;
};
class GenerateVideoPlaylistRequestTargets : public Darabonba::Model {
public:
  shared_ptr<TargetAudio> audio{};
  shared_ptr<double> duration{};
  shared_ptr<vector<double>> initialSegments{};
  shared_ptr<double> initialTranscode{};
  shared_ptr<TargetSubtitle> subtitle{};
  shared_ptr<map<string, string>> tags{};
  shared_ptr<long> transcodeAhead{};
  shared_ptr<string> URI{};
  shared_ptr<TargetVideo> video{};

  GenerateVideoPlaylistRequestTargets() {}

  explicit GenerateVideoPlaylistRequestTargets(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audio) {
      res["Audio"] = audio ? boost::any(audio->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (initialSegments) {
      res["InitialSegments"] = boost::any(*initialSegments);
    }
    if (initialTranscode) {
      res["InitialTranscode"] = boost::any(*initialTranscode);
    }
    if (subtitle) {
      res["Subtitle"] = subtitle ? boost::any(subtitle->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (transcodeAhead) {
      res["TranscodeAhead"] = boost::any(*transcodeAhead);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    if (video) {
      res["Video"] = video ? boost::any(video->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Audio") != m.end() && !m["Audio"].empty()) {
      if (typeid(map<string, boost::any>) == m["Audio"].type()) {
        TargetAudio model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Audio"]));
        audio = make_shared<TargetAudio>(model1);
      }
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("InitialSegments") != m.end() && !m["InitialSegments"].empty()) {
      vector<double> toVec1;
      if (typeid(vector<boost::any>) == m["InitialSegments"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["InitialSegments"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<double>(item));
        }
      }
      initialSegments = make_shared<vector<double>>(toVec1);
    }
    if (m.find("InitialTranscode") != m.end() && !m["InitialTranscode"].empty()) {
      initialTranscode = make_shared<double>(boost::any_cast<double>(m["InitialTranscode"]));
    }
    if (m.find("Subtitle") != m.end() && !m["Subtitle"].empty()) {
      if (typeid(map<string, boost::any>) == m["Subtitle"].type()) {
        TargetSubtitle model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Subtitle"]));
        subtitle = make_shared<TargetSubtitle>(model1);
      }
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Tags"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("TranscodeAhead") != m.end() && !m["TranscodeAhead"].empty()) {
      transcodeAhead = make_shared<long>(boost::any_cast<long>(m["TranscodeAhead"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
    if (m.find("Video") != m.end() && !m["Video"].empty()) {
      if (typeid(map<string, boost::any>) == m["Video"].type()) {
        TargetVideo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Video"]));
        video = make_shared<TargetVideo>(model1);
      }
    }
  }


  virtual ~GenerateVideoPlaylistRequestTargets() = default;
};
class GenerateVideoPlaylistRequest : public Darabonba::Model {
public:
  shared_ptr<CredentialConfig> credentialConfig{};
  shared_ptr<string> masterURI{};
  shared_ptr<Notification> notification{};
  shared_ptr<string> overwritePolicy{};
  shared_ptr<string> projectName{};
  shared_ptr<double> sourceDuration{};
  shared_ptr<double> sourceStartTime{};
  shared_ptr<vector<GenerateVideoPlaylistRequestSourceSubtitles>> sourceSubtitles{};
  shared_ptr<string> sourceURI{};
  shared_ptr<map<string, string>> tags{};
  shared_ptr<vector<GenerateVideoPlaylistRequestTargets>> targets{};
  shared_ptr<string> userData{};

  GenerateVideoPlaylistRequest() {}

  explicit GenerateVideoPlaylistRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfig) {
      res["CredentialConfig"] = credentialConfig ? boost::any(credentialConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (masterURI) {
      res["MasterURI"] = boost::any(*masterURI);
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (overwritePolicy) {
      res["OverwritePolicy"] = boost::any(*overwritePolicy);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceDuration) {
      res["SourceDuration"] = boost::any(*sourceDuration);
    }
    if (sourceStartTime) {
      res["SourceStartTime"] = boost::any(*sourceStartTime);
    }
    if (sourceSubtitles) {
      vector<boost::any> temp1;
      for(auto item1:*sourceSubtitles){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SourceSubtitles"] = boost::any(temp1);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (targets) {
      vector<boost::any> temp1;
      for(auto item1:*targets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Targets"] = boost::any(temp1);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CredentialConfig"].type()) {
        CredentialConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CredentialConfig"]));
        credentialConfig = make_shared<CredentialConfig>(model1);
      }
    }
    if (m.find("MasterURI") != m.end() && !m["MasterURI"].empty()) {
      masterURI = make_shared<string>(boost::any_cast<string>(m["MasterURI"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        Notification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<Notification>(model1);
      }
    }
    if (m.find("OverwritePolicy") != m.end() && !m["OverwritePolicy"].empty()) {
      overwritePolicy = make_shared<string>(boost::any_cast<string>(m["OverwritePolicy"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceDuration") != m.end() && !m["SourceDuration"].empty()) {
      sourceDuration = make_shared<double>(boost::any_cast<double>(m["SourceDuration"]));
    }
    if (m.find("SourceStartTime") != m.end() && !m["SourceStartTime"].empty()) {
      sourceStartTime = make_shared<double>(boost::any_cast<double>(m["SourceStartTime"]));
    }
    if (m.find("SourceSubtitles") != m.end() && !m["SourceSubtitles"].empty()) {
      if (typeid(vector<boost::any>) == m["SourceSubtitles"].type()) {
        vector<GenerateVideoPlaylistRequestSourceSubtitles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SourceSubtitles"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GenerateVideoPlaylistRequestSourceSubtitles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        sourceSubtitles = make_shared<vector<GenerateVideoPlaylistRequestSourceSubtitles>>(expect1);
      }
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["Tags"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("Targets") != m.end() && !m["Targets"].empty()) {
      if (typeid(vector<boost::any>) == m["Targets"].type()) {
        vector<GenerateVideoPlaylistRequestTargets> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Targets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GenerateVideoPlaylistRequestTargets model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        targets = make_shared<vector<GenerateVideoPlaylistRequestTargets>>(expect1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GenerateVideoPlaylistRequest() = default;
};
class GenerateVideoPlaylistShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> credentialConfigShrink{};
  shared_ptr<string> masterURI{};
  shared_ptr<string> notificationShrink{};
  shared_ptr<string> overwritePolicy{};
  shared_ptr<string> projectName{};
  shared_ptr<double> sourceDuration{};
  shared_ptr<double> sourceStartTime{};
  shared_ptr<string> sourceSubtitlesShrink{};
  shared_ptr<string> sourceURI{};
  shared_ptr<string> tagsShrink{};
  shared_ptr<string> targetsShrink{};
  shared_ptr<string> userData{};

  GenerateVideoPlaylistShrinkRequest() {}

  explicit GenerateVideoPlaylistShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfigShrink) {
      res["CredentialConfig"] = boost::any(*credentialConfigShrink);
    }
    if (masterURI) {
      res["MasterURI"] = boost::any(*masterURI);
    }
    if (notificationShrink) {
      res["Notification"] = boost::any(*notificationShrink);
    }
    if (overwritePolicy) {
      res["OverwritePolicy"] = boost::any(*overwritePolicy);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceDuration) {
      res["SourceDuration"] = boost::any(*sourceDuration);
    }
    if (sourceStartTime) {
      res["SourceStartTime"] = boost::any(*sourceStartTime);
    }
    if (sourceSubtitlesShrink) {
      res["SourceSubtitles"] = boost::any(*sourceSubtitlesShrink);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    if (targetsShrink) {
      res["Targets"] = boost::any(*targetsShrink);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      credentialConfigShrink = make_shared<string>(boost::any_cast<string>(m["CredentialConfig"]));
    }
    if (m.find("MasterURI") != m.end() && !m["MasterURI"].empty()) {
      masterURI = make_shared<string>(boost::any_cast<string>(m["MasterURI"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      notificationShrink = make_shared<string>(boost::any_cast<string>(m["Notification"]));
    }
    if (m.find("OverwritePolicy") != m.end() && !m["OverwritePolicy"].empty()) {
      overwritePolicy = make_shared<string>(boost::any_cast<string>(m["OverwritePolicy"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceDuration") != m.end() && !m["SourceDuration"].empty()) {
      sourceDuration = make_shared<double>(boost::any_cast<double>(m["SourceDuration"]));
    }
    if (m.find("SourceStartTime") != m.end() && !m["SourceStartTime"].empty()) {
      sourceStartTime = make_shared<double>(boost::any_cast<double>(m["SourceStartTime"]));
    }
    if (m.find("SourceSubtitles") != m.end() && !m["SourceSubtitles"].empty()) {
      sourceSubtitlesShrink = make_shared<string>(boost::any_cast<string>(m["SourceSubtitles"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
    if (m.find("Targets") != m.end() && !m["Targets"].empty()) {
      targetsShrink = make_shared<string>(boost::any_cast<string>(m["Targets"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GenerateVideoPlaylistShrinkRequest() = default;
};
class GenerateVideoPlaylistResponseBodyAudioPlaylist : public Darabonba::Model {
public:
  shared_ptr<long> channels{};
  shared_ptr<string> token{};
  shared_ptr<string> URI{};

  GenerateVideoPlaylistResponseBodyAudioPlaylist() {}

  explicit GenerateVideoPlaylistResponseBodyAudioPlaylist(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (channels) {
      res["Channels"] = boost::any(*channels);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Channels") != m.end() && !m["Channels"].empty()) {
      channels = make_shared<long>(boost::any_cast<long>(m["Channels"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~GenerateVideoPlaylistResponseBodyAudioPlaylist() = default;
};
class GenerateVideoPlaylistResponseBodySubtitlePlaylist : public Darabonba::Model {
public:
  shared_ptr<long> index{};
  shared_ptr<string> language{};
  shared_ptr<string> token{};
  shared_ptr<string> URI{};

  GenerateVideoPlaylistResponseBodySubtitlePlaylist() {}

  explicit GenerateVideoPlaylistResponseBodySubtitlePlaylist(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["Index"] = boost::any(*index);
    }
    if (language) {
      res["Language"] = boost::any(*language);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Index") != m.end() && !m["Index"].empty()) {
      index = make_shared<long>(boost::any_cast<long>(m["Index"]));
    }
    if (m.find("Language") != m.end() && !m["Language"].empty()) {
      language = make_shared<string>(boost::any_cast<string>(m["Language"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~GenerateVideoPlaylistResponseBodySubtitlePlaylist() = default;
};
class GenerateVideoPlaylistResponseBodyVideoPlaylist : public Darabonba::Model {
public:
  shared_ptr<string> frameRate{};
  shared_ptr<string> resolution{};
  shared_ptr<string> token{};
  shared_ptr<string> URI{};

  GenerateVideoPlaylistResponseBodyVideoPlaylist() {}

  explicit GenerateVideoPlaylistResponseBodyVideoPlaylist(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (frameRate) {
      res["FrameRate"] = boost::any(*frameRate);
    }
    if (resolution) {
      res["Resolution"] = boost::any(*resolution);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FrameRate") != m.end() && !m["FrameRate"].empty()) {
      frameRate = make_shared<string>(boost::any_cast<string>(m["FrameRate"]));
    }
    if (m.find("Resolution") != m.end() && !m["Resolution"].empty()) {
      resolution = make_shared<string>(boost::any_cast<string>(m["Resolution"]));
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~GenerateVideoPlaylistResponseBodyVideoPlaylist() = default;
};
class GenerateVideoPlaylistResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<GenerateVideoPlaylistResponseBodyAudioPlaylist>> audioPlaylist{};
  shared_ptr<double> duration{};
  shared_ptr<string> masterURI{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<GenerateVideoPlaylistResponseBodySubtitlePlaylist>> subtitlePlaylist{};
  shared_ptr<string> token{};
  shared_ptr<vector<GenerateVideoPlaylistResponseBodyVideoPlaylist>> videoPlaylist{};

  GenerateVideoPlaylistResponseBody() {}

  explicit GenerateVideoPlaylistResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (audioPlaylist) {
      vector<boost::any> temp1;
      for(auto item1:*audioPlaylist){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["AudioPlaylist"] = boost::any(temp1);
    }
    if (duration) {
      res["Duration"] = boost::any(*duration);
    }
    if (masterURI) {
      res["MasterURI"] = boost::any(*masterURI);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (subtitlePlaylist) {
      vector<boost::any> temp1;
      for(auto item1:*subtitlePlaylist){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SubtitlePlaylist"] = boost::any(temp1);
    }
    if (token) {
      res["Token"] = boost::any(*token);
    }
    if (videoPlaylist) {
      vector<boost::any> temp1;
      for(auto item1:*videoPlaylist){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["VideoPlaylist"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AudioPlaylist") != m.end() && !m["AudioPlaylist"].empty()) {
      if (typeid(vector<boost::any>) == m["AudioPlaylist"].type()) {
        vector<GenerateVideoPlaylistResponseBodyAudioPlaylist> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["AudioPlaylist"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GenerateVideoPlaylistResponseBodyAudioPlaylist model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        audioPlaylist = make_shared<vector<GenerateVideoPlaylistResponseBodyAudioPlaylist>>(expect1);
      }
    }
    if (m.find("Duration") != m.end() && !m["Duration"].empty()) {
      duration = make_shared<double>(boost::any_cast<double>(m["Duration"]));
    }
    if (m.find("MasterURI") != m.end() && !m["MasterURI"].empty()) {
      masterURI = make_shared<string>(boost::any_cast<string>(m["MasterURI"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SubtitlePlaylist") != m.end() && !m["SubtitlePlaylist"].empty()) {
      if (typeid(vector<boost::any>) == m["SubtitlePlaylist"].type()) {
        vector<GenerateVideoPlaylistResponseBodySubtitlePlaylist> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SubtitlePlaylist"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GenerateVideoPlaylistResponseBodySubtitlePlaylist model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subtitlePlaylist = make_shared<vector<GenerateVideoPlaylistResponseBodySubtitlePlaylist>>(expect1);
      }
    }
    if (m.find("Token") != m.end() && !m["Token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["Token"]));
    }
    if (m.find("VideoPlaylist") != m.end() && !m["VideoPlaylist"].empty()) {
      if (typeid(vector<boost::any>) == m["VideoPlaylist"].type()) {
        vector<GenerateVideoPlaylistResponseBodyVideoPlaylist> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["VideoPlaylist"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GenerateVideoPlaylistResponseBodyVideoPlaylist model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        videoPlaylist = make_shared<vector<GenerateVideoPlaylistResponseBodyVideoPlaylist>>(expect1);
      }
    }
  }


  virtual ~GenerateVideoPlaylistResponseBody() = default;
};
class GenerateVideoPlaylistResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GenerateVideoPlaylistResponseBody> body{};

  GenerateVideoPlaylistResponse() {}

  explicit GenerateVideoPlaylistResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateVideoPlaylistResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateVideoPlaylistResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateVideoPlaylistResponse() = default;
};
class GenerateWebofficeTokenRequest : public Darabonba::Model {
public:
  shared_ptr<bool> cachePreview{};
  shared_ptr<CredentialConfig> credentialConfig{};
  shared_ptr<bool> externalUploaded{};
  shared_ptr<string> filename{};
  shared_ptr<bool> hidecmb{};
  shared_ptr<Notification> notification{};
  shared_ptr<string> notifyTopicName{};
  shared_ptr<string> password{};
  shared_ptr<WebofficePermission> permission{};
  shared_ptr<long> previewPages{};
  shared_ptr<string> projectName{};
  shared_ptr<string> referer{};
  shared_ptr<string> sourceURI{};
  shared_ptr<WebofficeUser> user{};
  shared_ptr<string> userData{};
  shared_ptr<WebofficeWatermark> watermark{};

  GenerateWebofficeTokenRequest() {}

  explicit GenerateWebofficeTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cachePreview) {
      res["CachePreview"] = boost::any(*cachePreview);
    }
    if (credentialConfig) {
      res["CredentialConfig"] = credentialConfig ? boost::any(credentialConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (externalUploaded) {
      res["ExternalUploaded"] = boost::any(*externalUploaded);
    }
    if (filename) {
      res["Filename"] = boost::any(*filename);
    }
    if (hidecmb) {
      res["Hidecmb"] = boost::any(*hidecmb);
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (notifyTopicName) {
      res["NotifyTopicName"] = boost::any(*notifyTopicName);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (permission) {
      res["Permission"] = permission ? boost::any(permission->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (previewPages) {
      res["PreviewPages"] = boost::any(*previewPages);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (referer) {
      res["Referer"] = boost::any(*referer);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    if (user) {
      res["User"] = user ? boost::any(user->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (watermark) {
      res["Watermark"] = watermark ? boost::any(watermark->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CachePreview") != m.end() && !m["CachePreview"].empty()) {
      cachePreview = make_shared<bool>(boost::any_cast<bool>(m["CachePreview"]));
    }
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CredentialConfig"].type()) {
        CredentialConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CredentialConfig"]));
        credentialConfig = make_shared<CredentialConfig>(model1);
      }
    }
    if (m.find("ExternalUploaded") != m.end() && !m["ExternalUploaded"].empty()) {
      externalUploaded = make_shared<bool>(boost::any_cast<bool>(m["ExternalUploaded"]));
    }
    if (m.find("Filename") != m.end() && !m["Filename"].empty()) {
      filename = make_shared<string>(boost::any_cast<string>(m["Filename"]));
    }
    if (m.find("Hidecmb") != m.end() && !m["Hidecmb"].empty()) {
      hidecmb = make_shared<bool>(boost::any_cast<bool>(m["Hidecmb"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        Notification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<Notification>(model1);
      }
    }
    if (m.find("NotifyTopicName") != m.end() && !m["NotifyTopicName"].empty()) {
      notifyTopicName = make_shared<string>(boost::any_cast<string>(m["NotifyTopicName"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Permission") != m.end() && !m["Permission"].empty()) {
      if (typeid(map<string, boost::any>) == m["Permission"].type()) {
        WebofficePermission model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Permission"]));
        permission = make_shared<WebofficePermission>(model1);
      }
    }
    if (m.find("PreviewPages") != m.end() && !m["PreviewPages"].empty()) {
      previewPages = make_shared<long>(boost::any_cast<long>(m["PreviewPages"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Referer") != m.end() && !m["Referer"].empty()) {
      referer = make_shared<string>(boost::any_cast<string>(m["Referer"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      if (typeid(map<string, boost::any>) == m["User"].type()) {
        WebofficeUser model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["User"]));
        user = make_shared<WebofficeUser>(model1);
      }
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Watermark") != m.end() && !m["Watermark"].empty()) {
      if (typeid(map<string, boost::any>) == m["Watermark"].type()) {
        WebofficeWatermark model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Watermark"]));
        watermark = make_shared<WebofficeWatermark>(model1);
      }
    }
  }


  virtual ~GenerateWebofficeTokenRequest() = default;
};
class GenerateWebofficeTokenShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<bool> cachePreview{};
  shared_ptr<string> credentialConfigShrink{};
  shared_ptr<bool> externalUploaded{};
  shared_ptr<string> filename{};
  shared_ptr<bool> hidecmb{};
  shared_ptr<string> notificationShrink{};
  shared_ptr<string> notifyTopicName{};
  shared_ptr<string> password{};
  shared_ptr<string> permissionShrink{};
  shared_ptr<long> previewPages{};
  shared_ptr<string> projectName{};
  shared_ptr<string> referer{};
  shared_ptr<string> sourceURI{};
  shared_ptr<string> userShrink{};
  shared_ptr<string> userData{};
  shared_ptr<string> watermarkShrink{};

  GenerateWebofficeTokenShrinkRequest() {}

  explicit GenerateWebofficeTokenShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cachePreview) {
      res["CachePreview"] = boost::any(*cachePreview);
    }
    if (credentialConfigShrink) {
      res["CredentialConfig"] = boost::any(*credentialConfigShrink);
    }
    if (externalUploaded) {
      res["ExternalUploaded"] = boost::any(*externalUploaded);
    }
    if (filename) {
      res["Filename"] = boost::any(*filename);
    }
    if (hidecmb) {
      res["Hidecmb"] = boost::any(*hidecmb);
    }
    if (notificationShrink) {
      res["Notification"] = boost::any(*notificationShrink);
    }
    if (notifyTopicName) {
      res["NotifyTopicName"] = boost::any(*notifyTopicName);
    }
    if (password) {
      res["Password"] = boost::any(*password);
    }
    if (permissionShrink) {
      res["Permission"] = boost::any(*permissionShrink);
    }
    if (previewPages) {
      res["PreviewPages"] = boost::any(*previewPages);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (referer) {
      res["Referer"] = boost::any(*referer);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    if (userShrink) {
      res["User"] = boost::any(*userShrink);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    if (watermarkShrink) {
      res["Watermark"] = boost::any(*watermarkShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CachePreview") != m.end() && !m["CachePreview"].empty()) {
      cachePreview = make_shared<bool>(boost::any_cast<bool>(m["CachePreview"]));
    }
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      credentialConfigShrink = make_shared<string>(boost::any_cast<string>(m["CredentialConfig"]));
    }
    if (m.find("ExternalUploaded") != m.end() && !m["ExternalUploaded"].empty()) {
      externalUploaded = make_shared<bool>(boost::any_cast<bool>(m["ExternalUploaded"]));
    }
    if (m.find("Filename") != m.end() && !m["Filename"].empty()) {
      filename = make_shared<string>(boost::any_cast<string>(m["Filename"]));
    }
    if (m.find("Hidecmb") != m.end() && !m["Hidecmb"].empty()) {
      hidecmb = make_shared<bool>(boost::any_cast<bool>(m["Hidecmb"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      notificationShrink = make_shared<string>(boost::any_cast<string>(m["Notification"]));
    }
    if (m.find("NotifyTopicName") != m.end() && !m["NotifyTopicName"].empty()) {
      notifyTopicName = make_shared<string>(boost::any_cast<string>(m["NotifyTopicName"]));
    }
    if (m.find("Password") != m.end() && !m["Password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["Password"]));
    }
    if (m.find("Permission") != m.end() && !m["Permission"].empty()) {
      permissionShrink = make_shared<string>(boost::any_cast<string>(m["Permission"]));
    }
    if (m.find("PreviewPages") != m.end() && !m["PreviewPages"].empty()) {
      previewPages = make_shared<long>(boost::any_cast<long>(m["PreviewPages"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Referer") != m.end() && !m["Referer"].empty()) {
      referer = make_shared<string>(boost::any_cast<string>(m["Referer"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
    if (m.find("User") != m.end() && !m["User"].empty()) {
      userShrink = make_shared<string>(boost::any_cast<string>(m["User"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
    if (m.find("Watermark") != m.end() && !m["Watermark"].empty()) {
      watermarkShrink = make_shared<string>(boost::any_cast<string>(m["Watermark"]));
    }
  }


  virtual ~GenerateWebofficeTokenShrinkRequest() = default;
};
class GenerateWebofficeTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> accessTokenExpiredTime{};
  shared_ptr<string> refreshToken{};
  shared_ptr<string> refreshTokenExpiredTime{};
  shared_ptr<string> requestId{};
  shared_ptr<string> webofficeURL{};

  GenerateWebofficeTokenResponseBody() {}

  explicit GenerateWebofficeTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["AccessToken"] = boost::any(*accessToken);
    }
    if (accessTokenExpiredTime) {
      res["AccessTokenExpiredTime"] = boost::any(*accessTokenExpiredTime);
    }
    if (refreshToken) {
      res["RefreshToken"] = boost::any(*refreshToken);
    }
    if (refreshTokenExpiredTime) {
      res["RefreshTokenExpiredTime"] = boost::any(*refreshTokenExpiredTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (webofficeURL) {
      res["WebofficeURL"] = boost::any(*webofficeURL);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessToken") != m.end() && !m["AccessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["AccessToken"]));
    }
    if (m.find("AccessTokenExpiredTime") != m.end() && !m["AccessTokenExpiredTime"].empty()) {
      accessTokenExpiredTime = make_shared<string>(boost::any_cast<string>(m["AccessTokenExpiredTime"]));
    }
    if (m.find("RefreshToken") != m.end() && !m["RefreshToken"].empty()) {
      refreshToken = make_shared<string>(boost::any_cast<string>(m["RefreshToken"]));
    }
    if (m.find("RefreshTokenExpiredTime") != m.end() && !m["RefreshTokenExpiredTime"].empty()) {
      refreshTokenExpiredTime = make_shared<string>(boost::any_cast<string>(m["RefreshTokenExpiredTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("WebofficeURL") != m.end() && !m["WebofficeURL"].empty()) {
      webofficeURL = make_shared<string>(boost::any_cast<string>(m["WebofficeURL"]));
    }
  }


  virtual ~GenerateWebofficeTokenResponseBody() = default;
};
class GenerateWebofficeTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GenerateWebofficeTokenResponseBody> body{};

  GenerateWebofficeTokenResponse() {}

  explicit GenerateWebofficeTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GenerateWebofficeTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GenerateWebofficeTokenResponseBody>(model1);
      }
    }
  }


  virtual ~GenerateWebofficeTokenResponse() = default;
};
class GetBatchRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> projectName{};

  GetBatchRequest() {}

  explicit GetBatchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~GetBatchRequest() = default;
};
class GetBatchResponseBody : public Darabonba::Model {
public:
  shared_ptr<DataIngestion> batch{};
  shared_ptr<string> requestId{};

  GetBatchResponseBody() {}

  explicit GetBatchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batch) {
      res["Batch"] = batch ? boost::any(batch->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Batch") != m.end() && !m["Batch"].empty()) {
      if (typeid(map<string, boost::any>) == m["Batch"].type()) {
        DataIngestion model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Batch"]));
        batch = make_shared<DataIngestion>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetBatchResponseBody() = default;
};
class GetBatchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBatchResponseBody> body{};

  GetBatchResponse() {}

  explicit GetBatchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBatchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBatchResponseBody>(model1);
      }
    }
  }


  virtual ~GetBatchResponse() = default;
};
class GetBindingRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> projectName{};
  shared_ptr<string> URI{};

  GetBindingRequest() {}

  explicit GetBindingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~GetBindingRequest() = default;
};
class GetBindingResponseBody : public Darabonba::Model {
public:
  shared_ptr<Binding> binding{};
  shared_ptr<string> requestId{};

  GetBindingResponseBody() {}

  explicit GetBindingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (binding) {
      res["Binding"] = binding ? boost::any(binding->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Binding") != m.end() && !m["Binding"].empty()) {
      if (typeid(map<string, boost::any>) == m["Binding"].type()) {
        Binding model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Binding"]));
        binding = make_shared<Binding>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetBindingResponseBody() = default;
};
class GetBindingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetBindingResponseBody> body{};

  GetBindingResponse() {}

  explicit GetBindingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetBindingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetBindingResponseBody>(model1);
      }
    }
  }


  virtual ~GetBindingResponse() = default;
};
class GetDRMLicenseRequest : public Darabonba::Model {
public:
  shared_ptr<string> keyId{};
  shared_ptr<string> notifyEndpoint{};
  shared_ptr<string> notifyTopicName{};
  shared_ptr<string> projectName{};
  shared_ptr<string> protectionSystem{};

  GetDRMLicenseRequest() {}

  explicit GetDRMLicenseRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (keyId) {
      res["KeyId"] = boost::any(*keyId);
    }
    if (notifyEndpoint) {
      res["NotifyEndpoint"] = boost::any(*notifyEndpoint);
    }
    if (notifyTopicName) {
      res["NotifyTopicName"] = boost::any(*notifyTopicName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (protectionSystem) {
      res["ProtectionSystem"] = boost::any(*protectionSystem);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("KeyId") != m.end() && !m["KeyId"].empty()) {
      keyId = make_shared<string>(boost::any_cast<string>(m["KeyId"]));
    }
    if (m.find("NotifyEndpoint") != m.end() && !m["NotifyEndpoint"].empty()) {
      notifyEndpoint = make_shared<string>(boost::any_cast<string>(m["NotifyEndpoint"]));
    }
    if (m.find("NotifyTopicName") != m.end() && !m["NotifyTopicName"].empty()) {
      notifyTopicName = make_shared<string>(boost::any_cast<string>(m["NotifyTopicName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ProtectionSystem") != m.end() && !m["ProtectionSystem"].empty()) {
      protectionSystem = make_shared<string>(boost::any_cast<string>(m["ProtectionSystem"]));
    }
  }


  virtual ~GetDRMLicenseRequest() = default;
};
class GetDRMLicenseResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> deviceInfo{};
  shared_ptr<string> license{};
  shared_ptr<string> requestId{};
  shared_ptr<long> states{};

  GetDRMLicenseResponseBody() {}

  explicit GetDRMLicenseResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (deviceInfo) {
      res["DeviceInfo"] = boost::any(*deviceInfo);
    }
    if (license) {
      res["License"] = boost::any(*license);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (states) {
      res["States"] = boost::any(*states);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DeviceInfo") != m.end() && !m["DeviceInfo"].empty()) {
      deviceInfo = make_shared<string>(boost::any_cast<string>(m["DeviceInfo"]));
    }
    if (m.find("License") != m.end() && !m["License"].empty()) {
      license = make_shared<string>(boost::any_cast<string>(m["License"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("States") != m.end() && !m["States"].empty()) {
      states = make_shared<long>(boost::any_cast<long>(m["States"]));
    }
  }


  virtual ~GetDRMLicenseResponseBody() = default;
};
class GetDRMLicenseResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDRMLicenseResponseBody> body{};

  GetDRMLicenseResponse() {}

  explicit GetDRMLicenseResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDRMLicenseResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDRMLicenseResponseBody>(model1);
      }
    }
  }


  virtual ~GetDRMLicenseResponse() = default;
};
class GetDatasetRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> projectName{};
  shared_ptr<bool> withStatistics{};

  GetDatasetRequest() {}

  explicit GetDatasetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (withStatistics) {
      res["WithStatistics"] = boost::any(*withStatistics);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("WithStatistics") != m.end() && !m["WithStatistics"].empty()) {
      withStatistics = make_shared<bool>(boost::any_cast<bool>(m["WithStatistics"]));
    }
  }


  virtual ~GetDatasetRequest() = default;
};
class GetDatasetResponseBody : public Darabonba::Model {
public:
  shared_ptr<Dataset> dataset{};
  shared_ptr<string> requestId{};

  GetDatasetResponseBody() {}

  explicit GetDatasetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataset) {
      res["Dataset"] = dataset ? boost::any(dataset->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dataset") != m.end() && !m["Dataset"].empty()) {
      if (typeid(map<string, boost::any>) == m["Dataset"].type()) {
        Dataset model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Dataset"]));
        dataset = make_shared<Dataset>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetDatasetResponseBody() = default;
};
class GetDatasetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDatasetResponseBody> body{};

  GetDatasetResponse() {}

  explicit GetDatasetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDatasetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDatasetResponseBody>(model1);
      }
    }
  }


  virtual ~GetDatasetResponse() = default;
};
class GetDecodeBlindWatermarkResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskType{};

  GetDecodeBlindWatermarkResultRequest() {}

  explicit GetDecodeBlindWatermarkResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~GetDecodeBlindWatermarkResultRequest() = default;
};
class GetDecodeBlindWatermarkResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> content{};
  shared_ptr<string> endTime{};
  shared_ptr<string> eventId{};
  shared_ptr<string> message{};
  shared_ptr<string> projectName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskType{};
  shared_ptr<string> userData{};

  GetDecodeBlindWatermarkResultResponseBody() {}

  explicit GetDecodeBlindWatermarkResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (content) {
      res["Content"] = boost::any(*content);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Content") != m.end() && !m["Content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["Content"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetDecodeBlindWatermarkResultResponseBody() = default;
};
class GetDecodeBlindWatermarkResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetDecodeBlindWatermarkResultResponseBody> body{};

  GetDecodeBlindWatermarkResultResponse() {}

  explicit GetDecodeBlindWatermarkResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetDecodeBlindWatermarkResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetDecodeBlindWatermarkResultResponseBody>(model1);
      }
    }
  }


  virtual ~GetDecodeBlindWatermarkResultResponse() = default;
};
class GetFigureClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> objectId{};
  shared_ptr<string> projectName{};

  GetFigureClusterRequest() {}

  explicit GetFigureClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~GetFigureClusterRequest() = default;
};
class GetFigureClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<FigureCluster> figureCluster{};
  shared_ptr<string> requestId{};

  GetFigureClusterResponseBody() {}

  explicit GetFigureClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (figureCluster) {
      res["FigureCluster"] = figureCluster ? boost::any(figureCluster->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FigureCluster") != m.end() && !m["FigureCluster"].empty()) {
      if (typeid(map<string, boost::any>) == m["FigureCluster"].type()) {
        FigureCluster model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FigureCluster"]));
        figureCluster = make_shared<FigureCluster>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetFigureClusterResponseBody() = default;
};
class GetFigureClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetFigureClusterResponseBody> body{};

  GetFigureClusterResponse() {}

  explicit GetFigureClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetFigureClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetFigureClusterResponseBody>(model1);
      }
    }
  }


  virtual ~GetFigureClusterResponse() = default;
};
class GetFileMetaRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> projectName{};
  shared_ptr<string> URI{};
  shared_ptr<vector<string>> withFields{};

  GetFileMetaRequest() {}

  explicit GetFileMetaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    if (withFields) {
      res["WithFields"] = boost::any(*withFields);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
    if (m.find("WithFields") != m.end() && !m["WithFields"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WithFields"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WithFields"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      withFields = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetFileMetaRequest() = default;
};
class GetFileMetaShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> projectName{};
  shared_ptr<string> URI{};
  shared_ptr<string> withFieldsShrink{};

  GetFileMetaShrinkRequest() {}

  explicit GetFileMetaShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    if (withFieldsShrink) {
      res["WithFields"] = boost::any(*withFieldsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
    if (m.find("WithFields") != m.end() && !m["WithFields"].empty()) {
      withFieldsShrink = make_shared<string>(boost::any_cast<string>(m["WithFields"]));
    }
  }


  virtual ~GetFileMetaShrinkRequest() = default;
};
class GetFileMetaResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<File>> files{};
  shared_ptr<string> requestId{};

  GetFileMetaResponseBody() {}

  explicit GetFileMetaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (files) {
      vector<boost::any> temp1;
      for(auto item1:*files){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Files"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      if (typeid(vector<boost::any>) == m["Files"].type()) {
        vector<File> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Files"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            File model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        files = make_shared<vector<File>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetFileMetaResponseBody() = default;
};
class GetFileMetaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetFileMetaResponseBody> body{};

  GetFileMetaResponse() {}

  explicit GetFileMetaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetFileMetaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetFileMetaResponseBody>(model1);
      }
    }
  }


  virtual ~GetFileMetaResponse() = default;
};
class GetImageModerationResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskType{};

  GetImageModerationResultRequest() {}

  explicit GetImageModerationResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~GetImageModerationResultRequest() = default;
};
class GetImageModerationResultResponseBodyModerationResultFramesBlockFrames : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<long> offset{};
  shared_ptr<double> rate{};

  GetImageModerationResultResponseBodyModerationResultFramesBlockFrames() {}

  explicit GetImageModerationResultResponseBodyModerationResultFramesBlockFrames(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<double>(boost::any_cast<double>(m["Rate"]));
    }
  }


  virtual ~GetImageModerationResultResponseBodyModerationResultFramesBlockFrames() = default;
};
class GetImageModerationResultResponseBodyModerationResultFrames : public Darabonba::Model {
public:
  shared_ptr<vector<GetImageModerationResultResponseBodyModerationResultFramesBlockFrames>> blockFrames{};
  shared_ptr<long> totalCount{};

  GetImageModerationResultResponseBodyModerationResultFrames() {}

  explicit GetImageModerationResultResponseBodyModerationResultFrames(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockFrames) {
      vector<boost::any> temp1;
      for(auto item1:*blockFrames){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BlockFrames"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockFrames") != m.end() && !m["BlockFrames"].empty()) {
      if (typeid(vector<boost::any>) == m["BlockFrames"].type()) {
        vector<GetImageModerationResultResponseBodyModerationResultFramesBlockFrames> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BlockFrames"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetImageModerationResultResponseBodyModerationResultFramesBlockFrames model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        blockFrames = make_shared<vector<GetImageModerationResultResponseBodyModerationResultFramesBlockFrames>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetImageModerationResultResponseBodyModerationResultFrames() = default;
};
class GetImageModerationResultResponseBodyModerationResult : public Darabonba::Model {
public:
  shared_ptr<vector<string>> categories{};
  shared_ptr<GetImageModerationResultResponseBodyModerationResultFrames> frames{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> URI{};

  GetImageModerationResultResponseBodyModerationResult() {}

  explicit GetImageModerationResultResponseBodyModerationResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categories) {
      res["Categories"] = boost::any(*categories);
    }
    if (frames) {
      res["Frames"] = frames ? boost::any(frames->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Categories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Categories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      categories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Frames") != m.end() && !m["Frames"].empty()) {
      if (typeid(map<string, boost::any>) == m["Frames"].type()) {
        GetImageModerationResultResponseBodyModerationResultFrames model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Frames"]));
        frames = make_shared<GetImageModerationResultResponseBodyModerationResultFrames>(model1);
      }
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~GetImageModerationResultResponseBodyModerationResult() = default;
};
class GetImageModerationResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> endTime{};
  shared_ptr<string> eventId{};
  shared_ptr<string> message{};
  shared_ptr<GetImageModerationResultResponseBodyModerationResult> moderationResult{};
  shared_ptr<string> projectName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskType{};
  shared_ptr<string> userData{};

  GetImageModerationResultResponseBody() {}

  explicit GetImageModerationResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (moderationResult) {
      res["ModerationResult"] = moderationResult ? boost::any(moderationResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ModerationResult") != m.end() && !m["ModerationResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ModerationResult"].type()) {
        GetImageModerationResultResponseBodyModerationResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ModerationResult"]));
        moderationResult = make_shared<GetImageModerationResultResponseBodyModerationResult>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetImageModerationResultResponseBody() = default;
};
class GetImageModerationResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetImageModerationResultResponseBody> body{};

  GetImageModerationResultResponse() {}

  explicit GetImageModerationResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetImageModerationResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetImageModerationResultResponseBody>(model1);
      }
    }
  }


  virtual ~GetImageModerationResultResponse() = default;
};
class GetOSSBucketAttachmentRequest : public Darabonba::Model {
public:
  shared_ptr<string> OSSBucket{};

  GetOSSBucketAttachmentRequest() {}

  explicit GetOSSBucketAttachmentRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (OSSBucket) {
      res["OSSBucket"] = boost::any(*OSSBucket);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("OSSBucket") != m.end() && !m["OSSBucket"].empty()) {
      OSSBucket = make_shared<string>(boost::any_cast<string>(m["OSSBucket"]));
    }
  }


  virtual ~GetOSSBucketAttachmentRequest() = default;
};
class GetOSSBucketAttachmentResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> description{};
  shared_ptr<string> projectName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> updateTime{};

  GetOSSBucketAttachmentResponseBody() {}

  explicit GetOSSBucketAttachmentResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["CreateTime"] = boost::any(*createTime);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (updateTime) {
      res["UpdateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTime") != m.end() && !m["CreateTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["CreateTime"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("UpdateTime") != m.end() && !m["UpdateTime"].empty()) {
      updateTime = make_shared<string>(boost::any_cast<string>(m["UpdateTime"]));
    }
  }


  virtual ~GetOSSBucketAttachmentResponseBody() = default;
};
class GetOSSBucketAttachmentResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetOSSBucketAttachmentResponseBody> body{};

  GetOSSBucketAttachmentResponse() {}

  explicit GetOSSBucketAttachmentResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOSSBucketAttachmentResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOSSBucketAttachmentResponseBody>(model1);
      }
    }
  }


  virtual ~GetOSSBucketAttachmentResponse() = default;
};
class GetProjectRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};
  shared_ptr<bool> withStatistics{};

  GetProjectRequest() {}

  explicit GetProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (withStatistics) {
      res["WithStatistics"] = boost::any(*withStatistics);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("WithStatistics") != m.end() && !m["WithStatistics"].empty()) {
      withStatistics = make_shared<bool>(boost::any_cast<bool>(m["WithStatistics"]));
    }
  }


  virtual ~GetProjectRequest() = default;
};
class GetProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<Project> project{};
  shared_ptr<string> requestId{};

  GetProjectResponseBody() {}

  explicit GetProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (project) {
      res["Project"] = project ? boost::any(project->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      if (typeid(map<string, boost::any>) == m["Project"].type()) {
        Project model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Project"]));
        project = make_shared<Project>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~GetProjectResponseBody() = default;
};
class GetProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetProjectResponseBody> body{};

  GetProjectResponse() {}

  explicit GetProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetProjectResponseBody>(model1);
      }
    }
  }


  virtual ~GetProjectResponse() = default;
};
class GetStoryRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> objectId{};
  shared_ptr<string> projectName{};

  GetStoryRequest() {}

  explicit GetStoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~GetStoryRequest() = default;
};
class GetStoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<Story> story{};

  GetStoryResponseBody() {}

  explicit GetStoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (story) {
      res["Story"] = story ? boost::any(story->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Story") != m.end() && !m["Story"].empty()) {
      if (typeid(map<string, boost::any>) == m["Story"].type()) {
        Story model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Story"]));
        story = make_shared<Story>(model1);
      }
    }
  }


  virtual ~GetStoryResponseBody() = default;
};
class GetStoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetStoryResponseBody> body{};

  GetStoryResponse() {}

  explicit GetStoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetStoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetStoryResponseBody>(model1);
      }
    }
  }


  virtual ~GetStoryResponse() = default;
};
class GetTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};
  shared_ptr<bool> requestDefinition{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskType{};

  GetTaskRequest() {}

  explicit GetTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (requestDefinition) {
      res["RequestDefinition"] = boost::any(*requestDefinition);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("RequestDefinition") != m.end() && !m["RequestDefinition"].empty()) {
      requestDefinition = make_shared<bool>(boost::any_cast<bool>(m["RequestDefinition"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~GetTaskRequest() = default;
};
class GetTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> endTime{};
  shared_ptr<string> eventId{};
  shared_ptr<string> message{};
  shared_ptr<long> progress{};
  shared_ptr<string> projectName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<map<string, boost::any>> tags{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskRequestDefinition{};
  shared_ptr<string> taskType{};
  shared_ptr<string> userData{};

  GetTaskResponseBody() {}

  explicit GetTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (progress) {
      res["Progress"] = boost::any(*progress);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskRequestDefinition) {
      res["TaskRequestDefinition"] = boost::any(*taskRequestDefinition);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("Progress") != m.end() && !m["Progress"].empty()) {
      progress = make_shared<long>(boost::any_cast<long>(m["Progress"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Tags"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskRequestDefinition") != m.end() && !m["TaskRequestDefinition"].empty()) {
      taskRequestDefinition = make_shared<string>(boost::any_cast<string>(m["TaskRequestDefinition"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetTaskResponseBody() = default;
};
class GetTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTaskResponseBody> body{};

  GetTaskResponse() {}

  explicit GetTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTaskResponseBody>(model1);
      }
    }
  }


  virtual ~GetTaskResponse() = default;
};
class GetTriggerRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> projectName{};

  GetTriggerRequest() {}

  explicit GetTriggerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~GetTriggerRequest() = default;
};
class GetTriggerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DataIngestion> trigger{};

  GetTriggerResponseBody() {}

  explicit GetTriggerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (trigger) {
      res["Trigger"] = trigger ? boost::any(trigger->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Trigger") != m.end() && !m["Trigger"].empty()) {
      if (typeid(map<string, boost::any>) == m["Trigger"].type()) {
        DataIngestion model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Trigger"]));
        trigger = make_shared<DataIngestion>(model1);
      }
    }
  }


  virtual ~GetTriggerResponseBody() = default;
};
class GetTriggerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTriggerResponseBody> body{};

  GetTriggerResponse() {}

  explicit GetTriggerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTriggerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTriggerResponseBody>(model1);
      }
    }
  }


  virtual ~GetTriggerResponse() = default;
};
class GetVideoLabelClassificationResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskType{};

  GetVideoLabelClassificationResultRequest() {}

  explicit GetVideoLabelClassificationResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~GetVideoLabelClassificationResultRequest() = default;
};
class GetVideoLabelClassificationResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> endTime{};
  shared_ptr<string> eventId{};
  shared_ptr<vector<Label>> labels{};
  shared_ptr<string> message{};
  shared_ptr<string> projectName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskType{};
  shared_ptr<string> userData{};

  GetVideoLabelClassificationResultResponseBody() {}

  explicit GetVideoLabelClassificationResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (labels) {
      vector<boost::any> temp1;
      for(auto item1:*labels){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Labels"] = boost::any(temp1);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("Labels") != m.end() && !m["Labels"].empty()) {
      if (typeid(vector<boost::any>) == m["Labels"].type()) {
        vector<Label> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Labels"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Label model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        labels = make_shared<vector<Label>>(expect1);
      }
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetVideoLabelClassificationResultResponseBody() = default;
};
class GetVideoLabelClassificationResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetVideoLabelClassificationResultResponseBody> body{};

  GetVideoLabelClassificationResultResponse() {}

  explicit GetVideoLabelClassificationResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVideoLabelClassificationResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVideoLabelClassificationResultResponseBody>(model1);
      }
    }
  }


  virtual ~GetVideoLabelClassificationResultResponse() = default;
};
class GetVideoModerationResultRequest : public Darabonba::Model {
public:
  shared_ptr<string> projectName{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskType{};

  GetVideoModerationResultRequest() {}

  explicit GetVideoModerationResultRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
  }


  virtual ~GetVideoModerationResultRequest() = default;
};
class GetVideoModerationResultResponseBodyModerationResultFramesBlockFrames : public Darabonba::Model {
public:
  shared_ptr<string> label{};
  shared_ptr<long> offset{};
  shared_ptr<double> rate{};

  GetVideoModerationResultResponseBodyModerationResultFramesBlockFrames() {}

  explicit GetVideoModerationResultResponseBodyModerationResultFramesBlockFrames(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (label) {
      res["Label"] = boost::any(*label);
    }
    if (offset) {
      res["Offset"] = boost::any(*offset);
    }
    if (rate) {
      res["Rate"] = boost::any(*rate);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Label") != m.end() && !m["Label"].empty()) {
      label = make_shared<string>(boost::any_cast<string>(m["Label"]));
    }
    if (m.find("Offset") != m.end() && !m["Offset"].empty()) {
      offset = make_shared<long>(boost::any_cast<long>(m["Offset"]));
    }
    if (m.find("Rate") != m.end() && !m["Rate"].empty()) {
      rate = make_shared<double>(boost::any_cast<double>(m["Rate"]));
    }
  }


  virtual ~GetVideoModerationResultResponseBodyModerationResultFramesBlockFrames() = default;
};
class GetVideoModerationResultResponseBodyModerationResultFrames : public Darabonba::Model {
public:
  shared_ptr<vector<GetVideoModerationResultResponseBodyModerationResultFramesBlockFrames>> blockFrames{};
  shared_ptr<long> totalCount{};

  GetVideoModerationResultResponseBodyModerationResultFrames() {}

  explicit GetVideoModerationResultResponseBodyModerationResultFrames(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (blockFrames) {
      vector<boost::any> temp1;
      for(auto item1:*blockFrames){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["BlockFrames"] = boost::any(temp1);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("BlockFrames") != m.end() && !m["BlockFrames"].empty()) {
      if (typeid(vector<boost::any>) == m["BlockFrames"].type()) {
        vector<GetVideoModerationResultResponseBodyModerationResultFramesBlockFrames> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["BlockFrames"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetVideoModerationResultResponseBodyModerationResultFramesBlockFrames model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        blockFrames = make_shared<vector<GetVideoModerationResultResponseBodyModerationResultFramesBlockFrames>>(expect1);
      }
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~GetVideoModerationResultResponseBodyModerationResultFrames() = default;
};
class GetVideoModerationResultResponseBodyModerationResult : public Darabonba::Model {
public:
  shared_ptr<vector<string>> categories{};
  shared_ptr<GetVideoModerationResultResponseBodyModerationResultFrames> frames{};
  shared_ptr<string> suggestion{};
  shared_ptr<string> URI{};

  GetVideoModerationResultResponseBodyModerationResult() {}

  explicit GetVideoModerationResultResponseBodyModerationResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (categories) {
      res["Categories"] = boost::any(*categories);
    }
    if (frames) {
      res["Frames"] = frames ? boost::any(frames->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (suggestion) {
      res["Suggestion"] = boost::any(*suggestion);
    }
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Categories") != m.end() && !m["Categories"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Categories"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Categories"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      categories = make_shared<vector<string>>(toVec1);
    }
    if (m.find("Frames") != m.end() && !m["Frames"].empty()) {
      if (typeid(map<string, boost::any>) == m["Frames"].type()) {
        GetVideoModerationResultResponseBodyModerationResultFrames model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Frames"]));
        frames = make_shared<GetVideoModerationResultResponseBodyModerationResultFrames>(model1);
      }
    }
    if (m.find("Suggestion") != m.end() && !m["Suggestion"].empty()) {
      suggestion = make_shared<string>(boost::any_cast<string>(m["Suggestion"]));
    }
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~GetVideoModerationResultResponseBodyModerationResult() = default;
};
class GetVideoModerationResultResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> endTime{};
  shared_ptr<string> eventId{};
  shared_ptr<string> message{};
  shared_ptr<GetVideoModerationResultResponseBodyModerationResult> moderationResult{};
  shared_ptr<string> projectName{};
  shared_ptr<string> requestId{};
  shared_ptr<string> startTime{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};
  shared_ptr<string> taskType{};
  shared_ptr<string> userData{};

  GetVideoModerationResultResponseBody() {}

  explicit GetVideoModerationResultResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (moderationResult) {
      res["ModerationResult"] = moderationResult ? boost::any(moderationResult->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (taskId) {
      res["TaskId"] = boost::any(*taskId);
    }
    if (taskType) {
      res["TaskType"] = boost::any(*taskType);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<string>(boost::any_cast<string>(m["EndTime"]));
    }
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("ModerationResult") != m.end() && !m["ModerationResult"].empty()) {
      if (typeid(map<string, boost::any>) == m["ModerationResult"].type()) {
        GetVideoModerationResultResponseBodyModerationResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ModerationResult"]));
        moderationResult = make_shared<GetVideoModerationResultResponseBodyModerationResult>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<string>(boost::any_cast<string>(m["StartTime"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TaskId") != m.end() && !m["TaskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["TaskId"]));
    }
    if (m.find("TaskType") != m.end() && !m["TaskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["TaskType"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~GetVideoModerationResultResponseBody() = default;
};
class GetVideoModerationResultResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetVideoModerationResultResponseBody> body{};

  GetVideoModerationResultResponse() {}

  explicit GetVideoModerationResultResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetVideoModerationResultResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetVideoModerationResultResponseBody>(model1);
      }
    }
  }


  virtual ~GetVideoModerationResultResponse() = default;
};
class IndexFileMetaRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<InputFile> file{};
  shared_ptr<Notification> notification{};
  shared_ptr<string> projectName{};
  shared_ptr<string> userData{};

  IndexFileMetaRequest() {}

  explicit IndexFileMetaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (notification) {
      res["Notification"] = notification ? boost::any(notification->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        InputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<InputFile>(model1);
      }
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      if (typeid(map<string, boost::any>) == m["Notification"].type()) {
        Notification model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Notification"]));
        notification = make_shared<Notification>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~IndexFileMetaRequest() = default;
};
class IndexFileMetaShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> fileShrink{};
  shared_ptr<string> notificationShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> userData{};

  IndexFileMetaShrinkRequest() {}

  explicit IndexFileMetaShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (fileShrink) {
      res["File"] = boost::any(*fileShrink);
    }
    if (notificationShrink) {
      res["Notification"] = boost::any(*notificationShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (userData) {
      res["UserData"] = boost::any(*userData);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      fileShrink = make_shared<string>(boost::any_cast<string>(m["File"]));
    }
    if (m.find("Notification") != m.end() && !m["Notification"].empty()) {
      notificationShrink = make_shared<string>(boost::any_cast<string>(m["Notification"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("UserData") != m.end() && !m["UserData"].empty()) {
      userData = make_shared<string>(boost::any_cast<string>(m["UserData"]));
    }
  }


  virtual ~IndexFileMetaShrinkRequest() = default;
};
class IndexFileMetaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> eventId{};
  shared_ptr<string> requestId{};

  IndexFileMetaResponseBody() {}

  explicit IndexFileMetaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventId) {
      res["EventId"] = boost::any(*eventId);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EventId") != m.end() && !m["EventId"].empty()) {
      eventId = make_shared<string>(boost::any_cast<string>(m["EventId"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~IndexFileMetaResponseBody() = default;
};
class IndexFileMetaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<IndexFileMetaResponseBody> body{};

  IndexFileMetaResponse() {}

  explicit IndexFileMetaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        IndexFileMetaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<IndexFileMetaResponseBody>(model1);
      }
    }
  }


  virtual ~IndexFileMetaResponse() = default;
};
class ListBatchesRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> order{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sort{};
  shared_ptr<string> state{};
  shared_ptr<string> tagSelector{};

  ListBatchesRequest() {}

  explicit ListBatchesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (tagSelector) {
      res["TagSelector"] = boost::any(*tagSelector);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["Sort"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TagSelector") != m.end() && !m["TagSelector"].empty()) {
      tagSelector = make_shared<string>(boost::any_cast<string>(m["TagSelector"]));
    }
  }


  virtual ~ListBatchesRequest() = default;
};
class ListBatchesResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<DataIngestion>> batches{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  ListBatchesResponseBody() {}

  explicit ListBatchesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batches) {
      vector<boost::any> temp1;
      for(auto item1:*batches){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Batches"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Batches") != m.end() && !m["Batches"].empty()) {
      if (typeid(vector<boost::any>) == m["Batches"].type()) {
        vector<DataIngestion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Batches"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataIngestion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        batches = make_shared<vector<DataIngestion>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListBatchesResponseBody() = default;
};
class ListBatchesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListBatchesResponseBody> body{};

  ListBatchesResponse() {}

  explicit ListBatchesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListBatchesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListBatchesResponseBody>(model1);
      }
    }
  }


  virtual ~ListBatchesResponse() = default;
};
class ListBindingsRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> projectName{};

  ListBindingsRequest() {}

  explicit ListBindingsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~ListBindingsRequest() = default;
};
class ListBindingsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<Binding>> bindings{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  ListBindingsResponseBody() {}

  explicit ListBindingsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bindings) {
      vector<boost::any> temp1;
      for(auto item1:*bindings){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Bindings"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Bindings") != m.end() && !m["Bindings"].empty()) {
      if (typeid(vector<boost::any>) == m["Bindings"].type()) {
        vector<Binding> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Bindings"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Binding model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        bindings = make_shared<vector<Binding>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListBindingsResponseBody() = default;
};
class ListBindingsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListBindingsResponseBody> body{};

  ListBindingsResponse() {}

  explicit ListBindingsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListBindingsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListBindingsResponseBody>(model1);
      }
    }
  }


  virtual ~ListBindingsResponse() = default;
};
class ListDatasetsRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> prefix{};
  shared_ptr<string> projectName{};

  ListDatasetsRequest() {}

  explicit ListDatasetsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (prefix) {
      res["Prefix"] = boost::any(*prefix);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Prefix") != m.end() && !m["Prefix"].empty()) {
      prefix = make_shared<string>(boost::any_cast<string>(m["Prefix"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~ListDatasetsRequest() = default;
};
class ListDatasetsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<Dataset>> datasets{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  ListDatasetsResponseBody() {}

  explicit ListDatasetsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasets) {
      vector<boost::any> temp1;
      for(auto item1:*datasets){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Datasets"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Datasets") != m.end() && !m["Datasets"].empty()) {
      if (typeid(vector<boost::any>) == m["Datasets"].type()) {
        vector<Dataset> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Datasets"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Dataset model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        datasets = make_shared<vector<Dataset>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListDatasetsResponseBody() = default;
};
class ListDatasetsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDatasetsResponseBody> body{};

  ListDatasetsResponse() {}

  explicit ListDatasetsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDatasetsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDatasetsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDatasetsResponse() = default;
};
class ListProjectsRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  ListProjectsRequestTag() {}

  explicit ListProjectsRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~ListProjectsRequestTag() = default;
};
class ListProjectsRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> prefix{};
  shared_ptr<vector<ListProjectsRequestTag>> tag{};

  ListProjectsRequest() {}

  explicit ListProjectsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (prefix) {
      res["Prefix"] = boost::any(*prefix);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Prefix") != m.end() && !m["Prefix"].empty()) {
      prefix = make_shared<string>(boost::any_cast<string>(m["Prefix"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<ListProjectsRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListProjectsRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<ListProjectsRequestTag>>(expect1);
      }
    }
  }


  virtual ~ListProjectsRequest() = default;
};
class ListProjectsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> prefix{};
  shared_ptr<string> tagShrink{};

  ListProjectsShrinkRequest() {}

  explicit ListProjectsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (prefix) {
      res["Prefix"] = boost::any(*prefix);
    }
    if (tagShrink) {
      res["Tag"] = boost::any(*tagShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Prefix") != m.end() && !m["Prefix"].empty()) {
      prefix = make_shared<string>(boost::any_cast<string>(m["Prefix"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tagShrink = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
  }


  virtual ~ListProjectsShrinkRequest() = default;
};
class ListProjectsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<vector<Project>> projects{};
  shared_ptr<string> requestId{};

  ListProjectsResponseBody() {}

  explicit ListProjectsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (projects) {
      vector<boost::any> temp1;
      for(auto item1:*projects){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Projects"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Projects") != m.end() && !m["Projects"].empty()) {
      if (typeid(vector<boost::any>) == m["Projects"].type()) {
        vector<Project> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Projects"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Project model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        projects = make_shared<vector<Project>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListProjectsResponseBody() = default;
};
class ListProjectsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListProjectsResponseBody> body{};

  ListProjectsResponse() {}

  explicit ListProjectsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListProjectsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListProjectsResponseBody>(model1);
      }
    }
  }


  virtual ~ListProjectsResponse() = default;
};
class ListRegionsRequest : public Darabonba::Model {
public:
  shared_ptr<string> acceptLanguage{};

  ListRegionsRequest() {}

  explicit ListRegionsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (acceptLanguage) {
      res["AcceptLanguage"] = boost::any(*acceptLanguage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AcceptLanguage") != m.end() && !m["AcceptLanguage"].empty()) {
      acceptLanguage = make_shared<string>(boost::any_cast<string>(m["AcceptLanguage"]));
    }
  }


  virtual ~ListRegionsRequest() = default;
};
class ListRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<RegionType>> regions{};
  shared_ptr<string> requestId{};

  ListRegionsResponseBody() {}

  explicit ListRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (regions) {
      vector<boost::any> temp1;
      for(auto item1:*regions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Regions"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Regions") != m.end() && !m["Regions"].empty()) {
      if (typeid(vector<boost::any>) == m["Regions"].type()) {
        vector<RegionType> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Regions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RegionType model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        regions = make_shared<vector<RegionType>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ListRegionsResponseBody() = default;
};
class ListRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListRegionsResponseBody> body{};

  ListRegionsResponse() {}

  explicit ListRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~ListRegionsResponse() = default;
};
class ListTasksRequest : public Darabonba::Model {
public:
  shared_ptr<TimeRange> endTimeRange{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> order{};
  shared_ptr<string> projectName{};
  shared_ptr<bool> requestDefinition{};
  shared_ptr<string> sort{};
  shared_ptr<TimeRange> startTimeRange{};
  shared_ptr<string> status{};
  shared_ptr<string> tagSelector{};
  shared_ptr<vector<string>> taskTypes{};

  ListTasksRequest() {}

  explicit ListTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTimeRange) {
      res["EndTimeRange"] = endTimeRange ? boost::any(endTimeRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (requestDefinition) {
      res["RequestDefinition"] = boost::any(*requestDefinition);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (startTimeRange) {
      res["StartTimeRange"] = startTimeRange ? boost::any(startTimeRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tagSelector) {
      res["TagSelector"] = boost::any(*tagSelector);
    }
    if (taskTypes) {
      res["TaskTypes"] = boost::any(*taskTypes);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTimeRange") != m.end() && !m["EndTimeRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["EndTimeRange"].type()) {
        TimeRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["EndTimeRange"]));
        endTimeRange = make_shared<TimeRange>(model1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("RequestDefinition") != m.end() && !m["RequestDefinition"].empty()) {
      requestDefinition = make_shared<bool>(boost::any_cast<bool>(m["RequestDefinition"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["Sort"]));
    }
    if (m.find("StartTimeRange") != m.end() && !m["StartTimeRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["StartTimeRange"].type()) {
        TimeRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StartTimeRange"]));
        startTimeRange = make_shared<TimeRange>(model1);
      }
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TagSelector") != m.end() && !m["TagSelector"].empty()) {
      tagSelector = make_shared<string>(boost::any_cast<string>(m["TagSelector"]));
    }
    if (m.find("TaskTypes") != m.end() && !m["TaskTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["TaskTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["TaskTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      taskTypes = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListTasksRequest() = default;
};
class ListTasksShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> endTimeRangeShrink{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> order{};
  shared_ptr<string> projectName{};
  shared_ptr<bool> requestDefinition{};
  shared_ptr<string> sort{};
  shared_ptr<string> startTimeRangeShrink{};
  shared_ptr<string> status{};
  shared_ptr<string> tagSelector{};
  shared_ptr<string> taskTypesShrink{};

  ListTasksShrinkRequest() {}

  explicit ListTasksShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTimeRangeShrink) {
      res["EndTimeRange"] = boost::any(*endTimeRangeShrink);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (requestDefinition) {
      res["RequestDefinition"] = boost::any(*requestDefinition);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (startTimeRangeShrink) {
      res["StartTimeRange"] = boost::any(*startTimeRangeShrink);
    }
    if (status) {
      res["Status"] = boost::any(*status);
    }
    if (tagSelector) {
      res["TagSelector"] = boost::any(*tagSelector);
    }
    if (taskTypesShrink) {
      res["TaskTypes"] = boost::any(*taskTypesShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("EndTimeRange") != m.end() && !m["EndTimeRange"].empty()) {
      endTimeRangeShrink = make_shared<string>(boost::any_cast<string>(m["EndTimeRange"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("RequestDefinition") != m.end() && !m["RequestDefinition"].empty()) {
      requestDefinition = make_shared<bool>(boost::any_cast<bool>(m["RequestDefinition"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["Sort"]));
    }
    if (m.find("StartTimeRange") != m.end() && !m["StartTimeRange"].empty()) {
      startTimeRangeShrink = make_shared<string>(boost::any_cast<string>(m["StartTimeRange"]));
    }
    if (m.find("Status") != m.end() && !m["Status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["Status"]));
    }
    if (m.find("TagSelector") != m.end() && !m["TagSelector"].empty()) {
      tagSelector = make_shared<string>(boost::any_cast<string>(m["TagSelector"]));
    }
    if (m.find("TaskTypes") != m.end() && !m["TaskTypes"].empty()) {
      taskTypesShrink = make_shared<string>(boost::any_cast<string>(m["TaskTypes"]));
    }
  }


  virtual ~ListTasksShrinkRequest() = default;
};
class ListTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> projectName{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<TaskInfo>> tasks{};

  ListTasksResponseBody() {}

  explicit ListTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tasks) {
      vector<boost::any> temp1;
      for(auto item1:*tasks){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tasks"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<string>(boost::any_cast<string>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Tasks") != m.end() && !m["Tasks"].empty()) {
      if (typeid(vector<boost::any>) == m["Tasks"].type()) {
        vector<TaskInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tasks"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TaskInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tasks = make_shared<vector<TaskInfo>>(expect1);
      }
    }
  }


  virtual ~ListTasksResponseBody() = default;
};
class ListTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTasksResponseBody> body{};

  ListTasksResponse() {}

  explicit ListTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTasksResponseBody>(model1);
      }
    }
  }


  virtual ~ListTasksResponse() = default;
};
class ListTriggersRequest : public Darabonba::Model {
public:
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> order{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sort{};
  shared_ptr<string> state{};
  shared_ptr<string> tagSelector{};

  ListTriggersRequest() {}

  explicit ListTriggersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (state) {
      res["State"] = boost::any(*state);
    }
    if (tagSelector) {
      res["TagSelector"] = boost::any(*tagSelector);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["Sort"]));
    }
    if (m.find("State") != m.end() && !m["State"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["State"]));
    }
    if (m.find("TagSelector") != m.end() && !m["TagSelector"].empty()) {
      tagSelector = make_shared<string>(boost::any_cast<string>(m["TagSelector"]));
    }
  }


  virtual ~ListTriggersRequest() = default;
};
class ListTriggersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<DataIngestion>> triggers{};

  ListTriggersResponseBody() {}

  explicit ListTriggersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (triggers) {
      vector<boost::any> temp1;
      for(auto item1:*triggers){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Triggers"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Triggers") != m.end() && !m["Triggers"].empty()) {
      if (typeid(vector<boost::any>) == m["Triggers"].type()) {
        vector<DataIngestion> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Triggers"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DataIngestion model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        triggers = make_shared<vector<DataIngestion>>(expect1);
      }
    }
  }


  virtual ~ListTriggersResponseBody() = default;
};
class ListTriggersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTriggersResponseBody> body{};

  ListTriggersResponse() {}

  explicit ListTriggersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTriggersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTriggersResponseBody>(model1);
      }
    }
  }


  virtual ~ListTriggersResponse() = default;
};
class QueryFigureClustersRequest : public Darabonba::Model {
public:
  shared_ptr<TimeRange> createTimeRange{};
  shared_ptr<string> customLabels{};
  shared_ptr<string> datasetName{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> order{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sort{};
  shared_ptr<TimeRange> updateTimeRange{};
  shared_ptr<bool> withTotalCount{};

  QueryFigureClustersRequest() {}

  explicit QueryFigureClustersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTimeRange) {
      res["CreateTimeRange"] = createTimeRange ? boost::any(createTimeRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customLabels) {
      res["CustomLabels"] = boost::any(*customLabels);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (updateTimeRange) {
      res["UpdateTimeRange"] = updateTimeRange ? boost::any(updateTimeRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (withTotalCount) {
      res["WithTotalCount"] = boost::any(*withTotalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTimeRange") != m.end() && !m["CreateTimeRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateTimeRange"].type()) {
        TimeRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateTimeRange"]));
        createTimeRange = make_shared<TimeRange>(model1);
      }
    }
    if (m.find("CustomLabels") != m.end() && !m["CustomLabels"].empty()) {
      customLabels = make_shared<string>(boost::any_cast<string>(m["CustomLabels"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["Sort"]));
    }
    if (m.find("UpdateTimeRange") != m.end() && !m["UpdateTimeRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["UpdateTimeRange"].type()) {
        TimeRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UpdateTimeRange"]));
        updateTimeRange = make_shared<TimeRange>(model1);
      }
    }
    if (m.find("WithTotalCount") != m.end() && !m["WithTotalCount"].empty()) {
      withTotalCount = make_shared<bool>(boost::any_cast<bool>(m["WithTotalCount"]));
    }
  }


  virtual ~QueryFigureClustersRequest() = default;
};
class QueryFigureClustersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> createTimeRangeShrink{};
  shared_ptr<string> customLabels{};
  shared_ptr<string> datasetName{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> order{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sort{};
  shared_ptr<string> updateTimeRangeShrink{};
  shared_ptr<bool> withTotalCount{};

  QueryFigureClustersShrinkRequest() {}

  explicit QueryFigureClustersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTimeRangeShrink) {
      res["CreateTimeRange"] = boost::any(*createTimeRangeShrink);
    }
    if (customLabels) {
      res["CustomLabels"] = boost::any(*customLabels);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (updateTimeRangeShrink) {
      res["UpdateTimeRange"] = boost::any(*updateTimeRangeShrink);
    }
    if (withTotalCount) {
      res["WithTotalCount"] = boost::any(*withTotalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTimeRange") != m.end() && !m["CreateTimeRange"].empty()) {
      createTimeRangeShrink = make_shared<string>(boost::any_cast<string>(m["CreateTimeRange"]));
    }
    if (m.find("CustomLabels") != m.end() && !m["CustomLabels"].empty()) {
      customLabels = make_shared<string>(boost::any_cast<string>(m["CustomLabels"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["Sort"]));
    }
    if (m.find("UpdateTimeRange") != m.end() && !m["UpdateTimeRange"].empty()) {
      updateTimeRangeShrink = make_shared<string>(boost::any_cast<string>(m["UpdateTimeRange"]));
    }
    if (m.find("WithTotalCount") != m.end() && !m["WithTotalCount"].empty()) {
      withTotalCount = make_shared<bool>(boost::any_cast<bool>(m["WithTotalCount"]));
    }
  }


  virtual ~QueryFigureClustersShrinkRequest() = default;
};
class QueryFigureClustersResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<FigureCluster>> figureClusters{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalCount{};

  QueryFigureClustersResponseBody() {}

  explicit QueryFigureClustersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (figureClusters) {
      vector<boost::any> temp1;
      for(auto item1:*figureClusters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["FigureClusters"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalCount) {
      res["TotalCount"] = boost::any(*totalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("FigureClusters") != m.end() && !m["FigureClusters"].empty()) {
      if (typeid(vector<boost::any>) == m["FigureClusters"].type()) {
        vector<FigureCluster> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["FigureClusters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            FigureCluster model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        figureClusters = make_shared<vector<FigureCluster>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalCount") != m.end() && !m["TotalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["TotalCount"]));
    }
  }


  virtual ~QueryFigureClustersResponseBody() = default;
};
class QueryFigureClustersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryFigureClustersResponseBody> body{};

  QueryFigureClustersResponse() {}

  explicit QueryFigureClustersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryFigureClustersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryFigureClustersResponseBody>(model1);
      }
    }
  }


  virtual ~QueryFigureClustersResponse() = default;
};
class QueryLocationDateClustersRequest : public Darabonba::Model {
public:
  shared_ptr<Address> address{};
  shared_ptr<TimeRange> createTimeRange{};
  shared_ptr<string> customLabels{};
  shared_ptr<string> datasetName{};
  shared_ptr<TimeRange> locationDateClusterEndTimeRange{};
  shared_ptr<vector<string>> locationDateClusterLevels{};
  shared_ptr<TimeRange> locationDateClusterStartTimeRange{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> objectId{};
  shared_ptr<string> order{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sort{};
  shared_ptr<string> title{};
  shared_ptr<TimeRange> updateTimeRange{};

  QueryLocationDateClustersRequest() {}

  explicit QueryLocationDateClustersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (address) {
      res["Address"] = address ? boost::any(address->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createTimeRange) {
      res["CreateTimeRange"] = createTimeRange ? boost::any(createTimeRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customLabels) {
      res["CustomLabels"] = boost::any(*customLabels);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (locationDateClusterEndTimeRange) {
      res["LocationDateClusterEndTimeRange"] = locationDateClusterEndTimeRange ? boost::any(locationDateClusterEndTimeRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (locationDateClusterLevels) {
      res["LocationDateClusterLevels"] = boost::any(*locationDateClusterLevels);
    }
    if (locationDateClusterStartTimeRange) {
      res["LocationDateClusterStartTimeRange"] = locationDateClusterStartTimeRange ? boost::any(locationDateClusterStartTimeRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (updateTimeRange) {
      res["UpdateTimeRange"] = updateTimeRange ? boost::any(updateTimeRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      if (typeid(map<string, boost::any>) == m["Address"].type()) {
        Address model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Address"]));
        address = make_shared<Address>(model1);
      }
    }
    if (m.find("CreateTimeRange") != m.end() && !m["CreateTimeRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateTimeRange"].type()) {
        TimeRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateTimeRange"]));
        createTimeRange = make_shared<TimeRange>(model1);
      }
    }
    if (m.find("CustomLabels") != m.end() && !m["CustomLabels"].empty()) {
      customLabels = make_shared<string>(boost::any_cast<string>(m["CustomLabels"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("LocationDateClusterEndTimeRange") != m.end() && !m["LocationDateClusterEndTimeRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["LocationDateClusterEndTimeRange"].type()) {
        TimeRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LocationDateClusterEndTimeRange"]));
        locationDateClusterEndTimeRange = make_shared<TimeRange>(model1);
      }
    }
    if (m.find("LocationDateClusterLevels") != m.end() && !m["LocationDateClusterLevels"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["LocationDateClusterLevels"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["LocationDateClusterLevels"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      locationDateClusterLevels = make_shared<vector<string>>(toVec1);
    }
    if (m.find("LocationDateClusterStartTimeRange") != m.end() && !m["LocationDateClusterStartTimeRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["LocationDateClusterStartTimeRange"].type()) {
        TimeRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["LocationDateClusterStartTimeRange"]));
        locationDateClusterStartTimeRange = make_shared<TimeRange>(model1);
      }
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["Sort"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UpdateTimeRange") != m.end() && !m["UpdateTimeRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["UpdateTimeRange"].type()) {
        TimeRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["UpdateTimeRange"]));
        updateTimeRange = make_shared<TimeRange>(model1);
      }
    }
  }


  virtual ~QueryLocationDateClustersRequest() = default;
};
class QueryLocationDateClustersShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> addressShrink{};
  shared_ptr<string> createTimeRangeShrink{};
  shared_ptr<string> customLabels{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> locationDateClusterEndTimeRangeShrink{};
  shared_ptr<string> locationDateClusterLevelsShrink{};
  shared_ptr<string> locationDateClusterStartTimeRangeShrink{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> objectId{};
  shared_ptr<string> order{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sort{};
  shared_ptr<string> title{};
  shared_ptr<string> updateTimeRangeShrink{};

  QueryLocationDateClustersShrinkRequest() {}

  explicit QueryLocationDateClustersShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (addressShrink) {
      res["Address"] = boost::any(*addressShrink);
    }
    if (createTimeRangeShrink) {
      res["CreateTimeRange"] = boost::any(*createTimeRangeShrink);
    }
    if (customLabels) {
      res["CustomLabels"] = boost::any(*customLabels);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (locationDateClusterEndTimeRangeShrink) {
      res["LocationDateClusterEndTimeRange"] = boost::any(*locationDateClusterEndTimeRangeShrink);
    }
    if (locationDateClusterLevelsShrink) {
      res["LocationDateClusterLevels"] = boost::any(*locationDateClusterLevelsShrink);
    }
    if (locationDateClusterStartTimeRangeShrink) {
      res["LocationDateClusterStartTimeRange"] = boost::any(*locationDateClusterStartTimeRangeShrink);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    if (updateTimeRangeShrink) {
      res["UpdateTimeRange"] = boost::any(*updateTimeRangeShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Address") != m.end() && !m["Address"].empty()) {
      addressShrink = make_shared<string>(boost::any_cast<string>(m["Address"]));
    }
    if (m.find("CreateTimeRange") != m.end() && !m["CreateTimeRange"].empty()) {
      createTimeRangeShrink = make_shared<string>(boost::any_cast<string>(m["CreateTimeRange"]));
    }
    if (m.find("CustomLabels") != m.end() && !m["CustomLabels"].empty()) {
      customLabels = make_shared<string>(boost::any_cast<string>(m["CustomLabels"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("LocationDateClusterEndTimeRange") != m.end() && !m["LocationDateClusterEndTimeRange"].empty()) {
      locationDateClusterEndTimeRangeShrink = make_shared<string>(boost::any_cast<string>(m["LocationDateClusterEndTimeRange"]));
    }
    if (m.find("LocationDateClusterLevels") != m.end() && !m["LocationDateClusterLevels"].empty()) {
      locationDateClusterLevelsShrink = make_shared<string>(boost::any_cast<string>(m["LocationDateClusterLevels"]));
    }
    if (m.find("LocationDateClusterStartTimeRange") != m.end() && !m["LocationDateClusterStartTimeRange"].empty()) {
      locationDateClusterStartTimeRangeShrink = make_shared<string>(boost::any_cast<string>(m["LocationDateClusterStartTimeRange"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["Sort"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
    if (m.find("UpdateTimeRange") != m.end() && !m["UpdateTimeRange"].empty()) {
      updateTimeRangeShrink = make_shared<string>(boost::any_cast<string>(m["UpdateTimeRange"]));
    }
  }


  virtual ~QueryLocationDateClustersShrinkRequest() = default;
};
class QueryLocationDateClustersResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<LocationDateCluster>> locationDateClusters{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};

  QueryLocationDateClustersResponseBody() {}

  explicit QueryLocationDateClustersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (locationDateClusters) {
      vector<boost::any> temp1;
      for(auto item1:*locationDateClusters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["LocationDateClusters"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("LocationDateClusters") != m.end() && !m["LocationDateClusters"].empty()) {
      if (typeid(vector<boost::any>) == m["LocationDateClusters"].type()) {
        vector<LocationDateCluster> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["LocationDateClusters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            LocationDateCluster model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        locationDateClusters = make_shared<vector<LocationDateCluster>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~QueryLocationDateClustersResponseBody() = default;
};
class QueryLocationDateClustersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryLocationDateClustersResponseBody> body{};

  QueryLocationDateClustersResponse() {}

  explicit QueryLocationDateClustersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryLocationDateClustersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryLocationDateClustersResponseBody>(model1);
      }
    }
  }


  virtual ~QueryLocationDateClustersResponse() = default;
};
class QuerySimilarImageClustersRequest : public Darabonba::Model {
public:
  shared_ptr<string> customLabels{};
  shared_ptr<string> datasetName{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> order{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sort{};

  QuerySimilarImageClustersRequest() {}

  explicit QuerySimilarImageClustersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customLabels) {
      res["CustomLabels"] = boost::any(*customLabels);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomLabels") != m.end() && !m["CustomLabels"].empty()) {
      customLabels = make_shared<string>(boost::any_cast<string>(m["CustomLabels"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["Sort"]));
    }
  }


  virtual ~QuerySimilarImageClustersRequest() = default;
};
class QuerySimilarImageClustersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<SimilarImageCluster>> similarImageClusters{};

  QuerySimilarImageClustersResponseBody() {}

  explicit QuerySimilarImageClustersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (similarImageClusters) {
      vector<boost::any> temp1;
      for(auto item1:*similarImageClusters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["SimilarImageClusters"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("SimilarImageClusters") != m.end() && !m["SimilarImageClusters"].empty()) {
      if (typeid(vector<boost::any>) == m["SimilarImageClusters"].type()) {
        vector<SimilarImageCluster> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["SimilarImageClusters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SimilarImageCluster model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        similarImageClusters = make_shared<vector<SimilarImageCluster>>(expect1);
      }
    }
  }


  virtual ~QuerySimilarImageClustersResponseBody() = default;
};
class QuerySimilarImageClustersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QuerySimilarImageClustersResponseBody> body{};

  QuerySimilarImageClustersResponse() {}

  explicit QuerySimilarImageClustersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QuerySimilarImageClustersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QuerySimilarImageClustersResponseBody>(model1);
      }
    }
  }


  virtual ~QuerySimilarImageClustersResponse() = default;
};
class QueryStoriesRequest : public Darabonba::Model {
public:
  shared_ptr<TimeRange> createTimeRange{};
  shared_ptr<string> customLabels{};
  shared_ptr<string> datasetName{};
  shared_ptr<vector<string>> figureClusterIds{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> objectId{};
  shared_ptr<string> order{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sort{};
  shared_ptr<TimeRange> storyEndTimeRange{};
  shared_ptr<string> storyName{};
  shared_ptr<TimeRange> storyStartTimeRange{};
  shared_ptr<string> storySubType{};
  shared_ptr<string> storyType{};
  shared_ptr<bool> withEmptyStories{};

  QueryStoriesRequest() {}

  explicit QueryStoriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTimeRange) {
      res["CreateTimeRange"] = createTimeRange ? boost::any(createTimeRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customLabels) {
      res["CustomLabels"] = boost::any(*customLabels);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (figureClusterIds) {
      res["FigureClusterIds"] = boost::any(*figureClusterIds);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (storyEndTimeRange) {
      res["StoryEndTimeRange"] = storyEndTimeRange ? boost::any(storyEndTimeRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (storyName) {
      res["StoryName"] = boost::any(*storyName);
    }
    if (storyStartTimeRange) {
      res["StoryStartTimeRange"] = storyStartTimeRange ? boost::any(storyStartTimeRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (storySubType) {
      res["StorySubType"] = boost::any(*storySubType);
    }
    if (storyType) {
      res["StoryType"] = boost::any(*storyType);
    }
    if (withEmptyStories) {
      res["WithEmptyStories"] = boost::any(*withEmptyStories);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTimeRange") != m.end() && !m["CreateTimeRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["CreateTimeRange"].type()) {
        TimeRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CreateTimeRange"]));
        createTimeRange = make_shared<TimeRange>(model1);
      }
    }
    if (m.find("CustomLabels") != m.end() && !m["CustomLabels"].empty()) {
      customLabels = make_shared<string>(boost::any_cast<string>(m["CustomLabels"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("FigureClusterIds") != m.end() && !m["FigureClusterIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["FigureClusterIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["FigureClusterIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      figureClusterIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["Sort"]));
    }
    if (m.find("StoryEndTimeRange") != m.end() && !m["StoryEndTimeRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["StoryEndTimeRange"].type()) {
        TimeRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StoryEndTimeRange"]));
        storyEndTimeRange = make_shared<TimeRange>(model1);
      }
    }
    if (m.find("StoryName") != m.end() && !m["StoryName"].empty()) {
      storyName = make_shared<string>(boost::any_cast<string>(m["StoryName"]));
    }
    if (m.find("StoryStartTimeRange") != m.end() && !m["StoryStartTimeRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["StoryStartTimeRange"].type()) {
        TimeRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["StoryStartTimeRange"]));
        storyStartTimeRange = make_shared<TimeRange>(model1);
      }
    }
    if (m.find("StorySubType") != m.end() && !m["StorySubType"].empty()) {
      storySubType = make_shared<string>(boost::any_cast<string>(m["StorySubType"]));
    }
    if (m.find("StoryType") != m.end() && !m["StoryType"].empty()) {
      storyType = make_shared<string>(boost::any_cast<string>(m["StoryType"]));
    }
    if (m.find("WithEmptyStories") != m.end() && !m["WithEmptyStories"].empty()) {
      withEmptyStories = make_shared<bool>(boost::any_cast<bool>(m["WithEmptyStories"]));
    }
  }


  virtual ~QueryStoriesRequest() = default;
};
class QueryStoriesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> createTimeRangeShrink{};
  shared_ptr<string> customLabels{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> figureClusterIdsShrink{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> objectId{};
  shared_ptr<string> order{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sort{};
  shared_ptr<string> storyEndTimeRangeShrink{};
  shared_ptr<string> storyName{};
  shared_ptr<string> storyStartTimeRangeShrink{};
  shared_ptr<string> storySubType{};
  shared_ptr<string> storyType{};
  shared_ptr<bool> withEmptyStories{};

  QueryStoriesShrinkRequest() {}

  explicit QueryStoriesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTimeRangeShrink) {
      res["CreateTimeRange"] = boost::any(*createTimeRangeShrink);
    }
    if (customLabels) {
      res["CustomLabels"] = boost::any(*customLabels);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (figureClusterIdsShrink) {
      res["FigureClusterIds"] = boost::any(*figureClusterIdsShrink);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (storyEndTimeRangeShrink) {
      res["StoryEndTimeRange"] = boost::any(*storyEndTimeRangeShrink);
    }
    if (storyName) {
      res["StoryName"] = boost::any(*storyName);
    }
    if (storyStartTimeRangeShrink) {
      res["StoryStartTimeRange"] = boost::any(*storyStartTimeRangeShrink);
    }
    if (storySubType) {
      res["StorySubType"] = boost::any(*storySubType);
    }
    if (storyType) {
      res["StoryType"] = boost::any(*storyType);
    }
    if (withEmptyStories) {
      res["WithEmptyStories"] = boost::any(*withEmptyStories);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CreateTimeRange") != m.end() && !m["CreateTimeRange"].empty()) {
      createTimeRangeShrink = make_shared<string>(boost::any_cast<string>(m["CreateTimeRange"]));
    }
    if (m.find("CustomLabels") != m.end() && !m["CustomLabels"].empty()) {
      customLabels = make_shared<string>(boost::any_cast<string>(m["CustomLabels"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("FigureClusterIds") != m.end() && !m["FigureClusterIds"].empty()) {
      figureClusterIdsShrink = make_shared<string>(boost::any_cast<string>(m["FigureClusterIds"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["Sort"]));
    }
    if (m.find("StoryEndTimeRange") != m.end() && !m["StoryEndTimeRange"].empty()) {
      storyEndTimeRangeShrink = make_shared<string>(boost::any_cast<string>(m["StoryEndTimeRange"]));
    }
    if (m.find("StoryName") != m.end() && !m["StoryName"].empty()) {
      storyName = make_shared<string>(boost::any_cast<string>(m["StoryName"]));
    }
    if (m.find("StoryStartTimeRange") != m.end() && !m["StoryStartTimeRange"].empty()) {
      storyStartTimeRangeShrink = make_shared<string>(boost::any_cast<string>(m["StoryStartTimeRange"]));
    }
    if (m.find("StorySubType") != m.end() && !m["StorySubType"].empty()) {
      storySubType = make_shared<string>(boost::any_cast<string>(m["StorySubType"]));
    }
    if (m.find("StoryType") != m.end() && !m["StoryType"].empty()) {
      storyType = make_shared<string>(boost::any_cast<string>(m["StoryType"]));
    }
    if (m.find("WithEmptyStories") != m.end() && !m["WithEmptyStories"].empty()) {
      withEmptyStories = make_shared<bool>(boost::any_cast<bool>(m["WithEmptyStories"]));
    }
  }


  virtual ~QueryStoriesShrinkRequest() = default;
};
class QueryStoriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<Story>> stories{};

  QueryStoriesResponseBody() {}

  explicit QueryStoriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (stories) {
      vector<boost::any> temp1;
      for(auto item1:*stories){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Stories"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Stories") != m.end() && !m["Stories"].empty()) {
      if (typeid(vector<boost::any>) == m["Stories"].type()) {
        vector<Story> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Stories"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Story model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        stories = make_shared<vector<Story>>(expect1);
      }
    }
  }


  virtual ~QueryStoriesResponseBody() = default;
};
class QueryStoriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<QueryStoriesResponseBody> body{};

  QueryStoriesResponse() {}

  explicit QueryStoriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        QueryStoriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<QueryStoriesResponseBody>(model1);
      }
    }
  }


  virtual ~QueryStoriesResponse() = default;
};
class RefreshWebofficeTokenRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<CredentialConfig> credentialConfig{};
  shared_ptr<string> projectName{};
  shared_ptr<string> refreshToken{};

  RefreshWebofficeTokenRequest() {}

  explicit RefreshWebofficeTokenRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["AccessToken"] = boost::any(*accessToken);
    }
    if (credentialConfig) {
      res["CredentialConfig"] = credentialConfig ? boost::any(credentialConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (refreshToken) {
      res["RefreshToken"] = boost::any(*refreshToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessToken") != m.end() && !m["AccessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["AccessToken"]));
    }
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CredentialConfig"].type()) {
        CredentialConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CredentialConfig"]));
        credentialConfig = make_shared<CredentialConfig>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("RefreshToken") != m.end() && !m["RefreshToken"].empty()) {
      refreshToken = make_shared<string>(boost::any_cast<string>(m["RefreshToken"]));
    }
  }


  virtual ~RefreshWebofficeTokenRequest() = default;
};
class RefreshWebofficeTokenShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> credentialConfigShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> refreshToken{};

  RefreshWebofficeTokenShrinkRequest() {}

  explicit RefreshWebofficeTokenShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["AccessToken"] = boost::any(*accessToken);
    }
    if (credentialConfigShrink) {
      res["CredentialConfig"] = boost::any(*credentialConfigShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (refreshToken) {
      res["RefreshToken"] = boost::any(*refreshToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessToken") != m.end() && !m["AccessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["AccessToken"]));
    }
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      credentialConfigShrink = make_shared<string>(boost::any_cast<string>(m["CredentialConfig"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("RefreshToken") != m.end() && !m["RefreshToken"].empty()) {
      refreshToken = make_shared<string>(boost::any_cast<string>(m["RefreshToken"]));
    }
  }


  virtual ~RefreshWebofficeTokenShrinkRequest() = default;
};
class RefreshWebofficeTokenResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> accessToken{};
  shared_ptr<string> accessTokenExpiredTime{};
  shared_ptr<string> refreshToken{};
  shared_ptr<string> refreshTokenExpiredTime{};
  shared_ptr<string> requestId{};

  RefreshWebofficeTokenResponseBody() {}

  explicit RefreshWebofficeTokenResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (accessToken) {
      res["AccessToken"] = boost::any(*accessToken);
    }
    if (accessTokenExpiredTime) {
      res["AccessTokenExpiredTime"] = boost::any(*accessTokenExpiredTime);
    }
    if (refreshToken) {
      res["RefreshToken"] = boost::any(*refreshToken);
    }
    if (refreshTokenExpiredTime) {
      res["RefreshTokenExpiredTime"] = boost::any(*refreshTokenExpiredTime);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("AccessToken") != m.end() && !m["AccessToken"].empty()) {
      accessToken = make_shared<string>(boost::any_cast<string>(m["AccessToken"]));
    }
    if (m.find("AccessTokenExpiredTime") != m.end() && !m["AccessTokenExpiredTime"].empty()) {
      accessTokenExpiredTime = make_shared<string>(boost::any_cast<string>(m["AccessTokenExpiredTime"]));
    }
    if (m.find("RefreshToken") != m.end() && !m["RefreshToken"].empty()) {
      refreshToken = make_shared<string>(boost::any_cast<string>(m["RefreshToken"]));
    }
    if (m.find("RefreshTokenExpiredTime") != m.end() && !m["RefreshTokenExpiredTime"].empty()) {
      refreshTokenExpiredTime = make_shared<string>(boost::any_cast<string>(m["RefreshTokenExpiredTime"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RefreshWebofficeTokenResponseBody() = default;
};
class RefreshWebofficeTokenResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RefreshWebofficeTokenResponseBody> body{};

  RefreshWebofficeTokenResponse() {}

  explicit RefreshWebofficeTokenResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RefreshWebofficeTokenResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RefreshWebofficeTokenResponseBody>(model1);
      }
    }
  }


  virtual ~RefreshWebofficeTokenResponse() = default;
};
class RemoveStoryFilesRequestFiles : public Darabonba::Model {
public:
  shared_ptr<string> URI{};

  RemoveStoryFilesRequestFiles() {}

  explicit RemoveStoryFilesRequestFiles(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~RemoveStoryFilesRequestFiles() = default;
};
class RemoveStoryFilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<vector<RemoveStoryFilesRequestFiles>> files{};
  shared_ptr<string> objectId{};
  shared_ptr<string> projectName{};

  RemoveStoryFilesRequest() {}

  explicit RemoveStoryFilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (files) {
      vector<boost::any> temp1;
      for(auto item1:*files){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Files"] = boost::any(temp1);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      if (typeid(vector<boost::any>) == m["Files"].type()) {
        vector<RemoveStoryFilesRequestFiles> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Files"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RemoveStoryFilesRequestFiles model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        files = make_shared<vector<RemoveStoryFilesRequestFiles>>(expect1);
      }
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~RemoveStoryFilesRequest() = default;
};
class RemoveStoryFilesShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> filesShrink{};
  shared_ptr<string> objectId{};
  shared_ptr<string> projectName{};

  RemoveStoryFilesShrinkRequest() {}

  explicit RemoveStoryFilesShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (filesShrink) {
      res["Files"] = boost::any(*filesShrink);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      filesShrink = make_shared<string>(boost::any_cast<string>(m["Files"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~RemoveStoryFilesShrinkRequest() = default;
};
class RemoveStoryFilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  RemoveStoryFilesResponseBody() {}

  explicit RemoveStoryFilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~RemoveStoryFilesResponseBody() = default;
};
class RemoveStoryFilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveStoryFilesResponseBody> body{};

  RemoveStoryFilesResponse() {}

  explicit RemoveStoryFilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveStoryFilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveStoryFilesResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveStoryFilesResponse() = default;
};
class ResumeBatchRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> projectName{};

  ResumeBatchRequest() {}

  explicit ResumeBatchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~ResumeBatchRequest() = default;
};
class ResumeBatchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ResumeBatchResponseBody() {}

  explicit ResumeBatchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResumeBatchResponseBody() = default;
};
class ResumeBatchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResumeBatchResponseBody> body{};

  ResumeBatchResponse() {}

  explicit ResumeBatchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResumeBatchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResumeBatchResponseBody>(model1);
      }
    }
  }


  virtual ~ResumeBatchResponse() = default;
};
class ResumeTriggerRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> projectName{};

  ResumeTriggerRequest() {}

  explicit ResumeTriggerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~ResumeTriggerRequest() = default;
};
class ResumeTriggerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  ResumeTriggerResponseBody() {}

  explicit ResumeTriggerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~ResumeTriggerResponseBody() = default;
};
class ResumeTriggerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResumeTriggerResponseBody> body{};

  ResumeTriggerResponse() {}

  explicit ResumeTriggerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResumeTriggerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResumeTriggerResponseBody>(model1);
      }
    }
  }


  virtual ~ResumeTriggerResponse() = default;
};
class SearchImageFigureClusterRequest : public Darabonba::Model {
public:
  shared_ptr<CredentialConfig> credentialConfig{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceURI{};

  SearchImageFigureClusterRequest() {}

  explicit SearchImageFigureClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfig) {
      res["CredentialConfig"] = credentialConfig ? boost::any(credentialConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["CredentialConfig"].type()) {
        CredentialConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["CredentialConfig"]));
        credentialConfig = make_shared<CredentialConfig>(model1);
      }
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
  }


  virtual ~SearchImageFigureClusterRequest() = default;
};
class SearchImageFigureClusterShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> credentialConfigShrink{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> projectName{};
  shared_ptr<string> sourceURI{};

  SearchImageFigureClusterShrinkRequest() {}

  explicit SearchImageFigureClusterShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (credentialConfigShrink) {
      res["CredentialConfig"] = boost::any(*credentialConfigShrink);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (sourceURI) {
      res["SourceURI"] = boost::any(*sourceURI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CredentialConfig") != m.end() && !m["CredentialConfig"].empty()) {
      credentialConfigShrink = make_shared<string>(boost::any_cast<string>(m["CredentialConfig"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("SourceURI") != m.end() && !m["SourceURI"].empty()) {
      sourceURI = make_shared<string>(boost::any_cast<string>(m["SourceURI"]));
    }
  }


  virtual ~SearchImageFigureClusterShrinkRequest() = default;
};
class SearchImageFigureClusterResponseBodyClusters : public Darabonba::Model {
public:
  shared_ptr<Boundary> boundary{};
  shared_ptr<string> clusterId{};
  shared_ptr<double> similarity{};

  SearchImageFigureClusterResponseBodyClusters() {}

  explicit SearchImageFigureClusterResponseBodyClusters(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (boundary) {
      res["Boundary"] = boundary ? boost::any(boundary->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clusterId) {
      res["ClusterId"] = boost::any(*clusterId);
    }
    if (similarity) {
      res["Similarity"] = boost::any(*similarity);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Boundary") != m.end() && !m["Boundary"].empty()) {
      if (typeid(map<string, boost::any>) == m["Boundary"].type()) {
        Boundary model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Boundary"]));
        boundary = make_shared<Boundary>(model1);
      }
    }
    if (m.find("ClusterId") != m.end() && !m["ClusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["ClusterId"]));
    }
    if (m.find("Similarity") != m.end() && !m["Similarity"].empty()) {
      similarity = make_shared<double>(boost::any_cast<double>(m["Similarity"]));
    }
  }


  virtual ~SearchImageFigureClusterResponseBodyClusters() = default;
};
class SearchImageFigureClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<SearchImageFigureClusterResponseBodyClusters>> clusters{};
  shared_ptr<string> requestId{};

  SearchImageFigureClusterResponseBody() {}

  explicit SearchImageFigureClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusters) {
      vector<boost::any> temp1;
      for(auto item1:*clusters){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Clusters"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Clusters") != m.end() && !m["Clusters"].empty()) {
      if (typeid(vector<boost::any>) == m["Clusters"].type()) {
        vector<SearchImageFigureClusterResponseBodyClusters> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Clusters"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SearchImageFigureClusterResponseBodyClusters model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clusters = make_shared<vector<SearchImageFigureClusterResponseBodyClusters>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SearchImageFigureClusterResponseBody() = default;
};
class SearchImageFigureClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SearchImageFigureClusterResponseBody> body{};

  SearchImageFigureClusterResponse() {}

  explicit SearchImageFigureClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SearchImageFigureClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SearchImageFigureClusterResponseBody>(model1);
      }
    }
  }


  virtual ~SearchImageFigureClusterResponse() = default;
};
class SemanticQueryRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<long> maxResults{};
  shared_ptr<vector<string>> mediaTypes{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> projectName{};
  shared_ptr<string> query{};
  shared_ptr<vector<string>> withFields{};

  SemanticQueryRequest() {}

  explicit SemanticQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (mediaTypes) {
      res["MediaTypes"] = boost::any(*mediaTypes);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    if (withFields) {
      res["WithFields"] = boost::any(*withFields);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("MediaTypes") != m.end() && !m["MediaTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["MediaTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["MediaTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      mediaTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("WithFields") != m.end() && !m["WithFields"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WithFields"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WithFields"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      withFields = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~SemanticQueryRequest() = default;
};
class SemanticQueryShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> mediaTypesShrink{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> projectName{};
  shared_ptr<string> query{};
  shared_ptr<string> withFieldsShrink{};

  SemanticQueryShrinkRequest() {}

  explicit SemanticQueryShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (mediaTypesShrink) {
      res["MediaTypes"] = boost::any(*mediaTypesShrink);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (query) {
      res["Query"] = boost::any(*query);
    }
    if (withFieldsShrink) {
      res["WithFields"] = boost::any(*withFieldsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("MediaTypes") != m.end() && !m["MediaTypes"].empty()) {
      mediaTypesShrink = make_shared<string>(boost::any_cast<string>(m["MediaTypes"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("WithFields") != m.end() && !m["WithFields"].empty()) {
      withFieldsShrink = make_shared<string>(boost::any_cast<string>(m["WithFields"]));
    }
  }


  virtual ~SemanticQueryShrinkRequest() = default;
};
class SemanticQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<File>> files{};
  shared_ptr<string> requestId{};

  SemanticQueryResponseBody() {}

  explicit SemanticQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (files) {
      vector<boost::any> temp1;
      for(auto item1:*files){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Files"] = boost::any(temp1);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      if (typeid(vector<boost::any>) == m["Files"].type()) {
        vector<File> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Files"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            File model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        files = make_shared<vector<File>>(expect1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SemanticQueryResponseBody() = default;
};
class SemanticQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SemanticQueryResponseBody> body{};

  SemanticQueryResponse() {}

  explicit SemanticQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SemanticQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SemanticQueryResponseBody>(model1);
      }
    }
  }


  virtual ~SemanticQueryResponse() = default;
};
class SimpleQueryRequestAggregations : public Darabonba::Model {
public:
  shared_ptr<string> field{};
  shared_ptr<string> operation{};

  SimpleQueryRequestAggregations() {}

  explicit SimpleQueryRequestAggregations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
  }


  virtual ~SimpleQueryRequestAggregations() = default;
};
class SimpleQueryRequest : public Darabonba::Model {
public:
  shared_ptr<vector<SimpleQueryRequestAggregations>> aggregations{};
  shared_ptr<string> datasetName{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> order{};
  shared_ptr<string> projectName{};
  shared_ptr<SimpleQuery> query{};
  shared_ptr<string> sort{};
  shared_ptr<vector<string>> withFields{};
  shared_ptr<bool> withoutTotalHits{};

  SimpleQueryRequest() {}

  explicit SimpleQueryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregations) {
      vector<boost::any> temp1;
      for(auto item1:*aggregations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Aggregations"] = boost::any(temp1);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (query) {
      res["Query"] = query ? boost::any(query->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (withFields) {
      res["WithFields"] = boost::any(*withFields);
    }
    if (withoutTotalHits) {
      res["WithoutTotalHits"] = boost::any(*withoutTotalHits);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Aggregations") != m.end() && !m["Aggregations"].empty()) {
      if (typeid(vector<boost::any>) == m["Aggregations"].type()) {
        vector<SimpleQueryRequestAggregations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Aggregations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SimpleQueryRequestAggregations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aggregations = make_shared<vector<SimpleQueryRequestAggregations>>(expect1);
      }
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      if (typeid(map<string, boost::any>) == m["Query"].type()) {
        SimpleQuery model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Query"]));
        query = make_shared<SimpleQuery>(model1);
      }
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["Sort"]));
    }
    if (m.find("WithFields") != m.end() && !m["WithFields"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["WithFields"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["WithFields"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      withFields = make_shared<vector<string>>(toVec1);
    }
    if (m.find("WithoutTotalHits") != m.end() && !m["WithoutTotalHits"].empty()) {
      withoutTotalHits = make_shared<bool>(boost::any_cast<bool>(m["WithoutTotalHits"]));
    }
  }


  virtual ~SimpleQueryRequest() = default;
};
class SimpleQueryShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> aggregationsShrink{};
  shared_ptr<string> datasetName{};
  shared_ptr<long> maxResults{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> order{};
  shared_ptr<string> projectName{};
  shared_ptr<string> queryShrink{};
  shared_ptr<string> sort{};
  shared_ptr<string> withFieldsShrink{};
  shared_ptr<bool> withoutTotalHits{};

  SimpleQueryShrinkRequest() {}

  explicit SimpleQueryShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregationsShrink) {
      res["Aggregations"] = boost::any(*aggregationsShrink);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (maxResults) {
      res["MaxResults"] = boost::any(*maxResults);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (order) {
      res["Order"] = boost::any(*order);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (queryShrink) {
      res["Query"] = boost::any(*queryShrink);
    }
    if (sort) {
      res["Sort"] = boost::any(*sort);
    }
    if (withFieldsShrink) {
      res["WithFields"] = boost::any(*withFieldsShrink);
    }
    if (withoutTotalHits) {
      res["WithoutTotalHits"] = boost::any(*withoutTotalHits);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Aggregations") != m.end() && !m["Aggregations"].empty()) {
      aggregationsShrink = make_shared<string>(boost::any_cast<string>(m["Aggregations"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("MaxResults") != m.end() && !m["MaxResults"].empty()) {
      maxResults = make_shared<long>(boost::any_cast<long>(m["MaxResults"]));
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Order") != m.end() && !m["Order"].empty()) {
      order = make_shared<string>(boost::any_cast<string>(m["Order"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Query") != m.end() && !m["Query"].empty()) {
      queryShrink = make_shared<string>(boost::any_cast<string>(m["Query"]));
    }
    if (m.find("Sort") != m.end() && !m["Sort"].empty()) {
      sort = make_shared<string>(boost::any_cast<string>(m["Sort"]));
    }
    if (m.find("WithFields") != m.end() && !m["WithFields"].empty()) {
      withFieldsShrink = make_shared<string>(boost::any_cast<string>(m["WithFields"]));
    }
    if (m.find("WithoutTotalHits") != m.end() && !m["WithoutTotalHits"].empty()) {
      withoutTotalHits = make_shared<bool>(boost::any_cast<bool>(m["WithoutTotalHits"]));
    }
  }


  virtual ~SimpleQueryShrinkRequest() = default;
};
class SimpleQueryResponseBodyAggregationsGroups : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> value{};

  SimpleQueryResponseBodyAggregationsGroups() {}

  explicit SimpleQueryResponseBodyAggregationsGroups(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["Count"] = boost::any(*count);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Count") != m.end() && !m["Count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["Count"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~SimpleQueryResponseBodyAggregationsGroups() = default;
};
class SimpleQueryResponseBodyAggregations : public Darabonba::Model {
public:
  shared_ptr<string> field{};
  shared_ptr<vector<SimpleQueryResponseBodyAggregationsGroups>> groups{};
  shared_ptr<string> operation{};
  shared_ptr<double> value{};

  SimpleQueryResponseBodyAggregations() {}

  explicit SimpleQueryResponseBodyAggregations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (field) {
      res["Field"] = boost::any(*field);
    }
    if (groups) {
      vector<boost::any> temp1;
      for(auto item1:*groups){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Groups"] = boost::any(temp1);
    }
    if (operation) {
      res["Operation"] = boost::any(*operation);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Field") != m.end() && !m["Field"].empty()) {
      field = make_shared<string>(boost::any_cast<string>(m["Field"]));
    }
    if (m.find("Groups") != m.end() && !m["Groups"].empty()) {
      if (typeid(vector<boost::any>) == m["Groups"].type()) {
        vector<SimpleQueryResponseBodyAggregationsGroups> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Groups"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SimpleQueryResponseBodyAggregationsGroups model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        groups = make_shared<vector<SimpleQueryResponseBodyAggregationsGroups>>(expect1);
      }
    }
    if (m.find("Operation") != m.end() && !m["Operation"].empty()) {
      operation = make_shared<string>(boost::any_cast<string>(m["Operation"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<double>(boost::any_cast<double>(m["Value"]));
    }
  }


  virtual ~SimpleQueryResponseBodyAggregations() = default;
};
class SimpleQueryResponseBody : public Darabonba::Model {
public:
  shared_ptr<vector<SimpleQueryResponseBodyAggregations>> aggregations{};
  shared_ptr<vector<File>> files{};
  shared_ptr<string> nextToken{};
  shared_ptr<string> requestId{};
  shared_ptr<long> totalHits{};

  SimpleQueryResponseBody() {}

  explicit SimpleQueryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aggregations) {
      vector<boost::any> temp1;
      for(auto item1:*aggregations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Aggregations"] = boost::any(temp1);
    }
    if (files) {
      vector<boost::any> temp1;
      for(auto item1:*files){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Files"] = boost::any(temp1);
    }
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (totalHits) {
      res["TotalHits"] = boost::any(*totalHits);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Aggregations") != m.end() && !m["Aggregations"].empty()) {
      if (typeid(vector<boost::any>) == m["Aggregations"].type()) {
        vector<SimpleQueryResponseBodyAggregations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Aggregations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            SimpleQueryResponseBodyAggregations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aggregations = make_shared<vector<SimpleQueryResponseBodyAggregations>>(expect1);
      }
    }
    if (m.find("Files") != m.end() && !m["Files"].empty()) {
      if (typeid(vector<boost::any>) == m["Files"].type()) {
        vector<File> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Files"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            File model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        files = make_shared<vector<File>>(expect1);
      }
    }
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TotalHits") != m.end() && !m["TotalHits"].empty()) {
      totalHits = make_shared<long>(boost::any_cast<long>(m["TotalHits"]));
    }
  }


  virtual ~SimpleQueryResponseBody() = default;
};
class SimpleQueryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SimpleQueryResponseBody> body{};

  SimpleQueryResponse() {}

  explicit SimpleQueryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SimpleQueryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SimpleQueryResponseBody>(model1);
      }
    }
  }


  virtual ~SimpleQueryResponse() = default;
};
class SuspendBatchRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> projectName{};

  SuspendBatchRequest() {}

  explicit SuspendBatchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~SuspendBatchRequest() = default;
};
class SuspendBatchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SuspendBatchResponseBody() {}

  explicit SuspendBatchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SuspendBatchResponseBody() = default;
};
class SuspendBatchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SuspendBatchResponseBody> body{};

  SuspendBatchResponse() {}

  explicit SuspendBatchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SuspendBatchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SuspendBatchResponseBody>(model1);
      }
    }
  }


  virtual ~SuspendBatchResponse() = default;
};
class SuspendTriggerRequest : public Darabonba::Model {
public:
  shared_ptr<string> id{};
  shared_ptr<string> projectName{};

  SuspendTriggerRequest() {}

  explicit SuspendTriggerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~SuspendTriggerRequest() = default;
};
class SuspendTriggerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  SuspendTriggerResponseBody() {}

  explicit SuspendTriggerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~SuspendTriggerResponseBody() = default;
};
class SuspendTriggerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<SuspendTriggerResponseBody> body{};

  SuspendTriggerResponse() {}

  explicit SuspendTriggerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        SuspendTriggerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<SuspendTriggerResponseBody>(model1);
      }
    }
  }


  virtual ~SuspendTriggerResponse() = default;
};
class UpdateBatchRequestActions : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<vector<string>> parameters{};

  UpdateBatchRequestActions() {}

  explicit UpdateBatchRequestActions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Parameters"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Parameters"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      parameters = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateBatchRequestActions() = default;
};
class UpdateBatchRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateBatchRequestActions>> actions{};
  shared_ptr<string> id{};
  shared_ptr<Input> input{};
  shared_ptr<string> projectName{};
  shared_ptr<map<string, boost::any>> tags{};

  UpdateBatchRequest() {}

  explicit UpdateBatchRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actions) {
      vector<boost::any> temp1;
      for(auto item1:*actions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Actions"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Actions") != m.end() && !m["Actions"].empty()) {
      if (typeid(vector<boost::any>) == m["Actions"].type()) {
        vector<UpdateBatchRequestActions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Actions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateBatchRequestActions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        actions = make_shared<vector<UpdateBatchRequestActions>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        Input model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<Input>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Tags"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~UpdateBatchRequest() = default;
};
class UpdateBatchShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> actionsShrink{};
  shared_ptr<string> id{};
  shared_ptr<string> inputShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> tagsShrink{};

  UpdateBatchShrinkRequest() {}

  explicit UpdateBatchShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionsShrink) {
      res["Actions"] = boost::any(*actionsShrink);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inputShrink) {
      res["Input"] = boost::any(*inputShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Actions") != m.end() && !m["Actions"].empty()) {
      actionsShrink = make_shared<string>(boost::any_cast<string>(m["Actions"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      inputShrink = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~UpdateBatchShrinkRequest() = default;
};
class UpdateBatchResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateBatchResponseBody() {}

  explicit UpdateBatchResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateBatchResponseBody() = default;
};
class UpdateBatchResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateBatchResponseBody> body{};

  UpdateBatchResponse() {}

  explicit UpdateBatchResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateBatchResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateBatchResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateBatchResponse() = default;
};
class UpdateDatasetRequest : public Darabonba::Model {
public:
  shared_ptr<long> datasetMaxBindCount{};
  shared_ptr<long> datasetMaxEntityCount{};
  shared_ptr<long> datasetMaxFileCount{};
  shared_ptr<long> datasetMaxRelationCount{};
  shared_ptr<long> datasetMaxTotalFileSize{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> description{};
  shared_ptr<string> projectName{};
  shared_ptr<string> templateId{};

  UpdateDatasetRequest() {}

  explicit UpdateDatasetRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetMaxBindCount) {
      res["DatasetMaxBindCount"] = boost::any(*datasetMaxBindCount);
    }
    if (datasetMaxEntityCount) {
      res["DatasetMaxEntityCount"] = boost::any(*datasetMaxEntityCount);
    }
    if (datasetMaxFileCount) {
      res["DatasetMaxFileCount"] = boost::any(*datasetMaxFileCount);
    }
    if (datasetMaxRelationCount) {
      res["DatasetMaxRelationCount"] = boost::any(*datasetMaxRelationCount);
    }
    if (datasetMaxTotalFileSize) {
      res["DatasetMaxTotalFileSize"] = boost::any(*datasetMaxTotalFileSize);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetMaxBindCount") != m.end() && !m["DatasetMaxBindCount"].empty()) {
      datasetMaxBindCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxBindCount"]));
    }
    if (m.find("DatasetMaxEntityCount") != m.end() && !m["DatasetMaxEntityCount"].empty()) {
      datasetMaxEntityCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxEntityCount"]));
    }
    if (m.find("DatasetMaxFileCount") != m.end() && !m["DatasetMaxFileCount"].empty()) {
      datasetMaxFileCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxFileCount"]));
    }
    if (m.find("DatasetMaxRelationCount") != m.end() && !m["DatasetMaxRelationCount"].empty()) {
      datasetMaxRelationCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxRelationCount"]));
    }
    if (m.find("DatasetMaxTotalFileSize") != m.end() && !m["DatasetMaxTotalFileSize"].empty()) {
      datasetMaxTotalFileSize = make_shared<long>(boost::any_cast<long>(m["DatasetMaxTotalFileSize"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~UpdateDatasetRequest() = default;
};
class UpdateDatasetResponseBody : public Darabonba::Model {
public:
  shared_ptr<Dataset> dataset{};
  shared_ptr<string> requestId{};

  UpdateDatasetResponseBody() {}

  explicit UpdateDatasetResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataset) {
      res["Dataset"] = dataset ? boost::any(dataset->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Dataset") != m.end() && !m["Dataset"].empty()) {
      if (typeid(map<string, boost::any>) == m["Dataset"].type()) {
        Dataset model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Dataset"]));
        dataset = make_shared<Dataset>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateDatasetResponseBody() = default;
};
class UpdateDatasetResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDatasetResponseBody> body{};

  UpdateDatasetResponse() {}

  explicit UpdateDatasetResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDatasetResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDatasetResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDatasetResponse() = default;
};
class UpdateFigureClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<FigureClusterForReq> figureCluster{};
  shared_ptr<string> projectName{};

  UpdateFigureClusterRequest() {}

  explicit UpdateFigureClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (figureCluster) {
      res["FigureCluster"] = figureCluster ? boost::any(figureCluster->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("FigureCluster") != m.end() && !m["FigureCluster"].empty()) {
      if (typeid(map<string, boost::any>) == m["FigureCluster"].type()) {
        FigureClusterForReq model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["FigureCluster"]));
        figureCluster = make_shared<FigureClusterForReq>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~UpdateFigureClusterRequest() = default;
};
class UpdateFigureClusterShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> figureClusterShrink{};
  shared_ptr<string> projectName{};

  UpdateFigureClusterShrinkRequest() {}

  explicit UpdateFigureClusterShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (figureClusterShrink) {
      res["FigureCluster"] = boost::any(*figureClusterShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("FigureCluster") != m.end() && !m["FigureCluster"].empty()) {
      figureClusterShrink = make_shared<string>(boost::any_cast<string>(m["FigureCluster"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~UpdateFigureClusterShrinkRequest() = default;
};
class UpdateFigureClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateFigureClusterResponseBody() {}

  explicit UpdateFigureClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateFigureClusterResponseBody() = default;
};
class UpdateFigureClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateFigureClusterResponseBody> body{};

  UpdateFigureClusterResponse() {}

  explicit UpdateFigureClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateFigureClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateFigureClusterResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateFigureClusterResponse() = default;
};
class UpdateFileMetaRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<InputFile> file{};
  shared_ptr<string> projectName{};

  UpdateFileMetaRequest() {}

  explicit UpdateFileMetaRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (file) {
      res["File"] = file ? boost::any(file->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      if (typeid(map<string, boost::any>) == m["File"].type()) {
        InputFile model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["File"]));
        file = make_shared<InputFile>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~UpdateFileMetaRequest() = default;
};
class UpdateFileMetaShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> datasetName{};
  shared_ptr<string> fileShrink{};
  shared_ptr<string> projectName{};

  UpdateFileMetaShrinkRequest() {}

  explicit UpdateFileMetaShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (fileShrink) {
      res["File"] = boost::any(*fileShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("File") != m.end() && !m["File"].empty()) {
      fileShrink = make_shared<string>(boost::any_cast<string>(m["File"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
  }


  virtual ~UpdateFileMetaShrinkRequest() = default;
};
class UpdateFileMetaResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateFileMetaResponseBody() {}

  explicit UpdateFileMetaResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateFileMetaResponseBody() = default;
};
class UpdateFileMetaResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateFileMetaResponseBody> body{};

  UpdateFileMetaResponse() {}

  explicit UpdateFileMetaResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateFileMetaResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateFileMetaResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateFileMetaResponse() = default;
};
class UpdateLocationDateClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> customId{};
  shared_ptr<map<string, boost::any>> customLabels{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> objectId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> title{};

  UpdateLocationDateClusterRequest() {}

  explicit UpdateLocationDateClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customId) {
      res["CustomId"] = boost::any(*customId);
    }
    if (customLabels) {
      res["CustomLabels"] = boost::any(*customLabels);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomId") != m.end() && !m["CustomId"].empty()) {
      customId = make_shared<string>(boost::any_cast<string>(m["CustomId"]));
    }
    if (m.find("CustomLabels") != m.end() && !m["CustomLabels"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["CustomLabels"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customLabels = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~UpdateLocationDateClusterRequest() = default;
};
class UpdateLocationDateClusterShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> customId{};
  shared_ptr<string> customLabelsShrink{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> objectId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> title{};

  UpdateLocationDateClusterShrinkRequest() {}

  explicit UpdateLocationDateClusterShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (customId) {
      res["CustomId"] = boost::any(*customId);
    }
    if (customLabelsShrink) {
      res["CustomLabels"] = boost::any(*customLabelsShrink);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (title) {
      res["Title"] = boost::any(*title);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("CustomId") != m.end() && !m["CustomId"].empty()) {
      customId = make_shared<string>(boost::any_cast<string>(m["CustomId"]));
    }
    if (m.find("CustomLabels") != m.end() && !m["CustomLabels"].empty()) {
      customLabelsShrink = make_shared<string>(boost::any_cast<string>(m["CustomLabels"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Title") != m.end() && !m["Title"].empty()) {
      title = make_shared<string>(boost::any_cast<string>(m["Title"]));
    }
  }


  virtual ~UpdateLocationDateClusterShrinkRequest() = default;
};
class UpdateLocationDateClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLocationDateClusterResponseBody() {}

  explicit UpdateLocationDateClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLocationDateClusterResponseBody() = default;
};
class UpdateLocationDateClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLocationDateClusterResponseBody> body{};

  UpdateLocationDateClusterResponse() {}

  explicit UpdateLocationDateClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLocationDateClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLocationDateClusterResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLocationDateClusterResponse() = default;
};
class UpdateProjectRequestTag : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  UpdateProjectRequestTag() {}

  explicit UpdateProjectRequestTag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["Key"] = boost::any(*key);
    }
    if (value) {
      res["Value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Key") != m.end() && !m["Key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["Key"]));
    }
    if (m.find("Value") != m.end() && !m["Value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["Value"]));
    }
  }


  virtual ~UpdateProjectRequestTag() = default;
};
class UpdateProjectRequest : public Darabonba::Model {
public:
  shared_ptr<long> datasetMaxBindCount{};
  shared_ptr<long> datasetMaxEntityCount{};
  shared_ptr<long> datasetMaxFileCount{};
  shared_ptr<long> datasetMaxRelationCount{};
  shared_ptr<long> datasetMaxTotalFileSize{};
  shared_ptr<string> description{};
  shared_ptr<long> projectMaxDatasetCount{};
  shared_ptr<string> projectName{};
  shared_ptr<string> serviceRole{};
  shared_ptr<vector<UpdateProjectRequestTag>> tag{};
  shared_ptr<string> templateId{};

  UpdateProjectRequest() {}

  explicit UpdateProjectRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetMaxBindCount) {
      res["DatasetMaxBindCount"] = boost::any(*datasetMaxBindCount);
    }
    if (datasetMaxEntityCount) {
      res["DatasetMaxEntityCount"] = boost::any(*datasetMaxEntityCount);
    }
    if (datasetMaxFileCount) {
      res["DatasetMaxFileCount"] = boost::any(*datasetMaxFileCount);
    }
    if (datasetMaxRelationCount) {
      res["DatasetMaxRelationCount"] = boost::any(*datasetMaxRelationCount);
    }
    if (datasetMaxTotalFileSize) {
      res["DatasetMaxTotalFileSize"] = boost::any(*datasetMaxTotalFileSize);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (projectMaxDatasetCount) {
      res["ProjectMaxDatasetCount"] = boost::any(*projectMaxDatasetCount);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (serviceRole) {
      res["ServiceRole"] = boost::any(*serviceRole);
    }
    if (tag) {
      vector<boost::any> temp1;
      for(auto item1:*tag){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tag"] = boost::any(temp1);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetMaxBindCount") != m.end() && !m["DatasetMaxBindCount"].empty()) {
      datasetMaxBindCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxBindCount"]));
    }
    if (m.find("DatasetMaxEntityCount") != m.end() && !m["DatasetMaxEntityCount"].empty()) {
      datasetMaxEntityCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxEntityCount"]));
    }
    if (m.find("DatasetMaxFileCount") != m.end() && !m["DatasetMaxFileCount"].empty()) {
      datasetMaxFileCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxFileCount"]));
    }
    if (m.find("DatasetMaxRelationCount") != m.end() && !m["DatasetMaxRelationCount"].empty()) {
      datasetMaxRelationCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxRelationCount"]));
    }
    if (m.find("DatasetMaxTotalFileSize") != m.end() && !m["DatasetMaxTotalFileSize"].empty()) {
      datasetMaxTotalFileSize = make_shared<long>(boost::any_cast<long>(m["DatasetMaxTotalFileSize"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ProjectMaxDatasetCount") != m.end() && !m["ProjectMaxDatasetCount"].empty()) {
      projectMaxDatasetCount = make_shared<long>(boost::any_cast<long>(m["ProjectMaxDatasetCount"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ServiceRole") != m.end() && !m["ServiceRole"].empty()) {
      serviceRole = make_shared<string>(boost::any_cast<string>(m["ServiceRole"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      if (typeid(vector<boost::any>) == m["Tag"].type()) {
        vector<UpdateProjectRequestTag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tag"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateProjectRequestTag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tag = make_shared<vector<UpdateProjectRequestTag>>(expect1);
      }
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~UpdateProjectRequest() = default;
};
class UpdateProjectShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<long> datasetMaxBindCount{};
  shared_ptr<long> datasetMaxEntityCount{};
  shared_ptr<long> datasetMaxFileCount{};
  shared_ptr<long> datasetMaxRelationCount{};
  shared_ptr<long> datasetMaxTotalFileSize{};
  shared_ptr<string> description{};
  shared_ptr<long> projectMaxDatasetCount{};
  shared_ptr<string> projectName{};
  shared_ptr<string> serviceRole{};
  shared_ptr<string> tagShrink{};
  shared_ptr<string> templateId{};

  UpdateProjectShrinkRequest() {}

  explicit UpdateProjectShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (datasetMaxBindCount) {
      res["DatasetMaxBindCount"] = boost::any(*datasetMaxBindCount);
    }
    if (datasetMaxEntityCount) {
      res["DatasetMaxEntityCount"] = boost::any(*datasetMaxEntityCount);
    }
    if (datasetMaxFileCount) {
      res["DatasetMaxFileCount"] = boost::any(*datasetMaxFileCount);
    }
    if (datasetMaxRelationCount) {
      res["DatasetMaxRelationCount"] = boost::any(*datasetMaxRelationCount);
    }
    if (datasetMaxTotalFileSize) {
      res["DatasetMaxTotalFileSize"] = boost::any(*datasetMaxTotalFileSize);
    }
    if (description) {
      res["Description"] = boost::any(*description);
    }
    if (projectMaxDatasetCount) {
      res["ProjectMaxDatasetCount"] = boost::any(*projectMaxDatasetCount);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (serviceRole) {
      res["ServiceRole"] = boost::any(*serviceRole);
    }
    if (tagShrink) {
      res["Tag"] = boost::any(*tagShrink);
    }
    if (templateId) {
      res["TemplateId"] = boost::any(*templateId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("DatasetMaxBindCount") != m.end() && !m["DatasetMaxBindCount"].empty()) {
      datasetMaxBindCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxBindCount"]));
    }
    if (m.find("DatasetMaxEntityCount") != m.end() && !m["DatasetMaxEntityCount"].empty()) {
      datasetMaxEntityCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxEntityCount"]));
    }
    if (m.find("DatasetMaxFileCount") != m.end() && !m["DatasetMaxFileCount"].empty()) {
      datasetMaxFileCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxFileCount"]));
    }
    if (m.find("DatasetMaxRelationCount") != m.end() && !m["DatasetMaxRelationCount"].empty()) {
      datasetMaxRelationCount = make_shared<long>(boost::any_cast<long>(m["DatasetMaxRelationCount"]));
    }
    if (m.find("DatasetMaxTotalFileSize") != m.end() && !m["DatasetMaxTotalFileSize"].empty()) {
      datasetMaxTotalFileSize = make_shared<long>(boost::any_cast<long>(m["DatasetMaxTotalFileSize"]));
    }
    if (m.find("Description") != m.end() && !m["Description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["Description"]));
    }
    if (m.find("ProjectMaxDatasetCount") != m.end() && !m["ProjectMaxDatasetCount"].empty()) {
      projectMaxDatasetCount = make_shared<long>(boost::any_cast<long>(m["ProjectMaxDatasetCount"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("ServiceRole") != m.end() && !m["ServiceRole"].empty()) {
      serviceRole = make_shared<string>(boost::any_cast<string>(m["ServiceRole"]));
    }
    if (m.find("Tag") != m.end() && !m["Tag"].empty()) {
      tagShrink = make_shared<string>(boost::any_cast<string>(m["Tag"]));
    }
    if (m.find("TemplateId") != m.end() && !m["TemplateId"].empty()) {
      templateId = make_shared<string>(boost::any_cast<string>(m["TemplateId"]));
    }
  }


  virtual ~UpdateProjectShrinkRequest() = default;
};
class UpdateProjectResponseBody : public Darabonba::Model {
public:
  shared_ptr<Project> project{};
  shared_ptr<string> requestId{};

  UpdateProjectResponseBody() {}

  explicit UpdateProjectResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (project) {
      res["Project"] = project ? boost::any(project->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Project") != m.end() && !m["Project"].empty()) {
      if (typeid(map<string, boost::any>) == m["Project"].type()) {
        Project model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Project"]));
        project = make_shared<Project>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateProjectResponseBody() = default;
};
class UpdateProjectResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateProjectResponseBody> body{};

  UpdateProjectResponse() {}

  explicit UpdateProjectResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateProjectResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateProjectResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateProjectResponse() = default;
};
class UpdateStoryRequestCover : public Darabonba::Model {
public:
  shared_ptr<string> URI{};

  UpdateStoryRequestCover() {}

  explicit UpdateStoryRequestCover(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (URI) {
      res["URI"] = boost::any(*URI);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("URI") != m.end() && !m["URI"].empty()) {
      URI = make_shared<string>(boost::any_cast<string>(m["URI"]));
    }
  }


  virtual ~UpdateStoryRequestCover() = default;
};
class UpdateStoryRequest : public Darabonba::Model {
public:
  shared_ptr<UpdateStoryRequestCover> cover{};
  shared_ptr<string> customId{};
  shared_ptr<map<string, boost::any>> customLabels{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> objectId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> storyName{};

  UpdateStoryRequest() {}

  explicit UpdateStoryRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cover) {
      res["Cover"] = cover ? boost::any(cover->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (customId) {
      res["CustomId"] = boost::any(*customId);
    }
    if (customLabels) {
      res["CustomLabels"] = boost::any(*customLabels);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (storyName) {
      res["StoryName"] = boost::any(*storyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cover") != m.end() && !m["Cover"].empty()) {
      if (typeid(map<string, boost::any>) == m["Cover"].type()) {
        UpdateStoryRequestCover model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Cover"]));
        cover = make_shared<UpdateStoryRequestCover>(model1);
      }
    }
    if (m.find("CustomId") != m.end() && !m["CustomId"].empty()) {
      customId = make_shared<string>(boost::any_cast<string>(m["CustomId"]));
    }
    if (m.find("CustomLabels") != m.end() && !m["CustomLabels"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["CustomLabels"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      customLabels = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("StoryName") != m.end() && !m["StoryName"].empty()) {
      storyName = make_shared<string>(boost::any_cast<string>(m["StoryName"]));
    }
  }


  virtual ~UpdateStoryRequest() = default;
};
class UpdateStoryShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> coverShrink{};
  shared_ptr<string> customId{};
  shared_ptr<string> customLabelsShrink{};
  shared_ptr<string> datasetName{};
  shared_ptr<string> objectId{};
  shared_ptr<string> projectName{};
  shared_ptr<string> storyName{};

  UpdateStoryShrinkRequest() {}

  explicit UpdateStoryShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (coverShrink) {
      res["Cover"] = boost::any(*coverShrink);
    }
    if (customId) {
      res["CustomId"] = boost::any(*customId);
    }
    if (customLabelsShrink) {
      res["CustomLabels"] = boost::any(*customLabelsShrink);
    }
    if (datasetName) {
      res["DatasetName"] = boost::any(*datasetName);
    }
    if (objectId) {
      res["ObjectId"] = boost::any(*objectId);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (storyName) {
      res["StoryName"] = boost::any(*storyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Cover") != m.end() && !m["Cover"].empty()) {
      coverShrink = make_shared<string>(boost::any_cast<string>(m["Cover"]));
    }
    if (m.find("CustomId") != m.end() && !m["CustomId"].empty()) {
      customId = make_shared<string>(boost::any_cast<string>(m["CustomId"]));
    }
    if (m.find("CustomLabels") != m.end() && !m["CustomLabels"].empty()) {
      customLabelsShrink = make_shared<string>(boost::any_cast<string>(m["CustomLabels"]));
    }
    if (m.find("DatasetName") != m.end() && !m["DatasetName"].empty()) {
      datasetName = make_shared<string>(boost::any_cast<string>(m["DatasetName"]));
    }
    if (m.find("ObjectId") != m.end() && !m["ObjectId"].empty()) {
      objectId = make_shared<string>(boost::any_cast<string>(m["ObjectId"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("StoryName") != m.end() && !m["StoryName"].empty()) {
      storyName = make_shared<string>(boost::any_cast<string>(m["StoryName"]));
    }
  }


  virtual ~UpdateStoryShrinkRequest() = default;
};
class UpdateStoryResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateStoryResponseBody() {}

  explicit UpdateStoryResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateStoryResponseBody() = default;
};
class UpdateStoryResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateStoryResponseBody> body{};

  UpdateStoryResponse() {}

  explicit UpdateStoryResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateStoryResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateStoryResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateStoryResponse() = default;
};
class UpdateTriggerRequestActions : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<vector<string>> parameters{};

  UpdateTriggerRequestActions() {}

  explicit UpdateTriggerRequestActions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["Name"] = boost::any(*name);
    }
    if (parameters) {
      res["Parameters"] = boost::any(*parameters);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Name") != m.end() && !m["Name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["Name"]));
    }
    if (m.find("Parameters") != m.end() && !m["Parameters"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Parameters"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Parameters"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      parameters = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateTriggerRequestActions() = default;
};
class UpdateTriggerRequest : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateTriggerRequestActions>> actions{};
  shared_ptr<string> id{};
  shared_ptr<Input> input{};
  shared_ptr<string> projectName{};
  shared_ptr<map<string, boost::any>> tags{};

  UpdateTriggerRequest() {}

  explicit UpdateTriggerRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actions) {
      vector<boost::any> temp1;
      for(auto item1:*actions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Actions"] = boost::any(temp1);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (input) {
      res["Input"] = input ? boost::any(input->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Actions") != m.end() && !m["Actions"].empty()) {
      if (typeid(vector<boost::any>) == m["Actions"].type()) {
        vector<UpdateTriggerRequestActions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Actions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateTriggerRequestActions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        actions = make_shared<vector<UpdateTriggerRequestActions>>(expect1);
      }
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      if (typeid(map<string, boost::any>) == m["Input"].type()) {
        Input model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Input"]));
        input = make_shared<Input>(model1);
      }
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Tags"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~UpdateTriggerRequest() = default;
};
class UpdateTriggerShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> actionsShrink{};
  shared_ptr<string> id{};
  shared_ptr<string> inputShrink{};
  shared_ptr<string> projectName{};
  shared_ptr<string> tagsShrink{};

  UpdateTriggerShrinkRequest() {}

  explicit UpdateTriggerShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionsShrink) {
      res["Actions"] = boost::any(*actionsShrink);
    }
    if (id) {
      res["Id"] = boost::any(*id);
    }
    if (inputShrink) {
      res["Input"] = boost::any(*inputShrink);
    }
    if (projectName) {
      res["ProjectName"] = boost::any(*projectName);
    }
    if (tagsShrink) {
      res["Tags"] = boost::any(*tagsShrink);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Actions") != m.end() && !m["Actions"].empty()) {
      actionsShrink = make_shared<string>(boost::any_cast<string>(m["Actions"]));
    }
    if (m.find("Id") != m.end() && !m["Id"].empty()) {
      id = make_shared<string>(boost::any_cast<string>(m["Id"]));
    }
    if (m.find("Input") != m.end() && !m["Input"].empty()) {
      inputShrink = make_shared<string>(boost::any_cast<string>(m["Input"]));
    }
    if (m.find("ProjectName") != m.end() && !m["ProjectName"].empty()) {
      projectName = make_shared<string>(boost::any_cast<string>(m["ProjectName"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tagsShrink = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~UpdateTriggerShrinkRequest() = default;
};
class UpdateTriggerResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateTriggerResponseBody() {}

  explicit UpdateTriggerResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateTriggerResponseBody() = default;
};
class UpdateTriggerResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTriggerResponseBody> body{};

  UpdateTriggerResponse() {}

  explicit UpdateTriggerResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTriggerResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTriggerResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTriggerResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  AddImageMosaicResponse addImageMosaicWithOptions(shared_ptr<AddImageMosaicRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddImageMosaicResponse addImageMosaic(shared_ptr<AddImageMosaicRequest> request);
  AddStoryFilesResponse addStoryFilesWithOptions(shared_ptr<AddStoryFilesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddStoryFilesResponse addStoryFiles(shared_ptr<AddStoryFilesRequest> request);
  AttachOSSBucketResponse attachOSSBucketWithOptions(shared_ptr<AttachOSSBucketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AttachOSSBucketResponse attachOSSBucket(shared_ptr<AttachOSSBucketRequest> request);
  BatchDeleteFileMetaResponse batchDeleteFileMetaWithOptions(shared_ptr<BatchDeleteFileMetaRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchDeleteFileMetaResponse batchDeleteFileMeta(shared_ptr<BatchDeleteFileMetaRequest> request);
  BatchGetFigureClusterResponse batchGetFigureClusterWithOptions(shared_ptr<BatchGetFigureClusterRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetFigureClusterResponse batchGetFigureCluster(shared_ptr<BatchGetFigureClusterRequest> request);
  BatchGetFileMetaResponse batchGetFileMetaWithOptions(shared_ptr<BatchGetFileMetaRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchGetFileMetaResponse batchGetFileMeta(shared_ptr<BatchGetFileMetaRequest> request);
  BatchIndexFileMetaResponse batchIndexFileMetaWithOptions(shared_ptr<BatchIndexFileMetaRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchIndexFileMetaResponse batchIndexFileMeta(shared_ptr<BatchIndexFileMetaRequest> request);
  BatchUpdateFileMetaResponse batchUpdateFileMetaWithOptions(shared_ptr<BatchUpdateFileMetaRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  BatchUpdateFileMetaResponse batchUpdateFileMeta(shared_ptr<BatchUpdateFileMetaRequest> request);
  CompareImageFacesResponse compareImageFacesWithOptions(shared_ptr<CompareImageFacesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CompareImageFacesResponse compareImageFaces(shared_ptr<CompareImageFacesRequest> request);
  ContextualAnswerResponse contextualAnswerWithOptions(shared_ptr<ContextualAnswerRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ContextualAnswerResponse contextualAnswer(shared_ptr<ContextualAnswerRequest> request);
  ContextualRetrievalResponse contextualRetrievalWithOptions(shared_ptr<ContextualRetrievalRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ContextualRetrievalResponse contextualRetrieval(shared_ptr<ContextualRetrievalRequest> request);
  CreateArchiveFileInspectionTaskResponse createArchiveFileInspectionTaskWithOptions(shared_ptr<CreateArchiveFileInspectionTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateArchiveFileInspectionTaskResponse createArchiveFileInspectionTask(shared_ptr<CreateArchiveFileInspectionTaskRequest> request);
  CreateBatchResponse createBatchWithOptions(shared_ptr<CreateBatchRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBatchResponse createBatch(shared_ptr<CreateBatchRequest> request);
  CreateBindingResponse createBindingWithOptions(shared_ptr<CreateBindingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateBindingResponse createBinding(shared_ptr<CreateBindingRequest> request);
  CreateCompressPointCloudTaskResponse createCompressPointCloudTaskWithOptions(shared_ptr<CreateCompressPointCloudTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCompressPointCloudTaskResponse createCompressPointCloudTask(shared_ptr<CreateCompressPointCloudTaskRequest> request);
  CreateCustomizedStoryResponse createCustomizedStoryWithOptions(shared_ptr<CreateCustomizedStoryRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCustomizedStoryResponse createCustomizedStory(shared_ptr<CreateCustomizedStoryRequest> request);
  CreateDatasetResponse createDatasetWithOptions(shared_ptr<CreateDatasetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDatasetResponse createDataset(shared_ptr<CreateDatasetRequest> request);
  CreateDecodeBlindWatermarkTaskResponse createDecodeBlindWatermarkTaskWithOptions(shared_ptr<CreateDecodeBlindWatermarkTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDecodeBlindWatermarkTaskResponse createDecodeBlindWatermarkTask(shared_ptr<CreateDecodeBlindWatermarkTaskRequest> request);
  CreateFacesSearchingTaskResponse createFacesSearchingTaskWithOptions(shared_ptr<CreateFacesSearchingTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFacesSearchingTaskResponse createFacesSearchingTask(shared_ptr<CreateFacesSearchingTaskRequest> request);
  CreateFigureClusteringTaskResponse createFigureClusteringTaskWithOptions(shared_ptr<CreateFigureClusteringTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFigureClusteringTaskResponse createFigureClusteringTask(shared_ptr<CreateFigureClusteringTaskRequest> request);
  CreateFigureClustersMergingTaskResponse createFigureClustersMergingTaskWithOptions(shared_ptr<CreateFigureClustersMergingTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFigureClustersMergingTaskResponse createFigureClustersMergingTask(shared_ptr<CreateFigureClustersMergingTaskRequest> request);
  CreateFileCompressionTaskResponse createFileCompressionTaskWithOptions(shared_ptr<CreateFileCompressionTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFileCompressionTaskResponse createFileCompressionTask(shared_ptr<CreateFileCompressionTaskRequest> request);
  CreateFileUncompressionTaskResponse createFileUncompressionTaskWithOptions(shared_ptr<CreateFileUncompressionTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateFileUncompressionTaskResponse createFileUncompressionTask(shared_ptr<CreateFileUncompressionTaskRequest> request);
  CreateImageModerationTaskResponse createImageModerationTaskWithOptions(shared_ptr<CreateImageModerationTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateImageModerationTaskResponse createImageModerationTask(shared_ptr<CreateImageModerationTaskRequest> request);
  CreateImageSplicingTaskResponse createImageSplicingTaskWithOptions(shared_ptr<CreateImageSplicingTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateImageSplicingTaskResponse createImageSplicingTask(shared_ptr<CreateImageSplicingTaskRequest> request);
  CreateImageToPDFTaskResponse createImageToPDFTaskWithOptions(shared_ptr<CreateImageToPDFTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateImageToPDFTaskResponse createImageToPDFTask(shared_ptr<CreateImageToPDFTaskRequest> request);
  CreateLocationDateClusteringTaskResponse createLocationDateClusteringTaskWithOptions(shared_ptr<CreateLocationDateClusteringTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLocationDateClusteringTaskResponse createLocationDateClusteringTask(shared_ptr<CreateLocationDateClusteringTaskRequest> request);
  CreateMediaConvertTaskResponse createMediaConvertTaskWithOptions(shared_ptr<CreateMediaConvertTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateMediaConvertTaskResponse createMediaConvertTask(shared_ptr<CreateMediaConvertTaskRequest> request);
  CreateOfficeConversionTaskResponse createOfficeConversionTaskWithOptions(shared_ptr<CreateOfficeConversionTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateOfficeConversionTaskResponse createOfficeConversionTask(shared_ptr<CreateOfficeConversionTaskRequest> request);
  CreateProjectResponse createProjectWithOptions(shared_ptr<CreateProjectRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateProjectResponse createProject(shared_ptr<CreateProjectRequest> request);
  CreateSimilarImageClusteringTaskResponse createSimilarImageClusteringTaskWithOptions(shared_ptr<CreateSimilarImageClusteringTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSimilarImageClusteringTaskResponse createSimilarImageClusteringTask(shared_ptr<CreateSimilarImageClusteringTaskRequest> request);
  CreateStoryResponse createStoryWithOptions(shared_ptr<CreateStoryRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateStoryResponse createStory(shared_ptr<CreateStoryRequest> request);
  CreateTriggerResponse createTriggerWithOptions(shared_ptr<CreateTriggerRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateTriggerResponse createTrigger(shared_ptr<CreateTriggerRequest> request);
  CreateVideoLabelClassificationTaskResponse createVideoLabelClassificationTaskWithOptions(shared_ptr<CreateVideoLabelClassificationTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVideoLabelClassificationTaskResponse createVideoLabelClassificationTask(shared_ptr<CreateVideoLabelClassificationTaskRequest> request);
  CreateVideoModerationTaskResponse createVideoModerationTaskWithOptions(shared_ptr<CreateVideoModerationTaskRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVideoModerationTaskResponse createVideoModerationTask(shared_ptr<CreateVideoModerationTaskRequest> request);
  DeleteBatchResponse deleteBatchWithOptions(shared_ptr<DeleteBatchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBatchResponse deleteBatch(shared_ptr<DeleteBatchRequest> request);
  DeleteBindingResponse deleteBindingWithOptions(shared_ptr<DeleteBindingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteBindingResponse deleteBinding(shared_ptr<DeleteBindingRequest> request);
  DeleteDatasetResponse deleteDatasetWithOptions(shared_ptr<DeleteDatasetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDatasetResponse deleteDataset(shared_ptr<DeleteDatasetRequest> request);
  DeleteFileMetaResponse deleteFileMetaWithOptions(shared_ptr<DeleteFileMetaRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteFileMetaResponse deleteFileMeta(shared_ptr<DeleteFileMetaRequest> request);
  DeleteLocationDateClusterResponse deleteLocationDateClusterWithOptions(shared_ptr<DeleteLocationDateClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLocationDateClusterResponse deleteLocationDateCluster(shared_ptr<DeleteLocationDateClusterRequest> request);
  DeleteProjectResponse deleteProjectWithOptions(shared_ptr<DeleteProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteProjectResponse deleteProject(shared_ptr<DeleteProjectRequest> request);
  DeleteStoryResponse deleteStoryWithOptions(shared_ptr<DeleteStoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteStoryResponse deleteStory(shared_ptr<DeleteStoryRequest> request);
  DeleteTriggerResponse deleteTriggerWithOptions(shared_ptr<DeleteTriggerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteTriggerResponse deleteTrigger(shared_ptr<DeleteTriggerRequest> request);
  DetachOSSBucketResponse detachOSSBucketWithOptions(shared_ptr<DetachOSSBucketRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetachOSSBucketResponse detachOSSBucket(shared_ptr<DetachOSSBucketRequest> request);
  DetectImageBodiesResponse detectImageBodiesWithOptions(shared_ptr<DetectImageBodiesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetectImageBodiesResponse detectImageBodies(shared_ptr<DetectImageBodiesRequest> request);
  DetectImageCarsResponse detectImageCarsWithOptions(shared_ptr<DetectImageCarsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetectImageCarsResponse detectImageCars(shared_ptr<DetectImageCarsRequest> request);
  DetectImageCodesResponse detectImageCodesWithOptions(shared_ptr<DetectImageCodesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetectImageCodesResponse detectImageCodes(shared_ptr<DetectImageCodesRequest> request);
  DetectImageCroppingResponse detectImageCroppingWithOptions(shared_ptr<DetectImageCroppingRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetectImageCroppingResponse detectImageCropping(shared_ptr<DetectImageCroppingRequest> request);
  DetectImageFacesResponse detectImageFacesWithOptions(shared_ptr<DetectImageFacesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetectImageFacesResponse detectImageFaces(shared_ptr<DetectImageFacesRequest> request);
  DetectImageLabelsResponse detectImageLabelsWithOptions(shared_ptr<DetectImageLabelsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetectImageLabelsResponse detectImageLabels(shared_ptr<DetectImageLabelsRequest> request);
  DetectImageScoreResponse detectImageScoreWithOptions(shared_ptr<DetectImageScoreRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetectImageScoreResponse detectImageScore(shared_ptr<DetectImageScoreRequest> request);
  DetectImageTextsResponse detectImageTextsWithOptions(shared_ptr<DetectImageTextsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetectImageTextsResponse detectImageTexts(shared_ptr<DetectImageTextsRequest> request);
  DetectMediaMetaResponse detectMediaMetaWithOptions(shared_ptr<DetectMediaMetaRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetectMediaMetaResponse detectMediaMeta(shared_ptr<DetectMediaMetaRequest> request);
  DetectTextAnomalyResponse detectTextAnomalyWithOptions(shared_ptr<DetectTextAnomalyRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DetectTextAnomalyResponse detectTextAnomaly(shared_ptr<DetectTextAnomalyRequest> request);
  EncodeBlindWatermarkResponse encodeBlindWatermarkWithOptions(shared_ptr<EncodeBlindWatermarkRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EncodeBlindWatermarkResponse encodeBlindWatermark(shared_ptr<EncodeBlindWatermarkRequest> request);
  ExtractDocumentTextResponse extractDocumentTextWithOptions(shared_ptr<ExtractDocumentTextRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ExtractDocumentTextResponse extractDocumentText(shared_ptr<ExtractDocumentTextRequest> request);
  FuzzyQueryResponse fuzzyQueryWithOptions(shared_ptr<FuzzyQueryRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  FuzzyQueryResponse fuzzyQuery(shared_ptr<FuzzyQueryRequest> request);
  GenerateVideoPlaylistResponse generateVideoPlaylistWithOptions(shared_ptr<GenerateVideoPlaylistRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateVideoPlaylistResponse generateVideoPlaylist(shared_ptr<GenerateVideoPlaylistRequest> request);
  GenerateWebofficeTokenResponse generateWebofficeTokenWithOptions(shared_ptr<GenerateWebofficeTokenRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GenerateWebofficeTokenResponse generateWebofficeToken(shared_ptr<GenerateWebofficeTokenRequest> request);
  GetBatchResponse getBatchWithOptions(shared_ptr<GetBatchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBatchResponse getBatch(shared_ptr<GetBatchRequest> request);
  GetBindingResponse getBindingWithOptions(shared_ptr<GetBindingRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetBindingResponse getBinding(shared_ptr<GetBindingRequest> request);
  GetDRMLicenseResponse getDRMLicenseWithOptions(shared_ptr<GetDRMLicenseRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDRMLicenseResponse getDRMLicense(shared_ptr<GetDRMLicenseRequest> request);
  GetDatasetResponse getDatasetWithOptions(shared_ptr<GetDatasetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDatasetResponse getDataset(shared_ptr<GetDatasetRequest> request);
  GetDecodeBlindWatermarkResultResponse getDecodeBlindWatermarkResultWithOptions(shared_ptr<GetDecodeBlindWatermarkResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetDecodeBlindWatermarkResultResponse getDecodeBlindWatermarkResult(shared_ptr<GetDecodeBlindWatermarkResultRequest> request);
  GetFigureClusterResponse getFigureClusterWithOptions(shared_ptr<GetFigureClusterRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFigureClusterResponse getFigureCluster(shared_ptr<GetFigureClusterRequest> request);
  GetFileMetaResponse getFileMetaWithOptions(shared_ptr<GetFileMetaRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetFileMetaResponse getFileMeta(shared_ptr<GetFileMetaRequest> request);
  GetImageModerationResultResponse getImageModerationResultWithOptions(shared_ptr<GetImageModerationResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetImageModerationResultResponse getImageModerationResult(shared_ptr<GetImageModerationResultRequest> request);
  GetOSSBucketAttachmentResponse getOSSBucketAttachmentWithOptions(shared_ptr<GetOSSBucketAttachmentRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOSSBucketAttachmentResponse getOSSBucketAttachment(shared_ptr<GetOSSBucketAttachmentRequest> request);
  GetProjectResponse getProjectWithOptions(shared_ptr<GetProjectRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetProjectResponse getProject(shared_ptr<GetProjectRequest> request);
  GetStoryResponse getStoryWithOptions(shared_ptr<GetStoryRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetStoryResponse getStory(shared_ptr<GetStoryRequest> request);
  GetTaskResponse getTaskWithOptions(shared_ptr<GetTaskRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTaskResponse getTask(shared_ptr<GetTaskRequest> request);
  GetTriggerResponse getTriggerWithOptions(shared_ptr<GetTriggerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTriggerResponse getTrigger(shared_ptr<GetTriggerRequest> request);
  GetVideoLabelClassificationResultResponse getVideoLabelClassificationResultWithOptions(shared_ptr<GetVideoLabelClassificationResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVideoLabelClassificationResultResponse getVideoLabelClassificationResult(shared_ptr<GetVideoLabelClassificationResultRequest> request);
  GetVideoModerationResultResponse getVideoModerationResultWithOptions(shared_ptr<GetVideoModerationResultRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetVideoModerationResultResponse getVideoModerationResult(shared_ptr<GetVideoModerationResultRequest> request);
  IndexFileMetaResponse indexFileMetaWithOptions(shared_ptr<IndexFileMetaRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  IndexFileMetaResponse indexFileMeta(shared_ptr<IndexFileMetaRequest> request);
  ListBatchesResponse listBatchesWithOptions(shared_ptr<ListBatchesRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBatchesResponse listBatches(shared_ptr<ListBatchesRequest> request);
  ListBindingsResponse listBindingsWithOptions(shared_ptr<ListBindingsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListBindingsResponse listBindings(shared_ptr<ListBindingsRequest> request);
  ListDatasetsResponse listDatasetsWithOptions(shared_ptr<ListDatasetsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDatasetsResponse listDatasets(shared_ptr<ListDatasetsRequest> request);
  ListProjectsResponse listProjectsWithOptions(shared_ptr<ListProjectsRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListProjectsResponse listProjects(shared_ptr<ListProjectsRequest> request);
  ListRegionsResponse listRegionsWithOptions(shared_ptr<ListRegionsRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListRegionsResponse listRegions(shared_ptr<ListRegionsRequest> request);
  ListTasksResponse listTasksWithOptions(shared_ptr<ListTasksRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTasksResponse listTasks(shared_ptr<ListTasksRequest> request);
  ListTriggersResponse listTriggersWithOptions(shared_ptr<ListTriggersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTriggersResponse listTriggers(shared_ptr<ListTriggersRequest> request);
  QueryFigureClustersResponse queryFigureClustersWithOptions(shared_ptr<QueryFigureClustersRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryFigureClustersResponse queryFigureClusters(shared_ptr<QueryFigureClustersRequest> request);
  QueryLocationDateClustersResponse queryLocationDateClustersWithOptions(shared_ptr<QueryLocationDateClustersRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryLocationDateClustersResponse queryLocationDateClusters(shared_ptr<QueryLocationDateClustersRequest> request);
  QuerySimilarImageClustersResponse querySimilarImageClustersWithOptions(shared_ptr<QuerySimilarImageClustersRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QuerySimilarImageClustersResponse querySimilarImageClusters(shared_ptr<QuerySimilarImageClustersRequest> request);
  QueryStoriesResponse queryStoriesWithOptions(shared_ptr<QueryStoriesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  QueryStoriesResponse queryStories(shared_ptr<QueryStoriesRequest> request);
  RefreshWebofficeTokenResponse refreshWebofficeTokenWithOptions(shared_ptr<RefreshWebofficeTokenRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RefreshWebofficeTokenResponse refreshWebofficeToken(shared_ptr<RefreshWebofficeTokenRequest> request);
  RemoveStoryFilesResponse removeStoryFilesWithOptions(shared_ptr<RemoveStoryFilesRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveStoryFilesResponse removeStoryFiles(shared_ptr<RemoveStoryFilesRequest> request);
  ResumeBatchResponse resumeBatchWithOptions(shared_ptr<ResumeBatchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResumeBatchResponse resumeBatch(shared_ptr<ResumeBatchRequest> request);
  ResumeTriggerResponse resumeTriggerWithOptions(shared_ptr<ResumeTriggerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResumeTriggerResponse resumeTrigger(shared_ptr<ResumeTriggerRequest> request);
  SearchImageFigureClusterResponse searchImageFigureClusterWithOptions(shared_ptr<SearchImageFigureClusterRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SearchImageFigureClusterResponse searchImageFigureCluster(shared_ptr<SearchImageFigureClusterRequest> request);
  SemanticQueryResponse semanticQueryWithOptions(shared_ptr<SemanticQueryRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SemanticQueryResponse semanticQuery(shared_ptr<SemanticQueryRequest> request);
  SimpleQueryResponse simpleQueryWithOptions(shared_ptr<SimpleQueryRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SimpleQueryResponse simpleQuery(shared_ptr<SimpleQueryRequest> request);
  SuspendBatchResponse suspendBatchWithOptions(shared_ptr<SuspendBatchRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SuspendBatchResponse suspendBatch(shared_ptr<SuspendBatchRequest> request);
  SuspendTriggerResponse suspendTriggerWithOptions(shared_ptr<SuspendTriggerRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  SuspendTriggerResponse suspendTrigger(shared_ptr<SuspendTriggerRequest> request);
  UpdateBatchResponse updateBatchWithOptions(shared_ptr<UpdateBatchRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateBatchResponse updateBatch(shared_ptr<UpdateBatchRequest> request);
  UpdateDatasetResponse updateDatasetWithOptions(shared_ptr<UpdateDatasetRequest> request, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDatasetResponse updateDataset(shared_ptr<UpdateDatasetRequest> request);
  UpdateFigureClusterResponse updateFigureClusterWithOptions(shared_ptr<UpdateFigureClusterRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateFigureClusterResponse updateFigureCluster(shared_ptr<UpdateFigureClusterRequest> request);
  UpdateFileMetaResponse updateFileMetaWithOptions(shared_ptr<UpdateFileMetaRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateFileMetaResponse updateFileMeta(shared_ptr<UpdateFileMetaRequest> request);
  UpdateLocationDateClusterResponse updateLocationDateClusterWithOptions(shared_ptr<UpdateLocationDateClusterRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLocationDateClusterResponse updateLocationDateCluster(shared_ptr<UpdateLocationDateClusterRequest> request);
  UpdateProjectResponse updateProjectWithOptions(shared_ptr<UpdateProjectRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateProjectResponse updateProject(shared_ptr<UpdateProjectRequest> request);
  UpdateStoryResponse updateStoryWithOptions(shared_ptr<UpdateStoryRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateStoryResponse updateStory(shared_ptr<UpdateStoryRequest> request);
  UpdateTriggerResponse updateTriggerWithOptions(shared_ptr<UpdateTriggerRequest> tmpReq, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTriggerResponse updateTrigger(shared_ptr<UpdateTriggerRequest> request);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Imm20200930

#endif
