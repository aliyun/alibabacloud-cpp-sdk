// This file is auto-generated, don't edit it. Thanks.

#ifndef ALIBABACLOUD_ELASTICSEARCH20170613_H_
#define ALIBABACLOUD_ELASTICSEARCH20170613_H_

#include <alibabacloud/open_api.hpp>
#include <boost/any.hpp>
#include <boost/throw_exception.hpp>
#include <darabonba/core.hpp>
#include <darabonba/util.hpp>
#include <iostream>
#include <map>
#include <vector>

using namespace std;

namespace Alibabacloud_Elasticsearch20170613 {
class ClientNodeConfiguration : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<long> disk{};
  shared_ptr<string> diskType{};
  shared_ptr<string> spec{};

  ClientNodeConfiguration() {}

  explicit ClientNodeConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["amount"]));
    }
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~ClientNodeConfiguration() = default;
};
class DictInfo : public Darabonba::Model {
public:
  shared_ptr<long> fileSize{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> type{};

  DictInfo() {}

  explicit DictInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileSize) {
      res["fileSize"] = boost::any(*fileSize);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fileSize") != m.end() && !m["fileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["fileSize"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DictInfo() = default;
};
class ElasticDataNodeConfiguration : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<long> disk{};
  shared_ptr<bool> diskEncryption{};
  shared_ptr<string> diskType{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<string> spec{};

  ElasticDataNodeConfiguration() {}

  explicit ElasticDataNodeConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskEncryption) {
      res["diskEncryption"] = boost::any(*diskEncryption);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (performanceLevel) {
      res["performanceLevel"] = boost::any(*performanceLevel);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["amount"]));
    }
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskEncryption") != m.end() && !m["diskEncryption"].empty()) {
      diskEncryption = make_shared<bool>(boost::any_cast<bool>(m["diskEncryption"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("performanceLevel") != m.end() && !m["performanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["performanceLevel"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~ElasticDataNodeConfiguration() = default;
};
class ElasticsearchAdvancedSetting : public Darabonba::Model {
public:
  shared_ptr<string> gcName{};

  ElasticsearchAdvancedSetting() {}

  explicit ElasticsearchAdvancedSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gcName) {
      res["gcName"] = boost::any(*gcName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gcName") != m.end() && !m["gcName"].empty()) {
      gcName = make_shared<string>(boost::any_cast<string>(m["gcName"]));
    }
  }


  virtual ~ElasticsearchAdvancedSetting() = default;
};
class KibanaNodeConfiguration : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<long> disk{};
  shared_ptr<string> spec{};

  KibanaNodeConfiguration() {}

  explicit KibanaNodeConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["amount"]));
    }
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~KibanaNodeConfiguration() = default;
};
class MasterNodeConfiguration : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<long> disk{};
  shared_ptr<string> diskType{};
  shared_ptr<string> spec{};

  MasterNodeConfiguration() {}

  explicit MasterNodeConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["amount"]));
    }
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~MasterNodeConfiguration() = default;
};
class WhiteIpGroup : public Darabonba::Model {
public:
  shared_ptr<string> whiteIpType{};
  shared_ptr<string> groupName{};
  shared_ptr<vector<string>> ips{};

  WhiteIpGroup() {}

  explicit WhiteIpGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (whiteIpType) {
      res["WhiteIpType"] = boost::any(*whiteIpType);
    }
    if (groupName) {
      res["groupName"] = boost::any(*groupName);
    }
    if (ips) {
      res["ips"] = boost::any(*ips);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("WhiteIpType") != m.end() && !m["WhiteIpType"].empty()) {
      whiteIpType = make_shared<string>(boost::any_cast<string>(m["WhiteIpType"]));
    }
    if (m.find("groupName") != m.end() && !m["groupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["groupName"]));
    }
    if (m.find("ips") != m.end() && !m["ips"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ips"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ips"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ips = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~WhiteIpGroup() = default;
};
class NetworkConfig : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vsArea{};
  shared_ptr<string> vswitchId{};
  shared_ptr<vector<WhiteIpGroup>> whiteIpGroupList{};

  NetworkConfig() {}

  explicit NetworkConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    if (vsArea) {
      res["vsArea"] = boost::any(*vsArea);
    }
    if (vswitchId) {
      res["vswitchId"] = boost::any(*vswitchId);
    }
    if (whiteIpGroupList) {
      vector<boost::any> temp1;
      for(auto item1:*whiteIpGroupList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["whiteIpGroupList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
    if (m.find("vsArea") != m.end() && !m["vsArea"].empty()) {
      vsArea = make_shared<string>(boost::any_cast<string>(m["vsArea"]));
    }
    if (m.find("vswitchId") != m.end() && !m["vswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["vswitchId"]));
    }
    if (m.find("whiteIpGroupList") != m.end() && !m["whiteIpGroupList"].empty()) {
      if (typeid(vector<boost::any>) == m["whiteIpGroupList"].type()) {
        vector<WhiteIpGroup> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["whiteIpGroupList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            WhiteIpGroup model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        whiteIpGroupList = make_shared<vector<WhiteIpGroup>>(expect1);
      }
    }
  }


  virtual ~NetworkConfig() = default;
};
class NodeSpec : public Darabonba::Model {
public:
  shared_ptr<long> disk{};
  shared_ptr<bool> diskEncryption{};
  shared_ptr<string> diskType{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<string> spec{};

  NodeSpec() {}

  explicit NodeSpec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskEncryption) {
      res["diskEncryption"] = boost::any(*diskEncryption);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (performanceLevel) {
      res["performanceLevel"] = boost::any(*performanceLevel);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskEncryption") != m.end() && !m["diskEncryption"].empty()) {
      diskEncryption = make_shared<bool>(boost::any_cast<bool>(m["diskEncryption"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("performanceLevel") != m.end() && !m["performanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["performanceLevel"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~NodeSpec() = default;
};
class ReadWritePolicy : public Darabonba::Model {
public:
  shared_ptr<bool> autoGeneratePk{};
  shared_ptr<bool> writeHa{};
  shared_ptr<string> writePolicy{};

  ReadWritePolicy() {}

  explicit ReadWritePolicy(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoGeneratePk) {
      res["autoGeneratePk"] = boost::any(*autoGeneratePk);
    }
    if (writeHa) {
      res["writeHa"] = boost::any(*writeHa);
    }
    if (writePolicy) {
      res["writePolicy"] = boost::any(*writePolicy);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("autoGeneratePk") != m.end() && !m["autoGeneratePk"].empty()) {
      autoGeneratePk = make_shared<bool>(boost::any_cast<bool>(m["autoGeneratePk"]));
    }
    if (m.find("writeHa") != m.end() && !m["writeHa"].empty()) {
      writeHa = make_shared<bool>(boost::any_cast<bool>(m["writeHa"]));
    }
    if (m.find("writePolicy") != m.end() && !m["writePolicy"].empty()) {
      writePolicy = make_shared<string>(boost::any_cast<string>(m["writePolicy"]));
    }
  }


  virtual ~ReadWritePolicy() = default;
};
class Tag : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  Tag() {}

  explicit Tag(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["tagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["tagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tagKey") != m.end() && !m["tagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["tagKey"]));
    }
    if (m.find("tagValue") != m.end() && !m["tagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["tagValue"]));
    }
  }


  virtual ~Tag() = default;
};
class WarmNodeConfiguration : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<long> disk{};
  shared_ptr<bool> diskEncryption{};
  shared_ptr<string> diskType{};
  shared_ptr<string> performanceLevel{};
  shared_ptr<string> spec{};

  WarmNodeConfiguration() {}

  explicit WarmNodeConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskEncryption) {
      res["diskEncryption"] = boost::any(*diskEncryption);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (performanceLevel) {
      res["performanceLevel"] = boost::any(*performanceLevel);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["amount"]));
    }
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskEncryption") != m.end() && !m["diskEncryption"].empty()) {
      diskEncryption = make_shared<bool>(boost::any_cast<bool>(m["diskEncryption"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("performanceLevel") != m.end() && !m["performanceLevel"].empty()) {
      performanceLevel = make_shared<string>(boost::any_cast<string>(m["performanceLevel"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~WarmNodeConfiguration() = default;
};
class ZoneInfo : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> zoneId{};

  ZoneInfo() {}

  explicit ZoneInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (zoneId) {
      res["zoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("zoneId") != m.end() && !m["zoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["zoneId"]));
    }
  }


  virtual ~ZoneInfo() = default;
};
class Elasticsearch : public Darabonba::Model {
public:
  shared_ptr<bool> advancedDedicateMaster{};
  shared_ptr<ElasticsearchAdvancedSetting> advancedSetting{};
  shared_ptr<vector<DictInfo>> aliwsDicts{};
  shared_ptr<ClientNodeConfiguration> clientNodeConfiguration{};
  shared_ptr<string> createdAt{};
  shared_ptr<bool> dataNode{};
  shared_ptr<bool> dedicateMaster{};
  shared_ptr<string> description{};
  shared_ptr<vector<DictInfo>> dictList{};
  shared_ptr<string> domain{};
  shared_ptr<ElasticDataNodeConfiguration> elasticDataNodeConfiguration{};
  shared_ptr<bool> enableKibanaPrivateNetwork{};
  shared_ptr<bool> enableKibanaPublicNetwork{};
  shared_ptr<bool> enablePublic{};
  shared_ptr<long> endTime{};
  shared_ptr<map<string, string>> esConfig{};
  shared_ptr<vector<string>> esIPWhitelist{};
  shared_ptr<string> esVersion{};
  shared_ptr<vector<map<string, boost::any>>> extendConfigs{};
  shared_ptr<bool> haveClientNode{};
  shared_ptr<bool> haveElasticDataNode{};
  shared_ptr<bool> haveKibana{};
  shared_ptr<vector<DictInfo>> ikHotDicts{};
  shared_ptr<string> instanceId{};
  shared_ptr<KibanaNodeConfiguration> kibanaConfiguration{};
  shared_ptr<string> kibanaDomain{};
  shared_ptr<vector<string>> kibanaIPWhitelist{};
  shared_ptr<long> kibanaPort{};
  shared_ptr<string> kibanaPrivateDomain{};
  shared_ptr<vector<string>> kibanaPrivateIPWhitelist{};
  shared_ptr<long> kibanaPrivatePort{};
  shared_ptr<string> kibanaProtocol{};
  shared_ptr<MasterNodeConfiguration> masterConfiguration{};
  shared_ptr<NetworkConfig> networkConfig{};
  shared_ptr<long> nodeAmount{};
  shared_ptr<NodeSpec> nodeSpec{};
  shared_ptr<string> paymentType{};
  shared_ptr<long> port{};
  shared_ptr<vector<string>> privateNetworkIpWhiteList{};
  shared_ptr<string> productType{};
  shared_ptr<string> protocol{};
  shared_ptr<string> publicDomain{};
  shared_ptr<vector<string>> publicIpWhitelist{};
  shared_ptr<long> publicPort{};
  shared_ptr<ReadWritePolicy> readWritePolicy{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> serviceVpc{};
  shared_ptr<string> status{};
  shared_ptr<vector<DictInfo>> synonymsDicts{};
  shared_ptr<vector<Tag>> tags{};
  shared_ptr<string> updatedAt{};
  shared_ptr<bool> warmNode{};
  shared_ptr<WarmNodeConfiguration> warmNodeConfiguration{};
  shared_ptr<long> zoneCount{};
  shared_ptr<vector<ZoneInfo>> zoneInfos{};

  Elasticsearch() {}

  explicit Elasticsearch(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advancedDedicateMaster) {
      res["advancedDedicateMaster"] = boost::any(*advancedDedicateMaster);
    }
    if (advancedSetting) {
      res["advancedSetting"] = advancedSetting ? boost::any(advancedSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (aliwsDicts) {
      vector<boost::any> temp1;
      for(auto item1:*aliwsDicts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["aliwsDicts"] = boost::any(temp1);
    }
    if (clientNodeConfiguration) {
      res["clientNodeConfiguration"] = clientNodeConfiguration ? boost::any(clientNodeConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (dataNode) {
      res["dataNode"] = boost::any(*dataNode);
    }
    if (dedicateMaster) {
      res["dedicateMaster"] = boost::any(*dedicateMaster);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (dictList) {
      vector<boost::any> temp1;
      for(auto item1:*dictList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["dictList"] = boost::any(temp1);
    }
    if (domain) {
      res["domain"] = boost::any(*domain);
    }
    if (elasticDataNodeConfiguration) {
      res["elasticDataNodeConfiguration"] = elasticDataNodeConfiguration ? boost::any(elasticDataNodeConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (enableKibanaPrivateNetwork) {
      res["enableKibanaPrivateNetwork"] = boost::any(*enableKibanaPrivateNetwork);
    }
    if (enableKibanaPublicNetwork) {
      res["enableKibanaPublicNetwork"] = boost::any(*enableKibanaPublicNetwork);
    }
    if (enablePublic) {
      res["enablePublic"] = boost::any(*enablePublic);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (esConfig) {
      res["esConfig"] = boost::any(*esConfig);
    }
    if (esIPWhitelist) {
      res["esIPWhitelist"] = boost::any(*esIPWhitelist);
    }
    if (esVersion) {
      res["esVersion"] = boost::any(*esVersion);
    }
    if (extendConfigs) {
      res["extendConfigs"] = boost::any(*extendConfigs);
    }
    if (haveClientNode) {
      res["haveClientNode"] = boost::any(*haveClientNode);
    }
    if (haveElasticDataNode) {
      res["haveElasticDataNode"] = boost::any(*haveElasticDataNode);
    }
    if (haveKibana) {
      res["haveKibana"] = boost::any(*haveKibana);
    }
    if (ikHotDicts) {
      vector<boost::any> temp1;
      for(auto item1:*ikHotDicts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ikHotDicts"] = boost::any(temp1);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (kibanaConfiguration) {
      res["kibanaConfiguration"] = kibanaConfiguration ? boost::any(kibanaConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (kibanaDomain) {
      res["kibanaDomain"] = boost::any(*kibanaDomain);
    }
    if (kibanaIPWhitelist) {
      res["kibanaIPWhitelist"] = boost::any(*kibanaIPWhitelist);
    }
    if (kibanaPort) {
      res["kibanaPort"] = boost::any(*kibanaPort);
    }
    if (kibanaPrivateDomain) {
      res["kibanaPrivateDomain"] = boost::any(*kibanaPrivateDomain);
    }
    if (kibanaPrivateIPWhitelist) {
      res["kibanaPrivateIPWhitelist"] = boost::any(*kibanaPrivateIPWhitelist);
    }
    if (kibanaPrivatePort) {
      res["kibanaPrivatePort"] = boost::any(*kibanaPrivatePort);
    }
    if (kibanaProtocol) {
      res["kibanaProtocol"] = boost::any(*kibanaProtocol);
    }
    if (masterConfiguration) {
      res["masterConfiguration"] = masterConfiguration ? boost::any(masterConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (networkConfig) {
      res["networkConfig"] = networkConfig ? boost::any(networkConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodeAmount) {
      res["nodeAmount"] = boost::any(*nodeAmount);
    }
    if (nodeSpec) {
      res["nodeSpec"] = nodeSpec ? boost::any(nodeSpec->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (paymentType) {
      res["paymentType"] = boost::any(*paymentType);
    }
    if (port) {
      res["port"] = boost::any(*port);
    }
    if (privateNetworkIpWhiteList) {
      res["privateNetworkIpWhiteList"] = boost::any(*privateNetworkIpWhiteList);
    }
    if (productType) {
      res["productType"] = boost::any(*productType);
    }
    if (protocol) {
      res["protocol"] = boost::any(*protocol);
    }
    if (publicDomain) {
      res["publicDomain"] = boost::any(*publicDomain);
    }
    if (publicIpWhitelist) {
      res["publicIpWhitelist"] = boost::any(*publicIpWhitelist);
    }
    if (publicPort) {
      res["publicPort"] = boost::any(*publicPort);
    }
    if (readWritePolicy) {
      res["readWritePolicy"] = readWritePolicy ? boost::any(readWritePolicy->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (resourceGroupId) {
      res["resourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (serviceVpc) {
      res["serviceVpc"] = boost::any(*serviceVpc);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (synonymsDicts) {
      vector<boost::any> temp1;
      for(auto item1:*synonymsDicts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["synonymsDicts"] = boost::any(temp1);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tags"] = boost::any(temp1);
    }
    if (updatedAt) {
      res["updatedAt"] = boost::any(*updatedAt);
    }
    if (warmNode) {
      res["warmNode"] = boost::any(*warmNode);
    }
    if (warmNodeConfiguration) {
      res["warmNodeConfiguration"] = warmNodeConfiguration ? boost::any(warmNodeConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (zoneCount) {
      res["zoneCount"] = boost::any(*zoneCount);
    }
    if (zoneInfos) {
      vector<boost::any> temp1;
      for(auto item1:*zoneInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["zoneInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("advancedDedicateMaster") != m.end() && !m["advancedDedicateMaster"].empty()) {
      advancedDedicateMaster = make_shared<bool>(boost::any_cast<bool>(m["advancedDedicateMaster"]));
    }
    if (m.find("advancedSetting") != m.end() && !m["advancedSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["advancedSetting"].type()) {
        ElasticsearchAdvancedSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["advancedSetting"]));
        advancedSetting = make_shared<ElasticsearchAdvancedSetting>(model1);
      }
    }
    if (m.find("aliwsDicts") != m.end() && !m["aliwsDicts"].empty()) {
      if (typeid(vector<boost::any>) == m["aliwsDicts"].type()) {
        vector<DictInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["aliwsDicts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DictInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aliwsDicts = make_shared<vector<DictInfo>>(expect1);
      }
    }
    if (m.find("clientNodeConfiguration") != m.end() && !m["clientNodeConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["clientNodeConfiguration"].type()) {
        ClientNodeConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["clientNodeConfiguration"]));
        clientNodeConfiguration = make_shared<ClientNodeConfiguration>(model1);
      }
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("dataNode") != m.end() && !m["dataNode"].empty()) {
      dataNode = make_shared<bool>(boost::any_cast<bool>(m["dataNode"]));
    }
    if (m.find("dedicateMaster") != m.end() && !m["dedicateMaster"].empty()) {
      dedicateMaster = make_shared<bool>(boost::any_cast<bool>(m["dedicateMaster"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("dictList") != m.end() && !m["dictList"].empty()) {
      if (typeid(vector<boost::any>) == m["dictList"].type()) {
        vector<DictInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["dictList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DictInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dictList = make_shared<vector<DictInfo>>(expect1);
      }
    }
    if (m.find("domain") != m.end() && !m["domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["domain"]));
    }
    if (m.find("elasticDataNodeConfiguration") != m.end() && !m["elasticDataNodeConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["elasticDataNodeConfiguration"].type()) {
        ElasticDataNodeConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["elasticDataNodeConfiguration"]));
        elasticDataNodeConfiguration = make_shared<ElasticDataNodeConfiguration>(model1);
      }
    }
    if (m.find("enableKibanaPrivateNetwork") != m.end() && !m["enableKibanaPrivateNetwork"].empty()) {
      enableKibanaPrivateNetwork = make_shared<bool>(boost::any_cast<bool>(m["enableKibanaPrivateNetwork"]));
    }
    if (m.find("enableKibanaPublicNetwork") != m.end() && !m["enableKibanaPublicNetwork"].empty()) {
      enableKibanaPublicNetwork = make_shared<bool>(boost::any_cast<bool>(m["enableKibanaPublicNetwork"]));
    }
    if (m.find("enablePublic") != m.end() && !m["enablePublic"].empty()) {
      enablePublic = make_shared<bool>(boost::any_cast<bool>(m["enablePublic"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("esConfig") != m.end() && !m["esConfig"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["esConfig"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      esConfig = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("esIPWhitelist") != m.end() && !m["esIPWhitelist"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["esIPWhitelist"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["esIPWhitelist"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      esIPWhitelist = make_shared<vector<string>>(toVec1);
    }
    if (m.find("esVersion") != m.end() && !m["esVersion"].empty()) {
      esVersion = make_shared<string>(boost::any_cast<string>(m["esVersion"]));
    }
    if (m.find("extendConfigs") != m.end() && !m["extendConfigs"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["extendConfigs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["extendConfigs"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      extendConfigs = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("haveClientNode") != m.end() && !m["haveClientNode"].empty()) {
      haveClientNode = make_shared<bool>(boost::any_cast<bool>(m["haveClientNode"]));
    }
    if (m.find("haveElasticDataNode") != m.end() && !m["haveElasticDataNode"].empty()) {
      haveElasticDataNode = make_shared<bool>(boost::any_cast<bool>(m["haveElasticDataNode"]));
    }
    if (m.find("haveKibana") != m.end() && !m["haveKibana"].empty()) {
      haveKibana = make_shared<bool>(boost::any_cast<bool>(m["haveKibana"]));
    }
    if (m.find("ikHotDicts") != m.end() && !m["ikHotDicts"].empty()) {
      if (typeid(vector<boost::any>) == m["ikHotDicts"].type()) {
        vector<DictInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ikHotDicts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DictInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ikHotDicts = make_shared<vector<DictInfo>>(expect1);
      }
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("kibanaConfiguration") != m.end() && !m["kibanaConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["kibanaConfiguration"].type()) {
        KibanaNodeConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["kibanaConfiguration"]));
        kibanaConfiguration = make_shared<KibanaNodeConfiguration>(model1);
      }
    }
    if (m.find("kibanaDomain") != m.end() && !m["kibanaDomain"].empty()) {
      kibanaDomain = make_shared<string>(boost::any_cast<string>(m["kibanaDomain"]));
    }
    if (m.find("kibanaIPWhitelist") != m.end() && !m["kibanaIPWhitelist"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["kibanaIPWhitelist"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["kibanaIPWhitelist"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      kibanaIPWhitelist = make_shared<vector<string>>(toVec1);
    }
    if (m.find("kibanaPort") != m.end() && !m["kibanaPort"].empty()) {
      kibanaPort = make_shared<long>(boost::any_cast<long>(m["kibanaPort"]));
    }
    if (m.find("kibanaPrivateDomain") != m.end() && !m["kibanaPrivateDomain"].empty()) {
      kibanaPrivateDomain = make_shared<string>(boost::any_cast<string>(m["kibanaPrivateDomain"]));
    }
    if (m.find("kibanaPrivateIPWhitelist") != m.end() && !m["kibanaPrivateIPWhitelist"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["kibanaPrivateIPWhitelist"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["kibanaPrivateIPWhitelist"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      kibanaPrivateIPWhitelist = make_shared<vector<string>>(toVec1);
    }
    if (m.find("kibanaPrivatePort") != m.end() && !m["kibanaPrivatePort"].empty()) {
      kibanaPrivatePort = make_shared<long>(boost::any_cast<long>(m["kibanaPrivatePort"]));
    }
    if (m.find("kibanaProtocol") != m.end() && !m["kibanaProtocol"].empty()) {
      kibanaProtocol = make_shared<string>(boost::any_cast<string>(m["kibanaProtocol"]));
    }
    if (m.find("masterConfiguration") != m.end() && !m["masterConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["masterConfiguration"].type()) {
        MasterNodeConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["masterConfiguration"]));
        masterConfiguration = make_shared<MasterNodeConfiguration>(model1);
      }
    }
    if (m.find("networkConfig") != m.end() && !m["networkConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["networkConfig"].type()) {
        NetworkConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["networkConfig"]));
        networkConfig = make_shared<NetworkConfig>(model1);
      }
    }
    if (m.find("nodeAmount") != m.end() && !m["nodeAmount"].empty()) {
      nodeAmount = make_shared<long>(boost::any_cast<long>(m["nodeAmount"]));
    }
    if (m.find("nodeSpec") != m.end() && !m["nodeSpec"].empty()) {
      if (typeid(map<string, boost::any>) == m["nodeSpec"].type()) {
        NodeSpec model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["nodeSpec"]));
        nodeSpec = make_shared<NodeSpec>(model1);
      }
    }
    if (m.find("paymentType") != m.end() && !m["paymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["paymentType"]));
    }
    if (m.find("port") != m.end() && !m["port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["port"]));
    }
    if (m.find("privateNetworkIpWhiteList") != m.end() && !m["privateNetworkIpWhiteList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["privateNetworkIpWhiteList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["privateNetworkIpWhiteList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      privateNetworkIpWhiteList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("productType") != m.end() && !m["productType"].empty()) {
      productType = make_shared<string>(boost::any_cast<string>(m["productType"]));
    }
    if (m.find("protocol") != m.end() && !m["protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["protocol"]));
    }
    if (m.find("publicDomain") != m.end() && !m["publicDomain"].empty()) {
      publicDomain = make_shared<string>(boost::any_cast<string>(m["publicDomain"]));
    }
    if (m.find("publicIpWhitelist") != m.end() && !m["publicIpWhitelist"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["publicIpWhitelist"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["publicIpWhitelist"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      publicIpWhitelist = make_shared<vector<string>>(toVec1);
    }
    if (m.find("publicPort") != m.end() && !m["publicPort"].empty()) {
      publicPort = make_shared<long>(boost::any_cast<long>(m["publicPort"]));
    }
    if (m.find("readWritePolicy") != m.end() && !m["readWritePolicy"].empty()) {
      if (typeid(map<string, boost::any>) == m["readWritePolicy"].type()) {
        ReadWritePolicy model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["readWritePolicy"]));
        readWritePolicy = make_shared<ReadWritePolicy>(model1);
      }
    }
    if (m.find("resourceGroupId") != m.end() && !m["resourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["resourceGroupId"]));
    }
    if (m.find("serviceVpc") != m.end() && !m["serviceVpc"].empty()) {
      serviceVpc = make_shared<bool>(boost::any_cast<bool>(m["serviceVpc"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("synonymsDicts") != m.end() && !m["synonymsDicts"].empty()) {
      if (typeid(vector<boost::any>) == m["synonymsDicts"].type()) {
        vector<DictInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["synonymsDicts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DictInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        synonymsDicts = make_shared<vector<DictInfo>>(expect1);
      }
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<Tag> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            Tag model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<Tag>>(expect1);
      }
    }
    if (m.find("updatedAt") != m.end() && !m["updatedAt"].empty()) {
      updatedAt = make_shared<string>(boost::any_cast<string>(m["updatedAt"]));
    }
    if (m.find("warmNode") != m.end() && !m["warmNode"].empty()) {
      warmNode = make_shared<bool>(boost::any_cast<bool>(m["warmNode"]));
    }
    if (m.find("warmNodeConfiguration") != m.end() && !m["warmNodeConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["warmNodeConfiguration"].type()) {
        WarmNodeConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["warmNodeConfiguration"]));
        warmNodeConfiguration = make_shared<WarmNodeConfiguration>(model1);
      }
    }
    if (m.find("zoneCount") != m.end() && !m["zoneCount"].empty()) {
      zoneCount = make_shared<long>(boost::any_cast<long>(m["zoneCount"]));
    }
    if (m.find("zoneInfos") != m.end() && !m["zoneInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["zoneInfos"].type()) {
        vector<ZoneInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["zoneInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ZoneInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        zoneInfos = make_shared<vector<ZoneInfo>>(expect1);
      }
    }
  }


  virtual ~Elasticsearch() = default;
};
class LogstashEndpointList : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<long> port{};
  shared_ptr<string> zoneId{};

  LogstashEndpointList() {}

  explicit LogstashEndpointList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["host"] = boost::any(*host);
    }
    if (port) {
      res["port"] = boost::any(*port);
    }
    if (zoneId) {
      res["zoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("host") != m.end() && !m["host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["host"]));
    }
    if (m.find("port") != m.end() && !m["port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["port"]));
    }
    if (m.find("zoneId") != m.end() && !m["zoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["zoneId"]));
    }
  }


  virtual ~LogstashEndpointList() = default;
};
class LogstashNetworkConfig : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vsArea{};
  shared_ptr<string> vswitchId{};

  LogstashNetworkConfig() {}

  explicit LogstashNetworkConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    if (vsArea) {
      res["vsArea"] = boost::any(*vsArea);
    }
    if (vswitchId) {
      res["vswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
    if (m.find("vsArea") != m.end() && !m["vsArea"].empty()) {
      vsArea = make_shared<string>(boost::any_cast<string>(m["vsArea"]));
    }
    if (m.find("vswitchId") != m.end() && !m["vswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["vswitchId"]));
    }
  }


  virtual ~LogstashNetworkConfig() = default;
};
class LogstashNodeSpec : public Darabonba::Model {
public:
  shared_ptr<long> disk{};
  shared_ptr<string> diskType{};
  shared_ptr<string> spec{};

  LogstashNodeSpec() {}

  explicit LogstashNodeSpec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~LogstashNodeSpec() = default;
};
class LogstashTags : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  LogstashTags() {}

  explicit LogstashTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["tagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["tagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tagKey") != m.end() && !m["tagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["tagKey"]));
    }
    if (m.find("tagValue") != m.end() && !m["tagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["tagValue"]));
    }
  }


  virtual ~LogstashTags() = default;
};
class LogstashZoneInfos : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> zoneId{};

  LogstashZoneInfos() {}

  explicit LogstashZoneInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (zoneId) {
      res["zoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("zoneId") != m.end() && !m["zoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["zoneId"]));
    }
  }


  virtual ~LogstashZoneInfos() = default;
};
class Logstash : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> config{};
  shared_ptr<string> createdAt{};
  shared_ptr<bool> dataNode{};
  shared_ptr<string> description{};
  shared_ptr<long> endTime{};
  shared_ptr<vector<LogstashEndpointList>> endpointList{};
  shared_ptr<string> instanceId{};
  shared_ptr<LogstashNetworkConfig> networkConfig{};
  shared_ptr<long> nodeAmount{};
  shared_ptr<LogstashNodeSpec> nodeSpec{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> protocol{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<string> status{};
  shared_ptr<vector<LogstashTags>> tags{};
  shared_ptr<string> updatedAt{};
  shared_ptr<string> version{};
  shared_ptr<long> zoneCount{};
  shared_ptr<vector<LogstashZoneInfos>> zoneInfos{};

  Logstash() {}

  explicit Logstash(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (config) {
      res["config"] = boost::any(*config);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (dataNode) {
      res["dataNode"] = boost::any(*dataNode);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (endpointList) {
      vector<boost::any> temp1;
      for(auto item1:*endpointList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["endpointList"] = boost::any(temp1);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (networkConfig) {
      res["networkConfig"] = networkConfig ? boost::any(networkConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodeAmount) {
      res["nodeAmount"] = boost::any(*nodeAmount);
    }
    if (nodeSpec) {
      res["nodeSpec"] = nodeSpec ? boost::any(nodeSpec->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (paymentType) {
      res["paymentType"] = boost::any(*paymentType);
    }
    if (protocol) {
      res["protocol"] = boost::any(*protocol);
    }
    if (resourceGroupId) {
      res["resourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tags"] = boost::any(temp1);
    }
    if (updatedAt) {
      res["updatedAt"] = boost::any(*updatedAt);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    if (zoneCount) {
      res["zoneCount"] = boost::any(*zoneCount);
    }
    if (zoneInfos) {
      vector<boost::any> temp1;
      for(auto item1:*zoneInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["zoneInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("config") != m.end() && !m["config"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["config"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      config = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("dataNode") != m.end() && !m["dataNode"].empty()) {
      dataNode = make_shared<bool>(boost::any_cast<bool>(m["dataNode"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("endpointList") != m.end() && !m["endpointList"].empty()) {
      if (typeid(vector<boost::any>) == m["endpointList"].type()) {
        vector<LogstashEndpointList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["endpointList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            LogstashEndpointList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpointList = make_shared<vector<LogstashEndpointList>>(expect1);
      }
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("networkConfig") != m.end() && !m["networkConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["networkConfig"].type()) {
        LogstashNetworkConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["networkConfig"]));
        networkConfig = make_shared<LogstashNetworkConfig>(model1);
      }
    }
    if (m.find("nodeAmount") != m.end() && !m["nodeAmount"].empty()) {
      nodeAmount = make_shared<long>(boost::any_cast<long>(m["nodeAmount"]));
    }
    if (m.find("nodeSpec") != m.end() && !m["nodeSpec"].empty()) {
      if (typeid(map<string, boost::any>) == m["nodeSpec"].type()) {
        LogstashNodeSpec model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["nodeSpec"]));
        nodeSpec = make_shared<LogstashNodeSpec>(model1);
      }
    }
    if (m.find("paymentType") != m.end() && !m["paymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["paymentType"]));
    }
    if (m.find("protocol") != m.end() && !m["protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["protocol"]));
    }
    if (m.find("resourceGroupId") != m.end() && !m["resourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["resourceGroupId"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<LogstashTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            LogstashTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<LogstashTags>>(expect1);
      }
    }
    if (m.find("updatedAt") != m.end() && !m["updatedAt"].empty()) {
      updatedAt = make_shared<string>(boost::any_cast<string>(m["updatedAt"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
    if (m.find("zoneCount") != m.end() && !m["zoneCount"].empty()) {
      zoneCount = make_shared<long>(boost::any_cast<long>(m["zoneCount"]));
    }
    if (m.find("zoneInfos") != m.end() && !m["zoneInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["zoneInfos"].type()) {
        vector<LogstashZoneInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["zoneInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            LogstashZoneInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        zoneInfos = make_shared<vector<LogstashZoneInfos>>(expect1);
      }
    }
  }


  virtual ~Logstash() = default;
};
class NodeInfo : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<string> hostName{};
  shared_ptr<long> port{};
  shared_ptr<string> zoneId{};

  NodeInfo() {}

  explicit NodeInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["host"] = boost::any(*host);
    }
    if (hostName) {
      res["hostName"] = boost::any(*hostName);
    }
    if (port) {
      res["port"] = boost::any(*port);
    }
    if (zoneId) {
      res["zoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("host") != m.end() && !m["host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["host"]));
    }
    if (m.find("hostName") != m.end() && !m["hostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["hostName"]));
    }
    if (m.find("port") != m.end() && !m["port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["port"]));
    }
    if (m.find("zoneId") != m.end() && !m["zoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["zoneId"]));
    }
  }


  virtual ~NodeInfo() = default;
};
class PaymentInfo : public Darabonba::Model {
public:
  shared_ptr<long> autoRenewDuration{};
  shared_ptr<long> duration{};
  shared_ptr<bool> isAutoRenew{};
  shared_ptr<string> pricingCycle{};

  PaymentInfo() {}

  explicit PaymentInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenewDuration) {
      res["autoRenewDuration"] = boost::any(*autoRenewDuration);
    }
    if (duration) {
      res["duration"] = boost::any(*duration);
    }
    if (isAutoRenew) {
      res["isAutoRenew"] = boost::any(*isAutoRenew);
    }
    if (pricingCycle) {
      res["pricingCycle"] = boost::any(*pricingCycle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("autoRenewDuration") != m.end() && !m["autoRenewDuration"].empty()) {
      autoRenewDuration = make_shared<long>(boost::any_cast<long>(m["autoRenewDuration"]));
    }
    if (m.find("duration") != m.end() && !m["duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["duration"]));
    }
    if (m.find("isAutoRenew") != m.end() && !m["isAutoRenew"].empty()) {
      isAutoRenew = make_shared<bool>(boost::any_cast<bool>(m["isAutoRenew"]));
    }
    if (m.find("pricingCycle") != m.end() && !m["pricingCycle"].empty()) {
      pricingCycle = make_shared<string>(boost::any_cast<string>(m["pricingCycle"]));
    }
  }


  virtual ~PaymentInfo() = default;
};
class ActivateZonesRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};

  ActivateZonesRequest() {}

  explicit ActivateZonesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~ActivateZonesRequest() = default;
};
class ActivateZonesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  ActivateZonesResponseBody() {}

  explicit ActivateZonesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~ActivateZonesResponseBody() = default;
};
class ActivateZonesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ActivateZonesResponseBody> body{};

  ActivateZonesResponse() {}

  explicit ActivateZonesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ActivateZonesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ActivateZonesResponseBody>(model1);
      }
    }
  }


  virtual ~ActivateZonesResponse() = default;
};
class AddConnectableClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};

  AddConnectableClusterRequest() {}

  explicit AddConnectableClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~AddConnectableClusterRequest() = default;
};
class AddConnectableClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  AddConnectableClusterResponseBody() {}

  explicit AddConnectableClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~AddConnectableClusterResponseBody() = default;
};
class AddConnectableClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddConnectableClusterResponseBody> body{};

  AddConnectableClusterResponse() {}

  explicit AddConnectableClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddConnectableClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddConnectableClusterResponseBody>(model1);
      }
    }
  }


  virtual ~AddConnectableClusterResponse() = default;
};
class AddSnapshotRepoRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};

  AddSnapshotRepoRequest() {}

  explicit AddSnapshotRepoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~AddSnapshotRepoRequest() = default;
};
class AddSnapshotRepoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  AddSnapshotRepoResponseBody() {}

  explicit AddSnapshotRepoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~AddSnapshotRepoResponseBody() = default;
};
class AddSnapshotRepoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<AddSnapshotRepoResponseBody> body{};

  AddSnapshotRepoResponse() {}

  explicit AddSnapshotRepoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        AddSnapshotRepoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<AddSnapshotRepoResponseBody>(model1);
      }
    }
  }


  virtual ~AddSnapshotRepoResponse() = default;
};
class CancelDeletionRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};

  CancelDeletionRequest() {}

  explicit CancelDeletionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~CancelDeletionRequest() = default;
};
class CancelDeletionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  CancelDeletionResponseBody() {}

  explicit CancelDeletionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~CancelDeletionResponseBody() = default;
};
class CancelDeletionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelDeletionResponseBody> body{};

  CancelDeletionResponse() {}

  explicit CancelDeletionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelDeletionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelDeletionResponseBody>(model1);
      }
    }
  }


  virtual ~CancelDeletionResponse() = default;
};
class CancelLogstashDeletionRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};

  CancelLogstashDeletionRequest() {}

  explicit CancelLogstashDeletionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~CancelLogstashDeletionRequest() = default;
};
class CancelLogstashDeletionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  CancelLogstashDeletionResponseBody() {}

  explicit CancelLogstashDeletionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~CancelLogstashDeletionResponseBody() = default;
};
class CancelLogstashDeletionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelLogstashDeletionResponseBody> body{};

  CancelLogstashDeletionResponse() {}

  explicit CancelLogstashDeletionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelLogstashDeletionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelLogstashDeletionResponseBody>(model1);
      }
    }
  }


  virtual ~CancelLogstashDeletionResponse() = default;
};
class CancelTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> taskType{};

  CancelTaskRequest() {}

  explicit CancelTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (taskType) {
      res["taskType"] = boost::any(*taskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("taskType") != m.end() && !m["taskType"].empty()) {
      taskType = make_shared<string>(boost::any_cast<string>(m["taskType"]));
    }
  }


  virtual ~CancelTaskRequest() = default;
};
class CancelTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  CancelTaskResponseBody() {}

  explicit CancelTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~CancelTaskResponseBody() = default;
};
class CancelTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CancelTaskResponseBody> body{};

  CancelTaskResponse() {}

  explicit CancelTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CancelTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CancelTaskResponseBody>(model1);
      }
    }
  }


  virtual ~CancelTaskResponse() = default;
};
class CapacityPlanRequestDataInfo : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<long> size{};
  shared_ptr<long> totalCount{};
  shared_ptr<string> type{};
  shared_ptr<string> unit{};

  CapacityPlanRequestDataInfo() {}

  explicit CapacityPlanRequestDataInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    if (totalCount) {
      res["totalCount"] = boost::any(*totalCount);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (unit) {
      res["unit"] = boost::any(*unit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
    if (m.find("totalCount") != m.end() && !m["totalCount"].empty()) {
      totalCount = make_shared<long>(boost::any_cast<long>(m["totalCount"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("unit") != m.end() && !m["unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["unit"]));
    }
  }


  virtual ~CapacityPlanRequestDataInfo() = default;
};
class CapacityPlanRequestMetric : public Darabonba::Model {
public:
  shared_ptr<long> averageQps{};
  shared_ptr<string> code{};
  shared_ptr<long> concurrent{};
  shared_ptr<long> peakQps{};
  shared_ptr<long> responseTime{};
  shared_ptr<long> throughput{};
  shared_ptr<string> type{};

  CapacityPlanRequestMetric() {}

  explicit CapacityPlanRequestMetric(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (averageQps) {
      res["averageQps"] = boost::any(*averageQps);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (concurrent) {
      res["concurrent"] = boost::any(*concurrent);
    }
    if (peakQps) {
      res["peakQps"] = boost::any(*peakQps);
    }
    if (responseTime) {
      res["responseTime"] = boost::any(*responseTime);
    }
    if (throughput) {
      res["throughput"] = boost::any(*throughput);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("averageQps") != m.end() && !m["averageQps"].empty()) {
      averageQps = make_shared<long>(boost::any_cast<long>(m["averageQps"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("concurrent") != m.end() && !m["concurrent"].empty()) {
      concurrent = make_shared<long>(boost::any_cast<long>(m["concurrent"]));
    }
    if (m.find("peakQps") != m.end() && !m["peakQps"].empty()) {
      peakQps = make_shared<long>(boost::any_cast<long>(m["peakQps"]));
    }
    if (m.find("responseTime") != m.end() && !m["responseTime"].empty()) {
      responseTime = make_shared<long>(boost::any_cast<long>(m["responseTime"]));
    }
    if (m.find("throughput") != m.end() && !m["throughput"].empty()) {
      throughput = make_shared<long>(boost::any_cast<long>(m["throughput"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~CapacityPlanRequestMetric() = default;
};
class CapacityPlanRequest : public Darabonba::Model {
public:
  shared_ptr<bool> complexQueryAvailable{};
  shared_ptr<vector<CapacityPlanRequestDataInfo>> dataInfo{};
  shared_ptr<vector<CapacityPlanRequestMetric>> metric{};
  shared_ptr<string> usageScenario{};

  CapacityPlanRequest() {}

  explicit CapacityPlanRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (complexQueryAvailable) {
      res["complexQueryAvailable"] = boost::any(*complexQueryAvailable);
    }
    if (dataInfo) {
      vector<boost::any> temp1;
      for(auto item1:*dataInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["dataInfo"] = boost::any(temp1);
    }
    if (metric) {
      vector<boost::any> temp1;
      for(auto item1:*metric){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["metric"] = boost::any(temp1);
    }
    if (usageScenario) {
      res["usageScenario"] = boost::any(*usageScenario);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("complexQueryAvailable") != m.end() && !m["complexQueryAvailable"].empty()) {
      complexQueryAvailable = make_shared<bool>(boost::any_cast<bool>(m["complexQueryAvailable"]));
    }
    if (m.find("dataInfo") != m.end() && !m["dataInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["dataInfo"].type()) {
        vector<CapacityPlanRequestDataInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["dataInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CapacityPlanRequestDataInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataInfo = make_shared<vector<CapacityPlanRequestDataInfo>>(expect1);
      }
    }
    if (m.find("metric") != m.end() && !m["metric"].empty()) {
      if (typeid(vector<boost::any>) == m["metric"].type()) {
        vector<CapacityPlanRequestMetric> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["metric"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CapacityPlanRequestMetric model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        metric = make_shared<vector<CapacityPlanRequestMetric>>(expect1);
      }
    }
    if (m.find("usageScenario") != m.end() && !m["usageScenario"].empty()) {
      usageScenario = make_shared<string>(boost::any_cast<string>(m["usageScenario"]));
    }
  }


  virtual ~CapacityPlanRequest() = default;
};
class CapacityPlanResponseBodyResultExtendConfigs : public Darabonba::Model {
public:
  shared_ptr<string> configType{};
  shared_ptr<long> disk{};
  shared_ptr<string> diskType{};

  CapacityPlanResponseBodyResultExtendConfigs() {}

  explicit CapacityPlanResponseBodyResultExtendConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configType) {
      res["ConfigType"] = boost::any(*configType);
    }
    if (disk) {
      res["Disk"] = boost::any(*disk);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ConfigType") != m.end() && !m["ConfigType"].empty()) {
      configType = make_shared<string>(boost::any_cast<string>(m["ConfigType"]));
    }
    if (m.find("Disk") != m.end() && !m["Disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["Disk"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
  }


  virtual ~CapacityPlanResponseBodyResultExtendConfigs() = default;
};
class CapacityPlanResponseBodyResultNodeConfigurations : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<long> cpu{};
  shared_ptr<long> disk{};
  shared_ptr<string> diskType{};
  shared_ptr<long> memory{};
  shared_ptr<string> nodeType{};

  CapacityPlanResponseBodyResultNodeConfigurations() {}

  explicit CapacityPlanResponseBodyResultNodeConfigurations(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["Amount"] = boost::any(*amount);
    }
    if (cpu) {
      res["Cpu"] = boost::any(*cpu);
    }
    if (disk) {
      res["Disk"] = boost::any(*disk);
    }
    if (diskType) {
      res["DiskType"] = boost::any(*diskType);
    }
    if (memory) {
      res["Memory"] = boost::any(*memory);
    }
    if (nodeType) {
      res["NodeType"] = boost::any(*nodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Amount") != m.end() && !m["Amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["Amount"]));
    }
    if (m.find("Cpu") != m.end() && !m["Cpu"].empty()) {
      cpu = make_shared<long>(boost::any_cast<long>(m["Cpu"]));
    }
    if (m.find("Disk") != m.end() && !m["Disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["Disk"]));
    }
    if (m.find("DiskType") != m.end() && !m["DiskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["DiskType"]));
    }
    if (m.find("Memory") != m.end() && !m["Memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["Memory"]));
    }
    if (m.find("NodeType") != m.end() && !m["NodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["NodeType"]));
    }
  }


  virtual ~CapacityPlanResponseBodyResultNodeConfigurations() = default;
};
class CapacityPlanResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<CapacityPlanResponseBodyResultExtendConfigs>> extendConfigs{};
  shared_ptr<string> instanceCategory{};
  shared_ptr<vector<CapacityPlanResponseBodyResultNodeConfigurations>> nodeConfigurations{};
  shared_ptr<bool> oversizedCluster{};

  CapacityPlanResponseBodyResult() {}

  explicit CapacityPlanResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extendConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*extendConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ExtendConfigs"] = boost::any(temp1);
    }
    if (instanceCategory) {
      res["InstanceCategory"] = boost::any(*instanceCategory);
    }
    if (nodeConfigurations) {
      vector<boost::any> temp1;
      for(auto item1:*nodeConfigurations){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["NodeConfigurations"] = boost::any(temp1);
    }
    if (oversizedCluster) {
      res["OversizedCluster"] = boost::any(*oversizedCluster);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtendConfigs") != m.end() && !m["ExtendConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["ExtendConfigs"].type()) {
        vector<CapacityPlanResponseBodyResultExtendConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ExtendConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CapacityPlanResponseBodyResultExtendConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extendConfigs = make_shared<vector<CapacityPlanResponseBodyResultExtendConfigs>>(expect1);
      }
    }
    if (m.find("InstanceCategory") != m.end() && !m["InstanceCategory"].empty()) {
      instanceCategory = make_shared<string>(boost::any_cast<string>(m["InstanceCategory"]));
    }
    if (m.find("NodeConfigurations") != m.end() && !m["NodeConfigurations"].empty()) {
      if (typeid(vector<boost::any>) == m["NodeConfigurations"].type()) {
        vector<CapacityPlanResponseBodyResultNodeConfigurations> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["NodeConfigurations"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CapacityPlanResponseBodyResultNodeConfigurations model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeConfigurations = make_shared<vector<CapacityPlanResponseBodyResultNodeConfigurations>>(expect1);
      }
    }
    if (m.find("OversizedCluster") != m.end() && !m["OversizedCluster"].empty()) {
      oversizedCluster = make_shared<bool>(boost::any_cast<bool>(m["OversizedCluster"]));
    }
  }


  virtual ~CapacityPlanResponseBodyResult() = default;
};
class CapacityPlanResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CapacityPlanResponseBodyResult> result{};

  CapacityPlanResponseBody() {}

  explicit CapacityPlanResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CapacityPlanResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CapacityPlanResponseBodyResult>(model1);
      }
    }
  }


  virtual ~CapacityPlanResponseBody() = default;
};
class CapacityPlanResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CapacityPlanResponseBody> body{};

  CapacityPlanResponse() {}

  explicit CapacityPlanResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CapacityPlanResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CapacityPlanResponseBody>(model1);
      }
    }
  }


  virtual ~CapacityPlanResponse() = default;
};
class CloseDiagnosisRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> lang{};

  CloseDiagnosisRequest() {}

  explicit CloseDiagnosisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (lang) {
      res["lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("lang") != m.end() && !m["lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["lang"]));
    }
  }


  virtual ~CloseDiagnosisRequest() = default;
};
class CloseDiagnosisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  CloseDiagnosisResponseBody() {}

  explicit CloseDiagnosisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~CloseDiagnosisResponseBody() = default;
};
class CloseDiagnosisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CloseDiagnosisResponseBody> body{};

  CloseDiagnosisResponse() {}

  explicit CloseDiagnosisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CloseDiagnosisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CloseDiagnosisResponseBody>(model1);
      }
    }
  }


  virtual ~CloseDiagnosisResponse() = default;
};
class CloseHttpsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};

  CloseHttpsRequest() {}

  explicit CloseHttpsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~CloseHttpsRequest() = default;
};
class CloseHttpsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  CloseHttpsResponseBody() {}

  explicit CloseHttpsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~CloseHttpsResponseBody() = default;
};
class CloseHttpsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CloseHttpsResponseBody> body{};

  CloseHttpsResponse() {}

  explicit CloseHttpsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CloseHttpsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CloseHttpsResponseBody>(model1);
      }
    }
  }


  virtual ~CloseHttpsResponse() = default;
};
class CloseManagedIndexRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};

  CloseManagedIndexRequest() {}

  explicit CloseManagedIndexRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~CloseManagedIndexRequest() = default;
};
class CloseManagedIndexResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  CloseManagedIndexResponseBody() {}

  explicit CloseManagedIndexResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~CloseManagedIndexResponseBody() = default;
};
class CloseManagedIndexResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CloseManagedIndexResponseBody> body{};

  CloseManagedIndexResponse() {}

  explicit CloseManagedIndexResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CloseManagedIndexResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CloseManagedIndexResponseBody>(model1);
      }
    }
  }


  virtual ~CloseManagedIndexResponse() = default;
};
class CreateCollectorRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};

  CreateCollectorRequest() {}

  explicit CreateCollectorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~CreateCollectorRequest() = default;
};
class CreateCollectorResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> resId{};

  CreateCollectorResponseBodyResult() {}

  explicit CreateCollectorResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resId) {
      res["resId"] = boost::any(*resId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("resId") != m.end() && !m["resId"].empty()) {
      resId = make_shared<string>(boost::any_cast<string>(m["resId"]));
    }
  }


  virtual ~CreateCollectorResponseBodyResult() = default;
};
class CreateCollectorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateCollectorResponseBodyResult> result{};

  CreateCollectorResponseBody() {}

  explicit CreateCollectorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateCollectorResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateCollectorResponseBodyResult>(model1);
      }
    }
  }


  virtual ~CreateCollectorResponseBody() = default;
};
class CreateCollectorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateCollectorResponseBody> body{};

  CreateCollectorResponse() {}

  explicit CreateCollectorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateCollectorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateCollectorResponseBody>(model1);
      }
    }
  }


  virtual ~CreateCollectorResponse() = default;
};
class CreateComponentIndexRequestTemplate : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> aliases{};
  shared_ptr<map<string, boost::any>> mappings{};
  shared_ptr<map<string, boost::any>> settings{};

  CreateComponentIndexRequestTemplate() {}

  explicit CreateComponentIndexRequestTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliases) {
      res["aliases"] = boost::any(*aliases);
    }
    if (mappings) {
      res["mappings"] = boost::any(*mappings);
    }
    if (settings) {
      res["settings"] = boost::any(*settings);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aliases") != m.end() && !m["aliases"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["aliases"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      aliases = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("mappings") != m.end() && !m["mappings"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["mappings"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      mappings = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("settings") != m.end() && !m["settings"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["settings"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      settings = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~CreateComponentIndexRequestTemplate() = default;
};
class CreateComponentIndexRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> meta{};
  shared_ptr<CreateComponentIndexRequestTemplate> template_{};

  CreateComponentIndexRequest() {}

  explicit CreateComponentIndexRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (meta) {
      res["_meta"] = boost::any(*meta);
    }
    if (template_) {
      res["template"] = template_ ? boost::any(template_->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("_meta") != m.end() && !m["_meta"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["_meta"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      meta = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("template") != m.end() && !m["template"].empty()) {
      if (typeid(map<string, boost::any>) == m["template"].type()) {
        CreateComponentIndexRequestTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["template"]));
        template_ = make_shared<CreateComponentIndexRequestTemplate>(model1);
      }
    }
  }


  virtual ~CreateComponentIndexRequest() = default;
};
class CreateComponentIndexResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  CreateComponentIndexResponseBody() {}

  explicit CreateComponentIndexResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~CreateComponentIndexResponseBody() = default;
};
class CreateComponentIndexResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateComponentIndexResponseBody> body{};

  CreateComponentIndexResponse() {}

  explicit CreateComponentIndexResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateComponentIndexResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateComponentIndexResponseBody>(model1);
      }
    }
  }


  virtual ~CreateComponentIndexResponse() = default;
};
class CreateDataStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> body{};

  CreateDataStreamRequest() {}

  explicit CreateDataStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~CreateDataStreamRequest() = default;
};
class CreateDataStreamResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  CreateDataStreamResponseBodyResult() {}

  explicit CreateDataStreamResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~CreateDataStreamResponseBodyResult() = default;
};
class CreateDataStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateDataStreamResponseBodyResult> result{};

  CreateDataStreamResponseBody() {}

  explicit CreateDataStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateDataStreamResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateDataStreamResponseBodyResult>(model1);
      }
    }
  }


  virtual ~CreateDataStreamResponseBody() = default;
};
class CreateDataStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDataStreamResponseBody> body{};

  CreateDataStreamResponse() {}

  explicit CreateDataStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataStreamResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataStreamResponse() = default;
};
class CreateDataTasksRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> body{};

  CreateDataTasksRequest() {}

  explicit CreateDataTasksRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~CreateDataTasksRequest() = default;
};
class CreateDataTasksResponseBodyResultSinkCluster : public Darabonba::Model {
public:
  shared_ptr<string> dataSourceType{};
  shared_ptr<string> index{};
  shared_ptr<string> mapping{};
  shared_ptr<string> password{};
  shared_ptr<string> routing{};
  shared_ptr<string> settings{};
  shared_ptr<string> type{};
  shared_ptr<string> username{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcInstanceId{};
  shared_ptr<string> vpcInstancePort{};

  CreateDataTasksResponseBodyResultSinkCluster() {}

  explicit CreateDataTasksResponseBodyResultSinkCluster(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceType) {
      res["dataSourceType"] = boost::any(*dataSourceType);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (mapping) {
      res["mapping"] = boost::any(*mapping);
    }
    if (password) {
      res["password"] = boost::any(*password);
    }
    if (routing) {
      res["routing"] = boost::any(*routing);
    }
    if (settings) {
      res["settings"] = boost::any(*settings);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    if (vpcInstanceId) {
      res["vpcInstanceId"] = boost::any(*vpcInstanceId);
    }
    if (vpcInstancePort) {
      res["vpcInstancePort"] = boost::any(*vpcInstancePort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dataSourceType") != m.end() && !m["dataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["dataSourceType"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("mapping") != m.end() && !m["mapping"].empty()) {
      mapping = make_shared<string>(boost::any_cast<string>(m["mapping"]));
    }
    if (m.find("password") != m.end() && !m["password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["password"]));
    }
    if (m.find("routing") != m.end() && !m["routing"].empty()) {
      routing = make_shared<string>(boost::any_cast<string>(m["routing"]));
    }
    if (m.find("settings") != m.end() && !m["settings"].empty()) {
      settings = make_shared<string>(boost::any_cast<string>(m["settings"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
    if (m.find("vpcInstanceId") != m.end() && !m["vpcInstanceId"].empty()) {
      vpcInstanceId = make_shared<string>(boost::any_cast<string>(m["vpcInstanceId"]));
    }
    if (m.find("vpcInstancePort") != m.end() && !m["vpcInstancePort"].empty()) {
      vpcInstancePort = make_shared<string>(boost::any_cast<string>(m["vpcInstancePort"]));
    }
  }


  virtual ~CreateDataTasksResponseBodyResultSinkCluster() = default;
};
class CreateDataTasksResponseBodyResultSourceCluster : public Darabonba::Model {
public:
  shared_ptr<string> dataSourceType{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> index{};
  shared_ptr<string> password{};
  shared_ptr<string> type{};
  shared_ptr<string> username{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcInstanceId{};
  shared_ptr<long> vpcInstancePort{};

  CreateDataTasksResponseBodyResultSourceCluster() {}

  explicit CreateDataTasksResponseBodyResultSourceCluster(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceType) {
      res["dataSourceType"] = boost::any(*dataSourceType);
    }
    if (endpoint) {
      res["endpoint"] = boost::any(*endpoint);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (password) {
      res["password"] = boost::any(*password);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (username) {
      res["username"] = boost::any(*username);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    if (vpcInstanceId) {
      res["vpcInstanceId"] = boost::any(*vpcInstanceId);
    }
    if (vpcInstancePort) {
      res["vpcInstancePort"] = boost::any(*vpcInstancePort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dataSourceType") != m.end() && !m["dataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["dataSourceType"]));
    }
    if (m.find("endpoint") != m.end() && !m["endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["endpoint"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("password") != m.end() && !m["password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["password"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("username") != m.end() && !m["username"].empty()) {
      username = make_shared<string>(boost::any_cast<string>(m["username"]));
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
    if (m.find("vpcInstanceId") != m.end() && !m["vpcInstanceId"].empty()) {
      vpcInstanceId = make_shared<string>(boost::any_cast<string>(m["vpcInstanceId"]));
    }
    if (m.find("vpcInstancePort") != m.end() && !m["vpcInstancePort"].empty()) {
      vpcInstancePort = make_shared<long>(boost::any_cast<long>(m["vpcInstancePort"]));
    }
  }


  virtual ~CreateDataTasksResponseBodyResultSourceCluster() = default;
};
class CreateDataTasksResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<CreateDataTasksResponseBodyResultSinkCluster> sinkCluster{};
  shared_ptr<CreateDataTasksResponseBodyResultSourceCluster> sourceCluster{};

  CreateDataTasksResponseBodyResult() {}

  explicit CreateDataTasksResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (sinkCluster) {
      res["sinkCluster"] = sinkCluster ? boost::any(sinkCluster->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourceCluster) {
      res["sourceCluster"] = sourceCluster ? boost::any(sourceCluster->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("sinkCluster") != m.end() && !m["sinkCluster"].empty()) {
      if (typeid(map<string, boost::any>) == m["sinkCluster"].type()) {
        CreateDataTasksResponseBodyResultSinkCluster model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["sinkCluster"]));
        sinkCluster = make_shared<CreateDataTasksResponseBodyResultSinkCluster>(model1);
      }
    }
    if (m.find("sourceCluster") != m.end() && !m["sourceCluster"].empty()) {
      if (typeid(map<string, boost::any>) == m["sourceCluster"].type()) {
        CreateDataTasksResponseBodyResultSourceCluster model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["sourceCluster"]));
        sourceCluster = make_shared<CreateDataTasksResponseBodyResultSourceCluster>(model1);
      }
    }
  }


  virtual ~CreateDataTasksResponseBodyResult() = default;
};
class CreateDataTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<CreateDataTasksResponseBodyResult>> result{};

  CreateDataTasksResponseBody() {}

  explicit CreateDataTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<CreateDataTasksResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            CreateDataTasksResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<CreateDataTasksResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~CreateDataTasksResponseBody() = default;
};
class CreateDataTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateDataTasksResponseBody> body{};

  CreateDataTasksResponse() {}

  explicit CreateDataTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateDataTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateDataTasksResponseBody>(model1);
      }
    }
  }


  virtual ~CreateDataTasksResponse() = default;
};
class CreateILMPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> body{};

  CreateILMPolicyRequest() {}

  explicit CreateILMPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~CreateILMPolicyRequest() = default;
};
class CreateILMPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  CreateILMPolicyResponseBody() {}

  explicit CreateILMPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~CreateILMPolicyResponseBody() = default;
};
class CreateILMPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateILMPolicyResponseBody> body{};

  CreateILMPolicyResponse() {}

  explicit CreateILMPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateILMPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateILMPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~CreateILMPolicyResponse() = default;
};
class CreateIndexTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> body{};

  CreateIndexTemplateRequest() {}

  explicit CreateIndexTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~CreateIndexTemplateRequest() = default;
};
class CreateIndexTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  CreateIndexTemplateResponseBody() {}

  explicit CreateIndexTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~CreateIndexTemplateResponseBody() = default;
};
class CreateIndexTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateIndexTemplateResponseBody> body{};

  CreateIndexTemplateResponse() {}

  explicit CreateIndexTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateIndexTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateIndexTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~CreateIndexTemplateResponse() = default;
};
class CreateLogstashRequestNetworkConfig : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vsArea{};
  shared_ptr<string> vswitchId{};

  CreateLogstashRequestNetworkConfig() {}

  explicit CreateLogstashRequestNetworkConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    if (vsArea) {
      res["vsArea"] = boost::any(*vsArea);
    }
    if (vswitchId) {
      res["vswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
    if (m.find("vsArea") != m.end() && !m["vsArea"].empty()) {
      vsArea = make_shared<string>(boost::any_cast<string>(m["vsArea"]));
    }
    if (m.find("vswitchId") != m.end() && !m["vswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["vswitchId"]));
    }
  }


  virtual ~CreateLogstashRequestNetworkConfig() = default;
};
class CreateLogstashRequestNodeSpec : public Darabonba::Model {
public:
  shared_ptr<long> disk{};
  shared_ptr<string> diskType{};
  shared_ptr<string> spec{};

  CreateLogstashRequestNodeSpec() {}

  explicit CreateLogstashRequestNodeSpec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~CreateLogstashRequestNodeSpec() = default;
};
class CreateLogstashRequestPaymentInfo : public Darabonba::Model {
public:
  shared_ptr<long> autoRenewDuration{};
  shared_ptr<long> duration{};
  shared_ptr<bool> isAutoRenew{};
  shared_ptr<string> pricingCycle{};

  CreateLogstashRequestPaymentInfo() {}

  explicit CreateLogstashRequestPaymentInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (autoRenewDuration) {
      res["autoRenewDuration"] = boost::any(*autoRenewDuration);
    }
    if (duration) {
      res["duration"] = boost::any(*duration);
    }
    if (isAutoRenew) {
      res["isAutoRenew"] = boost::any(*isAutoRenew);
    }
    if (pricingCycle) {
      res["pricingCycle"] = boost::any(*pricingCycle);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("autoRenewDuration") != m.end() && !m["autoRenewDuration"].empty()) {
      autoRenewDuration = make_shared<long>(boost::any_cast<long>(m["autoRenewDuration"]));
    }
    if (m.find("duration") != m.end() && !m["duration"].empty()) {
      duration = make_shared<long>(boost::any_cast<long>(m["duration"]));
    }
    if (m.find("isAutoRenew") != m.end() && !m["isAutoRenew"].empty()) {
      isAutoRenew = make_shared<bool>(boost::any_cast<bool>(m["isAutoRenew"]));
    }
    if (m.find("pricingCycle") != m.end() && !m["pricingCycle"].empty()) {
      pricingCycle = make_shared<string>(boost::any_cast<string>(m["pricingCycle"]));
    }
  }


  virtual ~CreateLogstashRequestPaymentInfo() = default;
};
class CreateLogstashRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<CreateLogstashRequestNetworkConfig> networkConfig{};
  shared_ptr<long> nodeAmount{};
  shared_ptr<CreateLogstashRequestNodeSpec> nodeSpec{};
  shared_ptr<CreateLogstashRequestPaymentInfo> paymentInfo{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> version{};
  shared_ptr<string> clientToken{};

  CreateLogstashRequest() {}

  explicit CreateLogstashRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (networkConfig) {
      res["networkConfig"] = networkConfig ? boost::any(networkConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodeAmount) {
      res["nodeAmount"] = boost::any(*nodeAmount);
    }
    if (nodeSpec) {
      res["nodeSpec"] = nodeSpec ? boost::any(nodeSpec->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (paymentInfo) {
      res["paymentInfo"] = paymentInfo ? boost::any(paymentInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (paymentType) {
      res["paymentType"] = boost::any(*paymentType);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("networkConfig") != m.end() && !m["networkConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["networkConfig"].type()) {
        CreateLogstashRequestNetworkConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["networkConfig"]));
        networkConfig = make_shared<CreateLogstashRequestNetworkConfig>(model1);
      }
    }
    if (m.find("nodeAmount") != m.end() && !m["nodeAmount"].empty()) {
      nodeAmount = make_shared<long>(boost::any_cast<long>(m["nodeAmount"]));
    }
    if (m.find("nodeSpec") != m.end() && !m["nodeSpec"].empty()) {
      if (typeid(map<string, boost::any>) == m["nodeSpec"].type()) {
        CreateLogstashRequestNodeSpec model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["nodeSpec"]));
        nodeSpec = make_shared<CreateLogstashRequestNodeSpec>(model1);
      }
    }
    if (m.find("paymentInfo") != m.end() && !m["paymentInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["paymentInfo"].type()) {
        CreateLogstashRequestPaymentInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["paymentInfo"]));
        paymentInfo = make_shared<CreateLogstashRequestPaymentInfo>(model1);
      }
    }
    if (m.find("paymentType") != m.end() && !m["paymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["paymentType"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~CreateLogstashRequest() = default;
};
class CreateLogstashResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<Logstash> result{};

  CreateLogstashResponseBody() {}

  explicit CreateLogstashResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        Logstash model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<Logstash>(model1);
      }
    }
  }


  virtual ~CreateLogstashResponseBody() = default;
};
class CreateLogstashResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateLogstashResponseBody> body{};

  CreateLogstashResponse() {}

  explicit CreateLogstashResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateLogstashResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateLogstashResponseBody>(model1);
      }
    }
  }


  virtual ~CreateLogstashResponse() = default;
};
class CreatePipelinesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> body{};
  shared_ptr<bool> trigger{};

  CreatePipelinesRequest() {}

  explicit CreatePipelinesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (trigger) {
      res["trigger"] = boost::any(*trigger);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("trigger") != m.end() && !m["trigger"].empty()) {
      trigger = make_shared<bool>(boost::any_cast<bool>(m["trigger"]));
    }
  }


  virtual ~CreatePipelinesRequest() = default;
};
class CreatePipelinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  CreatePipelinesResponseBody() {}

  explicit CreatePipelinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~CreatePipelinesResponseBody() = default;
};
class CreatePipelinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreatePipelinesResponseBody> body{};

  CreatePipelinesResponse() {}

  explicit CreatePipelinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreatePipelinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreatePipelinesResponseBody>(model1);
      }
    }
  }


  virtual ~CreatePipelinesResponse() = default;
};
class CreateSnapshotRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> body{};

  CreateSnapshotRequest() {}

  explicit CreateSnapshotRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~CreateSnapshotRequest() = default;
};
class CreateSnapshotResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  CreateSnapshotResponseBody() {}

  explicit CreateSnapshotResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~CreateSnapshotResponseBody() = default;
};
class CreateSnapshotResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateSnapshotResponseBody> body{};

  CreateSnapshotResponse() {}

  explicit CreateSnapshotResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateSnapshotResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateSnapshotResponseBody>(model1);
      }
    }
  }


  virtual ~CreateSnapshotResponse() = default;
};
class CreateVpcEndpointRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> serviceId{};
  shared_ptr<string> zoneId{};
  shared_ptr<bool> dryRun{};

  CreateVpcEndpointRequest() {}

  explicit CreateVpcEndpointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (serviceId) {
      res["serviceId"] = boost::any(*serviceId);
    }
    if (zoneId) {
      res["zoneId"] = boost::any(*zoneId);
    }
    if (dryRun) {
      res["dryRun"] = boost::any(*dryRun);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("serviceId") != m.end() && !m["serviceId"].empty()) {
      serviceId = make_shared<string>(boost::any_cast<string>(m["serviceId"]));
    }
    if (m.find("zoneId") != m.end() && !m["zoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["zoneId"]));
    }
    if (m.find("dryRun") != m.end() && !m["dryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["dryRun"]));
    }
  }


  virtual ~CreateVpcEndpointRequest() = default;
};
class CreateVpcEndpointResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> endpointDomain{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> endpointName{};
  shared_ptr<string> serviceId{};

  CreateVpcEndpointResponseBodyResult() {}

  explicit CreateVpcEndpointResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpointDomain) {
      res["endpointDomain"] = boost::any(*endpointDomain);
    }
    if (endpointId) {
      res["endpointId"] = boost::any(*endpointId);
    }
    if (endpointName) {
      res["endpointName"] = boost::any(*endpointName);
    }
    if (serviceId) {
      res["serviceId"] = boost::any(*serviceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endpointDomain") != m.end() && !m["endpointDomain"].empty()) {
      endpointDomain = make_shared<string>(boost::any_cast<string>(m["endpointDomain"]));
    }
    if (m.find("endpointId") != m.end() && !m["endpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["endpointId"]));
    }
    if (m.find("endpointName") != m.end() && !m["endpointName"].empty()) {
      endpointName = make_shared<string>(boost::any_cast<string>(m["endpointName"]));
    }
    if (m.find("serviceId") != m.end() && !m["serviceId"].empty()) {
      serviceId = make_shared<string>(boost::any_cast<string>(m["serviceId"]));
    }
  }


  virtual ~CreateVpcEndpointResponseBodyResult() = default;
};
class CreateVpcEndpointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateVpcEndpointResponseBodyResult> result{};

  CreateVpcEndpointResponseBody() {}

  explicit CreateVpcEndpointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateVpcEndpointResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateVpcEndpointResponseBodyResult>(model1);
      }
    }
  }


  virtual ~CreateVpcEndpointResponseBody() = default;
};
class CreateVpcEndpointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateVpcEndpointResponseBody> body{};

  CreateVpcEndpointResponse() {}

  explicit CreateVpcEndpointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateVpcEndpointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateVpcEndpointResponseBody>(model1);
      }
    }
  }


  virtual ~CreateVpcEndpointResponse() = default;
};
class DeactivateZonesRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};

  DeactivateZonesRequest() {}

  explicit DeactivateZonesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~DeactivateZonesRequest() = default;
};
class DeactivateZonesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  DeactivateZonesResponseBody() {}

  explicit DeactivateZonesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~DeactivateZonesResponseBody() = default;
};
class DeactivateZonesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeactivateZonesResponseBody> body{};

  DeactivateZonesResponse() {}

  explicit DeactivateZonesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeactivateZonesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeactivateZonesResponseBody>(model1);
      }
    }
  }


  virtual ~DeactivateZonesResponse() = default;
};
class DeleteCollectorRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};

  DeleteCollectorRequest() {}

  explicit DeleteCollectorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~DeleteCollectorRequest() = default;
};
class DeleteCollectorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  DeleteCollectorResponseBody() {}

  explicit DeleteCollectorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~DeleteCollectorResponseBody() = default;
};
class DeleteCollectorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteCollectorResponseBody> body{};

  DeleteCollectorResponse() {}

  explicit DeleteCollectorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteCollectorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteCollectorResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteCollectorResponse() = default;
};
class DeleteComponentIndexResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  DeleteComponentIndexResponseBody() {}

  explicit DeleteComponentIndexResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~DeleteComponentIndexResponseBody() = default;
};
class DeleteComponentIndexResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteComponentIndexResponseBody> body{};

  DeleteComponentIndexResponse() {}

  explicit DeleteComponentIndexResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteComponentIndexResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteComponentIndexResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteComponentIndexResponse() = default;
};
class DeleteConnectedClusterRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> connectedInstanceId{};

  DeleteConnectedClusterRequest() {}

  explicit DeleteConnectedClusterRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (connectedInstanceId) {
      res["connectedInstanceId"] = boost::any(*connectedInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("connectedInstanceId") != m.end() && !m["connectedInstanceId"].empty()) {
      connectedInstanceId = make_shared<string>(boost::any_cast<string>(m["connectedInstanceId"]));
    }
  }


  virtual ~DeleteConnectedClusterRequest() = default;
};
class DeleteConnectedClusterResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  DeleteConnectedClusterResponseBody() {}

  explicit DeleteConnectedClusterResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~DeleteConnectedClusterResponseBody() = default;
};
class DeleteConnectedClusterResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteConnectedClusterResponseBody> body{};

  DeleteConnectedClusterResponse() {}

  explicit DeleteConnectedClusterResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteConnectedClusterResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteConnectedClusterResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteConnectedClusterResponse() = default;
};
class DeleteDataStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};

  DeleteDataStreamRequest() {}

  explicit DeleteDataStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~DeleteDataStreamRequest() = default;
};
class DeleteDataStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  DeleteDataStreamResponseBody() {}

  explicit DeleteDataStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~DeleteDataStreamResponseBody() = default;
};
class DeleteDataStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDataStreamResponseBody> body{};

  DeleteDataStreamResponse() {}

  explicit DeleteDataStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDataStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDataStreamResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDataStreamResponse() = default;
};
class DeleteDataTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> taskId{};

  DeleteDataTaskRequest() {}

  explicit DeleteDataTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["taskId"]));
    }
  }


  virtual ~DeleteDataTaskRequest() = default;
};
class DeleteDataTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  DeleteDataTaskResponseBody() {}

  explicit DeleteDataTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~DeleteDataTaskResponseBody() = default;
};
class DeleteDataTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDataTaskResponseBody> body{};

  DeleteDataTaskResponse() {}

  explicit DeleteDataTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDataTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDataTaskResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDataTaskResponse() = default;
};
class DeleteDeprecatedTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  DeleteDeprecatedTemplateResponseBody() {}

  explicit DeleteDeprecatedTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~DeleteDeprecatedTemplateResponseBody() = default;
};
class DeleteDeprecatedTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteDeprecatedTemplateResponseBody> body{};

  DeleteDeprecatedTemplateResponse() {}

  explicit DeleteDeprecatedTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteDeprecatedTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteDeprecatedTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteDeprecatedTemplateResponse() = default;
};
class DeleteILMPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  DeleteILMPolicyResponseBody() {}

  explicit DeleteILMPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~DeleteILMPolicyResponseBody() = default;
};
class DeleteILMPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteILMPolicyResponseBody> body{};

  DeleteILMPolicyResponse() {}

  explicit DeleteILMPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteILMPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteILMPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteILMPolicyResponse() = default;
};
class DeleteIndexTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  DeleteIndexTemplateResponseBody() {}

  explicit DeleteIndexTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~DeleteIndexTemplateResponseBody() = default;
};
class DeleteIndexTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteIndexTemplateResponseBody> body{};

  DeleteIndexTemplateResponse() {}

  explicit DeleteIndexTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteIndexTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteIndexTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteIndexTemplateResponse() = default;
};
class DeleteInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> deleteType{};

  DeleteInstanceRequest() {}

  explicit DeleteInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (deleteType) {
      res["deleteType"] = boost::any(*deleteType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("deleteType") != m.end() && !m["deleteType"].empty()) {
      deleteType = make_shared<string>(boost::any_cast<string>(m["deleteType"]));
    }
  }


  virtual ~DeleteInstanceRequest() = default;
};
class DeleteInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteInstanceResponseBody() {}

  explicit DeleteInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteInstanceResponseBody() = default;
};
class DeleteInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteInstanceResponseBody> body{};

  DeleteInstanceResponse() {}

  explicit DeleteInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteInstanceResponse() = default;
};
class DeleteLogstashRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> deleteType{};

  DeleteLogstashRequest() {}

  explicit DeleteLogstashRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (deleteType) {
      res["deleteType"] = boost::any(*deleteType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("deleteType") != m.end() && !m["deleteType"].empty()) {
      deleteType = make_shared<string>(boost::any_cast<string>(m["deleteType"]));
    }
  }


  virtual ~DeleteLogstashRequest() = default;
};
class DeleteLogstashResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  DeleteLogstashResponseBody() {}

  explicit DeleteLogstashResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~DeleteLogstashResponseBody() = default;
};
class DeleteLogstashResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteLogstashResponseBody> body{};

  DeleteLogstashResponse() {}

  explicit DeleteLogstashResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteLogstashResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteLogstashResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteLogstashResponse() = default;
};
class DeletePipelinesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> pipelineIds{};

  DeletePipelinesRequest() {}

  explicit DeletePipelinesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (pipelineIds) {
      res["pipelineIds"] = boost::any(*pipelineIds);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("pipelineIds") != m.end() && !m["pipelineIds"].empty()) {
      pipelineIds = make_shared<string>(boost::any_cast<string>(m["pipelineIds"]));
    }
  }


  virtual ~DeletePipelinesRequest() = default;
};
class DeletePipelinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  DeletePipelinesResponseBody() {}

  explicit DeletePipelinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~DeletePipelinesResponseBody() = default;
};
class DeletePipelinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeletePipelinesResponseBody> body{};

  DeletePipelinesResponse() {}

  explicit DeletePipelinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeletePipelinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeletePipelinesResponseBody>(model1);
      }
    }
  }


  virtual ~DeletePipelinesResponse() = default;
};
class DeleteSnapshotRepoRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> repoPath{};

  DeleteSnapshotRepoRequest() {}

  explicit DeleteSnapshotRepoRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (repoPath) {
      res["repoPath"] = boost::any(*repoPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("repoPath") != m.end() && !m["repoPath"].empty()) {
      repoPath = make_shared<string>(boost::any_cast<string>(m["repoPath"]));
    }
  }


  virtual ~DeleteSnapshotRepoRequest() = default;
};
class DeleteSnapshotRepoResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  DeleteSnapshotRepoResponseBody() {}

  explicit DeleteSnapshotRepoResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~DeleteSnapshotRepoResponseBody() = default;
};
class DeleteSnapshotRepoResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteSnapshotRepoResponseBody> body{};

  DeleteSnapshotRepoResponse() {}

  explicit DeleteSnapshotRepoResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteSnapshotRepoResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteSnapshotRepoResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteSnapshotRepoResponse() = default;
};
class DeleteVpcEndpointRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};

  DeleteVpcEndpointRequest() {}

  explicit DeleteVpcEndpointRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~DeleteVpcEndpointRequest() = default;
};
class DeleteVpcEndpointResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  DeleteVpcEndpointResponseBody() {}

  explicit DeleteVpcEndpointResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~DeleteVpcEndpointResponseBody() = default;
};
class DeleteVpcEndpointResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DeleteVpcEndpointResponseBody> body{};

  DeleteVpcEndpointResponse() {}

  explicit DeleteVpcEndpointResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DeleteVpcEndpointResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DeleteVpcEndpointResponseBody>(model1);
      }
    }
  }


  virtual ~DeleteVpcEndpointResponse() = default;
};
class DescribeAckOperatorResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> version{};

  DescribeAckOperatorResponseBodyResult() {}

  explicit DescribeAckOperatorResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
  }


  virtual ~DescribeAckOperatorResponseBodyResult() = default;
};
class DescribeAckOperatorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeAckOperatorResponseBodyResult> result{};

  DescribeAckOperatorResponseBody() {}

  explicit DescribeAckOperatorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeAckOperatorResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeAckOperatorResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeAckOperatorResponseBody() = default;
};
class DescribeAckOperatorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeAckOperatorResponseBody> body{};

  DescribeAckOperatorResponse() {}

  explicit DescribeAckOperatorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeAckOperatorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeAckOperatorResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeAckOperatorResponse() = default;
};
class DescribeApmResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> apmServerDomain{};
  shared_ptr<string> createdAt{};
  shared_ptr<long> deployedReplica{};
  shared_ptr<string> description{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> nodeAmount{};
  shared_ptr<string> outputES{};
  shared_ptr<string> outputESUserName{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> region{};
  shared_ptr<long> replica{};
  shared_ptr<string> resourceSpec{};
  shared_ptr<string> status{};
  shared_ptr<string> version{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vsArea{};
  shared_ptr<string> vswitchId{};

  DescribeApmResponseBodyResult() {}

  explicit DescribeApmResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (apmServerDomain) {
      res["apmServerDomain"] = boost::any(*apmServerDomain);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (deployedReplica) {
      res["deployedReplica"] = boost::any(*deployedReplica);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (nodeAmount) {
      res["nodeAmount"] = boost::any(*nodeAmount);
    }
    if (outputES) {
      res["outputES"] = boost::any(*outputES);
    }
    if (outputESUserName) {
      res["outputESUserName"] = boost::any(*outputESUserName);
    }
    if (ownerId) {
      res["ownerId"] = boost::any(*ownerId);
    }
    if (paymentType) {
      res["paymentType"] = boost::any(*paymentType);
    }
    if (region) {
      res["region"] = boost::any(*region);
    }
    if (replica) {
      res["replica"] = boost::any(*replica);
    }
    if (resourceSpec) {
      res["resourceSpec"] = boost::any(*resourceSpec);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    if (vsArea) {
      res["vsArea"] = boost::any(*vsArea);
    }
    if (vswitchId) {
      res["vswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("apmServerDomain") != m.end() && !m["apmServerDomain"].empty()) {
      apmServerDomain = make_shared<string>(boost::any_cast<string>(m["apmServerDomain"]));
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("deployedReplica") != m.end() && !m["deployedReplica"].empty()) {
      deployedReplica = make_shared<long>(boost::any_cast<long>(m["deployedReplica"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("nodeAmount") != m.end() && !m["nodeAmount"].empty()) {
      nodeAmount = make_shared<long>(boost::any_cast<long>(m["nodeAmount"]));
    }
    if (m.find("outputES") != m.end() && !m["outputES"].empty()) {
      outputES = make_shared<string>(boost::any_cast<string>(m["outputES"]));
    }
    if (m.find("outputESUserName") != m.end() && !m["outputESUserName"].empty()) {
      outputESUserName = make_shared<string>(boost::any_cast<string>(m["outputESUserName"]));
    }
    if (m.find("ownerId") != m.end() && !m["ownerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["ownerId"]));
    }
    if (m.find("paymentType") != m.end() && !m["paymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["paymentType"]));
    }
    if (m.find("region") != m.end() && !m["region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["region"]));
    }
    if (m.find("replica") != m.end() && !m["replica"].empty()) {
      replica = make_shared<long>(boost::any_cast<long>(m["replica"]));
    }
    if (m.find("resourceSpec") != m.end() && !m["resourceSpec"].empty()) {
      resourceSpec = make_shared<string>(boost::any_cast<string>(m["resourceSpec"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
    if (m.find("vsArea") != m.end() && !m["vsArea"].empty()) {
      vsArea = make_shared<string>(boost::any_cast<string>(m["vsArea"]));
    }
    if (m.find("vswitchId") != m.end() && !m["vswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["vswitchId"]));
    }
  }


  virtual ~DescribeApmResponseBodyResult() = default;
};
class DescribeApmResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeApmResponseBodyResult> result{};

  DescribeApmResponseBody() {}

  explicit DescribeApmResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeApmResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeApmResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeApmResponseBody() = default;
};
class DescribeApmResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeApmResponseBody> body{};

  DescribeApmResponse() {}

  explicit DescribeApmResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeApmResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeApmResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeApmResponse() = default;
};
class DescribeCollectorResponseBodyResultConfigs : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> fileName{};

  DescribeCollectorResponseBodyResultConfigs() {}

  explicit DescribeCollectorResponseBodyResultConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (fileName) {
      res["fileName"] = boost::any(*fileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("fileName") != m.end() && !m["fileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["fileName"]));
    }
  }


  virtual ~DescribeCollectorResponseBodyResultConfigs() = default;
};
class DescribeCollectorResponseBodyResultExtendConfigsMachines : public Darabonba::Model {
public:
  shared_ptr<string> agentStatus{};
  shared_ptr<string> instanceId{};

  DescribeCollectorResponseBodyResultExtendConfigsMachines() {}

  explicit DescribeCollectorResponseBodyResultExtendConfigsMachines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentStatus) {
      res["agentStatus"] = boost::any(*agentStatus);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("agentStatus") != m.end() && !m["agentStatus"].empty()) {
      agentStatus = make_shared<string>(boost::any_cast<string>(m["agentStatus"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
  }


  virtual ~DescribeCollectorResponseBodyResultExtendConfigsMachines() = default;
};
class DescribeCollectorResponseBodyResultExtendConfigs : public Darabonba::Model {
public:
  shared_ptr<string> configType{};
  shared_ptr<bool> enableMonitoring{};
  shared_ptr<string> groupId{};
  shared_ptr<string> host{};
  shared_ptr<vector<string>> hosts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> kibanaHost{};
  shared_ptr<vector<DescribeCollectorResponseBodyResultExtendConfigsMachines>> machines{};
  shared_ptr<string> protocol{};
  shared_ptr<string> successPodsCount{};
  shared_ptr<string> totalPodsCount{};
  shared_ptr<string> type{};
  shared_ptr<string> userName{};

  DescribeCollectorResponseBodyResultExtendConfigs() {}

  explicit DescribeCollectorResponseBodyResultExtendConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configType) {
      res["configType"] = boost::any(*configType);
    }
    if (enableMonitoring) {
      res["enableMonitoring"] = boost::any(*enableMonitoring);
    }
    if (groupId) {
      res["groupId"] = boost::any(*groupId);
    }
    if (host) {
      res["host"] = boost::any(*host);
    }
    if (hosts) {
      res["hosts"] = boost::any(*hosts);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["instanceType"] = boost::any(*instanceType);
    }
    if (kibanaHost) {
      res["kibanaHost"] = boost::any(*kibanaHost);
    }
    if (machines) {
      vector<boost::any> temp1;
      for(auto item1:*machines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["machines"] = boost::any(temp1);
    }
    if (protocol) {
      res["protocol"] = boost::any(*protocol);
    }
    if (successPodsCount) {
      res["successPodsCount"] = boost::any(*successPodsCount);
    }
    if (totalPodsCount) {
      res["totalPodsCount"] = boost::any(*totalPodsCount);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (userName) {
      res["userName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("configType") != m.end() && !m["configType"].empty()) {
      configType = make_shared<string>(boost::any_cast<string>(m["configType"]));
    }
    if (m.find("enableMonitoring") != m.end() && !m["enableMonitoring"].empty()) {
      enableMonitoring = make_shared<bool>(boost::any_cast<bool>(m["enableMonitoring"]));
    }
    if (m.find("groupId") != m.end() && !m["groupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["groupId"]));
    }
    if (m.find("host") != m.end() && !m["host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["host"]));
    }
    if (m.find("hosts") != m.end() && !m["hosts"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["hosts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["hosts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hosts = make_shared<vector<string>>(toVec1);
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("instanceType") != m.end() && !m["instanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["instanceType"]));
    }
    if (m.find("kibanaHost") != m.end() && !m["kibanaHost"].empty()) {
      kibanaHost = make_shared<string>(boost::any_cast<string>(m["kibanaHost"]));
    }
    if (m.find("machines") != m.end() && !m["machines"].empty()) {
      if (typeid(vector<boost::any>) == m["machines"].type()) {
        vector<DescribeCollectorResponseBodyResultExtendConfigsMachines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["machines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCollectorResponseBodyResultExtendConfigsMachines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        machines = make_shared<vector<DescribeCollectorResponseBodyResultExtendConfigsMachines>>(expect1);
      }
    }
    if (m.find("protocol") != m.end() && !m["protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["protocol"]));
    }
    if (m.find("successPodsCount") != m.end() && !m["successPodsCount"].empty()) {
      successPodsCount = make_shared<string>(boost::any_cast<string>(m["successPodsCount"]));
    }
    if (m.find("totalPodsCount") != m.end() && !m["totalPodsCount"].empty()) {
      totalPodsCount = make_shared<string>(boost::any_cast<string>(m["totalPodsCount"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("userName") != m.end() && !m["userName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["userName"]));
    }
  }


  virtual ~DescribeCollectorResponseBodyResultExtendConfigs() = default;
};
class DescribeCollectorResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<string>> collectorPaths{};
  shared_ptr<vector<DescribeCollectorResponseBodyResultConfigs>> configs{};
  shared_ptr<bool> dryRun{};
  shared_ptr<vector<DescribeCollectorResponseBodyResultExtendConfigs>> extendConfigs{};
  shared_ptr<string> gmtCreatedTime{};
  shared_ptr<string> gmtUpdateTime{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> resId{};
  shared_ptr<string> resType{};
  shared_ptr<string> resVersion{};
  shared_ptr<string> status{};
  shared_ptr<string> vpcId{};

  DescribeCollectorResponseBodyResult() {}

  explicit DescribeCollectorResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (collectorPaths) {
      res["collectorPaths"] = boost::any(*collectorPaths);
    }
    if (configs) {
      vector<boost::any> temp1;
      for(auto item1:*configs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["configs"] = boost::any(temp1);
    }
    if (dryRun) {
      res["dryRun"] = boost::any(*dryRun);
    }
    if (extendConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*extendConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extendConfigs"] = boost::any(temp1);
    }
    if (gmtCreatedTime) {
      res["gmtCreatedTime"] = boost::any(*gmtCreatedTime);
    }
    if (gmtUpdateTime) {
      res["gmtUpdateTime"] = boost::any(*gmtUpdateTime);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (ownerId) {
      res["ownerId"] = boost::any(*ownerId);
    }
    if (resId) {
      res["resId"] = boost::any(*resId);
    }
    if (resType) {
      res["resType"] = boost::any(*resType);
    }
    if (resVersion) {
      res["resVersion"] = boost::any(*resVersion);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("collectorPaths") != m.end() && !m["collectorPaths"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["collectorPaths"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["collectorPaths"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      collectorPaths = make_shared<vector<string>>(toVec1);
    }
    if (m.find("configs") != m.end() && !m["configs"].empty()) {
      if (typeid(vector<boost::any>) == m["configs"].type()) {
        vector<DescribeCollectorResponseBodyResultConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["configs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCollectorResponseBodyResultConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configs = make_shared<vector<DescribeCollectorResponseBodyResultConfigs>>(expect1);
      }
    }
    if (m.find("dryRun") != m.end() && !m["dryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["dryRun"]));
    }
    if (m.find("extendConfigs") != m.end() && !m["extendConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["extendConfigs"].type()) {
        vector<DescribeCollectorResponseBodyResultExtendConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extendConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeCollectorResponseBodyResultExtendConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extendConfigs = make_shared<vector<DescribeCollectorResponseBodyResultExtendConfigs>>(expect1);
      }
    }
    if (m.find("gmtCreatedTime") != m.end() && !m["gmtCreatedTime"].empty()) {
      gmtCreatedTime = make_shared<string>(boost::any_cast<string>(m["gmtCreatedTime"]));
    }
    if (m.find("gmtUpdateTime") != m.end() && !m["gmtUpdateTime"].empty()) {
      gmtUpdateTime = make_shared<string>(boost::any_cast<string>(m["gmtUpdateTime"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("ownerId") != m.end() && !m["ownerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["ownerId"]));
    }
    if (m.find("resId") != m.end() && !m["resId"].empty()) {
      resId = make_shared<string>(boost::any_cast<string>(m["resId"]));
    }
    if (m.find("resType") != m.end() && !m["resType"].empty()) {
      resType = make_shared<string>(boost::any_cast<string>(m["resType"]));
    }
    if (m.find("resVersion") != m.end() && !m["resVersion"].empty()) {
      resVersion = make_shared<string>(boost::any_cast<string>(m["resVersion"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
  }


  virtual ~DescribeCollectorResponseBodyResult() = default;
};
class DescribeCollectorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeCollectorResponseBodyResult> result{};

  DescribeCollectorResponseBody() {}

  explicit DescribeCollectorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeCollectorResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeCollectorResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeCollectorResponseBody() = default;
};
class DescribeCollectorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeCollectorResponseBody> body{};

  DescribeCollectorResponse() {}

  explicit DescribeCollectorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeCollectorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeCollectorResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeCollectorResponse() = default;
};
class DescribeComponentIndexResponseBodyResultTemplate : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> aliases{};
  shared_ptr<map<string, boost::any>> mappings{};
  shared_ptr<map<string, boost::any>> settings{};

  DescribeComponentIndexResponseBodyResultTemplate() {}

  explicit DescribeComponentIndexResponseBodyResultTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliases) {
      res["aliases"] = boost::any(*aliases);
    }
    if (mappings) {
      res["mappings"] = boost::any(*mappings);
    }
    if (settings) {
      res["settings"] = boost::any(*settings);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aliases") != m.end() && !m["aliases"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["aliases"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      aliases = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("mappings") != m.end() && !m["mappings"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["mappings"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      mappings = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("settings") != m.end() && !m["settings"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["settings"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      settings = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~DescribeComponentIndexResponseBodyResultTemplate() = default;
};
class DescribeComponentIndexResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> meta{};
  shared_ptr<DescribeComponentIndexResponseBodyResultTemplate> template_{};

  DescribeComponentIndexResponseBodyResult() {}

  explicit DescribeComponentIndexResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (meta) {
      res["_meta"] = boost::any(*meta);
    }
    if (template_) {
      res["template"] = template_ ? boost::any(template_->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("_meta") != m.end() && !m["_meta"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["_meta"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      meta = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("template") != m.end() && !m["template"].empty()) {
      if (typeid(map<string, boost::any>) == m["template"].type()) {
        DescribeComponentIndexResponseBodyResultTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["template"]));
        template_ = make_shared<DescribeComponentIndexResponseBodyResultTemplate>(model1);
      }
    }
  }


  virtual ~DescribeComponentIndexResponseBodyResult() = default;
};
class DescribeComponentIndexResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeComponentIndexResponseBodyResult> result{};

  DescribeComponentIndexResponseBody() {}

  explicit DescribeComponentIndexResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeComponentIndexResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeComponentIndexResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeComponentIndexResponseBody() = default;
};
class DescribeComponentIndexResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeComponentIndexResponseBody> body{};

  DescribeComponentIndexResponse() {}

  explicit DescribeComponentIndexResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeComponentIndexResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeComponentIndexResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeComponentIndexResponse() = default;
};
class DescribeConnectableClustersRequest : public Darabonba::Model {
public:
  shared_ptr<bool> alreadySetItems{};

  DescribeConnectableClustersRequest() {}

  explicit DescribeConnectableClustersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alreadySetItems) {
      res["alreadySetItems"] = boost::any(*alreadySetItems);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alreadySetItems") != m.end() && !m["alreadySetItems"].empty()) {
      alreadySetItems = make_shared<bool>(boost::any_cast<bool>(m["alreadySetItems"]));
    }
  }


  virtual ~DescribeConnectableClustersRequest() = default;
};
class DescribeConnectableClustersResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> instances{};
  shared_ptr<string> networkType{};

  DescribeConnectableClustersResponseBodyResult() {}

  explicit DescribeConnectableClustersResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instances) {
      res["instances"] = boost::any(*instances);
    }
    if (networkType) {
      res["networkType"] = boost::any(*networkType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instances") != m.end() && !m["instances"].empty()) {
      instances = make_shared<string>(boost::any_cast<string>(m["instances"]));
    }
    if (m.find("networkType") != m.end() && !m["networkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["networkType"]));
    }
  }


  virtual ~DescribeConnectableClustersResponseBodyResult() = default;
};
class DescribeConnectableClustersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeConnectableClustersResponseBodyResult>> result{};

  DescribeConnectableClustersResponseBody() {}

  explicit DescribeConnectableClustersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeConnectableClustersResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeConnectableClustersResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeConnectableClustersResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~DescribeConnectableClustersResponseBody() = default;
};
class DescribeConnectableClustersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeConnectableClustersResponseBody> body{};

  DescribeConnectableClustersResponse() {}

  explicit DescribeConnectableClustersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeConnectableClustersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeConnectableClustersResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeConnectableClustersResponse() = default;
};
class DescribeDeprecatedTemplateResponseBodyResultTemplate : public Darabonba::Model {
public:
  shared_ptr<string> aliases{};
  shared_ptr<string> mappings{};
  shared_ptr<string> settings{};

  DescribeDeprecatedTemplateResponseBodyResultTemplate() {}

  explicit DescribeDeprecatedTemplateResponseBodyResultTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliases) {
      res["aliases"] = boost::any(*aliases);
    }
    if (mappings) {
      res["mappings"] = boost::any(*mappings);
    }
    if (settings) {
      res["settings"] = boost::any(*settings);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aliases") != m.end() && !m["aliases"].empty()) {
      aliases = make_shared<string>(boost::any_cast<string>(m["aliases"]));
    }
    if (m.find("mappings") != m.end() && !m["mappings"].empty()) {
      mappings = make_shared<string>(boost::any_cast<string>(m["mappings"]));
    }
    if (m.find("settings") != m.end() && !m["settings"].empty()) {
      settings = make_shared<string>(boost::any_cast<string>(m["settings"]));
    }
  }


  virtual ~DescribeDeprecatedTemplateResponseBodyResultTemplate() = default;
};
class DescribeDeprecatedTemplateResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> dataStream{};
  shared_ptr<vector<string>> indexPatterns{};
  shared_ptr<string> indexTemplate{};
  shared_ptr<long> order{};
  shared_ptr<DescribeDeprecatedTemplateResponseBodyResultTemplate> template_{};
  shared_ptr<string> version{};

  DescribeDeprecatedTemplateResponseBodyResult() {}

  explicit DescribeDeprecatedTemplateResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataStream) {
      res["dataStream"] = boost::any(*dataStream);
    }
    if (indexPatterns) {
      res["indexPatterns"] = boost::any(*indexPatterns);
    }
    if (indexTemplate) {
      res["indexTemplate"] = boost::any(*indexTemplate);
    }
    if (order) {
      res["order"] = boost::any(*order);
    }
    if (template_) {
      res["template"] = template_ ? boost::any(template_->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dataStream") != m.end() && !m["dataStream"].empty()) {
      dataStream = make_shared<bool>(boost::any_cast<bool>(m["dataStream"]));
    }
    if (m.find("indexPatterns") != m.end() && !m["indexPatterns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["indexPatterns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["indexPatterns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      indexPatterns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("indexTemplate") != m.end() && !m["indexTemplate"].empty()) {
      indexTemplate = make_shared<string>(boost::any_cast<string>(m["indexTemplate"]));
    }
    if (m.find("order") != m.end() && !m["order"].empty()) {
      order = make_shared<long>(boost::any_cast<long>(m["order"]));
    }
    if (m.find("template") != m.end() && !m["template"].empty()) {
      if (typeid(map<string, boost::any>) == m["template"].type()) {
        DescribeDeprecatedTemplateResponseBodyResultTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["template"]));
        template_ = make_shared<DescribeDeprecatedTemplateResponseBodyResultTemplate>(model1);
      }
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
  }


  virtual ~DescribeDeprecatedTemplateResponseBodyResult() = default;
};
class DescribeDeprecatedTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDeprecatedTemplateResponseBodyResult> result{};

  DescribeDeprecatedTemplateResponseBody() {}

  explicit DescribeDeprecatedTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeDeprecatedTemplateResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeDeprecatedTemplateResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeDeprecatedTemplateResponseBody() = default;
};
class DescribeDeprecatedTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDeprecatedTemplateResponseBody> body{};

  DescribeDeprecatedTemplateResponse() {}

  explicit DescribeDeprecatedTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDeprecatedTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDeprecatedTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDeprecatedTemplateResponse() = default;
};
class DescribeDiagnoseReportRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};

  DescribeDiagnoseReportRequest() {}

  explicit DescribeDiagnoseReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("lang") != m.end() && !m["lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["lang"]));
    }
  }


  virtual ~DescribeDiagnoseReportRequest() = default;
};
class DescribeDiagnoseReportResponseBodyResultDiagnoseItemsDetail : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> name{};
  shared_ptr<string> result{};
  shared_ptr<string> suggest{};
  shared_ptr<string> type{};

  DescribeDiagnoseReportResponseBodyResultDiagnoseItemsDetail() {}

  explicit DescribeDiagnoseReportResponseBodyResultDiagnoseItemsDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["desc"] = boost::any(*desc);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    if (suggest) {
      res["suggest"] = boost::any(*suggest);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("desc") != m.end() && !m["desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["desc"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["result"]));
    }
    if (m.find("suggest") != m.end() && !m["suggest"].empty()) {
      suggest = make_shared<string>(boost::any_cast<string>(m["suggest"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeDiagnoseReportResponseBodyResultDiagnoseItemsDetail() = default;
};
class DescribeDiagnoseReportResponseBodyResultDiagnoseItems : public Darabonba::Model {
public:
  shared_ptr<DescribeDiagnoseReportResponseBodyResultDiagnoseItemsDetail> detail{};
  shared_ptr<string> health{};
  shared_ptr<string> item{};

  DescribeDiagnoseReportResponseBodyResultDiagnoseItems() {}

  explicit DescribeDiagnoseReportResponseBodyResultDiagnoseItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detail) {
      res["detail"] = detail ? boost::any(detail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (health) {
      res["health"] = boost::any(*health);
    }
    if (item) {
      res["item"] = boost::any(*item);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("detail") != m.end() && !m["detail"].empty()) {
      if (typeid(map<string, boost::any>) == m["detail"].type()) {
        DescribeDiagnoseReportResponseBodyResultDiagnoseItemsDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["detail"]));
        detail = make_shared<DescribeDiagnoseReportResponseBodyResultDiagnoseItemsDetail>(model1);
      }
    }
    if (m.find("health") != m.end() && !m["health"].empty()) {
      health = make_shared<string>(boost::any_cast<string>(m["health"]));
    }
    if (m.find("item") != m.end() && !m["item"].empty()) {
      item = make_shared<string>(boost::any_cast<string>(m["item"]));
    }
  }


  virtual ~DescribeDiagnoseReportResponseBodyResultDiagnoseItems() = default;
};
class DescribeDiagnoseReportResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<vector<DescribeDiagnoseReportResponseBodyResultDiagnoseItems>> diagnoseItems{};
  shared_ptr<string> health{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> reportId{};
  shared_ptr<string> state{};
  shared_ptr<string> trigger{};

  DescribeDiagnoseReportResponseBodyResult() {}

  explicit DescribeDiagnoseReportResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (diagnoseItems) {
      vector<boost::any> temp1;
      for(auto item1:*diagnoseItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["diagnoseItems"] = boost::any(temp1);
    }
    if (health) {
      res["health"] = boost::any(*health);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (reportId) {
      res["reportId"] = boost::any(*reportId);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (trigger) {
      res["trigger"] = boost::any(*trigger);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["createTime"]));
    }
    if (m.find("diagnoseItems") != m.end() && !m["diagnoseItems"].empty()) {
      if (typeid(vector<boost::any>) == m["diagnoseItems"].type()) {
        vector<DescribeDiagnoseReportResponseBodyResultDiagnoseItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["diagnoseItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeDiagnoseReportResponseBodyResultDiagnoseItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        diagnoseItems = make_shared<vector<DescribeDiagnoseReportResponseBodyResultDiagnoseItems>>(expect1);
      }
    }
    if (m.find("health") != m.end() && !m["health"].empty()) {
      health = make_shared<string>(boost::any_cast<string>(m["health"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("reportId") != m.end() && !m["reportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["reportId"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("trigger") != m.end() && !m["trigger"].empty()) {
      trigger = make_shared<string>(boost::any_cast<string>(m["trigger"]));
    }
  }


  virtual ~DescribeDiagnoseReportResponseBodyResult() = default;
};
class DescribeDiagnoseReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDiagnoseReportResponseBodyResult> result{};

  DescribeDiagnoseReportResponseBody() {}

  explicit DescribeDiagnoseReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeDiagnoseReportResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeDiagnoseReportResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeDiagnoseReportResponseBody() = default;
};
class DescribeDiagnoseReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDiagnoseReportResponseBody> body{};

  DescribeDiagnoseReportResponse() {}

  explicit DescribeDiagnoseReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDiagnoseReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDiagnoseReportResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDiagnoseReportResponse() = default;
};
class DescribeDiagnosisSettingsRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};

  DescribeDiagnosisSettingsRequest() {}

  explicit DescribeDiagnosisSettingsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("lang") != m.end() && !m["lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["lang"]));
    }
  }


  virtual ~DescribeDiagnosisSettingsRequest() = default;
};
class DescribeDiagnosisSettingsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> scene{};
  shared_ptr<long> updateTime{};

  DescribeDiagnosisSettingsResponseBodyResult() {}

  explicit DescribeDiagnosisSettingsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (scene) {
      res["scene"] = boost::any(*scene);
    }
    if (updateTime) {
      res["updateTime"] = boost::any(*updateTime);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("scene") != m.end() && !m["scene"].empty()) {
      scene = make_shared<string>(boost::any_cast<string>(m["scene"]));
    }
    if (m.find("updateTime") != m.end() && !m["updateTime"].empty()) {
      updateTime = make_shared<long>(boost::any_cast<long>(m["updateTime"]));
    }
  }


  virtual ~DescribeDiagnosisSettingsResponseBodyResult() = default;
};
class DescribeDiagnosisSettingsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeDiagnosisSettingsResponseBodyResult> result{};

  DescribeDiagnosisSettingsResponseBody() {}

  explicit DescribeDiagnosisSettingsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeDiagnosisSettingsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeDiagnosisSettingsResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeDiagnosisSettingsResponseBody() = default;
};
class DescribeDiagnosisSettingsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDiagnosisSettingsResponseBody> body{};

  DescribeDiagnosisSettingsResponse() {}

  explicit DescribeDiagnosisSettingsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDiagnosisSettingsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDiagnosisSettingsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDiagnosisSettingsResponse() = default;
};
class DescribeDynamicSettingsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  DescribeDynamicSettingsResponseBody() {}

  explicit DescribeDynamicSettingsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~DescribeDynamicSettingsResponseBody() = default;
};
class DescribeDynamicSettingsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeDynamicSettingsResponseBody> body{};

  DescribeDynamicSettingsResponse() {}

  explicit DescribeDynamicSettingsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeDynamicSettingsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeDynamicSettingsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeDynamicSettingsResponse() = default;
};
class DescribeElasticsearchHealthResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  DescribeElasticsearchHealthResponseBody() {}

  explicit DescribeElasticsearchHealthResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~DescribeElasticsearchHealthResponseBody() = default;
};
class DescribeElasticsearchHealthResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeElasticsearchHealthResponseBody> body{};

  DescribeElasticsearchHealthResponse() {}

  explicit DescribeElasticsearchHealthResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeElasticsearchHealthResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeElasticsearchHealthResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeElasticsearchHealthResponse() = default;
};
class DescribeILMPolicyResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<map<string, boost::any>> phases{};

  DescribeILMPolicyResponseBodyResult() {}

  explicit DescribeILMPolicyResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (phases) {
      res["phases"] = boost::any(*phases);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("phases") != m.end() && !m["phases"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["phases"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      phases = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~DescribeILMPolicyResponseBodyResult() = default;
};
class DescribeILMPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeILMPolicyResponseBodyResult> result{};

  DescribeILMPolicyResponseBody() {}

  explicit DescribeILMPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeILMPolicyResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeILMPolicyResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeILMPolicyResponseBody() = default;
};
class DescribeILMPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeILMPolicyResponseBody> body{};

  DescribeILMPolicyResponse() {}

  explicit DescribeILMPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeILMPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeILMPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeILMPolicyResponse() = default;
};
class DescribeIndexTemplateResponseBodyResultTemplate : public Darabonba::Model {
public:
  shared_ptr<string> aliases{};
  shared_ptr<string> mappings{};
  shared_ptr<string> settings{};

  DescribeIndexTemplateResponseBodyResultTemplate() {}

  explicit DescribeIndexTemplateResponseBodyResultTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliases) {
      res["aliases"] = boost::any(*aliases);
    }
    if (mappings) {
      res["mappings"] = boost::any(*mappings);
    }
    if (settings) {
      res["settings"] = boost::any(*settings);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aliases") != m.end() && !m["aliases"].empty()) {
      aliases = make_shared<string>(boost::any_cast<string>(m["aliases"]));
    }
    if (m.find("mappings") != m.end() && !m["mappings"].empty()) {
      mappings = make_shared<string>(boost::any_cast<string>(m["mappings"]));
    }
    if (m.find("settings") != m.end() && !m["settings"].empty()) {
      settings = make_shared<string>(boost::any_cast<string>(m["settings"]));
    }
  }


  virtual ~DescribeIndexTemplateResponseBodyResultTemplate() = default;
};
class DescribeIndexTemplateResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> dataStream{};
  shared_ptr<string> ilmPolicy{};
  shared_ptr<vector<string>> indexPatterns{};
  shared_ptr<string> indexTemplate{};
  shared_ptr<long> priority{};
  shared_ptr<DescribeIndexTemplateResponseBodyResultTemplate> template_{};

  DescribeIndexTemplateResponseBodyResult() {}

  explicit DescribeIndexTemplateResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataStream) {
      res["dataStream"] = boost::any(*dataStream);
    }
    if (ilmPolicy) {
      res["ilmPolicy"] = boost::any(*ilmPolicy);
    }
    if (indexPatterns) {
      res["indexPatterns"] = boost::any(*indexPatterns);
    }
    if (indexTemplate) {
      res["indexTemplate"] = boost::any(*indexTemplate);
    }
    if (priority) {
      res["priority"] = boost::any(*priority);
    }
    if (template_) {
      res["template"] = template_ ? boost::any(template_->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dataStream") != m.end() && !m["dataStream"].empty()) {
      dataStream = make_shared<bool>(boost::any_cast<bool>(m["dataStream"]));
    }
    if (m.find("ilmPolicy") != m.end() && !m["ilmPolicy"].empty()) {
      ilmPolicy = make_shared<string>(boost::any_cast<string>(m["ilmPolicy"]));
    }
    if (m.find("indexPatterns") != m.end() && !m["indexPatterns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["indexPatterns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["indexPatterns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      indexPatterns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("indexTemplate") != m.end() && !m["indexTemplate"].empty()) {
      indexTemplate = make_shared<string>(boost::any_cast<string>(m["indexTemplate"]));
    }
    if (m.find("priority") != m.end() && !m["priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["priority"]));
    }
    if (m.find("template") != m.end() && !m["template"].empty()) {
      if (typeid(map<string, boost::any>) == m["template"].type()) {
        DescribeIndexTemplateResponseBodyResultTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["template"]));
        template_ = make_shared<DescribeIndexTemplateResponseBodyResultTemplate>(model1);
      }
    }
  }


  virtual ~DescribeIndexTemplateResponseBodyResult() = default;
};
class DescribeIndexTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeIndexTemplateResponseBodyResult> result{};

  DescribeIndexTemplateResponseBody() {}

  explicit DescribeIndexTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeIndexTemplateResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeIndexTemplateResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeIndexTemplateResponseBody() = default;
};
class DescribeIndexTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeIndexTemplateResponseBody> body{};

  DescribeIndexTemplateResponse() {}

  explicit DescribeIndexTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeIndexTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeIndexTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeIndexTemplateResponse() = default;
};
class DescribeInstanceResponseBodyResultAdvancedSetting : public Darabonba::Model {
public:
  shared_ptr<string> gcName{};

  DescribeInstanceResponseBodyResultAdvancedSetting() {}

  explicit DescribeInstanceResponseBodyResultAdvancedSetting(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gcName) {
      res["gcName"] = boost::any(*gcName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gcName") != m.end() && !m["gcName"].empty()) {
      gcName = make_shared<string>(boost::any_cast<string>(m["gcName"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyResultAdvancedSetting() = default;
};
class DescribeInstanceResponseBodyResultAliwsDicts : public Darabonba::Model {
public:
  shared_ptr<long> fileSize{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> type{};

  DescribeInstanceResponseBodyResultAliwsDicts() {}

  explicit DescribeInstanceResponseBodyResultAliwsDicts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileSize) {
      res["fileSize"] = boost::any(*fileSize);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fileSize") != m.end() && !m["fileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["fileSize"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyResultAliwsDicts() = default;
};
class DescribeInstanceResponseBodyResultClientNodeConfiguration : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<long> disk{};
  shared_ptr<string> diskType{};
  shared_ptr<string> spec{};

  DescribeInstanceResponseBodyResultClientNodeConfiguration() {}

  explicit DescribeInstanceResponseBodyResultClientNodeConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["amount"]));
    }
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyResultClientNodeConfiguration() = default;
};
class DescribeInstanceResponseBodyResultDictList : public Darabonba::Model {
public:
  shared_ptr<long> fileSize{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> type{};

  DescribeInstanceResponseBodyResultDictList() {}

  explicit DescribeInstanceResponseBodyResultDictList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileSize) {
      res["fileSize"] = boost::any(*fileSize);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fileSize") != m.end() && !m["fileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["fileSize"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyResultDictList() = default;
};
class DescribeInstanceResponseBodyResultElasticDataNodeConfiguration : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<long> disk{};
  shared_ptr<bool> diskEncryption{};
  shared_ptr<string> diskType{};
  shared_ptr<string> spec{};

  DescribeInstanceResponseBodyResultElasticDataNodeConfiguration() {}

  explicit DescribeInstanceResponseBodyResultElasticDataNodeConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskEncryption) {
      res["diskEncryption"] = boost::any(*diskEncryption);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["amount"]));
    }
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskEncryption") != m.end() && !m["diskEncryption"].empty()) {
      diskEncryption = make_shared<bool>(boost::any_cast<bool>(m["diskEncryption"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyResultElasticDataNodeConfiguration() = default;
};
class DescribeInstanceResponseBodyResultKibanaConfiguration : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<string> spec{};

  DescribeInstanceResponseBodyResultKibanaConfiguration() {}

  explicit DescribeInstanceResponseBodyResultKibanaConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["amount"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyResultKibanaConfiguration() = default;
};
class DescribeInstanceResponseBodyResultMasterConfiguration : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<long> disk{};
  shared_ptr<string> diskType{};
  shared_ptr<string> spec{};

  DescribeInstanceResponseBodyResultMasterConfiguration() {}

  explicit DescribeInstanceResponseBodyResultMasterConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["amount"]));
    }
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyResultMasterConfiguration() = default;
};
class DescribeInstanceResponseBodyResultNetworkConfigWhiteIpGroupList : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<vector<string>> ips{};
  shared_ptr<string> whiteIpType{};

  DescribeInstanceResponseBodyResultNetworkConfigWhiteIpGroupList() {}

  explicit DescribeInstanceResponseBodyResultNetworkConfigWhiteIpGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["groupName"] = boost::any(*groupName);
    }
    if (ips) {
      res["ips"] = boost::any(*ips);
    }
    if (whiteIpType) {
      res["whiteIpType"] = boost::any(*whiteIpType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("groupName") != m.end() && !m["groupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["groupName"]));
    }
    if (m.find("ips") != m.end() && !m["ips"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ips"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ips"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ips = make_shared<vector<string>>(toVec1);
    }
    if (m.find("whiteIpType") != m.end() && !m["whiteIpType"].empty()) {
      whiteIpType = make_shared<string>(boost::any_cast<string>(m["whiteIpType"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyResultNetworkConfigWhiteIpGroupList() = default;
};
class DescribeInstanceResponseBodyResultNetworkConfig : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vsArea{};
  shared_ptr<string> vswitchId{};
  shared_ptr<vector<DescribeInstanceResponseBodyResultNetworkConfigWhiteIpGroupList>> whiteIpGroupList{};

  DescribeInstanceResponseBodyResultNetworkConfig() {}

  explicit DescribeInstanceResponseBodyResultNetworkConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    if (vsArea) {
      res["vsArea"] = boost::any(*vsArea);
    }
    if (vswitchId) {
      res["vswitchId"] = boost::any(*vswitchId);
    }
    if (whiteIpGroupList) {
      vector<boost::any> temp1;
      for(auto item1:*whiteIpGroupList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["whiteIpGroupList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
    if (m.find("vsArea") != m.end() && !m["vsArea"].empty()) {
      vsArea = make_shared<string>(boost::any_cast<string>(m["vsArea"]));
    }
    if (m.find("vswitchId") != m.end() && !m["vswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["vswitchId"]));
    }
    if (m.find("whiteIpGroupList") != m.end() && !m["whiteIpGroupList"].empty()) {
      if (typeid(vector<boost::any>) == m["whiteIpGroupList"].type()) {
        vector<DescribeInstanceResponseBodyResultNetworkConfigWhiteIpGroupList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["whiteIpGroupList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceResponseBodyResultNetworkConfigWhiteIpGroupList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        whiteIpGroupList = make_shared<vector<DescribeInstanceResponseBodyResultNetworkConfigWhiteIpGroupList>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceResponseBodyResultNetworkConfig() = default;
};
class DescribeInstanceResponseBodyResultNodeSpec : public Darabonba::Model {
public:
  shared_ptr<long> disk{};
  shared_ptr<bool> diskEncryption{};
  shared_ptr<string> diskType{};
  shared_ptr<string> spec{};

  DescribeInstanceResponseBodyResultNodeSpec() {}

  explicit DescribeInstanceResponseBodyResultNodeSpec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskEncryption) {
      res["diskEncryption"] = boost::any(*diskEncryption);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskEncryption") != m.end() && !m["diskEncryption"].empty()) {
      diskEncryption = make_shared<bool>(boost::any_cast<bool>(m["diskEncryption"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyResultNodeSpec() = default;
};
class DescribeInstanceResponseBodyResultSynonymsDicts : public Darabonba::Model {
public:
  shared_ptr<long> fileSize{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> type{};

  DescribeInstanceResponseBodyResultSynonymsDicts() {}

  explicit DescribeInstanceResponseBodyResultSynonymsDicts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileSize) {
      res["fileSize"] = boost::any(*fileSize);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fileSize") != m.end() && !m["fileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["fileSize"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyResultSynonymsDicts() = default;
};
class DescribeInstanceResponseBodyResultTags : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  DescribeInstanceResponseBodyResultTags() {}

  explicit DescribeInstanceResponseBodyResultTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["tagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["tagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tagKey") != m.end() && !m["tagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["tagKey"]));
    }
    if (m.find("tagValue") != m.end() && !m["tagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["tagValue"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyResultTags() = default;
};
class DescribeInstanceResponseBodyResultWarmNodeConfiguration : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<long> disk{};
  shared_ptr<bool> diskEncryption{};
  shared_ptr<string> diskType{};
  shared_ptr<string> spec{};

  DescribeInstanceResponseBodyResultWarmNodeConfiguration() {}

  explicit DescribeInstanceResponseBodyResultWarmNodeConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskEncryption) {
      res["diskEncryption"] = boost::any(*diskEncryption);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["amount"]));
    }
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskEncryption") != m.end() && !m["diskEncryption"].empty()) {
      diskEncryption = make_shared<bool>(boost::any_cast<bool>(m["diskEncryption"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyResultWarmNodeConfiguration() = default;
};
class DescribeInstanceResponseBodyResultZoneInfos : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> zoneId{};

  DescribeInstanceResponseBodyResultZoneInfos() {}

  explicit DescribeInstanceResponseBodyResultZoneInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (zoneId) {
      res["zoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("zoneId") != m.end() && !m["zoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["zoneId"]));
    }
  }


  virtual ~DescribeInstanceResponseBodyResultZoneInfos() = default;
};
class DescribeInstanceResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> advancedDedicateMaster{};
  shared_ptr<DescribeInstanceResponseBodyResultAdvancedSetting> advancedSetting{};
  shared_ptr<vector<DescribeInstanceResponseBodyResultAliwsDicts>> aliwsDicts{};
  shared_ptr<DescribeInstanceResponseBodyResultClientNodeConfiguration> clientNodeConfiguration{};
  shared_ptr<string> createdAt{};
  shared_ptr<bool> dedicateMaster{};
  shared_ptr<string> description{};
  shared_ptr<vector<DescribeInstanceResponseBodyResultDictList>> dictList{};
  shared_ptr<string> domain{};
  shared_ptr<DescribeInstanceResponseBodyResultElasticDataNodeConfiguration> elasticDataNodeConfiguration{};
  shared_ptr<bool> enableKibanaPrivateNetwork{};
  shared_ptr<bool> enableKibanaPublicNetwork{};
  shared_ptr<bool> enablePublic{};
  shared_ptr<map<string, boost::any>> esConfig{};
  shared_ptr<vector<string>> esIPBlacklist{};
  shared_ptr<vector<string>> esIPWhitelist{};
  shared_ptr<string> esVersion{};
  shared_ptr<vector<map<string, boost::any>>> extendConfigs{};
  shared_ptr<bool> haveClientNode{};
  shared_ptr<bool> haveKibana{};
  shared_ptr<string> instanceId{};
  shared_ptr<bool> isNewDeployment{};
  shared_ptr<DescribeInstanceResponseBodyResultKibanaConfiguration> kibanaConfiguration{};
  shared_ptr<string> kibanaDomain{};
  shared_ptr<vector<string>> kibanaIPWhitelist{};
  shared_ptr<long> kibanaPort{};
  shared_ptr<vector<string>> kibanaPrivateIPWhitelist{};
  shared_ptr<DescribeInstanceResponseBodyResultMasterConfiguration> masterConfiguration{};
  shared_ptr<DescribeInstanceResponseBodyResultNetworkConfig> networkConfig{};
  shared_ptr<long> nodeAmount{};
  shared_ptr<DescribeInstanceResponseBodyResultNodeSpec> nodeSpec{};
  shared_ptr<string> paymentType{};
  shared_ptr<long> port{};
  shared_ptr<string> postpaidServiceStatus{};
  shared_ptr<vector<string>> privateNetworkIpWhiteList{};
  shared_ptr<string> protocol{};
  shared_ptr<string> publicDomain{};
  shared_ptr<vector<string>> publicIpWhitelist{};
  shared_ptr<long> publicPort{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> serviceVpc{};
  shared_ptr<string> status{};
  shared_ptr<vector<DescribeInstanceResponseBodyResultSynonymsDicts>> synonymsDicts{};
  shared_ptr<vector<DescribeInstanceResponseBodyResultTags>> tags{};
  shared_ptr<string> updatedAt{};
  shared_ptr<string> vpcInstanceId{};
  shared_ptr<bool> warmNode{};
  shared_ptr<DescribeInstanceResponseBodyResultWarmNodeConfiguration> warmNodeConfiguration{};
  shared_ptr<long> zoneCount{};
  shared_ptr<vector<DescribeInstanceResponseBodyResultZoneInfos>> zoneInfos{};

  DescribeInstanceResponseBodyResult() {}

  explicit DescribeInstanceResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advancedDedicateMaster) {
      res["advancedDedicateMaster"] = boost::any(*advancedDedicateMaster);
    }
    if (advancedSetting) {
      res["advancedSetting"] = advancedSetting ? boost::any(advancedSetting->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (aliwsDicts) {
      vector<boost::any> temp1;
      for(auto item1:*aliwsDicts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["aliwsDicts"] = boost::any(temp1);
    }
    if (clientNodeConfiguration) {
      res["clientNodeConfiguration"] = clientNodeConfiguration ? boost::any(clientNodeConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (dedicateMaster) {
      res["dedicateMaster"] = boost::any(*dedicateMaster);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (dictList) {
      vector<boost::any> temp1;
      for(auto item1:*dictList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["dictList"] = boost::any(temp1);
    }
    if (domain) {
      res["domain"] = boost::any(*domain);
    }
    if (elasticDataNodeConfiguration) {
      res["elasticDataNodeConfiguration"] = elasticDataNodeConfiguration ? boost::any(elasticDataNodeConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (enableKibanaPrivateNetwork) {
      res["enableKibanaPrivateNetwork"] = boost::any(*enableKibanaPrivateNetwork);
    }
    if (enableKibanaPublicNetwork) {
      res["enableKibanaPublicNetwork"] = boost::any(*enableKibanaPublicNetwork);
    }
    if (enablePublic) {
      res["enablePublic"] = boost::any(*enablePublic);
    }
    if (esConfig) {
      res["esConfig"] = boost::any(*esConfig);
    }
    if (esIPBlacklist) {
      res["esIPBlacklist"] = boost::any(*esIPBlacklist);
    }
    if (esIPWhitelist) {
      res["esIPWhitelist"] = boost::any(*esIPWhitelist);
    }
    if (esVersion) {
      res["esVersion"] = boost::any(*esVersion);
    }
    if (extendConfigs) {
      res["extendConfigs"] = boost::any(*extendConfigs);
    }
    if (haveClientNode) {
      res["haveClientNode"] = boost::any(*haveClientNode);
    }
    if (haveKibana) {
      res["haveKibana"] = boost::any(*haveKibana);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (isNewDeployment) {
      res["isNewDeployment"] = boost::any(*isNewDeployment);
    }
    if (kibanaConfiguration) {
      res["kibanaConfiguration"] = kibanaConfiguration ? boost::any(kibanaConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (kibanaDomain) {
      res["kibanaDomain"] = boost::any(*kibanaDomain);
    }
    if (kibanaIPWhitelist) {
      res["kibanaIPWhitelist"] = boost::any(*kibanaIPWhitelist);
    }
    if (kibanaPort) {
      res["kibanaPort"] = boost::any(*kibanaPort);
    }
    if (kibanaPrivateIPWhitelist) {
      res["kibanaPrivateIPWhitelist"] = boost::any(*kibanaPrivateIPWhitelist);
    }
    if (masterConfiguration) {
      res["masterConfiguration"] = masterConfiguration ? boost::any(masterConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (networkConfig) {
      res["networkConfig"] = networkConfig ? boost::any(networkConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodeAmount) {
      res["nodeAmount"] = boost::any(*nodeAmount);
    }
    if (nodeSpec) {
      res["nodeSpec"] = nodeSpec ? boost::any(nodeSpec->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (paymentType) {
      res["paymentType"] = boost::any(*paymentType);
    }
    if (port) {
      res["port"] = boost::any(*port);
    }
    if (postpaidServiceStatus) {
      res["postpaidServiceStatus"] = boost::any(*postpaidServiceStatus);
    }
    if (privateNetworkIpWhiteList) {
      res["privateNetworkIpWhiteList"] = boost::any(*privateNetworkIpWhiteList);
    }
    if (protocol) {
      res["protocol"] = boost::any(*protocol);
    }
    if (publicDomain) {
      res["publicDomain"] = boost::any(*publicDomain);
    }
    if (publicIpWhitelist) {
      res["publicIpWhitelist"] = boost::any(*publicIpWhitelist);
    }
    if (publicPort) {
      res["publicPort"] = boost::any(*publicPort);
    }
    if (resourceGroupId) {
      res["resourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (serviceVpc) {
      res["serviceVpc"] = boost::any(*serviceVpc);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (synonymsDicts) {
      vector<boost::any> temp1;
      for(auto item1:*synonymsDicts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["synonymsDicts"] = boost::any(temp1);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tags"] = boost::any(temp1);
    }
    if (updatedAt) {
      res["updatedAt"] = boost::any(*updatedAt);
    }
    if (vpcInstanceId) {
      res["vpcInstanceId"] = boost::any(*vpcInstanceId);
    }
    if (warmNode) {
      res["warmNode"] = boost::any(*warmNode);
    }
    if (warmNodeConfiguration) {
      res["warmNodeConfiguration"] = warmNodeConfiguration ? boost::any(warmNodeConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (zoneCount) {
      res["zoneCount"] = boost::any(*zoneCount);
    }
    if (zoneInfos) {
      vector<boost::any> temp1;
      for(auto item1:*zoneInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["zoneInfos"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("advancedDedicateMaster") != m.end() && !m["advancedDedicateMaster"].empty()) {
      advancedDedicateMaster = make_shared<bool>(boost::any_cast<bool>(m["advancedDedicateMaster"]));
    }
    if (m.find("advancedSetting") != m.end() && !m["advancedSetting"].empty()) {
      if (typeid(map<string, boost::any>) == m["advancedSetting"].type()) {
        DescribeInstanceResponseBodyResultAdvancedSetting model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["advancedSetting"]));
        advancedSetting = make_shared<DescribeInstanceResponseBodyResultAdvancedSetting>(model1);
      }
    }
    if (m.find("aliwsDicts") != m.end() && !m["aliwsDicts"].empty()) {
      if (typeid(vector<boost::any>) == m["aliwsDicts"].type()) {
        vector<DescribeInstanceResponseBodyResultAliwsDicts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["aliwsDicts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceResponseBodyResultAliwsDicts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        aliwsDicts = make_shared<vector<DescribeInstanceResponseBodyResultAliwsDicts>>(expect1);
      }
    }
    if (m.find("clientNodeConfiguration") != m.end() && !m["clientNodeConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["clientNodeConfiguration"].type()) {
        DescribeInstanceResponseBodyResultClientNodeConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["clientNodeConfiguration"]));
        clientNodeConfiguration = make_shared<DescribeInstanceResponseBodyResultClientNodeConfiguration>(model1);
      }
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("dedicateMaster") != m.end() && !m["dedicateMaster"].empty()) {
      dedicateMaster = make_shared<bool>(boost::any_cast<bool>(m["dedicateMaster"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("dictList") != m.end() && !m["dictList"].empty()) {
      if (typeid(vector<boost::any>) == m["dictList"].type()) {
        vector<DescribeInstanceResponseBodyResultDictList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["dictList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceResponseBodyResultDictList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dictList = make_shared<vector<DescribeInstanceResponseBodyResultDictList>>(expect1);
      }
    }
    if (m.find("domain") != m.end() && !m["domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["domain"]));
    }
    if (m.find("elasticDataNodeConfiguration") != m.end() && !m["elasticDataNodeConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["elasticDataNodeConfiguration"].type()) {
        DescribeInstanceResponseBodyResultElasticDataNodeConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["elasticDataNodeConfiguration"]));
        elasticDataNodeConfiguration = make_shared<DescribeInstanceResponseBodyResultElasticDataNodeConfiguration>(model1);
      }
    }
    if (m.find("enableKibanaPrivateNetwork") != m.end() && !m["enableKibanaPrivateNetwork"].empty()) {
      enableKibanaPrivateNetwork = make_shared<bool>(boost::any_cast<bool>(m["enableKibanaPrivateNetwork"]));
    }
    if (m.find("enableKibanaPublicNetwork") != m.end() && !m["enableKibanaPublicNetwork"].empty()) {
      enableKibanaPublicNetwork = make_shared<bool>(boost::any_cast<bool>(m["enableKibanaPublicNetwork"]));
    }
    if (m.find("enablePublic") != m.end() && !m["enablePublic"].empty()) {
      enablePublic = make_shared<bool>(boost::any_cast<bool>(m["enablePublic"]));
    }
    if (m.find("esConfig") != m.end() && !m["esConfig"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["esConfig"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      esConfig = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("esIPBlacklist") != m.end() && !m["esIPBlacklist"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["esIPBlacklist"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["esIPBlacklist"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      esIPBlacklist = make_shared<vector<string>>(toVec1);
    }
    if (m.find("esIPWhitelist") != m.end() && !m["esIPWhitelist"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["esIPWhitelist"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["esIPWhitelist"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      esIPWhitelist = make_shared<vector<string>>(toVec1);
    }
    if (m.find("esVersion") != m.end() && !m["esVersion"].empty()) {
      esVersion = make_shared<string>(boost::any_cast<string>(m["esVersion"]));
    }
    if (m.find("extendConfigs") != m.end() && !m["extendConfigs"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["extendConfigs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["extendConfigs"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      extendConfigs = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("haveClientNode") != m.end() && !m["haveClientNode"].empty()) {
      haveClientNode = make_shared<bool>(boost::any_cast<bool>(m["haveClientNode"]));
    }
    if (m.find("haveKibana") != m.end() && !m["haveKibana"].empty()) {
      haveKibana = make_shared<bool>(boost::any_cast<bool>(m["haveKibana"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("isNewDeployment") != m.end() && !m["isNewDeployment"].empty()) {
      isNewDeployment = make_shared<bool>(boost::any_cast<bool>(m["isNewDeployment"]));
    }
    if (m.find("kibanaConfiguration") != m.end() && !m["kibanaConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["kibanaConfiguration"].type()) {
        DescribeInstanceResponseBodyResultKibanaConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["kibanaConfiguration"]));
        kibanaConfiguration = make_shared<DescribeInstanceResponseBodyResultKibanaConfiguration>(model1);
      }
    }
    if (m.find("kibanaDomain") != m.end() && !m["kibanaDomain"].empty()) {
      kibanaDomain = make_shared<string>(boost::any_cast<string>(m["kibanaDomain"]));
    }
    if (m.find("kibanaIPWhitelist") != m.end() && !m["kibanaIPWhitelist"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["kibanaIPWhitelist"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["kibanaIPWhitelist"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      kibanaIPWhitelist = make_shared<vector<string>>(toVec1);
    }
    if (m.find("kibanaPort") != m.end() && !m["kibanaPort"].empty()) {
      kibanaPort = make_shared<long>(boost::any_cast<long>(m["kibanaPort"]));
    }
    if (m.find("kibanaPrivateIPWhitelist") != m.end() && !m["kibanaPrivateIPWhitelist"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["kibanaPrivateIPWhitelist"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["kibanaPrivateIPWhitelist"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      kibanaPrivateIPWhitelist = make_shared<vector<string>>(toVec1);
    }
    if (m.find("masterConfiguration") != m.end() && !m["masterConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["masterConfiguration"].type()) {
        DescribeInstanceResponseBodyResultMasterConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["masterConfiguration"]));
        masterConfiguration = make_shared<DescribeInstanceResponseBodyResultMasterConfiguration>(model1);
      }
    }
    if (m.find("networkConfig") != m.end() && !m["networkConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["networkConfig"].type()) {
        DescribeInstanceResponseBodyResultNetworkConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["networkConfig"]));
        networkConfig = make_shared<DescribeInstanceResponseBodyResultNetworkConfig>(model1);
      }
    }
    if (m.find("nodeAmount") != m.end() && !m["nodeAmount"].empty()) {
      nodeAmount = make_shared<long>(boost::any_cast<long>(m["nodeAmount"]));
    }
    if (m.find("nodeSpec") != m.end() && !m["nodeSpec"].empty()) {
      if (typeid(map<string, boost::any>) == m["nodeSpec"].type()) {
        DescribeInstanceResponseBodyResultNodeSpec model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["nodeSpec"]));
        nodeSpec = make_shared<DescribeInstanceResponseBodyResultNodeSpec>(model1);
      }
    }
    if (m.find("paymentType") != m.end() && !m["paymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["paymentType"]));
    }
    if (m.find("port") != m.end() && !m["port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["port"]));
    }
    if (m.find("postpaidServiceStatus") != m.end() && !m["postpaidServiceStatus"].empty()) {
      postpaidServiceStatus = make_shared<string>(boost::any_cast<string>(m["postpaidServiceStatus"]));
    }
    if (m.find("privateNetworkIpWhiteList") != m.end() && !m["privateNetworkIpWhiteList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["privateNetworkIpWhiteList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["privateNetworkIpWhiteList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      privateNetworkIpWhiteList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("protocol") != m.end() && !m["protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["protocol"]));
    }
    if (m.find("publicDomain") != m.end() && !m["publicDomain"].empty()) {
      publicDomain = make_shared<string>(boost::any_cast<string>(m["publicDomain"]));
    }
    if (m.find("publicIpWhitelist") != m.end() && !m["publicIpWhitelist"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["publicIpWhitelist"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["publicIpWhitelist"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      publicIpWhitelist = make_shared<vector<string>>(toVec1);
    }
    if (m.find("publicPort") != m.end() && !m["publicPort"].empty()) {
      publicPort = make_shared<long>(boost::any_cast<long>(m["publicPort"]));
    }
    if (m.find("resourceGroupId") != m.end() && !m["resourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["resourceGroupId"]));
    }
    if (m.find("serviceVpc") != m.end() && !m["serviceVpc"].empty()) {
      serviceVpc = make_shared<bool>(boost::any_cast<bool>(m["serviceVpc"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("synonymsDicts") != m.end() && !m["synonymsDicts"].empty()) {
      if (typeid(vector<boost::any>) == m["synonymsDicts"].type()) {
        vector<DescribeInstanceResponseBodyResultSynonymsDicts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["synonymsDicts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceResponseBodyResultSynonymsDicts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        synonymsDicts = make_shared<vector<DescribeInstanceResponseBodyResultSynonymsDicts>>(expect1);
      }
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<DescribeInstanceResponseBodyResultTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceResponseBodyResultTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeInstanceResponseBodyResultTags>>(expect1);
      }
    }
    if (m.find("updatedAt") != m.end() && !m["updatedAt"].empty()) {
      updatedAt = make_shared<string>(boost::any_cast<string>(m["updatedAt"]));
    }
    if (m.find("vpcInstanceId") != m.end() && !m["vpcInstanceId"].empty()) {
      vpcInstanceId = make_shared<string>(boost::any_cast<string>(m["vpcInstanceId"]));
    }
    if (m.find("warmNode") != m.end() && !m["warmNode"].empty()) {
      warmNode = make_shared<bool>(boost::any_cast<bool>(m["warmNode"]));
    }
    if (m.find("warmNodeConfiguration") != m.end() && !m["warmNodeConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["warmNodeConfiguration"].type()) {
        DescribeInstanceResponseBodyResultWarmNodeConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["warmNodeConfiguration"]));
        warmNodeConfiguration = make_shared<DescribeInstanceResponseBodyResultWarmNodeConfiguration>(model1);
      }
    }
    if (m.find("zoneCount") != m.end() && !m["zoneCount"].empty()) {
      zoneCount = make_shared<long>(boost::any_cast<long>(m["zoneCount"]));
    }
    if (m.find("zoneInfos") != m.end() && !m["zoneInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["zoneInfos"].type()) {
        vector<DescribeInstanceResponseBodyResultZoneInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["zoneInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeInstanceResponseBodyResultZoneInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        zoneInfos = make_shared<vector<DescribeInstanceResponseBodyResultZoneInfos>>(expect1);
      }
    }
  }


  virtual ~DescribeInstanceResponseBodyResult() = default;
};
class DescribeInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeInstanceResponseBodyResult> result{};

  DescribeInstanceResponseBody() {}

  explicit DescribeInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeInstanceResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeInstanceResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeInstanceResponseBody() = default;
};
class DescribeInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeInstanceResponseBody> body{};

  DescribeInstanceResponse() {}

  explicit DescribeInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeInstanceResponse() = default;
};
class DescribeKibanaSettingsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<map<string, boost::any>> result{};

  DescribeKibanaSettingsResponseBody() {}

  explicit DescribeKibanaSettingsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Result"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      result = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~DescribeKibanaSettingsResponseBody() = default;
};
class DescribeKibanaSettingsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeKibanaSettingsResponseBody> body{};

  DescribeKibanaSettingsResponse() {}

  explicit DescribeKibanaSettingsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeKibanaSettingsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeKibanaSettingsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeKibanaSettingsResponse() = default;
};
class DescribeLogstashResponseBodyResultTags : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  DescribeLogstashResponseBodyResultTags() {}

  explicit DescribeLogstashResponseBodyResultTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["tagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["tagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tagKey") != m.end() && !m["tagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["tagKey"]));
    }
    if (m.find("tagValue") != m.end() && !m["tagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["tagValue"]));
    }
  }


  virtual ~DescribeLogstashResponseBodyResultTags() = default;
};
class DescribeLogstashResponseBodyResultZoneInfos : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<string> zoneId{};

  DescribeLogstashResponseBodyResultZoneInfos() {}

  explicit DescribeLogstashResponseBodyResultZoneInfos(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (zoneId) {
      res["zoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("zoneId") != m.end() && !m["zoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["zoneId"]));
    }
  }


  virtual ~DescribeLogstashResponseBodyResultZoneInfos() = default;
};
class DescribeLogstashResponseBodyResultEndpointList : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<string> port{};
  shared_ptr<string> zoneId{};

  DescribeLogstashResponseBodyResultEndpointList() {}

  explicit DescribeLogstashResponseBodyResultEndpointList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["host"] = boost::any(*host);
    }
    if (port) {
      res["port"] = boost::any(*port);
    }
    if (zoneId) {
      res["zoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("host") != m.end() && !m["host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["host"]));
    }
    if (m.find("port") != m.end() && !m["port"].empty()) {
      port = make_shared<string>(boost::any_cast<string>(m["port"]));
    }
    if (m.find("zoneId") != m.end() && !m["zoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["zoneId"]));
    }
  }


  virtual ~DescribeLogstashResponseBodyResultEndpointList() = default;
};
class DescribeLogstashResponseBodyResultNetworkConfig : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vsArea{};
  shared_ptr<string> vswitchId{};

  DescribeLogstashResponseBodyResultNetworkConfig() {}

  explicit DescribeLogstashResponseBodyResultNetworkConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    if (vsArea) {
      res["vsArea"] = boost::any(*vsArea);
    }
    if (vswitchId) {
      res["vswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
    if (m.find("vsArea") != m.end() && !m["vsArea"].empty()) {
      vsArea = make_shared<string>(boost::any_cast<string>(m["vsArea"]));
    }
    if (m.find("vswitchId") != m.end() && !m["vswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["vswitchId"]));
    }
  }


  virtual ~DescribeLogstashResponseBodyResultNetworkConfig() = default;
};
class DescribeLogstashResponseBodyResultNodeSpec : public Darabonba::Model {
public:
  shared_ptr<long> disk{};
  shared_ptr<bool> diskEncryption{};
  shared_ptr<string> diskType{};
  shared_ptr<string> spec{};

  DescribeLogstashResponseBodyResultNodeSpec() {}

  explicit DescribeLogstashResponseBodyResultNodeSpec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskEncryption) {
      res["diskEncryption"] = boost::any(*diskEncryption);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskEncryption") != m.end() && !m["diskEncryption"].empty()) {
      diskEncryption = make_shared<bool>(boost::any_cast<bool>(m["diskEncryption"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~DescribeLogstashResponseBodyResultNodeSpec() = default;
};
class DescribeLogstashResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<map<string, boost::any>>> extendConfigs{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<vector<DescribeLogstashResponseBodyResultTags>> tags{};
  shared_ptr<vector<DescribeLogstashResponseBodyResultZoneInfos>> zoneInfos{};
  shared_ptr<map<string, boost::any>> config{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> description{};
  shared_ptr<vector<DescribeLogstashResponseBodyResultEndpointList>> endpointList{};
  shared_ptr<string> instanceId{};
  shared_ptr<DescribeLogstashResponseBodyResultNetworkConfig> networkConfig{};
  shared_ptr<long> nodeAmount{};
  shared_ptr<DescribeLogstashResponseBodyResultNodeSpec> nodeSpec{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> status{};
  shared_ptr<string> updatedAt{};
  shared_ptr<string> version{};
  shared_ptr<string> vpcInstanceId{};

  DescribeLogstashResponseBodyResult() {}

  explicit DescribeLogstashResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extendConfigs) {
      res["ExtendConfigs"] = boost::any(*extendConfigs);
    }
    if (resourceGroupId) {
      res["ResourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (zoneInfos) {
      vector<boost::any> temp1;
      for(auto item1:*zoneInfos){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ZoneInfos"] = boost::any(temp1);
    }
    if (config) {
      res["config"] = boost::any(*config);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (endpointList) {
      vector<boost::any> temp1;
      for(auto item1:*endpointList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["endpointList"] = boost::any(temp1);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (networkConfig) {
      res["networkConfig"] = networkConfig ? boost::any(networkConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodeAmount) {
      res["nodeAmount"] = boost::any(*nodeAmount);
    }
    if (nodeSpec) {
      res["nodeSpec"] = nodeSpec ? boost::any(nodeSpec->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (paymentType) {
      res["paymentType"] = boost::any(*paymentType);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (updatedAt) {
      res["updatedAt"] = boost::any(*updatedAt);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    if (vpcInstanceId) {
      res["vpcInstanceId"] = boost::any(*vpcInstanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ExtendConfigs") != m.end() && !m["ExtendConfigs"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["ExtendConfigs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ExtendConfigs"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      extendConfigs = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("ResourceGroupId") != m.end() && !m["ResourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["ResourceGroupId"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<DescribeLogstashResponseBodyResultTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLogstashResponseBodyResultTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<DescribeLogstashResponseBodyResultTags>>(expect1);
      }
    }
    if (m.find("ZoneInfos") != m.end() && !m["ZoneInfos"].empty()) {
      if (typeid(vector<boost::any>) == m["ZoneInfos"].type()) {
        vector<DescribeLogstashResponseBodyResultZoneInfos> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ZoneInfos"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLogstashResponseBodyResultZoneInfos model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        zoneInfos = make_shared<vector<DescribeLogstashResponseBodyResultZoneInfos>>(expect1);
      }
    }
    if (m.find("config") != m.end() && !m["config"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["config"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      config = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("endpointList") != m.end() && !m["endpointList"].empty()) {
      if (typeid(vector<boost::any>) == m["endpointList"].type()) {
        vector<DescribeLogstashResponseBodyResultEndpointList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["endpointList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeLogstashResponseBodyResultEndpointList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        endpointList = make_shared<vector<DescribeLogstashResponseBodyResultEndpointList>>(expect1);
      }
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("networkConfig") != m.end() && !m["networkConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["networkConfig"].type()) {
        DescribeLogstashResponseBodyResultNetworkConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["networkConfig"]));
        networkConfig = make_shared<DescribeLogstashResponseBodyResultNetworkConfig>(model1);
      }
    }
    if (m.find("nodeAmount") != m.end() && !m["nodeAmount"].empty()) {
      nodeAmount = make_shared<long>(boost::any_cast<long>(m["nodeAmount"]));
    }
    if (m.find("nodeSpec") != m.end() && !m["nodeSpec"].empty()) {
      if (typeid(map<string, boost::any>) == m["nodeSpec"].type()) {
        DescribeLogstashResponseBodyResultNodeSpec model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["nodeSpec"]));
        nodeSpec = make_shared<DescribeLogstashResponseBodyResultNodeSpec>(model1);
      }
    }
    if (m.find("paymentType") != m.end() && !m["paymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["paymentType"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("updatedAt") != m.end() && !m["updatedAt"].empty()) {
      updatedAt = make_shared<string>(boost::any_cast<string>(m["updatedAt"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
    if (m.find("vpcInstanceId") != m.end() && !m["vpcInstanceId"].empty()) {
      vpcInstanceId = make_shared<string>(boost::any_cast<string>(m["vpcInstanceId"]));
    }
  }


  virtual ~DescribeLogstashResponseBodyResult() = default;
};
class DescribeLogstashResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeLogstashResponseBodyResult> result{};

  DescribeLogstashResponseBody() {}

  explicit DescribeLogstashResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeLogstashResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeLogstashResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeLogstashResponseBody() = default;
};
class DescribeLogstashResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeLogstashResponseBody> body{};

  DescribeLogstashResponse() {}

  explicit DescribeLogstashResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeLogstashResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeLogstashResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeLogstashResponse() = default;
};
class DescribePipelineResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> batchDelay{};
  shared_ptr<long> batchSize{};
  shared_ptr<string> config{};
  shared_ptr<string> description{};
  shared_ptr<string> gmtCreatedTime{};
  shared_ptr<string> gmtUpdateTime{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> pipelineStatus{};
  shared_ptr<long> queueCheckPointWrites{};
  shared_ptr<long> queueMaxBytes{};
  shared_ptr<string> queueType{};
  shared_ptr<long> workers{};

  DescribePipelineResponseBodyResult() {}

  explicit DescribePipelineResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchDelay) {
      res["batchDelay"] = boost::any(*batchDelay);
    }
    if (batchSize) {
      res["batchSize"] = boost::any(*batchSize);
    }
    if (config) {
      res["config"] = boost::any(*config);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (gmtCreatedTime) {
      res["gmtCreatedTime"] = boost::any(*gmtCreatedTime);
    }
    if (gmtUpdateTime) {
      res["gmtUpdateTime"] = boost::any(*gmtUpdateTime);
    }
    if (pipelineId) {
      res["pipelineId"] = boost::any(*pipelineId);
    }
    if (pipelineStatus) {
      res["pipelineStatus"] = boost::any(*pipelineStatus);
    }
    if (queueCheckPointWrites) {
      res["queueCheckPointWrites"] = boost::any(*queueCheckPointWrites);
    }
    if (queueMaxBytes) {
      res["queueMaxBytes"] = boost::any(*queueMaxBytes);
    }
    if (queueType) {
      res["queueType"] = boost::any(*queueType);
    }
    if (workers) {
      res["workers"] = boost::any(*workers);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("batchDelay") != m.end() && !m["batchDelay"].empty()) {
      batchDelay = make_shared<long>(boost::any_cast<long>(m["batchDelay"]));
    }
    if (m.find("batchSize") != m.end() && !m["batchSize"].empty()) {
      batchSize = make_shared<long>(boost::any_cast<long>(m["batchSize"]));
    }
    if (m.find("config") != m.end() && !m["config"].empty()) {
      config = make_shared<string>(boost::any_cast<string>(m["config"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("gmtCreatedTime") != m.end() && !m["gmtCreatedTime"].empty()) {
      gmtCreatedTime = make_shared<string>(boost::any_cast<string>(m["gmtCreatedTime"]));
    }
    if (m.find("gmtUpdateTime") != m.end() && !m["gmtUpdateTime"].empty()) {
      gmtUpdateTime = make_shared<string>(boost::any_cast<string>(m["gmtUpdateTime"]));
    }
    if (m.find("pipelineId") != m.end() && !m["pipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["pipelineId"]));
    }
    if (m.find("pipelineStatus") != m.end() && !m["pipelineStatus"].empty()) {
      pipelineStatus = make_shared<string>(boost::any_cast<string>(m["pipelineStatus"]));
    }
    if (m.find("queueCheckPointWrites") != m.end() && !m["queueCheckPointWrites"].empty()) {
      queueCheckPointWrites = make_shared<long>(boost::any_cast<long>(m["queueCheckPointWrites"]));
    }
    if (m.find("queueMaxBytes") != m.end() && !m["queueMaxBytes"].empty()) {
      queueMaxBytes = make_shared<long>(boost::any_cast<long>(m["queueMaxBytes"]));
    }
    if (m.find("queueType") != m.end() && !m["queueType"].empty()) {
      queueType = make_shared<string>(boost::any_cast<string>(m["queueType"]));
    }
    if (m.find("workers") != m.end() && !m["workers"].empty()) {
      workers = make_shared<long>(boost::any_cast<long>(m["workers"]));
    }
  }


  virtual ~DescribePipelineResponseBodyResult() = default;
};
class DescribePipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribePipelineResponseBodyResult> result{};

  DescribePipelineResponseBody() {}

  explicit DescribePipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribePipelineResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribePipelineResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribePipelineResponseBody() = default;
};
class DescribePipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePipelineResponseBody> body{};

  DescribePipelineResponse() {}

  explicit DescribePipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePipelineResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePipelineResponse() = default;
};
class DescribePipelineManagementConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};

  DescribePipelineManagementConfigRequest() {}

  explicit DescribePipelineManagementConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~DescribePipelineManagementConfigRequest() = default;
};
class DescribePipelineManagementConfigResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> endpoints{};
  shared_ptr<string> esInstanceId{};
  shared_ptr<vector<string>> pipelineIds{};
  shared_ptr<string> pipelineManagementType{};
  shared_ptr<string> userName{};

  DescribePipelineManagementConfigResponseBodyResult() {}

  explicit DescribePipelineManagementConfigResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpoints) {
      res["endpoints"] = boost::any(*endpoints);
    }
    if (esInstanceId) {
      res["esInstanceId"] = boost::any(*esInstanceId);
    }
    if (pipelineIds) {
      res["pipelineIds"] = boost::any(*pipelineIds);
    }
    if (pipelineManagementType) {
      res["pipelineManagementType"] = boost::any(*pipelineManagementType);
    }
    if (userName) {
      res["userName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endpoints") != m.end() && !m["endpoints"].empty()) {
      endpoints = make_shared<string>(boost::any_cast<string>(m["endpoints"]));
    }
    if (m.find("esInstanceId") != m.end() && !m["esInstanceId"].empty()) {
      esInstanceId = make_shared<string>(boost::any_cast<string>(m["esInstanceId"]));
    }
    if (m.find("pipelineIds") != m.end() && !m["pipelineIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["pipelineIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["pipelineIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      pipelineIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("pipelineManagementType") != m.end() && !m["pipelineManagementType"].empty()) {
      pipelineManagementType = make_shared<string>(boost::any_cast<string>(m["pipelineManagementType"]));
    }
    if (m.find("userName") != m.end() && !m["userName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["userName"]));
    }
  }


  virtual ~DescribePipelineManagementConfigResponseBodyResult() = default;
};
class DescribePipelineManagementConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribePipelineManagementConfigResponseBodyResult> result{};

  DescribePipelineManagementConfigResponseBody() {}

  explicit DescribePipelineManagementConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribePipelineManagementConfigResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribePipelineManagementConfigResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribePipelineManagementConfigResponseBody() = default;
};
class DescribePipelineManagementConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribePipelineManagementConfigResponseBody> body{};

  DescribePipelineManagementConfigResponse() {}

  explicit DescribePipelineManagementConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribePipelineManagementConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribePipelineManagementConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribePipelineManagementConfigResponse() = default;
};
class DescribeRegionsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> consoleEndpoint{};
  shared_ptr<string> localName{};
  shared_ptr<string> regionEndpoint{};
  shared_ptr<string> regionId{};
  shared_ptr<string> status{};

  DescribeRegionsResponseBodyResult() {}

  explicit DescribeRegionsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (consoleEndpoint) {
      res["consoleEndpoint"] = boost::any(*consoleEndpoint);
    }
    if (localName) {
      res["localName"] = boost::any(*localName);
    }
    if (regionEndpoint) {
      res["regionEndpoint"] = boost::any(*regionEndpoint);
    }
    if (regionId) {
      res["regionId"] = boost::any(*regionId);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("consoleEndpoint") != m.end() && !m["consoleEndpoint"].empty()) {
      consoleEndpoint = make_shared<string>(boost::any_cast<string>(m["consoleEndpoint"]));
    }
    if (m.find("localName") != m.end() && !m["localName"].empty()) {
      localName = make_shared<string>(boost::any_cast<string>(m["localName"]));
    }
    if (m.find("regionEndpoint") != m.end() && !m["regionEndpoint"].empty()) {
      regionEndpoint = make_shared<string>(boost::any_cast<string>(m["regionEndpoint"]));
    }
    if (m.find("regionId") != m.end() && !m["regionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["regionId"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~DescribeRegionsResponseBodyResult() = default;
};
class DescribeRegionsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeRegionsResponseBodyResult>> result{};

  DescribeRegionsResponseBody() {}

  explicit DescribeRegionsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeRegionsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeRegionsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeRegionsResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~DescribeRegionsResponseBody() = default;
};
class DescribeRegionsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeRegionsResponseBody> body{};

  DescribeRegionsResponse() {}

  explicit DescribeRegionsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeRegionsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeRegionsResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeRegionsResponse() = default;
};
class DescribeSnapshotSettingResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};
  shared_ptr<string> quartzRegex{};

  DescribeSnapshotSettingResponseBodyResult() {}

  explicit DescribeSnapshotSettingResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["Enable"] = boost::any(*enable);
    }
    if (quartzRegex) {
      res["QuartzRegex"] = boost::any(*quartzRegex);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Enable") != m.end() && !m["Enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["Enable"]));
    }
    if (m.find("QuartzRegex") != m.end() && !m["QuartzRegex"].empty()) {
      quartzRegex = make_shared<string>(boost::any_cast<string>(m["QuartzRegex"]));
    }
  }


  virtual ~DescribeSnapshotSettingResponseBodyResult() = default;
};
class DescribeSnapshotSettingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeSnapshotSettingResponseBodyResult> result{};

  DescribeSnapshotSettingResponseBody() {}

  explicit DescribeSnapshotSettingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeSnapshotSettingResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeSnapshotSettingResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeSnapshotSettingResponseBody() = default;
};
class DescribeSnapshotSettingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeSnapshotSettingResponseBody> body{};

  DescribeSnapshotSettingResponse() {}

  explicit DescribeSnapshotSettingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeSnapshotSettingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeSnapshotSettingResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeSnapshotSettingResponse() = default;
};
class DescribeTemplatesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> templateName{};

  DescribeTemplatesResponseBodyResult() {}

  explicit DescribeTemplatesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (templateName) {
      res["templateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("templateName") != m.end() && !m["templateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["templateName"]));
    }
  }


  virtual ~DescribeTemplatesResponseBodyResult() = default;
};
class DescribeTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<DescribeTemplatesResponseBodyResult>> result{};

  DescribeTemplatesResponseBody() {}

  explicit DescribeTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<DescribeTemplatesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            DescribeTemplatesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<DescribeTemplatesResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~DescribeTemplatesResponseBody() = default;
};
class DescribeTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeTemplatesResponseBody> body{};

  DescribeTemplatesResponse() {}

  explicit DescribeTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeTemplatesResponse() = default;
};
class DescribeXpackMonitorConfigResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};
  shared_ptr<vector<string>> endpoints{};
  shared_ptr<string> esInstanceId{};
  shared_ptr<vector<string>> pipelineIds{};
  shared_ptr<string> userName{};

  DescribeXpackMonitorConfigResponseBodyResult() {}

  explicit DescribeXpackMonitorConfigResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    if (endpoints) {
      res["endpoints"] = boost::any(*endpoints);
    }
    if (esInstanceId) {
      res["esInstanceId"] = boost::any(*esInstanceId);
    }
    if (pipelineIds) {
      res["pipelineIds"] = boost::any(*pipelineIds);
    }
    if (userName) {
      res["userName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
    if (m.find("endpoints") != m.end() && !m["endpoints"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["endpoints"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["endpoints"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endpoints = make_shared<vector<string>>(toVec1);
    }
    if (m.find("esInstanceId") != m.end() && !m["esInstanceId"].empty()) {
      esInstanceId = make_shared<string>(boost::any_cast<string>(m["esInstanceId"]));
    }
    if (m.find("pipelineIds") != m.end() && !m["pipelineIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["pipelineIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["pipelineIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      pipelineIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("userName") != m.end() && !m["userName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["userName"]));
    }
  }


  virtual ~DescribeXpackMonitorConfigResponseBodyResult() = default;
};
class DescribeXpackMonitorConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DescribeXpackMonitorConfigResponseBodyResult> result{};

  DescribeXpackMonitorConfigResponseBody() {}

  explicit DescribeXpackMonitorConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DescribeXpackMonitorConfigResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DescribeXpackMonitorConfigResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DescribeXpackMonitorConfigResponseBody() = default;
};
class DescribeXpackMonitorConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DescribeXpackMonitorConfigResponseBody> body{};

  DescribeXpackMonitorConfigResponse() {}

  explicit DescribeXpackMonitorConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DescribeXpackMonitorConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DescribeXpackMonitorConfigResponseBody>(model1);
      }
    }
  }


  virtual ~DescribeXpackMonitorConfigResponse() = default;
};
class DiagnoseInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<vector<string>> diagnoseItems{};
  shared_ptr<vector<string>> indices{};
  shared_ptr<string> type{};
  shared_ptr<string> lang{};

  DiagnoseInstanceRequest() {}

  explicit DiagnoseInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (diagnoseItems) {
      res["diagnoseItems"] = boost::any(*diagnoseItems);
    }
    if (indices) {
      res["indices"] = boost::any(*indices);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (lang) {
      res["lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("diagnoseItems") != m.end() && !m["diagnoseItems"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["diagnoseItems"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["diagnoseItems"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      diagnoseItems = make_shared<vector<string>>(toVec1);
    }
    if (m.find("indices") != m.end() && !m["indices"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["indices"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["indices"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      indices = make_shared<vector<string>>(toVec1);
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("lang") != m.end() && !m["lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["lang"]));
    }
  }


  virtual ~DiagnoseInstanceRequest() = default;
};
class DiagnoseInstanceResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> reportId{};
  shared_ptr<string> state{};

  DiagnoseInstanceResponseBodyResult() {}

  explicit DiagnoseInstanceResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (reportId) {
      res["reportId"] = boost::any(*reportId);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["createTime"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("reportId") != m.end() && !m["reportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["reportId"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
  }


  virtual ~DiagnoseInstanceResponseBodyResult() = default;
};
class DiagnoseInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<DiagnoseInstanceResponseBodyResult> result{};

  DiagnoseInstanceResponseBody() {}

  explicit DiagnoseInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        DiagnoseInstanceResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<DiagnoseInstanceResponseBodyResult>(model1);
      }
    }
  }


  virtual ~DiagnoseInstanceResponseBody() = default;
};
class DiagnoseInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<DiagnoseInstanceResponseBody> body{};

  DiagnoseInstanceResponse() {}

  explicit DiagnoseInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        DiagnoseInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<DiagnoseInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~DiagnoseInstanceResponse() = default;
};
class EstimatedLogstashRestartTimeRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<bool> force{};

  EstimatedLogstashRestartTimeRequest() {}

  explicit EstimatedLogstashRestartTimeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (force) {
      res["force"] = boost::any(*force);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("force") != m.end() && !m["force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["force"]));
    }
  }


  virtual ~EstimatedLogstashRestartTimeRequest() = default;
};
class EstimatedLogstashRestartTimeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  EstimatedLogstashRestartTimeResponseBodyResult() {}

  explicit EstimatedLogstashRestartTimeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (unit) {
      res["unit"] = boost::any(*unit);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("unit") != m.end() && !m["unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["unit"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["value"]));
    }
  }


  virtual ~EstimatedLogstashRestartTimeResponseBodyResult() = default;
};
class EstimatedLogstashRestartTimeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<EstimatedLogstashRestartTimeResponseBodyResult> result{};

  EstimatedLogstashRestartTimeResponseBody() {}

  explicit EstimatedLogstashRestartTimeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        EstimatedLogstashRestartTimeResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<EstimatedLogstashRestartTimeResponseBodyResult>(model1);
      }
    }
  }


  virtual ~EstimatedLogstashRestartTimeResponseBody() = default;
};
class EstimatedLogstashRestartTimeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EstimatedLogstashRestartTimeResponseBody> body{};

  EstimatedLogstashRestartTimeResponse() {}

  explicit EstimatedLogstashRestartTimeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EstimatedLogstashRestartTimeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EstimatedLogstashRestartTimeResponseBody>(model1);
      }
    }
  }


  virtual ~EstimatedLogstashRestartTimeResponse() = default;
};
class EstimatedRestartTimeRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<bool> force{};

  EstimatedRestartTimeRequest() {}

  explicit EstimatedRestartTimeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (force) {
      res["force"] = boost::any(*force);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("force") != m.end() && !m["force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["force"]));
    }
  }


  virtual ~EstimatedRestartTimeRequest() = default;
};
class EstimatedRestartTimeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> unit{};
  shared_ptr<long> value{};

  EstimatedRestartTimeResponseBodyResult() {}

  explicit EstimatedRestartTimeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (unit) {
      res["unit"] = boost::any(*unit);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("unit") != m.end() && !m["unit"].empty()) {
      unit = make_shared<string>(boost::any_cast<string>(m["unit"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<long>(boost::any_cast<long>(m["value"]));
    }
  }


  virtual ~EstimatedRestartTimeResponseBodyResult() = default;
};
class EstimatedRestartTimeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<EstimatedRestartTimeResponseBodyResult> result{};

  EstimatedRestartTimeResponseBody() {}

  explicit EstimatedRestartTimeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        EstimatedRestartTimeResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<EstimatedRestartTimeResponseBodyResult>(model1);
      }
    }
  }


  virtual ~EstimatedRestartTimeResponseBody() = default;
};
class EstimatedRestartTimeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<EstimatedRestartTimeResponseBody> body{};

  EstimatedRestartTimeResponse() {}

  explicit EstimatedRestartTimeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        EstimatedRestartTimeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<EstimatedRestartTimeResponseBody>(model1);
      }
    }
  }


  virtual ~EstimatedRestartTimeResponse() = default;
};
class GetClusterDataInformationRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};

  GetClusterDataInformationRequest() {}

  explicit GetClusterDataInformationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~GetClusterDataInformationRequest() = default;
};
class GetClusterDataInformationResponseBodyResultMetaInfo : public Darabonba::Model {
public:
  shared_ptr<vector<string>> fields{};
  shared_ptr<vector<string>> indices{};
  shared_ptr<string> mapping{};
  shared_ptr<string> settings{};
  shared_ptr<vector<string>> typeName_{};

  GetClusterDataInformationResponseBodyResultMetaInfo() {}

  explicit GetClusterDataInformationResponseBodyResultMetaInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fields) {
      res["fields"] = boost::any(*fields);
    }
    if (indices) {
      res["indices"] = boost::any(*indices);
    }
    if (mapping) {
      res["mapping"] = boost::any(*mapping);
    }
    if (settings) {
      res["settings"] = boost::any(*settings);
    }
    if (typeName_) {
      res["typeName"] = boost::any(*typeName_);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fields") != m.end() && !m["fields"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["fields"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["fields"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      fields = make_shared<vector<string>>(toVec1);
    }
    if (m.find("indices") != m.end() && !m["indices"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["indices"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["indices"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      indices = make_shared<vector<string>>(toVec1);
    }
    if (m.find("mapping") != m.end() && !m["mapping"].empty()) {
      mapping = make_shared<string>(boost::any_cast<string>(m["mapping"]));
    }
    if (m.find("settings") != m.end() && !m["settings"].empty()) {
      settings = make_shared<string>(boost::any_cast<string>(m["settings"]));
    }
    if (m.find("typeName") != m.end() && !m["typeName"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["typeName"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["typeName"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      typeName_ = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetClusterDataInformationResponseBodyResultMetaInfo() = default;
};
class GetClusterDataInformationResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> connectable{};
  shared_ptr<GetClusterDataInformationResponseBodyResultMetaInfo> metaInfo{};

  GetClusterDataInformationResponseBodyResult() {}

  explicit GetClusterDataInformationResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectable) {
      res["connectable"] = boost::any(*connectable);
    }
    if (metaInfo) {
      res["metaInfo"] = metaInfo ? boost::any(metaInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("connectable") != m.end() && !m["connectable"].empty()) {
      connectable = make_shared<bool>(boost::any_cast<bool>(m["connectable"]));
    }
    if (m.find("metaInfo") != m.end() && !m["metaInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["metaInfo"].type()) {
        GetClusterDataInformationResponseBodyResultMetaInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["metaInfo"]));
        metaInfo = make_shared<GetClusterDataInformationResponseBodyResultMetaInfo>(model1);
      }
    }
  }


  virtual ~GetClusterDataInformationResponseBodyResult() = default;
};
class GetClusterDataInformationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetClusterDataInformationResponseBodyResult> result{};

  GetClusterDataInformationResponseBody() {}

  explicit GetClusterDataInformationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        GetClusterDataInformationResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<GetClusterDataInformationResponseBodyResult>(model1);
      }
    }
  }


  virtual ~GetClusterDataInformationResponseBody() = default;
};
class GetClusterDataInformationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetClusterDataInformationResponseBody> body{};

  GetClusterDataInformationResponse() {}

  explicit GetClusterDataInformationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetClusterDataInformationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetClusterDataInformationResponseBody>(model1);
      }
    }
  }


  virtual ~GetClusterDataInformationResponse() = default;
};
class GetElastictaskResponseBodyResultElasticExpansionTask : public Darabonba::Model {
public:
  shared_ptr<string> cronExpression{};
  shared_ptr<long> elasticNodeCount{};
  shared_ptr<long> replicaCount{};
  shared_ptr<vector<string>> targetIndices{};
  shared_ptr<string> triggerType{};

  GetElastictaskResponseBodyResultElasticExpansionTask() {}

  explicit GetElastictaskResponseBodyResultElasticExpansionTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cronExpression) {
      res["cronExpression"] = boost::any(*cronExpression);
    }
    if (elasticNodeCount) {
      res["elasticNodeCount"] = boost::any(*elasticNodeCount);
    }
    if (replicaCount) {
      res["replicaCount"] = boost::any(*replicaCount);
    }
    if (targetIndices) {
      res["targetIndices"] = boost::any(*targetIndices);
    }
    if (triggerType) {
      res["triggerType"] = boost::any(*triggerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cronExpression") != m.end() && !m["cronExpression"].empty()) {
      cronExpression = make_shared<string>(boost::any_cast<string>(m["cronExpression"]));
    }
    if (m.find("elasticNodeCount") != m.end() && !m["elasticNodeCount"].empty()) {
      elasticNodeCount = make_shared<long>(boost::any_cast<long>(m["elasticNodeCount"]));
    }
    if (m.find("replicaCount") != m.end() && !m["replicaCount"].empty()) {
      replicaCount = make_shared<long>(boost::any_cast<long>(m["replicaCount"]));
    }
    if (m.find("targetIndices") != m.end() && !m["targetIndices"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["targetIndices"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["targetIndices"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      targetIndices = make_shared<vector<string>>(toVec1);
    }
    if (m.find("triggerType") != m.end() && !m["triggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["triggerType"]));
    }
  }


  virtual ~GetElastictaskResponseBodyResultElasticExpansionTask() = default;
};
class GetElastictaskResponseBodyResultElasticShrinkTask : public Darabonba::Model {
public:
  shared_ptr<string> cronExpression{};
  shared_ptr<long> elasticNodeCount{};
  shared_ptr<long> replicaCount{};
  shared_ptr<vector<string>> targetIndices{};
  shared_ptr<string> triggerType{};

  GetElastictaskResponseBodyResultElasticShrinkTask() {}

  explicit GetElastictaskResponseBodyResultElasticShrinkTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cronExpression) {
      res["cronExpression"] = boost::any(*cronExpression);
    }
    if (elasticNodeCount) {
      res["elasticNodeCount"] = boost::any(*elasticNodeCount);
    }
    if (replicaCount) {
      res["replicaCount"] = boost::any(*replicaCount);
    }
    if (targetIndices) {
      res["targetIndices"] = boost::any(*targetIndices);
    }
    if (triggerType) {
      res["triggerType"] = boost::any(*triggerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cronExpression") != m.end() && !m["cronExpression"].empty()) {
      cronExpression = make_shared<string>(boost::any_cast<string>(m["cronExpression"]));
    }
    if (m.find("elasticNodeCount") != m.end() && !m["elasticNodeCount"].empty()) {
      elasticNodeCount = make_shared<long>(boost::any_cast<long>(m["elasticNodeCount"]));
    }
    if (m.find("replicaCount") != m.end() && !m["replicaCount"].empty()) {
      replicaCount = make_shared<long>(boost::any_cast<long>(m["replicaCount"]));
    }
    if (m.find("targetIndices") != m.end() && !m["targetIndices"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["targetIndices"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["targetIndices"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      targetIndices = make_shared<vector<string>>(toVec1);
    }
    if (m.find("triggerType") != m.end() && !m["triggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["triggerType"]));
    }
  }


  virtual ~GetElastictaskResponseBodyResultElasticShrinkTask() = default;
};
class GetElastictaskResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<GetElastictaskResponseBodyResultElasticExpansionTask> elasticExpansionTask{};
  shared_ptr<GetElastictaskResponseBodyResultElasticShrinkTask> elasticShrinkTask{};

  GetElastictaskResponseBodyResult() {}

  explicit GetElastictaskResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (elasticExpansionTask) {
      res["elasticExpansionTask"] = elasticExpansionTask ? boost::any(elasticExpansionTask->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (elasticShrinkTask) {
      res["elasticShrinkTask"] = elasticShrinkTask ? boost::any(elasticShrinkTask->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("elasticExpansionTask") != m.end() && !m["elasticExpansionTask"].empty()) {
      if (typeid(map<string, boost::any>) == m["elasticExpansionTask"].type()) {
        GetElastictaskResponseBodyResultElasticExpansionTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["elasticExpansionTask"]));
        elasticExpansionTask = make_shared<GetElastictaskResponseBodyResultElasticExpansionTask>(model1);
      }
    }
    if (m.find("elasticShrinkTask") != m.end() && !m["elasticShrinkTask"].empty()) {
      if (typeid(map<string, boost::any>) == m["elasticShrinkTask"].type()) {
        GetElastictaskResponseBodyResultElasticShrinkTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["elasticShrinkTask"]));
        elasticShrinkTask = make_shared<GetElastictaskResponseBodyResultElasticShrinkTask>(model1);
      }
    }
  }


  virtual ~GetElastictaskResponseBodyResult() = default;
};
class GetElastictaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetElastictaskResponseBodyResult> result{};

  GetElastictaskResponseBody() {}

  explicit GetElastictaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        GetElastictaskResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<GetElastictaskResponseBodyResult>(model1);
      }
    }
  }


  virtual ~GetElastictaskResponseBody() = default;
};
class GetElastictaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetElastictaskResponseBody> body{};

  GetElastictaskResponse() {}

  explicit GetElastictaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetElastictaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetElastictaskResponseBody>(model1);
      }
    }
  }


  virtual ~GetElastictaskResponse() = default;
};
class GetEmonGrafanaAlertsRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};

  GetEmonGrafanaAlertsRequest() {}

  explicit GetEmonGrafanaAlertsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~GetEmonGrafanaAlertsRequest() = default;
};
class GetEmonGrafanaAlertsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetEmonGrafanaAlertsResponseBody() {}

  explicit GetEmonGrafanaAlertsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetEmonGrafanaAlertsResponseBody() = default;
};
class GetEmonGrafanaAlertsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEmonGrafanaAlertsResponseBody> body{};

  GetEmonGrafanaAlertsResponse() {}

  explicit GetEmonGrafanaAlertsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEmonGrafanaAlertsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEmonGrafanaAlertsResponseBody>(model1);
      }
    }
  }


  virtual ~GetEmonGrafanaAlertsResponse() = default;
};
class GetEmonGrafanaDashboardsRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};

  GetEmonGrafanaDashboardsRequest() {}

  explicit GetEmonGrafanaDashboardsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~GetEmonGrafanaDashboardsRequest() = default;
};
class GetEmonGrafanaDashboardsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  GetEmonGrafanaDashboardsResponseBody() {}

  explicit GetEmonGrafanaDashboardsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetEmonGrafanaDashboardsResponseBody() = default;
};
class GetEmonGrafanaDashboardsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEmonGrafanaDashboardsResponseBody> body{};

  GetEmonGrafanaDashboardsResponse() {}

  explicit GetEmonGrafanaDashboardsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEmonGrafanaDashboardsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEmonGrafanaDashboardsResponseBody>(model1);
      }
    }
  }


  virtual ~GetEmonGrafanaDashboardsResponse() = default;
};
class GetEmonMonitorDataRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};

  GetEmonMonitorDataRequest() {}

  explicit GetEmonMonitorDataRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~GetEmonMonitorDataRequest() = default;
};
class GetEmonMonitorDataResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> dps{};
  shared_ptr<double> integrity{};
  shared_ptr<long> messageWatermark{};
  shared_ptr<string> metric{};
  shared_ptr<double> summary{};
  shared_ptr<map<string, boost::any>> tags{};

  GetEmonMonitorDataResponseBodyResult() {}

  explicit GetEmonMonitorDataResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dps) {
      res["dps"] = boost::any(*dps);
    }
    if (integrity) {
      res["integrity"] = boost::any(*integrity);
    }
    if (messageWatermark) {
      res["messageWatermark"] = boost::any(*messageWatermark);
    }
    if (metric) {
      res["metric"] = boost::any(*metric);
    }
    if (summary) {
      res["summary"] = boost::any(*summary);
    }
    if (tags) {
      res["tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dps") != m.end() && !m["dps"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["dps"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      dps = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("integrity") != m.end() && !m["integrity"].empty()) {
      integrity = make_shared<double>(boost::any_cast<double>(m["integrity"]));
    }
    if (m.find("messageWatermark") != m.end() && !m["messageWatermark"].empty()) {
      messageWatermark = make_shared<long>(boost::any_cast<long>(m["messageWatermark"]));
    }
    if (m.find("metric") != m.end() && !m["metric"].empty()) {
      metric = make_shared<string>(boost::any_cast<string>(m["metric"]));
    }
    if (m.find("summary") != m.end() && !m["summary"].empty()) {
      summary = make_shared<double>(boost::any_cast<double>(m["summary"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["tags"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      tags = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~GetEmonMonitorDataResponseBodyResult() = default;
};
class GetEmonMonitorDataResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetEmonMonitorDataResponseBodyResult>> result{};
  shared_ptr<bool> success{};

  GetEmonMonitorDataResponseBody() {}

  explicit GetEmonMonitorDataResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<GetEmonMonitorDataResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetEmonMonitorDataResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<GetEmonMonitorDataResponseBodyResult>>(expect1);
      }
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~GetEmonMonitorDataResponseBody() = default;
};
class GetEmonMonitorDataResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetEmonMonitorDataResponseBody> body{};

  GetEmonMonitorDataResponse() {}

  explicit GetEmonMonitorDataResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetEmonMonitorDataResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetEmonMonitorDataResponseBody>(model1);
      }
    }
  }


  virtual ~GetEmonMonitorDataResponse() = default;
};
class GetOpenStoreUsageResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> currentUsage{};
  shared_ptr<long> lastDayUsage{};

  GetOpenStoreUsageResponseBodyResult() {}

  explicit GetOpenStoreUsageResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (currentUsage) {
      res["currentUsage"] = boost::any(*currentUsage);
    }
    if (lastDayUsage) {
      res["lastDayUsage"] = boost::any(*lastDayUsage);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("currentUsage") != m.end() && !m["currentUsage"].empty()) {
      currentUsage = make_shared<long>(boost::any_cast<long>(m["currentUsage"]));
    }
    if (m.find("lastDayUsage") != m.end() && !m["lastDayUsage"].empty()) {
      lastDayUsage = make_shared<long>(boost::any_cast<long>(m["lastDayUsage"]));
    }
  }


  virtual ~GetOpenStoreUsageResponseBodyResult() = default;
};
class GetOpenStoreUsageResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetOpenStoreUsageResponseBodyResult> result{};

  GetOpenStoreUsageResponseBody() {}

  explicit GetOpenStoreUsageResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        GetOpenStoreUsageResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<GetOpenStoreUsageResponseBodyResult>(model1);
      }
    }
  }


  virtual ~GetOpenStoreUsageResponseBody() = default;
};
class GetOpenStoreUsageResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetOpenStoreUsageResponseBody> body{};

  GetOpenStoreUsageResponse() {}

  explicit GetOpenStoreUsageResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetOpenStoreUsageResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetOpenStoreUsageResponseBody>(model1);
      }
    }
  }


  virtual ~GetOpenStoreUsageResponse() = default;
};
class GetRegionConfigurationRequest : public Darabonba::Model {
public:
  shared_ptr<string> zoneId{};

  GetRegionConfigurationRequest() {}

  explicit GetRegionConfigurationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (zoneId) {
      res["zoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("zoneId") != m.end() && !m["zoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["zoneId"]));
    }
  }


  virtual ~GetRegionConfigurationRequest() = default;
};
class GetRegionConfigurationResponseBodyResultClientNodeAmountRange : public Darabonba::Model {
public:
  shared_ptr<long> maxAmount{};
  shared_ptr<long> minAmount{};

  GetRegionConfigurationResponseBodyResultClientNodeAmountRange() {}

  explicit GetRegionConfigurationResponseBodyResultClientNodeAmountRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxAmount) {
      res["maxAmount"] = boost::any(*maxAmount);
    }
    if (minAmount) {
      res["minAmount"] = boost::any(*minAmount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxAmount") != m.end() && !m["maxAmount"].empty()) {
      maxAmount = make_shared<long>(boost::any_cast<long>(m["maxAmount"]));
    }
    if (m.find("minAmount") != m.end() && !m["minAmount"].empty()) {
      minAmount = make_shared<long>(boost::any_cast<long>(m["minAmount"]));
    }
  }


  virtual ~GetRegionConfigurationResponseBodyResultClientNodeAmountRange() = default;
};
class GetRegionConfigurationResponseBodyResultClientNodeDiskList : public Darabonba::Model {
public:
  shared_ptr<string> diskType{};
  shared_ptr<long> maxSize{};
  shared_ptr<long> minSize{};
  shared_ptr<long> scaleLimit{};

  GetRegionConfigurationResponseBodyResultClientNodeDiskList() {}

  explicit GetRegionConfigurationResponseBodyResultClientNodeDiskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (maxSize) {
      res["maxSize"] = boost::any(*maxSize);
    }
    if (minSize) {
      res["minSize"] = boost::any(*minSize);
    }
    if (scaleLimit) {
      res["scaleLimit"] = boost::any(*scaleLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("maxSize") != m.end() && !m["maxSize"].empty()) {
      maxSize = make_shared<long>(boost::any_cast<long>(m["maxSize"]));
    }
    if (m.find("minSize") != m.end() && !m["minSize"].empty()) {
      minSize = make_shared<long>(boost::any_cast<long>(m["minSize"]));
    }
    if (m.find("scaleLimit") != m.end() && !m["scaleLimit"].empty()) {
      scaleLimit = make_shared<long>(boost::any_cast<long>(m["scaleLimit"]));
    }
  }


  virtual ~GetRegionConfigurationResponseBodyResultClientNodeDiskList() = default;
};
class GetRegionConfigurationResponseBodyResultDataDiskList : public Darabonba::Model {
public:
  shared_ptr<string> diskType{};
  shared_ptr<long> maxSize{};
  shared_ptr<long> minSize{};
  shared_ptr<long> scaleLimit{};
  shared_ptr<vector<string>> valueLimitSet{};

  GetRegionConfigurationResponseBodyResultDataDiskList() {}

  explicit GetRegionConfigurationResponseBodyResultDataDiskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (maxSize) {
      res["maxSize"] = boost::any(*maxSize);
    }
    if (minSize) {
      res["minSize"] = boost::any(*minSize);
    }
    if (scaleLimit) {
      res["scaleLimit"] = boost::any(*scaleLimit);
    }
    if (valueLimitSet) {
      res["valueLimitSet"] = boost::any(*valueLimitSet);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("maxSize") != m.end() && !m["maxSize"].empty()) {
      maxSize = make_shared<long>(boost::any_cast<long>(m["maxSize"]));
    }
    if (m.find("minSize") != m.end() && !m["minSize"].empty()) {
      minSize = make_shared<long>(boost::any_cast<long>(m["minSize"]));
    }
    if (m.find("scaleLimit") != m.end() && !m["scaleLimit"].empty()) {
      scaleLimit = make_shared<long>(boost::any_cast<long>(m["scaleLimit"]));
    }
    if (m.find("valueLimitSet") != m.end() && !m["valueLimitSet"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["valueLimitSet"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["valueLimitSet"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      valueLimitSet = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetRegionConfigurationResponseBodyResultDataDiskList() = default;
};
class GetRegionConfigurationResponseBodyResultElasticNodePropertiesAmountRange : public Darabonba::Model {
public:
  shared_ptr<long> maxAmount{};
  shared_ptr<long> minAmount{};

  GetRegionConfigurationResponseBodyResultElasticNodePropertiesAmountRange() {}

  explicit GetRegionConfigurationResponseBodyResultElasticNodePropertiesAmountRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxAmount) {
      res["maxAmount"] = boost::any(*maxAmount);
    }
    if (minAmount) {
      res["minAmount"] = boost::any(*minAmount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxAmount") != m.end() && !m["maxAmount"].empty()) {
      maxAmount = make_shared<long>(boost::any_cast<long>(m["maxAmount"]));
    }
    if (m.find("minAmount") != m.end() && !m["minAmount"].empty()) {
      minAmount = make_shared<long>(boost::any_cast<long>(m["minAmount"]));
    }
  }


  virtual ~GetRegionConfigurationResponseBodyResultElasticNodePropertiesAmountRange() = default;
};
class GetRegionConfigurationResponseBodyResultElasticNodePropertiesDiskList : public Darabonba::Model {
public:
  shared_ptr<bool> diskEncryption{};
  shared_ptr<string> diskType{};
  shared_ptr<long> maxSize{};
  shared_ptr<long> minSize{};
  shared_ptr<long> scaleLimit{};
  shared_ptr<vector<string>> valueLimitSet{};

  GetRegionConfigurationResponseBodyResultElasticNodePropertiesDiskList() {}

  explicit GetRegionConfigurationResponseBodyResultElasticNodePropertiesDiskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskEncryption) {
      res["diskEncryption"] = boost::any(*diskEncryption);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (maxSize) {
      res["maxSize"] = boost::any(*maxSize);
    }
    if (minSize) {
      res["minSize"] = boost::any(*minSize);
    }
    if (scaleLimit) {
      res["scaleLimit"] = boost::any(*scaleLimit);
    }
    if (valueLimitSet) {
      res["valueLimitSet"] = boost::any(*valueLimitSet);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("diskEncryption") != m.end() && !m["diskEncryption"].empty()) {
      diskEncryption = make_shared<bool>(boost::any_cast<bool>(m["diskEncryption"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("maxSize") != m.end() && !m["maxSize"].empty()) {
      maxSize = make_shared<long>(boost::any_cast<long>(m["maxSize"]));
    }
    if (m.find("minSize") != m.end() && !m["minSize"].empty()) {
      minSize = make_shared<long>(boost::any_cast<long>(m["minSize"]));
    }
    if (m.find("scaleLimit") != m.end() && !m["scaleLimit"].empty()) {
      scaleLimit = make_shared<long>(boost::any_cast<long>(m["scaleLimit"]));
    }
    if (m.find("valueLimitSet") != m.end() && !m["valueLimitSet"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["valueLimitSet"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["valueLimitSet"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      valueLimitSet = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetRegionConfigurationResponseBodyResultElasticNodePropertiesDiskList() = default;
};
class GetRegionConfigurationResponseBodyResultElasticNodeProperties : public Darabonba::Model {
public:
  shared_ptr<GetRegionConfigurationResponseBodyResultElasticNodePropertiesAmountRange> amountRange{};
  shared_ptr<vector<GetRegionConfigurationResponseBodyResultElasticNodePropertiesDiskList>> diskList{};
  shared_ptr<vector<string>> spec{};

  GetRegionConfigurationResponseBodyResultElasticNodeProperties() {}

  explicit GetRegionConfigurationResponseBodyResultElasticNodeProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amountRange) {
      res["amountRange"] = amountRange ? boost::any(amountRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (diskList) {
      vector<boost::any> temp1;
      for(auto item1:*diskList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["diskList"] = boost::any(temp1);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amountRange") != m.end() && !m["amountRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["amountRange"].type()) {
        GetRegionConfigurationResponseBodyResultElasticNodePropertiesAmountRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["amountRange"]));
        amountRange = make_shared<GetRegionConfigurationResponseBodyResultElasticNodePropertiesAmountRange>(model1);
      }
    }
    if (m.find("diskList") != m.end() && !m["diskList"].empty()) {
      if (typeid(vector<boost::any>) == m["diskList"].type()) {
        vector<GetRegionConfigurationResponseBodyResultElasticNodePropertiesDiskList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["diskList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRegionConfigurationResponseBodyResultElasticNodePropertiesDiskList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        diskList = make_shared<vector<GetRegionConfigurationResponseBodyResultElasticNodePropertiesDiskList>>(expect1);
      }
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["spec"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["spec"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      spec = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetRegionConfigurationResponseBodyResultElasticNodeProperties() = default;
};
class GetRegionConfigurationResponseBodyResultEsVersionsLatestList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetRegionConfigurationResponseBodyResultEsVersionsLatestList() {}

  explicit GetRegionConfigurationResponseBodyResultEsVersionsLatestList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~GetRegionConfigurationResponseBodyResultEsVersionsLatestList() = default;
};
class GetRegionConfigurationResponseBodyResultJvmConfine : public Darabonba::Model {
public:
  shared_ptr<long> memory{};
  shared_ptr<vector<string>> supportEsVersions{};
  shared_ptr<vector<string>> supportGcs{};

  GetRegionConfigurationResponseBodyResultJvmConfine() {}

  explicit GetRegionConfigurationResponseBodyResultJvmConfine(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (memory) {
      res["memory"] = boost::any(*memory);
    }
    if (supportEsVersions) {
      res["supportEsVersions"] = boost::any(*supportEsVersions);
    }
    if (supportGcs) {
      res["supportGcs"] = boost::any(*supportGcs);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("memory") != m.end() && !m["memory"].empty()) {
      memory = make_shared<long>(boost::any_cast<long>(m["memory"]));
    }
    if (m.find("supportEsVersions") != m.end() && !m["supportEsVersions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["supportEsVersions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["supportEsVersions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportEsVersions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("supportGcs") != m.end() && !m["supportGcs"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["supportGcs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["supportGcs"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      supportGcs = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetRegionConfigurationResponseBodyResultJvmConfine() = default;
};
class GetRegionConfigurationResponseBodyResultKibanaNodePropertiesAmountRange : public Darabonba::Model {
public:
  shared_ptr<long> maxAmount{};
  shared_ptr<long> minAmount{};

  GetRegionConfigurationResponseBodyResultKibanaNodePropertiesAmountRange() {}

  explicit GetRegionConfigurationResponseBodyResultKibanaNodePropertiesAmountRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxAmount) {
      res["maxAmount"] = boost::any(*maxAmount);
    }
    if (minAmount) {
      res["minAmount"] = boost::any(*minAmount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxAmount") != m.end() && !m["maxAmount"].empty()) {
      maxAmount = make_shared<long>(boost::any_cast<long>(m["maxAmount"]));
    }
    if (m.find("minAmount") != m.end() && !m["minAmount"].empty()) {
      minAmount = make_shared<long>(boost::any_cast<long>(m["minAmount"]));
    }
  }


  virtual ~GetRegionConfigurationResponseBodyResultKibanaNodePropertiesAmountRange() = default;
};
class GetRegionConfigurationResponseBodyResultKibanaNodeProperties : public Darabonba::Model {
public:
  shared_ptr<GetRegionConfigurationResponseBodyResultKibanaNodePropertiesAmountRange> amountRange{};
  shared_ptr<vector<string>> spec{};

  GetRegionConfigurationResponseBodyResultKibanaNodeProperties() {}

  explicit GetRegionConfigurationResponseBodyResultKibanaNodeProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amountRange) {
      res["amountRange"] = amountRange ? boost::any(amountRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amountRange") != m.end() && !m["amountRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["amountRange"].type()) {
        GetRegionConfigurationResponseBodyResultKibanaNodePropertiesAmountRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["amountRange"]));
        amountRange = make_shared<GetRegionConfigurationResponseBodyResultKibanaNodePropertiesAmountRange>(model1);
      }
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["spec"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["spec"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      spec = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetRegionConfigurationResponseBodyResultKibanaNodeProperties() = default;
};
class GetRegionConfigurationResponseBodyResultMasterDiskList : public Darabonba::Model {
public:
  shared_ptr<string> diskType{};
  shared_ptr<long> maxSize{};
  shared_ptr<long> minSize{};
  shared_ptr<long> scaleLimit{};

  GetRegionConfigurationResponseBodyResultMasterDiskList() {}

  explicit GetRegionConfigurationResponseBodyResultMasterDiskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (maxSize) {
      res["maxSize"] = boost::any(*maxSize);
    }
    if (minSize) {
      res["minSize"] = boost::any(*minSize);
    }
    if (scaleLimit) {
      res["scaleLimit"] = boost::any(*scaleLimit);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("maxSize") != m.end() && !m["maxSize"].empty()) {
      maxSize = make_shared<long>(boost::any_cast<long>(m["maxSize"]));
    }
    if (m.find("minSize") != m.end() && !m["minSize"].empty()) {
      minSize = make_shared<long>(boost::any_cast<long>(m["minSize"]));
    }
    if (m.find("scaleLimit") != m.end() && !m["scaleLimit"].empty()) {
      scaleLimit = make_shared<long>(boost::any_cast<long>(m["scaleLimit"]));
    }
  }


  virtual ~GetRegionConfigurationResponseBodyResultMasterDiskList() = default;
};
class GetRegionConfigurationResponseBodyResultNode : public Darabonba::Model {
public:
  shared_ptr<long> maxAmount{};
  shared_ptr<long> minAmount{};

  GetRegionConfigurationResponseBodyResultNode() {}

  explicit GetRegionConfigurationResponseBodyResultNode(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxAmount) {
      res["maxAmount"] = boost::any(*maxAmount);
    }
    if (minAmount) {
      res["minAmount"] = boost::any(*minAmount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxAmount") != m.end() && !m["maxAmount"].empty()) {
      maxAmount = make_shared<long>(boost::any_cast<long>(m["maxAmount"]));
    }
    if (m.find("minAmount") != m.end() && !m["minAmount"].empty()) {
      minAmount = make_shared<long>(boost::any_cast<long>(m["minAmount"]));
    }
  }


  virtual ~GetRegionConfigurationResponseBodyResultNode() = default;
};
class GetRegionConfigurationResponseBodyResultNodeSpecList : public Darabonba::Model {
public:
  shared_ptr<long> cpuCount{};
  shared_ptr<long> disk{};
  shared_ptr<string> diskType{};
  shared_ptr<bool> enable{};
  shared_ptr<long> memorySize{};
  shared_ptr<string> spec{};
  shared_ptr<string> specGroupType{};

  GetRegionConfigurationResponseBodyResultNodeSpecList() {}

  explicit GetRegionConfigurationResponseBodyResultNodeSpecList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpuCount) {
      res["cpuCount"] = boost::any(*cpuCount);
    }
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    if (memorySize) {
      res["memorySize"] = boost::any(*memorySize);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    if (specGroupType) {
      res["specGroupType"] = boost::any(*specGroupType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cpuCount") != m.end() && !m["cpuCount"].empty()) {
      cpuCount = make_shared<long>(boost::any_cast<long>(m["cpuCount"]));
    }
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
    if (m.find("memorySize") != m.end() && !m["memorySize"].empty()) {
      memorySize = make_shared<long>(boost::any_cast<long>(m["memorySize"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
    if (m.find("specGroupType") != m.end() && !m["specGroupType"].empty()) {
      specGroupType = make_shared<string>(boost::any_cast<string>(m["specGroupType"]));
    }
  }


  virtual ~GetRegionConfigurationResponseBodyResultNodeSpecList() = default;
};
class GetRegionConfigurationResponseBodyResultSupportVersionsSupportVersionList : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  GetRegionConfigurationResponseBodyResultSupportVersionsSupportVersionList() {}

  explicit GetRegionConfigurationResponseBodyResultSupportVersionsSupportVersionList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~GetRegionConfigurationResponseBodyResultSupportVersionsSupportVersionList() = default;
};
class GetRegionConfigurationResponseBodyResultSupportVersions : public Darabonba::Model {
public:
  shared_ptr<string> instanceCategory{};
  shared_ptr<vector<GetRegionConfigurationResponseBodyResultSupportVersionsSupportVersionList>> supportVersionList{};

  GetRegionConfigurationResponseBodyResultSupportVersions() {}

  explicit GetRegionConfigurationResponseBodyResultSupportVersions(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceCategory) {
      res["instanceCategory"] = boost::any(*instanceCategory);
    }
    if (supportVersionList) {
      vector<boost::any> temp1;
      for(auto item1:*supportVersionList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["supportVersionList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instanceCategory") != m.end() && !m["instanceCategory"].empty()) {
      instanceCategory = make_shared<string>(boost::any_cast<string>(m["instanceCategory"]));
    }
    if (m.find("supportVersionList") != m.end() && !m["supportVersionList"].empty()) {
      if (typeid(vector<boost::any>) == m["supportVersionList"].type()) {
        vector<GetRegionConfigurationResponseBodyResultSupportVersionsSupportVersionList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["supportVersionList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRegionConfigurationResponseBodyResultSupportVersionsSupportVersionList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        supportVersionList = make_shared<vector<GetRegionConfigurationResponseBodyResultSupportVersionsSupportVersionList>>(expect1);
      }
    }
  }


  virtual ~GetRegionConfigurationResponseBodyResultSupportVersions() = default;
};
class GetRegionConfigurationResponseBodyResultWarmNodePropertiesAmountRange : public Darabonba::Model {
public:
  shared_ptr<long> maxAmount{};
  shared_ptr<long> minAmount{};

  GetRegionConfigurationResponseBodyResultWarmNodePropertiesAmountRange() {}

  explicit GetRegionConfigurationResponseBodyResultWarmNodePropertiesAmountRange(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (maxAmount) {
      res["maxAmount"] = boost::any(*maxAmount);
    }
    if (minAmount) {
      res["minAmount"] = boost::any(*minAmount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("maxAmount") != m.end() && !m["maxAmount"].empty()) {
      maxAmount = make_shared<long>(boost::any_cast<long>(m["maxAmount"]));
    }
    if (m.find("minAmount") != m.end() && !m["minAmount"].empty()) {
      minAmount = make_shared<long>(boost::any_cast<long>(m["minAmount"]));
    }
  }


  virtual ~GetRegionConfigurationResponseBodyResultWarmNodePropertiesAmountRange() = default;
};
class GetRegionConfigurationResponseBodyResultWarmNodePropertiesDiskList : public Darabonba::Model {
public:
  shared_ptr<bool> diskEncryption{};
  shared_ptr<string> diskType{};
  shared_ptr<long> maxSize{};
  shared_ptr<long> minSize{};
  shared_ptr<long> scaleLimit{};
  shared_ptr<vector<string>> valueLimitSet{};

  GetRegionConfigurationResponseBodyResultWarmNodePropertiesDiskList() {}

  explicit GetRegionConfigurationResponseBodyResultWarmNodePropertiesDiskList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (diskEncryption) {
      res["diskEncryption"] = boost::any(*diskEncryption);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (maxSize) {
      res["maxSize"] = boost::any(*maxSize);
    }
    if (minSize) {
      res["minSize"] = boost::any(*minSize);
    }
    if (scaleLimit) {
      res["scaleLimit"] = boost::any(*scaleLimit);
    }
    if (valueLimitSet) {
      res["valueLimitSet"] = boost::any(*valueLimitSet);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("diskEncryption") != m.end() && !m["diskEncryption"].empty()) {
      diskEncryption = make_shared<bool>(boost::any_cast<bool>(m["diskEncryption"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("maxSize") != m.end() && !m["maxSize"].empty()) {
      maxSize = make_shared<long>(boost::any_cast<long>(m["maxSize"]));
    }
    if (m.find("minSize") != m.end() && !m["minSize"].empty()) {
      minSize = make_shared<long>(boost::any_cast<long>(m["minSize"]));
    }
    if (m.find("scaleLimit") != m.end() && !m["scaleLimit"].empty()) {
      scaleLimit = make_shared<long>(boost::any_cast<long>(m["scaleLimit"]));
    }
    if (m.find("valueLimitSet") != m.end() && !m["valueLimitSet"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["valueLimitSet"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["valueLimitSet"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      valueLimitSet = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetRegionConfigurationResponseBodyResultWarmNodePropertiesDiskList() = default;
};
class GetRegionConfigurationResponseBodyResultWarmNodeProperties : public Darabonba::Model {
public:
  shared_ptr<GetRegionConfigurationResponseBodyResultWarmNodePropertiesAmountRange> amountRange{};
  shared_ptr<vector<GetRegionConfigurationResponseBodyResultWarmNodePropertiesDiskList>> diskList{};
  shared_ptr<vector<string>> spec{};

  GetRegionConfigurationResponseBodyResultWarmNodeProperties() {}

  explicit GetRegionConfigurationResponseBodyResultWarmNodeProperties(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amountRange) {
      res["amountRange"] = amountRange ? boost::any(amountRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (diskList) {
      vector<boost::any> temp1;
      for(auto item1:*diskList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["diskList"] = boost::any(temp1);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amountRange") != m.end() && !m["amountRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["amountRange"].type()) {
        GetRegionConfigurationResponseBodyResultWarmNodePropertiesAmountRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["amountRange"]));
        amountRange = make_shared<GetRegionConfigurationResponseBodyResultWarmNodePropertiesAmountRange>(model1);
      }
    }
    if (m.find("diskList") != m.end() && !m["diskList"].empty()) {
      if (typeid(vector<boost::any>) == m["diskList"].type()) {
        vector<GetRegionConfigurationResponseBodyResultWarmNodePropertiesDiskList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["diskList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRegionConfigurationResponseBodyResultWarmNodePropertiesDiskList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        diskList = make_shared<vector<GetRegionConfigurationResponseBodyResultWarmNodePropertiesDiskList>>(expect1);
      }
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["spec"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["spec"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      spec = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetRegionConfigurationResponseBodyResultWarmNodeProperties() = default;
};
class GetRegionConfigurationResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<GetRegionConfigurationResponseBodyResultClientNodeAmountRange> clientNodeAmountRange{};
  shared_ptr<vector<GetRegionConfigurationResponseBodyResultClientNodeDiskList>> clientNodeDiskList{};
  shared_ptr<vector<string>> clientNodeSpec{};
  shared_ptr<string> createUrl{};
  shared_ptr<vector<GetRegionConfigurationResponseBodyResultDataDiskList>> dataDiskList{};
  shared_ptr<GetRegionConfigurationResponseBodyResultElasticNodeProperties> elasticNodeProperties{};
  shared_ptr<string> env{};
  shared_ptr<vector<string>> esVersions{};
  shared_ptr<vector<GetRegionConfigurationResponseBodyResultEsVersionsLatestList>> esVersionsLatestList{};
  shared_ptr<vector<string>> instanceSupportNodes{};
  shared_ptr<GetRegionConfigurationResponseBodyResultJvmConfine> jvmConfine{};
  shared_ptr<GetRegionConfigurationResponseBodyResultKibanaNodeProperties> kibanaNodeProperties{};
  shared_ptr<vector<GetRegionConfigurationResponseBodyResultMasterDiskList>> masterDiskList{};
  shared_ptr<vector<string>> masterSpec{};
  shared_ptr<GetRegionConfigurationResponseBodyResultNode> node{};
  shared_ptr<vector<GetRegionConfigurationResponseBodyResultNodeSpecList>> nodeSpecList{};
  shared_ptr<string> regionId{};
  shared_ptr<vector<GetRegionConfigurationResponseBodyResultSupportVersions>> supportVersions{};
  shared_ptr<GetRegionConfigurationResponseBodyResultWarmNodeProperties> warmNodeProperties{};
  shared_ptr<vector<string>> zones{};

  GetRegionConfigurationResponseBodyResult() {}

  explicit GetRegionConfigurationResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientNodeAmountRange) {
      res["clientNodeAmountRange"] = clientNodeAmountRange ? boost::any(clientNodeAmountRange->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clientNodeDiskList) {
      vector<boost::any> temp1;
      for(auto item1:*clientNodeDiskList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["clientNodeDiskList"] = boost::any(temp1);
    }
    if (clientNodeSpec) {
      res["clientNodeSpec"] = boost::any(*clientNodeSpec);
    }
    if (createUrl) {
      res["createUrl"] = boost::any(*createUrl);
    }
    if (dataDiskList) {
      vector<boost::any> temp1;
      for(auto item1:*dataDiskList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["dataDiskList"] = boost::any(temp1);
    }
    if (elasticNodeProperties) {
      res["elasticNodeProperties"] = elasticNodeProperties ? boost::any(elasticNodeProperties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (env) {
      res["env"] = boost::any(*env);
    }
    if (esVersions) {
      res["esVersions"] = boost::any(*esVersions);
    }
    if (esVersionsLatestList) {
      vector<boost::any> temp1;
      for(auto item1:*esVersionsLatestList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["esVersionsLatestList"] = boost::any(temp1);
    }
    if (instanceSupportNodes) {
      res["instanceSupportNodes"] = boost::any(*instanceSupportNodes);
    }
    if (jvmConfine) {
      res["jvmConfine"] = jvmConfine ? boost::any(jvmConfine->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (kibanaNodeProperties) {
      res["kibanaNodeProperties"] = kibanaNodeProperties ? boost::any(kibanaNodeProperties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (masterDiskList) {
      vector<boost::any> temp1;
      for(auto item1:*masterDiskList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["masterDiskList"] = boost::any(temp1);
    }
    if (masterSpec) {
      res["masterSpec"] = boost::any(*masterSpec);
    }
    if (node) {
      res["node"] = node ? boost::any(node->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodeSpecList) {
      vector<boost::any> temp1;
      for(auto item1:*nodeSpecList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["nodeSpecList"] = boost::any(temp1);
    }
    if (regionId) {
      res["regionId"] = boost::any(*regionId);
    }
    if (supportVersions) {
      vector<boost::any> temp1;
      for(auto item1:*supportVersions){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["supportVersions"] = boost::any(temp1);
    }
    if (warmNodeProperties) {
      res["warmNodeProperties"] = warmNodeProperties ? boost::any(warmNodeProperties->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (zones) {
      res["zones"] = boost::any(*zones);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientNodeAmountRange") != m.end() && !m["clientNodeAmountRange"].empty()) {
      if (typeid(map<string, boost::any>) == m["clientNodeAmountRange"].type()) {
        GetRegionConfigurationResponseBodyResultClientNodeAmountRange model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["clientNodeAmountRange"]));
        clientNodeAmountRange = make_shared<GetRegionConfigurationResponseBodyResultClientNodeAmountRange>(model1);
      }
    }
    if (m.find("clientNodeDiskList") != m.end() && !m["clientNodeDiskList"].empty()) {
      if (typeid(vector<boost::any>) == m["clientNodeDiskList"].type()) {
        vector<GetRegionConfigurationResponseBodyResultClientNodeDiskList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["clientNodeDiskList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRegionConfigurationResponseBodyResultClientNodeDiskList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        clientNodeDiskList = make_shared<vector<GetRegionConfigurationResponseBodyResultClientNodeDiskList>>(expect1);
      }
    }
    if (m.find("clientNodeSpec") != m.end() && !m["clientNodeSpec"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["clientNodeSpec"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["clientNodeSpec"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      clientNodeSpec = make_shared<vector<string>>(toVec1);
    }
    if (m.find("createUrl") != m.end() && !m["createUrl"].empty()) {
      createUrl = make_shared<string>(boost::any_cast<string>(m["createUrl"]));
    }
    if (m.find("dataDiskList") != m.end() && !m["dataDiskList"].empty()) {
      if (typeid(vector<boost::any>) == m["dataDiskList"].type()) {
        vector<GetRegionConfigurationResponseBodyResultDataDiskList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["dataDiskList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRegionConfigurationResponseBodyResultDataDiskList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dataDiskList = make_shared<vector<GetRegionConfigurationResponseBodyResultDataDiskList>>(expect1);
      }
    }
    if (m.find("elasticNodeProperties") != m.end() && !m["elasticNodeProperties"].empty()) {
      if (typeid(map<string, boost::any>) == m["elasticNodeProperties"].type()) {
        GetRegionConfigurationResponseBodyResultElasticNodeProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["elasticNodeProperties"]));
        elasticNodeProperties = make_shared<GetRegionConfigurationResponseBodyResultElasticNodeProperties>(model1);
      }
    }
    if (m.find("env") != m.end() && !m["env"].empty()) {
      env = make_shared<string>(boost::any_cast<string>(m["env"]));
    }
    if (m.find("esVersions") != m.end() && !m["esVersions"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["esVersions"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["esVersions"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      esVersions = make_shared<vector<string>>(toVec1);
    }
    if (m.find("esVersionsLatestList") != m.end() && !m["esVersionsLatestList"].empty()) {
      if (typeid(vector<boost::any>) == m["esVersionsLatestList"].type()) {
        vector<GetRegionConfigurationResponseBodyResultEsVersionsLatestList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["esVersionsLatestList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRegionConfigurationResponseBodyResultEsVersionsLatestList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        esVersionsLatestList = make_shared<vector<GetRegionConfigurationResponseBodyResultEsVersionsLatestList>>(expect1);
      }
    }
    if (m.find("instanceSupportNodes") != m.end() && !m["instanceSupportNodes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["instanceSupportNodes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["instanceSupportNodes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      instanceSupportNodes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("jvmConfine") != m.end() && !m["jvmConfine"].empty()) {
      if (typeid(map<string, boost::any>) == m["jvmConfine"].type()) {
        GetRegionConfigurationResponseBodyResultJvmConfine model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["jvmConfine"]));
        jvmConfine = make_shared<GetRegionConfigurationResponseBodyResultJvmConfine>(model1);
      }
    }
    if (m.find("kibanaNodeProperties") != m.end() && !m["kibanaNodeProperties"].empty()) {
      if (typeid(map<string, boost::any>) == m["kibanaNodeProperties"].type()) {
        GetRegionConfigurationResponseBodyResultKibanaNodeProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["kibanaNodeProperties"]));
        kibanaNodeProperties = make_shared<GetRegionConfigurationResponseBodyResultKibanaNodeProperties>(model1);
      }
    }
    if (m.find("masterDiskList") != m.end() && !m["masterDiskList"].empty()) {
      if (typeid(vector<boost::any>) == m["masterDiskList"].type()) {
        vector<GetRegionConfigurationResponseBodyResultMasterDiskList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["masterDiskList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRegionConfigurationResponseBodyResultMasterDiskList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        masterDiskList = make_shared<vector<GetRegionConfigurationResponseBodyResultMasterDiskList>>(expect1);
      }
    }
    if (m.find("masterSpec") != m.end() && !m["masterSpec"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["masterSpec"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["masterSpec"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      masterSpec = make_shared<vector<string>>(toVec1);
    }
    if (m.find("node") != m.end() && !m["node"].empty()) {
      if (typeid(map<string, boost::any>) == m["node"].type()) {
        GetRegionConfigurationResponseBodyResultNode model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["node"]));
        node = make_shared<GetRegionConfigurationResponseBodyResultNode>(model1);
      }
    }
    if (m.find("nodeSpecList") != m.end() && !m["nodeSpecList"].empty()) {
      if (typeid(vector<boost::any>) == m["nodeSpecList"].type()) {
        vector<GetRegionConfigurationResponseBodyResultNodeSpecList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["nodeSpecList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRegionConfigurationResponseBodyResultNodeSpecList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        nodeSpecList = make_shared<vector<GetRegionConfigurationResponseBodyResultNodeSpecList>>(expect1);
      }
    }
    if (m.find("regionId") != m.end() && !m["regionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["regionId"]));
    }
    if (m.find("supportVersions") != m.end() && !m["supportVersions"].empty()) {
      if (typeid(vector<boost::any>) == m["supportVersions"].type()) {
        vector<GetRegionConfigurationResponseBodyResultSupportVersions> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["supportVersions"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetRegionConfigurationResponseBodyResultSupportVersions model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        supportVersions = make_shared<vector<GetRegionConfigurationResponseBodyResultSupportVersions>>(expect1);
      }
    }
    if (m.find("warmNodeProperties") != m.end() && !m["warmNodeProperties"].empty()) {
      if (typeid(map<string, boost::any>) == m["warmNodeProperties"].type()) {
        GetRegionConfigurationResponseBodyResultWarmNodeProperties model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["warmNodeProperties"]));
        warmNodeProperties = make_shared<GetRegionConfigurationResponseBodyResultWarmNodeProperties>(model1);
      }
    }
    if (m.find("zones") != m.end() && !m["zones"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["zones"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["zones"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      zones = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~GetRegionConfigurationResponseBodyResult() = default;
};
class GetRegionConfigurationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<GetRegionConfigurationResponseBodyResult> result{};

  GetRegionConfigurationResponseBody() {}

  explicit GetRegionConfigurationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        GetRegionConfigurationResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<GetRegionConfigurationResponseBodyResult>(model1);
      }
    }
  }


  virtual ~GetRegionConfigurationResponseBody() = default;
};
class GetRegionConfigurationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetRegionConfigurationResponseBody> body{};

  GetRegionConfigurationResponse() {}

  explicit GetRegionConfigurationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetRegionConfigurationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetRegionConfigurationResponseBody>(model1);
      }
    }
  }


  virtual ~GetRegionConfigurationResponse() = default;
};
class GetSuggestShrinkableNodesRequest : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<bool> ignoreStatus{};
  shared_ptr<string> nodeType{};

  GetSuggestShrinkableNodesRequest() {}

  explicit GetSuggestShrinkableNodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["count"] = boost::any(*count);
    }
    if (ignoreStatus) {
      res["ignoreStatus"] = boost::any(*ignoreStatus);
    }
    if (nodeType) {
      res["nodeType"] = boost::any(*nodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("count") != m.end() && !m["count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["count"]));
    }
    if (m.find("ignoreStatus") != m.end() && !m["ignoreStatus"].empty()) {
      ignoreStatus = make_shared<bool>(boost::any_cast<bool>(m["ignoreStatus"]));
    }
    if (m.find("nodeType") != m.end() && !m["nodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["nodeType"]));
    }
  }


  virtual ~GetSuggestShrinkableNodesRequest() = default;
};
class GetSuggestShrinkableNodesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<long> port{};

  GetSuggestShrinkableNodesResponseBodyResult() {}

  explicit GetSuggestShrinkableNodesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["host"] = boost::any(*host);
    }
    if (port) {
      res["port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("host") != m.end() && !m["host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["host"]));
    }
    if (m.find("port") != m.end() && !m["port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["port"]));
    }
  }


  virtual ~GetSuggestShrinkableNodesResponseBodyResult() = default;
};
class GetSuggestShrinkableNodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetSuggestShrinkableNodesResponseBodyResult>> result{};

  GetSuggestShrinkableNodesResponseBody() {}

  explicit GetSuggestShrinkableNodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<GetSuggestShrinkableNodesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetSuggestShrinkableNodesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<GetSuggestShrinkableNodesResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~GetSuggestShrinkableNodesResponseBody() = default;
};
class GetSuggestShrinkableNodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetSuggestShrinkableNodesResponseBody> body{};

  GetSuggestShrinkableNodesResponse() {}

  explicit GetSuggestShrinkableNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetSuggestShrinkableNodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetSuggestShrinkableNodesResponseBody>(model1);
      }
    }
  }


  virtual ~GetSuggestShrinkableNodesResponse() = default;
};
class GetTransferableNodesRequest : public Darabonba::Model {
public:
  shared_ptr<long> count{};
  shared_ptr<string> nodeType{};

  GetTransferableNodesRequest() {}

  explicit GetTransferableNodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (count) {
      res["count"] = boost::any(*count);
    }
    if (nodeType) {
      res["nodeType"] = boost::any(*nodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("count") != m.end() && !m["count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["count"]));
    }
    if (m.find("nodeType") != m.end() && !m["nodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["nodeType"]));
    }
  }


  virtual ~GetTransferableNodesRequest() = default;
};
class GetTransferableNodesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<long> port{};

  GetTransferableNodesResponseBodyResult() {}

  explicit GetTransferableNodesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["host"] = boost::any(*host);
    }
    if (port) {
      res["port"] = boost::any(*port);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("host") != m.end() && !m["host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["host"]));
    }
    if (m.find("port") != m.end() && !m["port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["port"]));
    }
  }


  virtual ~GetTransferableNodesResponseBodyResult() = default;
};
class GetTransferableNodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<GetTransferableNodesResponseBodyResult>> result{};

  GetTransferableNodesResponseBody() {}

  explicit GetTransferableNodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<GetTransferableNodesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            GetTransferableNodesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<GetTransferableNodesResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~GetTransferableNodesResponseBody() = default;
};
class GetTransferableNodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<GetTransferableNodesResponseBody> body{};

  GetTransferableNodesResponse() {}

  explicit GetTransferableNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        GetTransferableNodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<GetTransferableNodesResponseBody>(model1);
      }
    }
  }


  virtual ~GetTransferableNodesResponse() = default;
};
class InitializeOperationRoleRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> body{};

  InitializeOperationRoleRequest() {}

  explicit InitializeOperationRoleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~InitializeOperationRoleRequest() = default;
};
class InitializeOperationRoleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  InitializeOperationRoleResponseBody() {}

  explicit InitializeOperationRoleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~InitializeOperationRoleResponseBody() = default;
};
class InitializeOperationRoleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InitializeOperationRoleResponseBody> body{};

  InitializeOperationRoleResponse() {}

  explicit InitializeOperationRoleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InitializeOperationRoleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InitializeOperationRoleResponseBody>(model1);
      }
    }
  }


  virtual ~InitializeOperationRoleResponse() = default;
};
class InstallAckOperatorRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> body{};

  InstallAckOperatorRequest() {}

  explicit InstallAckOperatorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~InstallAckOperatorRequest() = default;
};
class InstallAckOperatorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  InstallAckOperatorResponseBody() {}

  explicit InstallAckOperatorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~InstallAckOperatorResponseBody() = default;
};
class InstallAckOperatorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InstallAckOperatorResponseBody> body{};

  InstallAckOperatorResponse() {}

  explicit InstallAckOperatorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstallAckOperatorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstallAckOperatorResponseBody>(model1);
      }
    }
  }


  virtual ~InstallAckOperatorResponse() = default;
};
class InstallKibanaSystemPluginRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};

  InstallKibanaSystemPluginRequest() {}

  explicit InstallKibanaSystemPluginRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~InstallKibanaSystemPluginRequest() = default;
};
class InstallKibanaSystemPluginResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> result{};

  InstallKibanaSystemPluginResponseBody() {}

  explicit InstallKibanaSystemPluginResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Result"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      result = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~InstallKibanaSystemPluginResponseBody() = default;
};
class InstallKibanaSystemPluginResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InstallKibanaSystemPluginResponseBody> body{};

  InstallKibanaSystemPluginResponse() {}

  explicit InstallKibanaSystemPluginResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstallKibanaSystemPluginResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstallKibanaSystemPluginResponseBody>(model1);
      }
    }
  }


  virtual ~InstallKibanaSystemPluginResponse() = default;
};
class InstallLogstashSystemPluginRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};

  InstallLogstashSystemPluginRequest() {}

  explicit InstallLogstashSystemPluginRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~InstallLogstashSystemPluginRequest() = default;
};
class InstallLogstashSystemPluginResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> result{};

  InstallLogstashSystemPluginResponseBody() {}

  explicit InstallLogstashSystemPluginResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Result"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      result = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~InstallLogstashSystemPluginResponseBody() = default;
};
class InstallLogstashSystemPluginResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InstallLogstashSystemPluginResponseBody> body{};

  InstallLogstashSystemPluginResponse() {}

  explicit InstallLogstashSystemPluginResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstallLogstashSystemPluginResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstallLogstashSystemPluginResponseBody>(model1);
      }
    }
  }


  virtual ~InstallLogstashSystemPluginResponse() = default;
};
class InstallSystemPluginRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};

  InstallSystemPluginRequest() {}

  explicit InstallSystemPluginRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~InstallSystemPluginRequest() = default;
};
class InstallSystemPluginResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> result{};

  InstallSystemPluginResponseBody() {}

  explicit InstallSystemPluginResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Result"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      result = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~InstallSystemPluginResponseBody() = default;
};
class InstallSystemPluginResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InstallSystemPluginResponseBody> body{};

  InstallSystemPluginResponse() {}

  explicit InstallSystemPluginResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstallSystemPluginResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstallSystemPluginResponseBody>(model1);
      }
    }
  }


  virtual ~InstallSystemPluginResponse() = default;
};
class InstallUserPluginsRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};

  InstallUserPluginsRequest() {}

  explicit InstallUserPluginsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~InstallUserPluginsRequest() = default;
};
class InstallUserPluginsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> result{};

  InstallUserPluginsResponseBody() {}

  explicit InstallUserPluginsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Result"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      result = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~InstallUserPluginsResponseBody() = default;
};
class InstallUserPluginsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InstallUserPluginsResponseBody> body{};

  InstallUserPluginsResponse() {}

  explicit InstallUserPluginsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InstallUserPluginsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InstallUserPluginsResponseBody>(model1);
      }
    }
  }


  virtual ~InstallUserPluginsResponse() = default;
};
class InterruptElasticsearchTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};

  InterruptElasticsearchTaskRequest() {}

  explicit InterruptElasticsearchTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~InterruptElasticsearchTaskRequest() = default;
};
class InterruptElasticsearchTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  InterruptElasticsearchTaskResponseBody() {}

  explicit InterruptElasticsearchTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~InterruptElasticsearchTaskResponseBody() = default;
};
class InterruptElasticsearchTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InterruptElasticsearchTaskResponseBody> body{};

  InterruptElasticsearchTaskResponse() {}

  explicit InterruptElasticsearchTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InterruptElasticsearchTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InterruptElasticsearchTaskResponseBody>(model1);
      }
    }
  }


  virtual ~InterruptElasticsearchTaskResponse() = default;
};
class InterruptLogstashTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};

  InterruptLogstashTaskRequest() {}

  explicit InterruptLogstashTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~InterruptLogstashTaskRequest() = default;
};
class InterruptLogstashTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  InterruptLogstashTaskResponseBody() {}

  explicit InterruptLogstashTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~InterruptLogstashTaskResponseBody() = default;
};
class InterruptLogstashTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<InterruptLogstashTaskResponseBody> body{};

  InterruptLogstashTaskResponse() {}

  explicit InterruptLogstashTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        InterruptLogstashTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<InterruptLogstashTaskResponseBody>(model1);
      }
    }
  }


  virtual ~InterruptLogstashTaskResponse() = default;
};
class ListAckClustersRequest : public Darabonba::Model {
public:
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<string> vpcId{};

  ListAckClustersRequest() {}

  explicit ListAckClustersRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
  }


  virtual ~ListAckClustersRequest() = default;
};
class ListAckClustersResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> clusterId{};
  shared_ptr<string> clusterType{};
  shared_ptr<string> name{};
  shared_ptr<string> vpcId{};

  ListAckClustersResponseBodyResult() {}

  explicit ListAckClustersResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clusterId) {
      res["clusterId"] = boost::any(*clusterId);
    }
    if (clusterType) {
      res["clusterType"] = boost::any(*clusterType);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clusterId") != m.end() && !m["clusterId"].empty()) {
      clusterId = make_shared<string>(boost::any_cast<string>(m["clusterId"]));
    }
    if (m.find("clusterType") != m.end() && !m["clusterType"].empty()) {
      clusterType = make_shared<string>(boost::any_cast<string>(m["clusterType"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
  }


  virtual ~ListAckClustersResponseBodyResult() = default;
};
class ListAckClustersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListAckClustersResponseBodyResult>> result{};

  ListAckClustersResponseBody() {}

  explicit ListAckClustersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListAckClustersResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAckClustersResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListAckClustersResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListAckClustersResponseBody() = default;
};
class ListAckClustersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAckClustersResponseBody> body{};

  ListAckClustersResponse() {}

  explicit ListAckClustersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAckClustersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAckClustersResponseBody>(model1);
      }
    }
  }


  virtual ~ListAckClustersResponse() = default;
};
class ListAckNamespacesRequest : public Darabonba::Model {
public:
  shared_ptr<long> page{};
  shared_ptr<long> size{};

  ListAckNamespacesRequest() {}

  explicit ListAckNamespacesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
  }


  virtual ~ListAckNamespacesRequest() = default;
};
class ListAckNamespacesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> namespace_{};
  shared_ptr<string> status{};

  ListAckNamespacesResponseBodyResult() {}

  explicit ListAckNamespacesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (namespace_) {
      res["namespace"] = boost::any(*namespace_);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("namespace") != m.end() && !m["namespace"].empty()) {
      namespace_ = make_shared<string>(boost::any_cast<string>(m["namespace"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~ListAckNamespacesResponseBodyResult() = default;
};
class ListAckNamespacesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListAckNamespacesResponseBodyResult>> result{};

  ListAckNamespacesResponseBody() {}

  explicit ListAckNamespacesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListAckNamespacesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAckNamespacesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListAckNamespacesResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListAckNamespacesResponseBody() = default;
};
class ListAckNamespacesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAckNamespacesResponseBody> body{};

  ListAckNamespacesResponse() {}

  explicit ListAckNamespacesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAckNamespacesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAckNamespacesResponseBody>(model1);
      }
    }
  }


  virtual ~ListAckNamespacesResponse() = default;
};
class ListActionRecordsRequest : public Darabonba::Model {
public:
  shared_ptr<string> actionNames{};
  shared_ptr<long> endTime{};
  shared_ptr<string> filter{};
  shared_ptr<long> page{};
  shared_ptr<string> requestId{};
  shared_ptr<long> size{};
  shared_ptr<long> startTime{};
  shared_ptr<string> userId{};

  ListActionRecordsRequest() {}

  explicit ListActionRecordsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionNames) {
      res["actionNames"] = boost::any(*actionNames);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (filter) {
      res["filter"] = boost::any(*filter);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (userId) {
      res["userId"] = boost::any(*userId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("actionNames") != m.end() && !m["actionNames"].empty()) {
      actionNames = make_shared<string>(boost::any_cast<string>(m["actionNames"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("filter") != m.end() && !m["filter"].empty()) {
      filter = make_shared<string>(boost::any_cast<string>(m["filter"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
    if (m.find("userId") != m.end() && !m["userId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["userId"]));
    }
  }


  virtual ~ListActionRecordsRequest() = default;
};
class ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo : public Darabonba::Model {
public:
  shared_ptr<long> completeNodeCount{};
  shared_ptr<long> endTime{};
  shared_ptr<string> exception{};
  shared_ptr<long> latencyMills{};
  shared_ptr<long> nodeCount{};
  shared_ptr<string> process{};
  shared_ptr<long> startTime{};
  shared_ptr<string> stateType{};
  shared_ptr<string> subState{};

  ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo() {}

  explicit ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (completeNodeCount) {
      res["completeNodeCount"] = boost::any(*completeNodeCount);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (exception) {
      res["exception"] = boost::any(*exception);
    }
    if (latencyMills) {
      res["latencyMills"] = boost::any(*latencyMills);
    }
    if (nodeCount) {
      res["nodeCount"] = boost::any(*nodeCount);
    }
    if (process) {
      res["process"] = boost::any(*process);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (stateType) {
      res["stateType"] = boost::any(*stateType);
    }
    if (subState) {
      res["subState"] = boost::any(*subState);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("completeNodeCount") != m.end() && !m["completeNodeCount"].empty()) {
      completeNodeCount = make_shared<long>(boost::any_cast<long>(m["completeNodeCount"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("exception") != m.end() && !m["exception"].empty()) {
      exception = make_shared<string>(boost::any_cast<string>(m["exception"]));
    }
    if (m.find("latencyMills") != m.end() && !m["latencyMills"].empty()) {
      latencyMills = make_shared<long>(boost::any_cast<long>(m["latencyMills"]));
    }
    if (m.find("nodeCount") != m.end() && !m["nodeCount"].empty()) {
      nodeCount = make_shared<long>(boost::any_cast<long>(m["nodeCount"]));
    }
    if (m.find("process") != m.end() && !m["process"].empty()) {
      process = make_shared<string>(boost::any_cast<string>(m["process"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
    if (m.find("stateType") != m.end() && !m["stateType"].empty()) {
      stateType = make_shared<string>(boost::any_cast<string>(m["stateType"]));
    }
    if (m.find("subState") != m.end() && !m["subState"].empty()) {
      subState = make_shared<string>(boost::any_cast<string>(m["subState"]));
    }
  }


  virtual ~ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo() = default;
};
class ListActionRecordsResponseBodyResultStatusInfo : public Darabonba::Model {
public:
  shared_ptr<long> completeNodeCount{};
  shared_ptr<long> endTime{};
  shared_ptr<string> exception{};
  shared_ptr<long> latencyMills{};
  shared_ptr<long> nodeCount{};
  shared_ptr<string> process{};
  shared_ptr<long> startTime{};
  shared_ptr<string> stateType{};
  shared_ptr<string> subState{};
  shared_ptr<vector<ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo>> subStatusInfo{};

  ListActionRecordsResponseBodyResultStatusInfo() {}

  explicit ListActionRecordsResponseBodyResultStatusInfo(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (completeNodeCount) {
      res["completeNodeCount"] = boost::any(*completeNodeCount);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (exception) {
      res["exception"] = boost::any(*exception);
    }
    if (latencyMills) {
      res["latencyMills"] = boost::any(*latencyMills);
    }
    if (nodeCount) {
      res["nodeCount"] = boost::any(*nodeCount);
    }
    if (process) {
      res["process"] = boost::any(*process);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (stateType) {
      res["stateType"] = boost::any(*stateType);
    }
    if (subState) {
      res["subState"] = boost::any(*subState);
    }
    if (subStatusInfo) {
      vector<boost::any> temp1;
      for(auto item1:*subStatusInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["subStatusInfo"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("completeNodeCount") != m.end() && !m["completeNodeCount"].empty()) {
      completeNodeCount = make_shared<long>(boost::any_cast<long>(m["completeNodeCount"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("exception") != m.end() && !m["exception"].empty()) {
      exception = make_shared<string>(boost::any_cast<string>(m["exception"]));
    }
    if (m.find("latencyMills") != m.end() && !m["latencyMills"].empty()) {
      latencyMills = make_shared<long>(boost::any_cast<long>(m["latencyMills"]));
    }
    if (m.find("nodeCount") != m.end() && !m["nodeCount"].empty()) {
      nodeCount = make_shared<long>(boost::any_cast<long>(m["nodeCount"]));
    }
    if (m.find("process") != m.end() && !m["process"].empty()) {
      process = make_shared<string>(boost::any_cast<string>(m["process"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
    if (m.find("stateType") != m.end() && !m["stateType"].empty()) {
      stateType = make_shared<string>(boost::any_cast<string>(m["stateType"]));
    }
    if (m.find("subState") != m.end() && !m["subState"].empty()) {
      subState = make_shared<string>(boost::any_cast<string>(m["subState"]));
    }
    if (m.find("subStatusInfo") != m.end() && !m["subStatusInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["subStatusInfo"].type()) {
        vector<ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["subStatusInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        subStatusInfo = make_shared<vector<ListActionRecordsResponseBodyResultStatusInfoSubStatusInfo>>(expect1);
      }
    }
  }


  virtual ~ListActionRecordsResponseBodyResultStatusInfo() = default;
};
class ListActionRecordsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> actionName{};
  shared_ptr<map<string, boost::any>> actionParams{};
  shared_ptr<vector<string>> actionResultAccessList{};
  shared_ptr<long> endTime{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> metaNow{};
  shared_ptr<string> metaOld{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> process{};
  shared_ptr<map<string, boost::any>> recordDiff{};
  shared_ptr<vector<string>> recordIds{};
  shared_ptr<string> requestId{};
  shared_ptr<long> startTime{};
  shared_ptr<string> stateType{};
  shared_ptr<vector<ListActionRecordsResponseBodyResultStatusInfo>> statusInfo{};
  shared_ptr<string> userId{};
  shared_ptr<string> userInfo{};
  shared_ptr<string> userType{};

  ListActionRecordsResponseBodyResult() {}

  explicit ListActionRecordsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionName) {
      res["ActionName"] = boost::any(*actionName);
    }
    if (actionParams) {
      res["ActionParams"] = boost::any(*actionParams);
    }
    if (actionResultAccessList) {
      res["ActionResultAccessList"] = boost::any(*actionResultAccessList);
    }
    if (endTime) {
      res["EndTime"] = boost::any(*endTime);
    }
    if (instanceId) {
      res["InstanceId"] = boost::any(*instanceId);
    }
    if (metaNow) {
      res["MetaNow"] = boost::any(*metaNow);
    }
    if (metaOld) {
      res["MetaOld"] = boost::any(*metaOld);
    }
    if (ownerId) {
      res["OwnerId"] = boost::any(*ownerId);
    }
    if (process) {
      res["Process"] = boost::any(*process);
    }
    if (recordDiff) {
      res["RecordDiff"] = boost::any(*recordDiff);
    }
    if (recordIds) {
      res["RecordIds"] = boost::any(*recordIds);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (startTime) {
      res["StartTime"] = boost::any(*startTime);
    }
    if (stateType) {
      res["StateType"] = boost::any(*stateType);
    }
    if (statusInfo) {
      vector<boost::any> temp1;
      for(auto item1:*statusInfo){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["StatusInfo"] = boost::any(temp1);
    }
    if (userId) {
      res["UserId"] = boost::any(*userId);
    }
    if (userInfo) {
      res["UserInfo"] = boost::any(*userInfo);
    }
    if (userType) {
      res["UserType"] = boost::any(*userType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ActionName") != m.end() && !m["ActionName"].empty()) {
      actionName = make_shared<string>(boost::any_cast<string>(m["ActionName"]));
    }
    if (m.find("ActionParams") != m.end() && !m["ActionParams"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["ActionParams"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      actionParams = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("ActionResultAccessList") != m.end() && !m["ActionResultAccessList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ActionResultAccessList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ActionResultAccessList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      actionResultAccessList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("EndTime") != m.end() && !m["EndTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["EndTime"]));
    }
    if (m.find("InstanceId") != m.end() && !m["InstanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["InstanceId"]));
    }
    if (m.find("MetaNow") != m.end() && !m["MetaNow"].empty()) {
      metaNow = make_shared<string>(boost::any_cast<string>(m["MetaNow"]));
    }
    if (m.find("MetaOld") != m.end() && !m["MetaOld"].empty()) {
      metaOld = make_shared<string>(boost::any_cast<string>(m["MetaOld"]));
    }
    if (m.find("OwnerId") != m.end() && !m["OwnerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["OwnerId"]));
    }
    if (m.find("Process") != m.end() && !m["Process"].empty()) {
      process = make_shared<string>(boost::any_cast<string>(m["Process"]));
    }
    if (m.find("RecordDiff") != m.end() && !m["RecordDiff"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["RecordDiff"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      recordDiff = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RecordIds") != m.end() && !m["RecordIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["RecordIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["RecordIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      recordIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("StartTime") != m.end() && !m["StartTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["StartTime"]));
    }
    if (m.find("StateType") != m.end() && !m["StateType"].empty()) {
      stateType = make_shared<string>(boost::any_cast<string>(m["StateType"]));
    }
    if (m.find("StatusInfo") != m.end() && !m["StatusInfo"].empty()) {
      if (typeid(vector<boost::any>) == m["StatusInfo"].type()) {
        vector<ListActionRecordsResponseBodyResultStatusInfo> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["StatusInfo"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListActionRecordsResponseBodyResultStatusInfo model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        statusInfo = make_shared<vector<ListActionRecordsResponseBodyResultStatusInfo>>(expect1);
      }
    }
    if (m.find("UserId") != m.end() && !m["UserId"].empty()) {
      userId = make_shared<string>(boost::any_cast<string>(m["UserId"]));
    }
    if (m.find("UserInfo") != m.end() && !m["UserInfo"].empty()) {
      userInfo = make_shared<string>(boost::any_cast<string>(m["UserInfo"]));
    }
    if (m.find("UserType") != m.end() && !m["UserType"].empty()) {
      userType = make_shared<string>(boost::any_cast<string>(m["UserType"]));
    }
  }


  virtual ~ListActionRecordsResponseBodyResult() = default;
};
class ListActionRecordsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListActionRecordsResponseBodyResult>> result{};

  ListActionRecordsResponseBody() {}

  explicit ListActionRecordsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListActionRecordsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListActionRecordsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListActionRecordsResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListActionRecordsResponseBody() = default;
};
class ListActionRecordsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListActionRecordsResponseBody> body{};

  ListActionRecordsResponse() {}

  explicit ListActionRecordsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListActionRecordsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListActionRecordsResponseBody>(model1);
      }
    }
  }


  virtual ~ListActionRecordsResponse() = default;
};
class ListAllNodeRequest : public Darabonba::Model {
public:
  shared_ptr<bool> extended{};

  ListAllNodeRequest() {}

  explicit ListAllNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (extended) {
      res["extended"] = boost::any(*extended);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("extended") != m.end() && !m["extended"].empty()) {
      extended = make_shared<bool>(boost::any_cast<bool>(m["extended"]));
    }
  }


  virtual ~ListAllNodeRequest() = default;
};
class ListAllNodeResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> cpuPercent{};
  shared_ptr<string> diskUsedPercent{};
  shared_ptr<string> health{};
  shared_ptr<string> heapPercent{};
  shared_ptr<string> host{};
  shared_ptr<string> loadOneM{};
  shared_ptr<string> nodeType{};
  shared_ptr<long> port{};
  shared_ptr<string> zoneId{};

  ListAllNodeResponseBodyResult() {}

  explicit ListAllNodeResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cpuPercent) {
      res["cpuPercent"] = boost::any(*cpuPercent);
    }
    if (diskUsedPercent) {
      res["diskUsedPercent"] = boost::any(*diskUsedPercent);
    }
    if (health) {
      res["health"] = boost::any(*health);
    }
    if (heapPercent) {
      res["heapPercent"] = boost::any(*heapPercent);
    }
    if (host) {
      res["host"] = boost::any(*host);
    }
    if (loadOneM) {
      res["loadOneM"] = boost::any(*loadOneM);
    }
    if (nodeType) {
      res["nodeType"] = boost::any(*nodeType);
    }
    if (port) {
      res["port"] = boost::any(*port);
    }
    if (zoneId) {
      res["zoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cpuPercent") != m.end() && !m["cpuPercent"].empty()) {
      cpuPercent = make_shared<string>(boost::any_cast<string>(m["cpuPercent"]));
    }
    if (m.find("diskUsedPercent") != m.end() && !m["diskUsedPercent"].empty()) {
      diskUsedPercent = make_shared<string>(boost::any_cast<string>(m["diskUsedPercent"]));
    }
    if (m.find("health") != m.end() && !m["health"].empty()) {
      health = make_shared<string>(boost::any_cast<string>(m["health"]));
    }
    if (m.find("heapPercent") != m.end() && !m["heapPercent"].empty()) {
      heapPercent = make_shared<string>(boost::any_cast<string>(m["heapPercent"]));
    }
    if (m.find("host") != m.end() && !m["host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["host"]));
    }
    if (m.find("loadOneM") != m.end() && !m["loadOneM"].empty()) {
      loadOneM = make_shared<string>(boost::any_cast<string>(m["loadOneM"]));
    }
    if (m.find("nodeType") != m.end() && !m["nodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["nodeType"]));
    }
    if (m.find("port") != m.end() && !m["port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["port"]));
    }
    if (m.find("zoneId") != m.end() && !m["zoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["zoneId"]));
    }
  }


  virtual ~ListAllNodeResponseBodyResult() = default;
};
class ListAllNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListAllNodeResponseBodyResult>> result{};

  ListAllNodeResponseBody() {}

  explicit ListAllNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListAllNodeResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAllNodeResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListAllNodeResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListAllNodeResponseBody() = default;
};
class ListAllNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAllNodeResponseBody> body{};

  ListAllNodeResponse() {}

  explicit ListAllNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAllNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAllNodeResponseBody>(model1);
      }
    }
  }


  virtual ~ListAllNodeResponse() = default;
};
class ListAlternativeSnapshotReposRequest : public Darabonba::Model {
public:
  shared_ptr<bool> alreadySetItems{};

  ListAlternativeSnapshotReposRequest() {}

  explicit ListAlternativeSnapshotReposRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (alreadySetItems) {
      res["alreadySetItems"] = boost::any(*alreadySetItems);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("alreadySetItems") != m.end() && !m["alreadySetItems"].empty()) {
      alreadySetItems = make_shared<bool>(boost::any_cast<bool>(m["alreadySetItems"]));
    }
  }


  virtual ~ListAlternativeSnapshotReposRequest() = default;
};
class ListAlternativeSnapshotReposResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> repoPath{};

  ListAlternativeSnapshotReposResponseBodyResult() {}

  explicit ListAlternativeSnapshotReposResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (repoPath) {
      res["repoPath"] = boost::any(*repoPath);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("repoPath") != m.end() && !m["repoPath"].empty()) {
      repoPath = make_shared<string>(boost::any_cast<string>(m["repoPath"]));
    }
  }


  virtual ~ListAlternativeSnapshotReposResponseBodyResult() = default;
};
class ListAlternativeSnapshotReposResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListAlternativeSnapshotReposResponseBodyResult>> result{};

  ListAlternativeSnapshotReposResponseBody() {}

  explicit ListAlternativeSnapshotReposResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListAlternativeSnapshotReposResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAlternativeSnapshotReposResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListAlternativeSnapshotReposResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListAlternativeSnapshotReposResponseBody() = default;
};
class ListAlternativeSnapshotReposResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAlternativeSnapshotReposResponseBody> body{};

  ListAlternativeSnapshotReposResponse() {}

  explicit ListAlternativeSnapshotReposResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAlternativeSnapshotReposResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAlternativeSnapshotReposResponseBody>(model1);
      }
    }
  }


  virtual ~ListAlternativeSnapshotReposResponse() = default;
};
class ListApmRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> output{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};

  ListApmRequest() {}

  explicit ListApmRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (output) {
      res["output"] = boost::any(*output);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("output") != m.end() && !m["output"].empty()) {
      output = make_shared<string>(boost::any_cast<string>(m["output"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
  }


  virtual ~ListApmRequest() = default;
};
class ListApmResponseBodyHeaders : public Darabonba::Model {
public:
  shared_ptr<long> xTotalCount{};

  ListApmResponseBodyHeaders() {}

  explicit ListApmResponseBodyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (xTotalCount) {
      res["X-Total-Count"] = boost::any(*xTotalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("X-Total-Count") != m.end() && !m["X-Total-Count"].empty()) {
      xTotalCount = make_shared<long>(boost::any_cast<long>(m["X-Total-Count"]));
    }
  }


  virtual ~ListApmResponseBodyHeaders() = default;
};
class ListApmResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> createdAt{};
  shared_ptr<long> deployedReplica{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> nodeAmount{};
  shared_ptr<string> outputES{};
  shared_ptr<string> outputESUserName{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> region{};
  shared_ptr<long> replica{};
  shared_ptr<string> resourceSpec{};
  shared_ptr<string> status{};
  shared_ptr<string> version{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vsArea{};
  shared_ptr<string> vswitchId{};

  ListApmResponseBodyResult() {}

  explicit ListApmResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (deployedReplica) {
      res["deployedReplica"] = boost::any(*deployedReplica);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (nodeAmount) {
      res["nodeAmount"] = boost::any(*nodeAmount);
    }
    if (outputES) {
      res["outputES"] = boost::any(*outputES);
    }
    if (outputESUserName) {
      res["outputESUserName"] = boost::any(*outputESUserName);
    }
    if (ownerId) {
      res["ownerId"] = boost::any(*ownerId);
    }
    if (paymentType) {
      res["paymentType"] = boost::any(*paymentType);
    }
    if (region) {
      res["region"] = boost::any(*region);
    }
    if (replica) {
      res["replica"] = boost::any(*replica);
    }
    if (resourceSpec) {
      res["resourceSpec"] = boost::any(*resourceSpec);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    if (vsArea) {
      res["vsArea"] = boost::any(*vsArea);
    }
    if (vswitchId) {
      res["vswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("deployedReplica") != m.end() && !m["deployedReplica"].empty()) {
      deployedReplica = make_shared<long>(boost::any_cast<long>(m["deployedReplica"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("nodeAmount") != m.end() && !m["nodeAmount"].empty()) {
      nodeAmount = make_shared<long>(boost::any_cast<long>(m["nodeAmount"]));
    }
    if (m.find("outputES") != m.end() && !m["outputES"].empty()) {
      outputES = make_shared<string>(boost::any_cast<string>(m["outputES"]));
    }
    if (m.find("outputESUserName") != m.end() && !m["outputESUserName"].empty()) {
      outputESUserName = make_shared<string>(boost::any_cast<string>(m["outputESUserName"]));
    }
    if (m.find("ownerId") != m.end() && !m["ownerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["ownerId"]));
    }
    if (m.find("paymentType") != m.end() && !m["paymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["paymentType"]));
    }
    if (m.find("region") != m.end() && !m["region"].empty()) {
      region = make_shared<string>(boost::any_cast<string>(m["region"]));
    }
    if (m.find("replica") != m.end() && !m["replica"].empty()) {
      replica = make_shared<long>(boost::any_cast<long>(m["replica"]));
    }
    if (m.find("resourceSpec") != m.end() && !m["resourceSpec"].empty()) {
      resourceSpec = make_shared<string>(boost::any_cast<string>(m["resourceSpec"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
    if (m.find("vsArea") != m.end() && !m["vsArea"].empty()) {
      vsArea = make_shared<string>(boost::any_cast<string>(m["vsArea"]));
    }
    if (m.find("vswitchId") != m.end() && !m["vswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["vswitchId"]));
    }
  }


  virtual ~ListApmResponseBodyResult() = default;
};
class ListApmResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListApmResponseBodyHeaders> headers{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListApmResponseBodyResult>> result{};

  ListApmResponseBody() {}

  explicit ListApmResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["Headers"] = headers ? boost::any(headers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      if (typeid(map<string, boost::any>) == m["Headers"].type()) {
        ListApmResponseBodyHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Headers"]));
        headers = make_shared<ListApmResponseBodyHeaders>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListApmResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListApmResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListApmResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListApmResponseBody() = default;
};
class ListApmResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListApmResponseBody> body{};

  ListApmResponse() {}

  explicit ListApmResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListApmResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListApmResponseBody>(model1);
      }
    }
  }


  virtual ~ListApmResponse() = default;
};
class ListAvailableEsInstanceIdsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> esInstanceId{};
  shared_ptr<string> kibanaEndpoint{};

  ListAvailableEsInstanceIdsResponseBodyResult() {}

  explicit ListAvailableEsInstanceIdsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (endpoint) {
      res["endpoint"] = boost::any(*endpoint);
    }
    if (esInstanceId) {
      res["esInstanceId"] = boost::any(*esInstanceId);
    }
    if (kibanaEndpoint) {
      res["kibanaEndpoint"] = boost::any(*kibanaEndpoint);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("endpoint") != m.end() && !m["endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["endpoint"]));
    }
    if (m.find("esInstanceId") != m.end() && !m["esInstanceId"].empty()) {
      esInstanceId = make_shared<string>(boost::any_cast<string>(m["esInstanceId"]));
    }
    if (m.find("kibanaEndpoint") != m.end() && !m["kibanaEndpoint"].empty()) {
      kibanaEndpoint = make_shared<string>(boost::any_cast<string>(m["kibanaEndpoint"]));
    }
  }


  virtual ~ListAvailableEsInstanceIdsResponseBodyResult() = default;
};
class ListAvailableEsInstanceIdsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListAvailableEsInstanceIdsResponseBodyResult>> result{};

  ListAvailableEsInstanceIdsResponseBody() {}

  explicit ListAvailableEsInstanceIdsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListAvailableEsInstanceIdsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListAvailableEsInstanceIdsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListAvailableEsInstanceIdsResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListAvailableEsInstanceIdsResponseBody() = default;
};
class ListAvailableEsInstanceIdsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListAvailableEsInstanceIdsResponseBody> body{};

  ListAvailableEsInstanceIdsResponse() {}

  explicit ListAvailableEsInstanceIdsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListAvailableEsInstanceIdsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListAvailableEsInstanceIdsResponseBody>(model1);
      }
    }
  }


  virtual ~ListAvailableEsInstanceIdsResponse() = default;
};
class ListCollectorsRequest : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> name{};
  shared_ptr<long> page{};
  shared_ptr<string> resId{};
  shared_ptr<long> size{};
  shared_ptr<string> sourceType{};

  ListCollectorsRequest() {}

  explicit ListCollectorsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (resId) {
      res["resId"] = boost::any(*resId);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("resId") != m.end() && !m["resId"].empty()) {
      resId = make_shared<string>(boost::any_cast<string>(m["resId"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
  }


  virtual ~ListCollectorsRequest() = default;
};
class ListCollectorsResponseBodyHeaders : public Darabonba::Model {
public:
  shared_ptr<long> xTotalCount{};

  ListCollectorsResponseBodyHeaders() {}

  explicit ListCollectorsResponseBodyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (xTotalCount) {
      res["X-Total-Count"] = boost::any(*xTotalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("X-Total-Count") != m.end() && !m["X-Total-Count"].empty()) {
      xTotalCount = make_shared<long>(boost::any_cast<long>(m["X-Total-Count"]));
    }
  }


  virtual ~ListCollectorsResponseBodyHeaders() = default;
};
class ListCollectorsResponseBodyResultConfigs : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> fileName{};

  ListCollectorsResponseBodyResultConfigs() {}

  explicit ListCollectorsResponseBodyResultConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (fileName) {
      res["fileName"] = boost::any(*fileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("fileName") != m.end() && !m["fileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["fileName"]));
    }
  }


  virtual ~ListCollectorsResponseBodyResultConfigs() = default;
};
class ListCollectorsResponseBodyResultExtendConfigsMachines : public Darabonba::Model {
public:
  shared_ptr<string> agentStatus{};
  shared_ptr<string> instanceId{};

  ListCollectorsResponseBodyResultExtendConfigsMachines() {}

  explicit ListCollectorsResponseBodyResultExtendConfigsMachines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentStatus) {
      res["agentStatus"] = boost::any(*agentStatus);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("agentStatus") != m.end() && !m["agentStatus"].empty()) {
      agentStatus = make_shared<string>(boost::any_cast<string>(m["agentStatus"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
  }


  virtual ~ListCollectorsResponseBodyResultExtendConfigsMachines() = default;
};
class ListCollectorsResponseBodyResultExtendConfigs : public Darabonba::Model {
public:
  shared_ptr<string> configType{};
  shared_ptr<bool> enableMonitoring{};
  shared_ptr<string> groupId{};
  shared_ptr<string> host{};
  shared_ptr<vector<string>> hosts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> kibanaHost{};
  shared_ptr<vector<ListCollectorsResponseBodyResultExtendConfigsMachines>> machines{};
  shared_ptr<string> protocol{};
  shared_ptr<string> successPodsCount{};
  shared_ptr<string> totalPodsCount{};
  shared_ptr<string> type{};
  shared_ptr<string> userName{};

  ListCollectorsResponseBodyResultExtendConfigs() {}

  explicit ListCollectorsResponseBodyResultExtendConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configType) {
      res["configType"] = boost::any(*configType);
    }
    if (enableMonitoring) {
      res["enableMonitoring"] = boost::any(*enableMonitoring);
    }
    if (groupId) {
      res["groupId"] = boost::any(*groupId);
    }
    if (host) {
      res["host"] = boost::any(*host);
    }
    if (hosts) {
      res["hosts"] = boost::any(*hosts);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["instanceType"] = boost::any(*instanceType);
    }
    if (kibanaHost) {
      res["kibanaHost"] = boost::any(*kibanaHost);
    }
    if (machines) {
      vector<boost::any> temp1;
      for(auto item1:*machines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["machines"] = boost::any(temp1);
    }
    if (protocol) {
      res["protocol"] = boost::any(*protocol);
    }
    if (successPodsCount) {
      res["successPodsCount"] = boost::any(*successPodsCount);
    }
    if (totalPodsCount) {
      res["totalPodsCount"] = boost::any(*totalPodsCount);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (userName) {
      res["userName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("configType") != m.end() && !m["configType"].empty()) {
      configType = make_shared<string>(boost::any_cast<string>(m["configType"]));
    }
    if (m.find("enableMonitoring") != m.end() && !m["enableMonitoring"].empty()) {
      enableMonitoring = make_shared<bool>(boost::any_cast<bool>(m["enableMonitoring"]));
    }
    if (m.find("groupId") != m.end() && !m["groupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["groupId"]));
    }
    if (m.find("host") != m.end() && !m["host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["host"]));
    }
    if (m.find("hosts") != m.end() && !m["hosts"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["hosts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["hosts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hosts = make_shared<vector<string>>(toVec1);
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("instanceType") != m.end() && !m["instanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["instanceType"]));
    }
    if (m.find("kibanaHost") != m.end() && !m["kibanaHost"].empty()) {
      kibanaHost = make_shared<string>(boost::any_cast<string>(m["kibanaHost"]));
    }
    if (m.find("machines") != m.end() && !m["machines"].empty()) {
      if (typeid(vector<boost::any>) == m["machines"].type()) {
        vector<ListCollectorsResponseBodyResultExtendConfigsMachines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["machines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCollectorsResponseBodyResultExtendConfigsMachines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        machines = make_shared<vector<ListCollectorsResponseBodyResultExtendConfigsMachines>>(expect1);
      }
    }
    if (m.find("protocol") != m.end() && !m["protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["protocol"]));
    }
    if (m.find("successPodsCount") != m.end() && !m["successPodsCount"].empty()) {
      successPodsCount = make_shared<string>(boost::any_cast<string>(m["successPodsCount"]));
    }
    if (m.find("totalPodsCount") != m.end() && !m["totalPodsCount"].empty()) {
      totalPodsCount = make_shared<string>(boost::any_cast<string>(m["totalPodsCount"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("userName") != m.end() && !m["userName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["userName"]));
    }
  }


  virtual ~ListCollectorsResponseBodyResultExtendConfigs() = default;
};
class ListCollectorsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<string>> collectorPaths{};
  shared_ptr<vector<ListCollectorsResponseBodyResultConfigs>> configs{};
  shared_ptr<bool> dryRun{};
  shared_ptr<vector<ListCollectorsResponseBodyResultExtendConfigs>> extendConfigs{};
  shared_ptr<string> gmtCreatedTime{};
  shared_ptr<string> gmtUpdateTime{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> resId{};
  shared_ptr<string> resType{};
  shared_ptr<string> resVersion{};
  shared_ptr<string> status{};
  shared_ptr<string> vpcId{};

  ListCollectorsResponseBodyResult() {}

  explicit ListCollectorsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (collectorPaths) {
      res["collectorPaths"] = boost::any(*collectorPaths);
    }
    if (configs) {
      vector<boost::any> temp1;
      for(auto item1:*configs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["configs"] = boost::any(temp1);
    }
    if (dryRun) {
      res["dryRun"] = boost::any(*dryRun);
    }
    if (extendConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*extendConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extendConfigs"] = boost::any(temp1);
    }
    if (gmtCreatedTime) {
      res["gmtCreatedTime"] = boost::any(*gmtCreatedTime);
    }
    if (gmtUpdateTime) {
      res["gmtUpdateTime"] = boost::any(*gmtUpdateTime);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (ownerId) {
      res["ownerId"] = boost::any(*ownerId);
    }
    if (resId) {
      res["resId"] = boost::any(*resId);
    }
    if (resType) {
      res["resType"] = boost::any(*resType);
    }
    if (resVersion) {
      res["resVersion"] = boost::any(*resVersion);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("collectorPaths") != m.end() && !m["collectorPaths"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["collectorPaths"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["collectorPaths"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      collectorPaths = make_shared<vector<string>>(toVec1);
    }
    if (m.find("configs") != m.end() && !m["configs"].empty()) {
      if (typeid(vector<boost::any>) == m["configs"].type()) {
        vector<ListCollectorsResponseBodyResultConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["configs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCollectorsResponseBodyResultConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configs = make_shared<vector<ListCollectorsResponseBodyResultConfigs>>(expect1);
      }
    }
    if (m.find("dryRun") != m.end() && !m["dryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["dryRun"]));
    }
    if (m.find("extendConfigs") != m.end() && !m["extendConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["extendConfigs"].type()) {
        vector<ListCollectorsResponseBodyResultExtendConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extendConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCollectorsResponseBodyResultExtendConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extendConfigs = make_shared<vector<ListCollectorsResponseBodyResultExtendConfigs>>(expect1);
      }
    }
    if (m.find("gmtCreatedTime") != m.end() && !m["gmtCreatedTime"].empty()) {
      gmtCreatedTime = make_shared<string>(boost::any_cast<string>(m["gmtCreatedTime"]));
    }
    if (m.find("gmtUpdateTime") != m.end() && !m["gmtUpdateTime"].empty()) {
      gmtUpdateTime = make_shared<string>(boost::any_cast<string>(m["gmtUpdateTime"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("ownerId") != m.end() && !m["ownerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["ownerId"]));
    }
    if (m.find("resId") != m.end() && !m["resId"].empty()) {
      resId = make_shared<string>(boost::any_cast<string>(m["resId"]));
    }
    if (m.find("resType") != m.end() && !m["resType"].empty()) {
      resType = make_shared<string>(boost::any_cast<string>(m["resType"]));
    }
    if (m.find("resVersion") != m.end() && !m["resVersion"].empty()) {
      resVersion = make_shared<string>(boost::any_cast<string>(m["resVersion"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
  }


  virtual ~ListCollectorsResponseBodyResult() = default;
};
class ListCollectorsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListCollectorsResponseBodyHeaders> headers{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListCollectorsResponseBodyResult>> result{};

  ListCollectorsResponseBody() {}

  explicit ListCollectorsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["Headers"] = headers ? boost::any(headers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      if (typeid(map<string, boost::any>) == m["Headers"].type()) {
        ListCollectorsResponseBodyHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Headers"]));
        headers = make_shared<ListCollectorsResponseBodyHeaders>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListCollectorsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListCollectorsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListCollectorsResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListCollectorsResponseBody() = default;
};
class ListCollectorsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListCollectorsResponseBody> body{};

  ListCollectorsResponse() {}

  explicit ListCollectorsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListCollectorsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListCollectorsResponseBody>(model1);
      }
    }
  }


  virtual ~ListCollectorsResponse() = default;
};
class ListComponentIndicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};

  ListComponentIndicesRequest() {}

  explicit ListComponentIndicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
  }


  virtual ~ListComponentIndicesRequest() = default;
};
class ListComponentIndicesResponseBodyHeaders : public Darabonba::Model {
public:
  shared_ptr<long> xTotalCount{};

  ListComponentIndicesResponseBodyHeaders() {}

  explicit ListComponentIndicesResponseBodyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (xTotalCount) {
      res["X-Total-Count"] = boost::any(*xTotalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("X-Total-Count") != m.end() && !m["X-Total-Count"].empty()) {
      xTotalCount = make_shared<long>(boost::any_cast<long>(m["X-Total-Count"]));
    }
  }


  virtual ~ListComponentIndicesResponseBodyHeaders() = default;
};
class ListComponentIndicesResponseBodyResultContentTemplateSettingsIndexLifecycle : public Darabonba::Model {
public:
  shared_ptr<string> name{};

  ListComponentIndicesResponseBodyResultContentTemplateSettingsIndexLifecycle() {}

  explicit ListComponentIndicesResponseBodyResultContentTemplateSettingsIndexLifecycle(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~ListComponentIndicesResponseBodyResultContentTemplateSettingsIndexLifecycle() = default;
};
class ListComponentIndicesResponseBodyResultContentTemplateSettingsIndex : public Darabonba::Model {
public:
  shared_ptr<string> codec{};
  shared_ptr<ListComponentIndicesResponseBodyResultContentTemplateSettingsIndexLifecycle> lifecycle{};

  ListComponentIndicesResponseBodyResultContentTemplateSettingsIndex() {}

  explicit ListComponentIndicesResponseBodyResultContentTemplateSettingsIndex(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (codec) {
      res["codec"] = boost::any(*codec);
    }
    if (lifecycle) {
      res["lifecycle"] = lifecycle ? boost::any(lifecycle->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("codec") != m.end() && !m["codec"].empty()) {
      codec = make_shared<string>(boost::any_cast<string>(m["codec"]));
    }
    if (m.find("lifecycle") != m.end() && !m["lifecycle"].empty()) {
      if (typeid(map<string, boost::any>) == m["lifecycle"].type()) {
        ListComponentIndicesResponseBodyResultContentTemplateSettingsIndexLifecycle model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["lifecycle"]));
        lifecycle = make_shared<ListComponentIndicesResponseBodyResultContentTemplateSettingsIndexLifecycle>(model1);
      }
    }
  }


  virtual ~ListComponentIndicesResponseBodyResultContentTemplateSettingsIndex() = default;
};
class ListComponentIndicesResponseBodyResultContentTemplateSettings : public Darabonba::Model {
public:
  shared_ptr<ListComponentIndicesResponseBodyResultContentTemplateSettingsIndex> index{};

  ListComponentIndicesResponseBodyResultContentTemplateSettings() {}

  explicit ListComponentIndicesResponseBodyResultContentTemplateSettings(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (index) {
      res["index"] = index ? boost::any(index->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("index") != m.end() && !m["index"].empty()) {
      if (typeid(map<string, boost::any>) == m["index"].type()) {
        ListComponentIndicesResponseBodyResultContentTemplateSettingsIndex model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["index"]));
        index = make_shared<ListComponentIndicesResponseBodyResultContentTemplateSettingsIndex>(model1);
      }
    }
  }


  virtual ~ListComponentIndicesResponseBodyResultContentTemplateSettings() = default;
};
class ListComponentIndicesResponseBodyResultContentTemplate : public Darabonba::Model {
public:
  shared_ptr<ListComponentIndicesResponseBodyResultContentTemplateSettings> settings{};

  ListComponentIndicesResponseBodyResultContentTemplate() {}

  explicit ListComponentIndicesResponseBodyResultContentTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (settings) {
      res["settings"] = settings ? boost::any(settings->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("settings") != m.end() && !m["settings"].empty()) {
      if (typeid(map<string, boost::any>) == m["settings"].type()) {
        ListComponentIndicesResponseBodyResultContentTemplateSettings model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["settings"]));
        settings = make_shared<ListComponentIndicesResponseBodyResultContentTemplateSettings>(model1);
      }
    }
  }


  virtual ~ListComponentIndicesResponseBodyResultContentTemplate() = default;
};
class ListComponentIndicesResponseBodyResultContent : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> meta{};
  shared_ptr<ListComponentIndicesResponseBodyResultContentTemplate> template_{};
  shared_ptr<long> version{};

  ListComponentIndicesResponseBodyResultContent() {}

  explicit ListComponentIndicesResponseBodyResultContent(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (meta) {
      res["_meta"] = boost::any(*meta);
    }
    if (template_) {
      res["template"] = template_ ? boost::any(template_->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("_meta") != m.end() && !m["_meta"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["_meta"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      meta = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("template") != m.end() && !m["template"].empty()) {
      if (typeid(map<string, boost::any>) == m["template"].type()) {
        ListComponentIndicesResponseBodyResultContentTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["template"]));
        template_ = make_shared<ListComponentIndicesResponseBodyResultContentTemplate>(model1);
      }
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<long>(boost::any_cast<long>(m["version"]));
    }
  }


  virtual ~ListComponentIndicesResponseBodyResultContent() = default;
};
class ListComponentIndicesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<string>> composed{};
  shared_ptr<ListComponentIndicesResponseBodyResultContent> content{};
  shared_ptr<string> name{};

  ListComponentIndicesResponseBodyResult() {}

  explicit ListComponentIndicesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (composed) {
      res["composed"] = boost::any(*composed);
    }
    if (content) {
      res["content"] = content ? boost::any(content->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("composed") != m.end() && !m["composed"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["composed"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["composed"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      composed = make_shared<vector<string>>(toVec1);
    }
    if (m.find("content") != m.end() && !m["content"].empty()) {
      if (typeid(map<string, boost::any>) == m["content"].type()) {
        ListComponentIndicesResponseBodyResultContent model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["content"]));
        content = make_shared<ListComponentIndicesResponseBodyResultContent>(model1);
      }
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~ListComponentIndicesResponseBodyResult() = default;
};
class ListComponentIndicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListComponentIndicesResponseBodyHeaders> headers{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListComponentIndicesResponseBodyResult>> result{};

  ListComponentIndicesResponseBody() {}

  explicit ListComponentIndicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["Headers"] = headers ? boost::any(headers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      if (typeid(map<string, boost::any>) == m["Headers"].type()) {
        ListComponentIndicesResponseBodyHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Headers"]));
        headers = make_shared<ListComponentIndicesResponseBodyHeaders>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListComponentIndicesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListComponentIndicesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListComponentIndicesResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListComponentIndicesResponseBody() = default;
};
class ListComponentIndicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListComponentIndicesResponseBody> body{};

  ListComponentIndicesResponse() {}

  explicit ListComponentIndicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListComponentIndicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListComponentIndicesResponseBody>(model1);
      }
    }
  }


  virtual ~ListComponentIndicesResponse() = default;
};
class ListConnectedClustersResponseBodyResultResult : public Darabonba::Model {
public:
  shared_ptr<string> instances{};
  shared_ptr<string> networkType{};

  ListConnectedClustersResponseBodyResultResult() {}

  explicit ListConnectedClustersResponseBodyResultResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instances) {
      res["instances"] = boost::any(*instances);
    }
    if (networkType) {
      res["networkType"] = boost::any(*networkType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instances") != m.end() && !m["instances"].empty()) {
      instances = make_shared<string>(boost::any_cast<string>(m["instances"]));
    }
    if (m.find("networkType") != m.end() && !m["networkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["networkType"]));
    }
  }


  virtual ~ListConnectedClustersResponseBodyResultResult() = default;
};
class ListConnectedClustersResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListConnectedClustersResponseBodyResultResult>> result{};

  ListConnectedClustersResponseBodyResult() {}

  explicit ListConnectedClustersResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListConnectedClustersResponseBodyResultResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListConnectedClustersResponseBodyResultResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListConnectedClustersResponseBodyResultResult>>(expect1);
      }
    }
  }


  virtual ~ListConnectedClustersResponseBodyResult() = default;
};
class ListConnectedClustersResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListConnectedClustersResponseBodyResult> result{};

  ListConnectedClustersResponseBody() {}

  explicit ListConnectedClustersResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ListConnectedClustersResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ListConnectedClustersResponseBodyResult>(model1);
      }
    }
  }


  virtual ~ListConnectedClustersResponseBody() = default;
};
class ListConnectedClustersResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListConnectedClustersResponseBody> body{};

  ListConnectedClustersResponse() {}

  explicit ListConnectedClustersResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListConnectedClustersResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListConnectedClustersResponseBody>(model1);
      }
    }
  }


  virtual ~ListConnectedClustersResponse() = default;
};
class ListDataStreamsRequest : public Darabonba::Model {
public:
  shared_ptr<bool> isManaged{};
  shared_ptr<string> name{};

  ListDataStreamsRequest() {}

  explicit ListDataStreamsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (isManaged) {
      res["isManaged"] = boost::any(*isManaged);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("isManaged") != m.end() && !m["isManaged"].empty()) {
      isManaged = make_shared<bool>(boost::any_cast<bool>(m["isManaged"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~ListDataStreamsRequest() = default;
};
class ListDataStreamsResponseBodyHeaders : public Darabonba::Model {
public:
  shared_ptr<long> xManagedCount{};
  shared_ptr<long> xManagedStorageSize{};

  ListDataStreamsResponseBodyHeaders() {}

  explicit ListDataStreamsResponseBodyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (xManagedCount) {
      res["X-Managed-Count"] = boost::any(*xManagedCount);
    }
    if (xManagedStorageSize) {
      res["X-Managed-StorageSize"] = boost::any(*xManagedStorageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("X-Managed-Count") != m.end() && !m["X-Managed-Count"].empty()) {
      xManagedCount = make_shared<long>(boost::any_cast<long>(m["X-Managed-Count"]));
    }
    if (m.find("X-Managed-StorageSize") != m.end() && !m["X-Managed-StorageSize"].empty()) {
      xManagedStorageSize = make_shared<long>(boost::any_cast<long>(m["X-Managed-StorageSize"]));
    }
  }


  virtual ~ListDataStreamsResponseBodyHeaders() = default;
};
class ListDataStreamsResponseBodyResultIndices : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> health{};
  shared_ptr<bool> isManaged{};
  shared_ptr<string> managedStatus{};
  shared_ptr<string> name{};
  shared_ptr<long> size{};

  ListDataStreamsResponseBodyResultIndices() {}

  explicit ListDataStreamsResponseBodyResultIndices(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (health) {
      res["health"] = boost::any(*health);
    }
    if (isManaged) {
      res["isManaged"] = boost::any(*isManaged);
    }
    if (managedStatus) {
      res["managedStatus"] = boost::any(*managedStatus);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("health") != m.end() && !m["health"].empty()) {
      health = make_shared<string>(boost::any_cast<string>(m["health"]));
    }
    if (m.find("isManaged") != m.end() && !m["isManaged"].empty()) {
      isManaged = make_shared<bool>(boost::any_cast<bool>(m["isManaged"]));
    }
    if (m.find("managedStatus") != m.end() && !m["managedStatus"].empty()) {
      managedStatus = make_shared<string>(boost::any_cast<string>(m["managedStatus"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
  }


  virtual ~ListDataStreamsResponseBodyResultIndices() = default;
};
class ListDataStreamsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> health{};
  shared_ptr<string> ilmPolicyName{};
  shared_ptr<string> indexTemplateName{};
  shared_ptr<vector<ListDataStreamsResponseBodyResultIndices>> indices{};
  shared_ptr<long> managedStorageSize{};
  shared_ptr<string> name{};
  shared_ptr<long> totalStorageSize{};

  ListDataStreamsResponseBodyResult() {}

  explicit ListDataStreamsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (health) {
      res["health"] = boost::any(*health);
    }
    if (ilmPolicyName) {
      res["ilmPolicyName"] = boost::any(*ilmPolicyName);
    }
    if (indexTemplateName) {
      res["indexTemplateName"] = boost::any(*indexTemplateName);
    }
    if (indices) {
      vector<boost::any> temp1;
      for(auto item1:*indices){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["indices"] = boost::any(temp1);
    }
    if (managedStorageSize) {
      res["managedStorageSize"] = boost::any(*managedStorageSize);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (totalStorageSize) {
      res["totalStorageSize"] = boost::any(*totalStorageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("health") != m.end() && !m["health"].empty()) {
      health = make_shared<string>(boost::any_cast<string>(m["health"]));
    }
    if (m.find("ilmPolicyName") != m.end() && !m["ilmPolicyName"].empty()) {
      ilmPolicyName = make_shared<string>(boost::any_cast<string>(m["ilmPolicyName"]));
    }
    if (m.find("indexTemplateName") != m.end() && !m["indexTemplateName"].empty()) {
      indexTemplateName = make_shared<string>(boost::any_cast<string>(m["indexTemplateName"]));
    }
    if (m.find("indices") != m.end() && !m["indices"].empty()) {
      if (typeid(vector<boost::any>) == m["indices"].type()) {
        vector<ListDataStreamsResponseBodyResultIndices> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["indices"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataStreamsResponseBodyResultIndices model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        indices = make_shared<vector<ListDataStreamsResponseBodyResultIndices>>(expect1);
      }
    }
    if (m.find("managedStorageSize") != m.end() && !m["managedStorageSize"].empty()) {
      managedStorageSize = make_shared<long>(boost::any_cast<long>(m["managedStorageSize"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("totalStorageSize") != m.end() && !m["totalStorageSize"].empty()) {
      totalStorageSize = make_shared<long>(boost::any_cast<long>(m["totalStorageSize"]));
    }
  }


  virtual ~ListDataStreamsResponseBodyResult() = default;
};
class ListDataStreamsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDataStreamsResponseBodyHeaders> headers{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListDataStreamsResponseBodyResult>> result{};

  ListDataStreamsResponseBody() {}

  explicit ListDataStreamsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["Headers"] = headers ? boost::any(headers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      if (typeid(map<string, boost::any>) == m["Headers"].type()) {
        ListDataStreamsResponseBodyHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Headers"]));
        headers = make_shared<ListDataStreamsResponseBodyHeaders>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListDataStreamsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataStreamsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListDataStreamsResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListDataStreamsResponseBody() = default;
};
class ListDataStreamsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataStreamsResponseBody> body{};

  ListDataStreamsResponse() {}

  explicit ListDataStreamsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataStreamsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataStreamsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataStreamsResponse() = default;
};
class ListDataTasksResponseBodyResultSinkCluster : public Darabonba::Model {
public:
  shared_ptr<string> dataSourceType{};
  shared_ptr<string> endpoint{};
  shared_ptr<string> index{};
  shared_ptr<string> type{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vpcInstanceId{};
  shared_ptr<string> vpcInstancePort{};

  ListDataTasksResponseBodyResultSinkCluster() {}

  explicit ListDataTasksResponseBodyResultSinkCluster(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceType) {
      res["dataSourceType"] = boost::any(*dataSourceType);
    }
    if (endpoint) {
      res["endpoint"] = boost::any(*endpoint);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    if (vpcInstanceId) {
      res["vpcInstanceId"] = boost::any(*vpcInstanceId);
    }
    if (vpcInstancePort) {
      res["vpcInstancePort"] = boost::any(*vpcInstancePort);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dataSourceType") != m.end() && !m["dataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["dataSourceType"]));
    }
    if (m.find("endpoint") != m.end() && !m["endpoint"].empty()) {
      endpoint = make_shared<string>(boost::any_cast<string>(m["endpoint"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
    if (m.find("vpcInstanceId") != m.end() && !m["vpcInstanceId"].empty()) {
      vpcInstanceId = make_shared<string>(boost::any_cast<string>(m["vpcInstanceId"]));
    }
    if (m.find("vpcInstancePort") != m.end() && !m["vpcInstancePort"].empty()) {
      vpcInstancePort = make_shared<string>(boost::any_cast<string>(m["vpcInstancePort"]));
    }
  }


  virtual ~ListDataTasksResponseBodyResultSinkCluster() = default;
};
class ListDataTasksResponseBodyResultSourceCluster : public Darabonba::Model {
public:
  shared_ptr<string> dataSourceType{};
  shared_ptr<string> index{};
  shared_ptr<string> mapping{};
  shared_ptr<string> routing{};
  shared_ptr<string> settings{};
  shared_ptr<string> type{};

  ListDataTasksResponseBodyResultSourceCluster() {}

  explicit ListDataTasksResponseBodyResultSourceCluster(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataSourceType) {
      res["dataSourceType"] = boost::any(*dataSourceType);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (mapping) {
      res["mapping"] = boost::any(*mapping);
    }
    if (routing) {
      res["routing"] = boost::any(*routing);
    }
    if (settings) {
      res["settings"] = boost::any(*settings);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dataSourceType") != m.end() && !m["dataSourceType"].empty()) {
      dataSourceType = make_shared<string>(boost::any_cast<string>(m["dataSourceType"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("mapping") != m.end() && !m["mapping"].empty()) {
      mapping = make_shared<string>(boost::any_cast<string>(m["mapping"]));
    }
    if (m.find("routing") != m.end() && !m["routing"].empty()) {
      routing = make_shared<string>(boost::any_cast<string>(m["routing"]));
    }
    if (m.find("settings") != m.end() && !m["settings"].empty()) {
      settings = make_shared<string>(boost::any_cast<string>(m["settings"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ListDataTasksResponseBodyResultSourceCluster() = default;
};
class ListDataTasksResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<ListDataTasksResponseBodyResultSinkCluster> sinkCluster{};
  shared_ptr<ListDataTasksResponseBodyResultSourceCluster> sourceCluster{};
  shared_ptr<string> status{};
  shared_ptr<string> taskId{};

  ListDataTasksResponseBodyResult() {}

  explicit ListDataTasksResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (sinkCluster) {
      res["sinkCluster"] = sinkCluster ? boost::any(sinkCluster->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (sourceCluster) {
      res["sourceCluster"] = sourceCluster ? boost::any(sourceCluster->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (taskId) {
      res["taskId"] = boost::any(*taskId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("sinkCluster") != m.end() && !m["sinkCluster"].empty()) {
      if (typeid(map<string, boost::any>) == m["sinkCluster"].type()) {
        ListDataTasksResponseBodyResultSinkCluster model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["sinkCluster"]));
        sinkCluster = make_shared<ListDataTasksResponseBodyResultSinkCluster>(model1);
      }
    }
    if (m.find("sourceCluster") != m.end() && !m["sourceCluster"].empty()) {
      if (typeid(map<string, boost::any>) == m["sourceCluster"].type()) {
        ListDataTasksResponseBodyResultSourceCluster model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["sourceCluster"]));
        sourceCluster = make_shared<ListDataTasksResponseBodyResultSourceCluster>(model1);
      }
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("taskId") != m.end() && !m["taskId"].empty()) {
      taskId = make_shared<string>(boost::any_cast<string>(m["taskId"]));
    }
  }


  virtual ~ListDataTasksResponseBodyResult() = default;
};
class ListDataTasksResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListDataTasksResponseBodyResult>> result{};

  ListDataTasksResponseBody() {}

  explicit ListDataTasksResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListDataTasksResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDataTasksResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListDataTasksResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListDataTasksResponseBody() = default;
};
class ListDataTasksResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDataTasksResponseBody> body{};

  ListDataTasksResponse() {}

  explicit ListDataTasksResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDataTasksResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDataTasksResponseBody>(model1);
      }
    }
  }


  virtual ~ListDataTasksResponse() = default;
};
class ListDefaultCollectorConfigurationsRequest : public Darabonba::Model {
public:
  shared_ptr<string> resType{};
  shared_ptr<string> resVersion{};
  shared_ptr<string> sourceType{};

  ListDefaultCollectorConfigurationsRequest() {}

  explicit ListDefaultCollectorConfigurationsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resType) {
      res["resType"] = boost::any(*resType);
    }
    if (resVersion) {
      res["resVersion"] = boost::any(*resVersion);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("resType") != m.end() && !m["resType"].empty()) {
      resType = make_shared<string>(boost::any_cast<string>(m["resType"]));
    }
    if (m.find("resVersion") != m.end() && !m["resVersion"].empty()) {
      resVersion = make_shared<string>(boost::any_cast<string>(m["resVersion"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
  }


  virtual ~ListDefaultCollectorConfigurationsRequest() = default;
};
class ListDefaultCollectorConfigurationsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> fileName{};

  ListDefaultCollectorConfigurationsResponseBodyResult() {}

  explicit ListDefaultCollectorConfigurationsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (fileName) {
      res["fileName"] = boost::any(*fileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("fileName") != m.end() && !m["fileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["fileName"]));
    }
  }


  virtual ~ListDefaultCollectorConfigurationsResponseBodyResult() = default;
};
class ListDefaultCollectorConfigurationsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListDefaultCollectorConfigurationsResponseBodyResult>> result{};

  ListDefaultCollectorConfigurationsResponseBody() {}

  explicit ListDefaultCollectorConfigurationsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListDefaultCollectorConfigurationsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDefaultCollectorConfigurationsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListDefaultCollectorConfigurationsResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListDefaultCollectorConfigurationsResponseBody() = default;
};
class ListDefaultCollectorConfigurationsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDefaultCollectorConfigurationsResponseBody> body{};

  ListDefaultCollectorConfigurationsResponse() {}

  explicit ListDefaultCollectorConfigurationsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDefaultCollectorConfigurationsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDefaultCollectorConfigurationsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDefaultCollectorConfigurationsResponse() = default;
};
class ListDeprecatedTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};

  ListDeprecatedTemplatesRequest() {}

  explicit ListDeprecatedTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
  }


  virtual ~ListDeprecatedTemplatesRequest() = default;
};
class ListDeprecatedTemplatesResponseBodyHeaders : public Darabonba::Model {
public:
  shared_ptr<long> xTotalCount{};

  ListDeprecatedTemplatesResponseBodyHeaders() {}

  explicit ListDeprecatedTemplatesResponseBodyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (xTotalCount) {
      res["X-Total-Count"] = boost::any(*xTotalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("X-Total-Count") != m.end() && !m["X-Total-Count"].empty()) {
      xTotalCount = make_shared<long>(boost::any_cast<long>(m["X-Total-Count"]));
    }
  }


  virtual ~ListDeprecatedTemplatesResponseBodyHeaders() = default;
};
class ListDeprecatedTemplatesResponseBodyResultTemplate : public Darabonba::Model {
public:
  shared_ptr<string> aliases{};
  shared_ptr<string> mappings{};
  shared_ptr<string> settings{};

  ListDeprecatedTemplatesResponseBodyResultTemplate() {}

  explicit ListDeprecatedTemplatesResponseBodyResultTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliases) {
      res["aliases"] = boost::any(*aliases);
    }
    if (mappings) {
      res["mappings"] = boost::any(*mappings);
    }
    if (settings) {
      res["settings"] = boost::any(*settings);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aliases") != m.end() && !m["aliases"].empty()) {
      aliases = make_shared<string>(boost::any_cast<string>(m["aliases"]));
    }
    if (m.find("mappings") != m.end() && !m["mappings"].empty()) {
      mappings = make_shared<string>(boost::any_cast<string>(m["mappings"]));
    }
    if (m.find("settings") != m.end() && !m["settings"].empty()) {
      settings = make_shared<string>(boost::any_cast<string>(m["settings"]));
    }
  }


  virtual ~ListDeprecatedTemplatesResponseBodyResultTemplate() = default;
};
class ListDeprecatedTemplatesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> dataStream{};
  shared_ptr<vector<string>> indexPatterns{};
  shared_ptr<string> indexTemplate{};
  shared_ptr<long> order{};
  shared_ptr<ListDeprecatedTemplatesResponseBodyResultTemplate> template_{};
  shared_ptr<string> version{};

  ListDeprecatedTemplatesResponseBodyResult() {}

  explicit ListDeprecatedTemplatesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataStream) {
      res["dataStream"] = boost::any(*dataStream);
    }
    if (indexPatterns) {
      res["indexPatterns"] = boost::any(*indexPatterns);
    }
    if (indexTemplate) {
      res["indexTemplate"] = boost::any(*indexTemplate);
    }
    if (order) {
      res["order"] = boost::any(*order);
    }
    if (template_) {
      res["template"] = template_ ? boost::any(template_->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dataStream") != m.end() && !m["dataStream"].empty()) {
      dataStream = make_shared<bool>(boost::any_cast<bool>(m["dataStream"]));
    }
    if (m.find("indexPatterns") != m.end() && !m["indexPatterns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["indexPatterns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["indexPatterns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      indexPatterns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("indexTemplate") != m.end() && !m["indexTemplate"].empty()) {
      indexTemplate = make_shared<string>(boost::any_cast<string>(m["indexTemplate"]));
    }
    if (m.find("order") != m.end() && !m["order"].empty()) {
      order = make_shared<long>(boost::any_cast<long>(m["order"]));
    }
    if (m.find("template") != m.end() && !m["template"].empty()) {
      if (typeid(map<string, boost::any>) == m["template"].type()) {
        ListDeprecatedTemplatesResponseBodyResultTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["template"]));
        template_ = make_shared<ListDeprecatedTemplatesResponseBodyResultTemplate>(model1);
      }
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
  }


  virtual ~ListDeprecatedTemplatesResponseBodyResult() = default;
};
class ListDeprecatedTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDeprecatedTemplatesResponseBodyHeaders> headers{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListDeprecatedTemplatesResponseBodyResult>> result{};

  ListDeprecatedTemplatesResponseBody() {}

  explicit ListDeprecatedTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["Headers"] = headers ? boost::any(headers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      if (typeid(map<string, boost::any>) == m["Headers"].type()) {
        ListDeprecatedTemplatesResponseBodyHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Headers"]));
        headers = make_shared<ListDeprecatedTemplatesResponseBodyHeaders>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListDeprecatedTemplatesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDeprecatedTemplatesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListDeprecatedTemplatesResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListDeprecatedTemplatesResponseBody() = default;
};
class ListDeprecatedTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDeprecatedTemplatesResponseBody> body{};

  ListDeprecatedTemplatesResponse() {}

  explicit ListDeprecatedTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDeprecatedTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDeprecatedTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDeprecatedTemplatesResponse() = default;
};
class ListDiagnoseIndicesRequest : public Darabonba::Model {
public:
  shared_ptr<string> lang{};

  ListDiagnoseIndicesRequest() {}

  explicit ListDiagnoseIndicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (lang) {
      res["lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("lang") != m.end() && !m["lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["lang"]));
    }
  }


  virtual ~ListDiagnoseIndicesRequest() = default;
};
class ListDiagnoseIndicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> result{};

  ListDiagnoseIndicesResponseBody() {}

  explicit ListDiagnoseIndicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Result"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      result = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDiagnoseIndicesResponseBody() = default;
};
class ListDiagnoseIndicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDiagnoseIndicesResponseBody> body{};

  ListDiagnoseIndicesResponse() {}

  explicit ListDiagnoseIndicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDiagnoseIndicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDiagnoseIndicesResponseBody>(model1);
      }
    }
  }


  virtual ~ListDiagnoseIndicesResponse() = default;
};
class ListDiagnoseReportRequest : public Darabonba::Model {
public:
  shared_ptr<bool> detail{};
  shared_ptr<long> endTime{};
  shared_ptr<string> lang{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<long> startTime{};
  shared_ptr<string> trigger{};

  ListDiagnoseReportRequest() {}

  explicit ListDiagnoseReportRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detail) {
      res["detail"] = boost::any(*detail);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (lang) {
      res["lang"] = boost::any(*lang);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (trigger) {
      res["trigger"] = boost::any(*trigger);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("detail") != m.end() && !m["detail"].empty()) {
      detail = make_shared<bool>(boost::any_cast<bool>(m["detail"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("lang") != m.end() && !m["lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["lang"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
    if (m.find("trigger") != m.end() && !m["trigger"].empty()) {
      trigger = make_shared<string>(boost::any_cast<string>(m["trigger"]));
    }
  }


  virtual ~ListDiagnoseReportRequest() = default;
};
class ListDiagnoseReportResponseBodyHeaders : public Darabonba::Model {
public:
  shared_ptr<long> xTotalCount{};

  ListDiagnoseReportResponseBodyHeaders() {}

  explicit ListDiagnoseReportResponseBodyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (xTotalCount) {
      res["X-Total-Count"] = boost::any(*xTotalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("X-Total-Count") != m.end() && !m["X-Total-Count"].empty()) {
      xTotalCount = make_shared<long>(boost::any_cast<long>(m["X-Total-Count"]));
    }
  }


  virtual ~ListDiagnoseReportResponseBodyHeaders() = default;
};
class ListDiagnoseReportResponseBodyResultDiagnoseItemsDetail : public Darabonba::Model {
public:
  shared_ptr<string> desc{};
  shared_ptr<string> name{};
  shared_ptr<string> result{};
  shared_ptr<string> suggest{};
  shared_ptr<string> type{};

  ListDiagnoseReportResponseBodyResultDiagnoseItemsDetail() {}

  explicit ListDiagnoseReportResponseBodyResultDiagnoseItemsDetail(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (desc) {
      res["desc"] = boost::any(*desc);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (result) {
      res["result"] = boost::any(*result);
    }
    if (suggest) {
      res["suggest"] = boost::any(*suggest);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("desc") != m.end() && !m["desc"].empty()) {
      desc = make_shared<string>(boost::any_cast<string>(m["desc"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("result") != m.end() && !m["result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["result"]));
    }
    if (m.find("suggest") != m.end() && !m["suggest"].empty()) {
      suggest = make_shared<string>(boost::any_cast<string>(m["suggest"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ListDiagnoseReportResponseBodyResultDiagnoseItemsDetail() = default;
};
class ListDiagnoseReportResponseBodyResultDiagnoseItems : public Darabonba::Model {
public:
  shared_ptr<ListDiagnoseReportResponseBodyResultDiagnoseItemsDetail> detail{};
  shared_ptr<string> health{};
  shared_ptr<string> item{};

  ListDiagnoseReportResponseBodyResultDiagnoseItems() {}

  explicit ListDiagnoseReportResponseBodyResultDiagnoseItems(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (detail) {
      res["detail"] = detail ? boost::any(detail->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (health) {
      res["health"] = boost::any(*health);
    }
    if (item) {
      res["item"] = boost::any(*item);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("detail") != m.end() && !m["detail"].empty()) {
      if (typeid(map<string, boost::any>) == m["detail"].type()) {
        ListDiagnoseReportResponseBodyResultDiagnoseItemsDetail model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["detail"]));
        detail = make_shared<ListDiagnoseReportResponseBodyResultDiagnoseItemsDetail>(model1);
      }
    }
    if (m.find("health") != m.end() && !m["health"].empty()) {
      health = make_shared<string>(boost::any_cast<string>(m["health"]));
    }
    if (m.find("item") != m.end() && !m["item"].empty()) {
      item = make_shared<string>(boost::any_cast<string>(m["item"]));
    }
  }


  virtual ~ListDiagnoseReportResponseBodyResultDiagnoseItems() = default;
};
class ListDiagnoseReportResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> createTime{};
  shared_ptr<vector<ListDiagnoseReportResponseBodyResultDiagnoseItems>> diagnoseItems{};
  shared_ptr<string> health{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> reportId{};
  shared_ptr<string> state{};
  shared_ptr<string> trigger{};

  ListDiagnoseReportResponseBodyResult() {}

  explicit ListDiagnoseReportResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (diagnoseItems) {
      vector<boost::any> temp1;
      for(auto item1:*diagnoseItems){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["diagnoseItems"] = boost::any(temp1);
    }
    if (health) {
      res["health"] = boost::any(*health);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (reportId) {
      res["reportId"] = boost::any(*reportId);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    if (trigger) {
      res["trigger"] = boost::any(*trigger);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<long>(boost::any_cast<long>(m["createTime"]));
    }
    if (m.find("diagnoseItems") != m.end() && !m["diagnoseItems"].empty()) {
      if (typeid(vector<boost::any>) == m["diagnoseItems"].type()) {
        vector<ListDiagnoseReportResponseBodyResultDiagnoseItems> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["diagnoseItems"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDiagnoseReportResponseBodyResultDiagnoseItems model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        diagnoseItems = make_shared<vector<ListDiagnoseReportResponseBodyResultDiagnoseItems>>(expect1);
      }
    }
    if (m.find("health") != m.end() && !m["health"].empty()) {
      health = make_shared<string>(boost::any_cast<string>(m["health"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("reportId") != m.end() && !m["reportId"].empty()) {
      reportId = make_shared<string>(boost::any_cast<string>(m["reportId"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
    if (m.find("trigger") != m.end() && !m["trigger"].empty()) {
      trigger = make_shared<string>(boost::any_cast<string>(m["trigger"]));
    }
  }


  virtual ~ListDiagnoseReportResponseBodyResult() = default;
};
class ListDiagnoseReportResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDiagnoseReportResponseBodyHeaders> headers{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListDiagnoseReportResponseBodyResult>> result{};

  ListDiagnoseReportResponseBody() {}

  explicit ListDiagnoseReportResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["Headers"] = headers ? boost::any(headers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      if (typeid(map<string, boost::any>) == m["Headers"].type()) {
        ListDiagnoseReportResponseBodyHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Headers"]));
        headers = make_shared<ListDiagnoseReportResponseBodyHeaders>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListDiagnoseReportResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDiagnoseReportResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListDiagnoseReportResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListDiagnoseReportResponseBody() = default;
};
class ListDiagnoseReportResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDiagnoseReportResponseBody> body{};

  ListDiagnoseReportResponse() {}

  explicit ListDiagnoseReportResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDiagnoseReportResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDiagnoseReportResponseBody>(model1);
      }
    }
  }


  virtual ~ListDiagnoseReportResponse() = default;
};
class ListDiagnoseReportIdsRequest : public Darabonba::Model {
public:
  shared_ptr<long> endTime{};
  shared_ptr<string> lang{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<long> startTime{};
  shared_ptr<string> trigger{};

  ListDiagnoseReportIdsRequest() {}

  explicit ListDiagnoseReportIdsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (lang) {
      res["lang"] = boost::any(*lang);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    if (startTime) {
      res["startTime"] = boost::any(*startTime);
    }
    if (trigger) {
      res["trigger"] = boost::any(*trigger);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("lang") != m.end() && !m["lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["lang"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
    if (m.find("startTime") != m.end() && !m["startTime"].empty()) {
      startTime = make_shared<long>(boost::any_cast<long>(m["startTime"]));
    }
    if (m.find("trigger") != m.end() && !m["trigger"].empty()) {
      trigger = make_shared<string>(boost::any_cast<string>(m["trigger"]));
    }
  }


  virtual ~ListDiagnoseReportIdsRequest() = default;
};
class ListDiagnoseReportIdsResponseBodyHeaders : public Darabonba::Model {
public:
  shared_ptr<long> xTotalCount{};

  ListDiagnoseReportIdsResponseBodyHeaders() {}

  explicit ListDiagnoseReportIdsResponseBodyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (xTotalCount) {
      res["X-Total-Count"] = boost::any(*xTotalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("X-Total-Count") != m.end() && !m["X-Total-Count"].empty()) {
      xTotalCount = make_shared<long>(boost::any_cast<long>(m["X-Total-Count"]));
    }
  }


  virtual ~ListDiagnoseReportIdsResponseBodyHeaders() = default;
};
class ListDiagnoseReportIdsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDiagnoseReportIdsResponseBodyHeaders> headers{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> result{};

  ListDiagnoseReportIdsResponseBody() {}

  explicit ListDiagnoseReportIdsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["Headers"] = headers ? boost::any(headers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      if (typeid(map<string, boost::any>) == m["Headers"].type()) {
        ListDiagnoseReportIdsResponseBodyHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Headers"]));
        headers = make_shared<ListDiagnoseReportIdsResponseBodyHeaders>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Result"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      result = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~ListDiagnoseReportIdsResponseBody() = default;
};
class ListDiagnoseReportIdsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDiagnoseReportIdsResponseBody> body{};

  ListDiagnoseReportIdsResponse() {}

  explicit ListDiagnoseReportIdsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDiagnoseReportIdsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDiagnoseReportIdsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDiagnoseReportIdsResponse() = default;
};
class ListDictInformationRequest : public Darabonba::Model {
public:
  shared_ptr<string> analyzerType{};
  shared_ptr<string> bucketName{};
  shared_ptr<string> key{};

  ListDictInformationRequest() {}

  explicit ListDictInformationRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analyzerType) {
      res["analyzerType"] = boost::any(*analyzerType);
    }
    if (bucketName) {
      res["bucketName"] = boost::any(*bucketName);
    }
    if (key) {
      res["key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("analyzerType") != m.end() && !m["analyzerType"].empty()) {
      analyzerType = make_shared<string>(boost::any_cast<string>(m["analyzerType"]));
    }
    if (m.find("bucketName") != m.end() && !m["bucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["bucketName"]));
    }
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
  }


  virtual ~ListDictInformationRequest() = default;
};
class ListDictInformationResponseBodyResultOssObject : public Darabonba::Model {
public:
  shared_ptr<string> bucketName{};
  shared_ptr<string> etag{};
  shared_ptr<string> key{};

  ListDictInformationResponseBodyResultOssObject() {}

  explicit ListDictInformationResponseBodyResultOssObject(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bucketName) {
      res["bucketName"] = boost::any(*bucketName);
    }
    if (etag) {
      res["etag"] = boost::any(*etag);
    }
    if (key) {
      res["key"] = boost::any(*key);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bucketName") != m.end() && !m["bucketName"].empty()) {
      bucketName = make_shared<string>(boost::any_cast<string>(m["bucketName"]));
    }
    if (m.find("etag") != m.end() && !m["etag"].empty()) {
      etag = make_shared<string>(boost::any_cast<string>(m["etag"]));
    }
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
  }


  virtual ~ListDictInformationResponseBodyResultOssObject() = default;
};
class ListDictInformationResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> fileSize{};
  shared_ptr<ListDictInformationResponseBodyResultOssObject> ossObject{};
  shared_ptr<string> type{};

  ListDictInformationResponseBodyResult() {}

  explicit ListDictInformationResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileSize) {
      res["fileSize"] = boost::any(*fileSize);
    }
    if (ossObject) {
      res["ossObject"] = ossObject ? boost::any(ossObject->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fileSize") != m.end() && !m["fileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["fileSize"]));
    }
    if (m.find("ossObject") != m.end() && !m["ossObject"].empty()) {
      if (typeid(map<string, boost::any>) == m["ossObject"].type()) {
        ListDictInformationResponseBodyResultOssObject model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["ossObject"]));
        ossObject = make_shared<ListDictInformationResponseBodyResultOssObject>(model1);
      }
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ListDictInformationResponseBodyResult() = default;
};
class ListDictInformationResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ListDictInformationResponseBodyResult> result{};

  ListDictInformationResponseBody() {}

  explicit ListDictInformationResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ListDictInformationResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ListDictInformationResponseBodyResult>(model1);
      }
    }
  }


  virtual ~ListDictInformationResponseBody() = default;
};
class ListDictInformationResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDictInformationResponseBody> body{};

  ListDictInformationResponse() {}

  explicit ListDictInformationResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDictInformationResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDictInformationResponseBody>(model1);
      }
    }
  }


  virtual ~ListDictInformationResponse() = default;
};
class ListDictsRequest : public Darabonba::Model {
public:
  shared_ptr<string> analyzerType{};
  shared_ptr<string> name{};

  ListDictsRequest() {}

  explicit ListDictsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (analyzerType) {
      res["analyzerType"] = boost::any(*analyzerType);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("analyzerType") != m.end() && !m["analyzerType"].empty()) {
      analyzerType = make_shared<string>(boost::any_cast<string>(m["analyzerType"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
  }


  virtual ~ListDictsRequest() = default;
};
class ListDictsResponseBodyHeaders : public Darabonba::Model {
public:
  shared_ptr<long> xTotalCount{};

  ListDictsResponseBodyHeaders() {}

  explicit ListDictsResponseBodyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (xTotalCount) {
      res["X-Total-Count"] = boost::any(*xTotalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("X-Total-Count") != m.end() && !m["X-Total-Count"].empty()) {
      xTotalCount = make_shared<long>(boost::any_cast<long>(m["X-Total-Count"]));
    }
  }


  virtual ~ListDictsResponseBodyHeaders() = default;
};
class ListDictsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> downloadUrl{};
  shared_ptr<long> fileSize{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> type{};

  ListDictsResponseBodyResult() {}

  explicit ListDictsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (downloadUrl) {
      res["downloadUrl"] = boost::any(*downloadUrl);
    }
    if (fileSize) {
      res["fileSize"] = boost::any(*fileSize);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("downloadUrl") != m.end() && !m["downloadUrl"].empty()) {
      downloadUrl = make_shared<string>(boost::any_cast<string>(m["downloadUrl"]));
    }
    if (m.find("fileSize") != m.end() && !m["fileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["fileSize"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ListDictsResponseBodyResult() = default;
};
class ListDictsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListDictsResponseBodyHeaders> headers{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListDictsResponseBodyResult>> result{};

  ListDictsResponseBody() {}

  explicit ListDictsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["Headers"] = headers ? boost::any(headers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      if (typeid(map<string, boost::any>) == m["Headers"].type()) {
        ListDictsResponseBodyHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Headers"]));
        headers = make_shared<ListDictsResponseBodyHeaders>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListDictsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListDictsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListDictsResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListDictsResponseBody() = default;
};
class ListDictsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListDictsResponseBody> body{};

  ListDictsResponse() {}

  explicit ListDictsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListDictsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListDictsResponseBody>(model1);
      }
    }
  }


  virtual ~ListDictsResponse() = default;
};
class ListEcsInstancesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ecsInstanceIds{};
  shared_ptr<string> ecsInstanceName{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<string> tags{};
  shared_ptr<string> vpcId{};

  ListEcsInstancesRequest() {}

  explicit ListEcsInstancesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecsInstanceIds) {
      res["ecsInstanceIds"] = boost::any(*ecsInstanceIds);
    }
    if (ecsInstanceName) {
      res["ecsInstanceName"] = boost::any(*ecsInstanceName);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    if (tags) {
      res["tags"] = boost::any(*tags);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ecsInstanceIds") != m.end() && !m["ecsInstanceIds"].empty()) {
      ecsInstanceIds = make_shared<string>(boost::any_cast<string>(m["ecsInstanceIds"]));
    }
    if (m.find("ecsInstanceName") != m.end() && !m["ecsInstanceName"].empty()) {
      ecsInstanceName = make_shared<string>(boost::any_cast<string>(m["ecsInstanceName"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["tags"]));
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
  }


  virtual ~ListEcsInstancesRequest() = default;
};
class ListEcsInstancesResponseBodyHeaders : public Darabonba::Model {
public:
  shared_ptr<long> xTotalCount{};

  ListEcsInstancesResponseBodyHeaders() {}

  explicit ListEcsInstancesResponseBodyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (xTotalCount) {
      res["X-Total-Count"] = boost::any(*xTotalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("X-Total-Count") != m.end() && !m["X-Total-Count"].empty()) {
      xTotalCount = make_shared<long>(boost::any_cast<long>(m["X-Total-Count"]));
    }
  }


  virtual ~ListEcsInstancesResponseBodyHeaders() = default;
};
class ListEcsInstancesResponseBodyResultCollectorsConfigs : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> fileName{};

  ListEcsInstancesResponseBodyResultCollectorsConfigs() {}

  explicit ListEcsInstancesResponseBodyResultCollectorsConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (fileName) {
      res["fileName"] = boost::any(*fileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("fileName") != m.end() && !m["fileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["fileName"]));
    }
  }


  virtual ~ListEcsInstancesResponseBodyResultCollectorsConfigs() = default;
};
class ListEcsInstancesResponseBodyResultCollectorsExtendConfigsMachines : public Darabonba::Model {
public:
  shared_ptr<string> agentStatus{};
  shared_ptr<string> instanceId{};

  ListEcsInstancesResponseBodyResultCollectorsExtendConfigsMachines() {}

  explicit ListEcsInstancesResponseBodyResultCollectorsExtendConfigsMachines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentStatus) {
      res["agentStatus"] = boost::any(*agentStatus);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("agentStatus") != m.end() && !m["agentStatus"].empty()) {
      agentStatus = make_shared<string>(boost::any_cast<string>(m["agentStatus"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
  }


  virtual ~ListEcsInstancesResponseBodyResultCollectorsExtendConfigsMachines() = default;
};
class ListEcsInstancesResponseBodyResultCollectorsExtendConfigs : public Darabonba::Model {
public:
  shared_ptr<string> configType{};
  shared_ptr<bool> enableMonitoring{};
  shared_ptr<string> groupId{};
  shared_ptr<vector<string>> hosts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<vector<ListEcsInstancesResponseBodyResultCollectorsExtendConfigsMachines>> machines{};
  shared_ptr<string> protocol{};
  shared_ptr<string> type{};
  shared_ptr<string> userName{};

  ListEcsInstancesResponseBodyResultCollectorsExtendConfigs() {}

  explicit ListEcsInstancesResponseBodyResultCollectorsExtendConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configType) {
      res["configType"] = boost::any(*configType);
    }
    if (enableMonitoring) {
      res["enableMonitoring"] = boost::any(*enableMonitoring);
    }
    if (groupId) {
      res["groupId"] = boost::any(*groupId);
    }
    if (hosts) {
      res["hosts"] = boost::any(*hosts);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["instanceType"] = boost::any(*instanceType);
    }
    if (machines) {
      vector<boost::any> temp1;
      for(auto item1:*machines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["machines"] = boost::any(temp1);
    }
    if (protocol) {
      res["protocol"] = boost::any(*protocol);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (userName) {
      res["userName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("configType") != m.end() && !m["configType"].empty()) {
      configType = make_shared<string>(boost::any_cast<string>(m["configType"]));
    }
    if (m.find("enableMonitoring") != m.end() && !m["enableMonitoring"].empty()) {
      enableMonitoring = make_shared<bool>(boost::any_cast<bool>(m["enableMonitoring"]));
    }
    if (m.find("groupId") != m.end() && !m["groupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["groupId"]));
    }
    if (m.find("hosts") != m.end() && !m["hosts"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["hosts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["hosts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hosts = make_shared<vector<string>>(toVec1);
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("instanceType") != m.end() && !m["instanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["instanceType"]));
    }
    if (m.find("machines") != m.end() && !m["machines"].empty()) {
      if (typeid(vector<boost::any>) == m["machines"].type()) {
        vector<ListEcsInstancesResponseBodyResultCollectorsExtendConfigsMachines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["machines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEcsInstancesResponseBodyResultCollectorsExtendConfigsMachines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        machines = make_shared<vector<ListEcsInstancesResponseBodyResultCollectorsExtendConfigsMachines>>(expect1);
      }
    }
    if (m.find("protocol") != m.end() && !m["protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["protocol"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("userName") != m.end() && !m["userName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["userName"]));
    }
  }


  virtual ~ListEcsInstancesResponseBodyResultCollectorsExtendConfigs() = default;
};
class ListEcsInstancesResponseBodyResultCollectors : public Darabonba::Model {
public:
  shared_ptr<vector<string>> collectorPaths{};
  shared_ptr<vector<ListEcsInstancesResponseBodyResultCollectorsConfigs>> configs{};
  shared_ptr<bool> dryRun{};
  shared_ptr<vector<ListEcsInstancesResponseBodyResultCollectorsExtendConfigs>> extendConfigs{};
  shared_ptr<string> gmtCreatedTime{};
  shared_ptr<string> gmtUpdateTime{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> resId{};
  shared_ptr<string> resType{};
  shared_ptr<string> resVersion{};
  shared_ptr<string> status{};
  shared_ptr<string> vpcId{};

  ListEcsInstancesResponseBodyResultCollectors() {}

  explicit ListEcsInstancesResponseBodyResultCollectors(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (collectorPaths) {
      res["collectorPaths"] = boost::any(*collectorPaths);
    }
    if (configs) {
      vector<boost::any> temp1;
      for(auto item1:*configs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["configs"] = boost::any(temp1);
    }
    if (dryRun) {
      res["dryRun"] = boost::any(*dryRun);
    }
    if (extendConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*extendConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extendConfigs"] = boost::any(temp1);
    }
    if (gmtCreatedTime) {
      res["gmtCreatedTime"] = boost::any(*gmtCreatedTime);
    }
    if (gmtUpdateTime) {
      res["gmtUpdateTime"] = boost::any(*gmtUpdateTime);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (ownerId) {
      res["ownerId"] = boost::any(*ownerId);
    }
    if (resId) {
      res["resId"] = boost::any(*resId);
    }
    if (resType) {
      res["resType"] = boost::any(*resType);
    }
    if (resVersion) {
      res["resVersion"] = boost::any(*resVersion);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("collectorPaths") != m.end() && !m["collectorPaths"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["collectorPaths"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["collectorPaths"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      collectorPaths = make_shared<vector<string>>(toVec1);
    }
    if (m.find("configs") != m.end() && !m["configs"].empty()) {
      if (typeid(vector<boost::any>) == m["configs"].type()) {
        vector<ListEcsInstancesResponseBodyResultCollectorsConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["configs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEcsInstancesResponseBodyResultCollectorsConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configs = make_shared<vector<ListEcsInstancesResponseBodyResultCollectorsConfigs>>(expect1);
      }
    }
    if (m.find("dryRun") != m.end() && !m["dryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["dryRun"]));
    }
    if (m.find("extendConfigs") != m.end() && !m["extendConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["extendConfigs"].type()) {
        vector<ListEcsInstancesResponseBodyResultCollectorsExtendConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extendConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEcsInstancesResponseBodyResultCollectorsExtendConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extendConfigs = make_shared<vector<ListEcsInstancesResponseBodyResultCollectorsExtendConfigs>>(expect1);
      }
    }
    if (m.find("gmtCreatedTime") != m.end() && !m["gmtCreatedTime"].empty()) {
      gmtCreatedTime = make_shared<string>(boost::any_cast<string>(m["gmtCreatedTime"]));
    }
    if (m.find("gmtUpdateTime") != m.end() && !m["gmtUpdateTime"].empty()) {
      gmtUpdateTime = make_shared<string>(boost::any_cast<string>(m["gmtUpdateTime"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("ownerId") != m.end() && !m["ownerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["ownerId"]));
    }
    if (m.find("resId") != m.end() && !m["resId"].empty()) {
      resId = make_shared<string>(boost::any_cast<string>(m["resId"]));
    }
    if (m.find("resType") != m.end() && !m["resType"].empty()) {
      resType = make_shared<string>(boost::any_cast<string>(m["resType"]));
    }
    if (m.find("resVersion") != m.end() && !m["resVersion"].empty()) {
      resVersion = make_shared<string>(boost::any_cast<string>(m["resVersion"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
  }


  virtual ~ListEcsInstancesResponseBodyResultCollectors() = default;
};
class ListEcsInstancesResponseBodyResultIpAddress : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<string> ipType{};

  ListEcsInstancesResponseBodyResultIpAddress() {}

  explicit ListEcsInstancesResponseBodyResultIpAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["host"] = boost::any(*host);
    }
    if (ipType) {
      res["ipType"] = boost::any(*ipType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("host") != m.end() && !m["host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["host"]));
    }
    if (m.find("ipType") != m.end() && !m["ipType"].empty()) {
      ipType = make_shared<string>(boost::any_cast<string>(m["ipType"]));
    }
  }


  virtual ~ListEcsInstancesResponseBodyResultIpAddress() = default;
};
class ListEcsInstancesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> cloudAssistantStatus{};
  shared_ptr<vector<ListEcsInstancesResponseBodyResultCollectors>> collectors{};
  shared_ptr<string> ecsInstanceId{};
  shared_ptr<string> ecsInstanceName{};
  shared_ptr<vector<ListEcsInstancesResponseBodyResultIpAddress>> ipAddress{};
  shared_ptr<string> osType{};
  shared_ptr<string> status{};
  shared_ptr<string> tags{};

  ListEcsInstancesResponseBodyResult() {}

  explicit ListEcsInstancesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cloudAssistantStatus) {
      res["cloudAssistantStatus"] = boost::any(*cloudAssistantStatus);
    }
    if (collectors) {
      vector<boost::any> temp1;
      for(auto item1:*collectors){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["collectors"] = boost::any(temp1);
    }
    if (ecsInstanceId) {
      res["ecsInstanceId"] = boost::any(*ecsInstanceId);
    }
    if (ecsInstanceName) {
      res["ecsInstanceName"] = boost::any(*ecsInstanceName);
    }
    if (ipAddress) {
      vector<boost::any> temp1;
      for(auto item1:*ipAddress){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ipAddress"] = boost::any(temp1);
    }
    if (osType) {
      res["osType"] = boost::any(*osType);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (tags) {
      res["tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cloudAssistantStatus") != m.end() && !m["cloudAssistantStatus"].empty()) {
      cloudAssistantStatus = make_shared<string>(boost::any_cast<string>(m["cloudAssistantStatus"]));
    }
    if (m.find("collectors") != m.end() && !m["collectors"].empty()) {
      if (typeid(vector<boost::any>) == m["collectors"].type()) {
        vector<ListEcsInstancesResponseBodyResultCollectors> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["collectors"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEcsInstancesResponseBodyResultCollectors model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        collectors = make_shared<vector<ListEcsInstancesResponseBodyResultCollectors>>(expect1);
      }
    }
    if (m.find("ecsInstanceId") != m.end() && !m["ecsInstanceId"].empty()) {
      ecsInstanceId = make_shared<string>(boost::any_cast<string>(m["ecsInstanceId"]));
    }
    if (m.find("ecsInstanceName") != m.end() && !m["ecsInstanceName"].empty()) {
      ecsInstanceName = make_shared<string>(boost::any_cast<string>(m["ecsInstanceName"]));
    }
    if (m.find("ipAddress") != m.end() && !m["ipAddress"].empty()) {
      if (typeid(vector<boost::any>) == m["ipAddress"].type()) {
        vector<ListEcsInstancesResponseBodyResultIpAddress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ipAddress"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEcsInstancesResponseBodyResultIpAddress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipAddress = make_shared<vector<ListEcsInstancesResponseBodyResultIpAddress>>(expect1);
      }
    }
    if (m.find("osType") != m.end() && !m["osType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["osType"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["tags"]));
    }
  }


  virtual ~ListEcsInstancesResponseBodyResult() = default;
};
class ListEcsInstancesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListEcsInstancesResponseBodyHeaders> headers{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListEcsInstancesResponseBodyResult>> result{};

  ListEcsInstancesResponseBody() {}

  explicit ListEcsInstancesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["Headers"] = headers ? boost::any(headers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      if (typeid(map<string, boost::any>) == m["Headers"].type()) {
        ListEcsInstancesResponseBodyHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Headers"]));
        headers = make_shared<ListEcsInstancesResponseBodyHeaders>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListEcsInstancesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListEcsInstancesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListEcsInstancesResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListEcsInstancesResponseBody() = default;
};
class ListEcsInstancesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListEcsInstancesResponseBody> body{};

  ListEcsInstancesResponse() {}

  explicit ListEcsInstancesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListEcsInstancesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListEcsInstancesResponseBody>(model1);
      }
    }
  }


  virtual ~ListEcsInstancesResponse() = default;
};
class ListExtendfilesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> filePath{};
  shared_ptr<long> fileSize{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceType{};

  ListExtendfilesResponseBodyResult() {}

  explicit ListExtendfilesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (filePath) {
      res["filePath"] = boost::any(*filePath);
    }
    if (fileSize) {
      res["fileSize"] = boost::any(*fileSize);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("filePath") != m.end() && !m["filePath"].empty()) {
      filePath = make_shared<string>(boost::any_cast<string>(m["filePath"]));
    }
    if (m.find("fileSize") != m.end() && !m["fileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["fileSize"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
  }


  virtual ~ListExtendfilesResponseBodyResult() = default;
};
class ListExtendfilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListExtendfilesResponseBodyResult>> result{};

  ListExtendfilesResponseBody() {}

  explicit ListExtendfilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListExtendfilesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListExtendfilesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListExtendfilesResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListExtendfilesResponseBody() = default;
};
class ListExtendfilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListExtendfilesResponseBody> body{};

  ListExtendfilesResponse() {}

  explicit ListExtendfilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListExtendfilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListExtendfilesResponseBody>(model1);
      }
    }
  }


  virtual ~ListExtendfilesResponse() = default;
};
class ListILMPoliciesRequest : public Darabonba::Model {
public:
  shared_ptr<string> policyName{};

  ListILMPoliciesRequest() {}

  explicit ListILMPoliciesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (policyName) {
      res["policyName"] = boost::any(*policyName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("policyName") != m.end() && !m["policyName"].empty()) {
      policyName = make_shared<string>(boost::any_cast<string>(m["policyName"]));
    }
  }


  virtual ~ListILMPoliciesRequest() = default;
};
class ListILMPoliciesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<map<string, boost::any>> phases{};

  ListILMPoliciesResponseBodyResult() {}

  explicit ListILMPoliciesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (phases) {
      res["phases"] = boost::any(*phases);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("phases") != m.end() && !m["phases"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["phases"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      phases = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~ListILMPoliciesResponseBodyResult() = default;
};
class ListILMPoliciesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListILMPoliciesResponseBodyResult>> result{};

  ListILMPoliciesResponseBody() {}

  explicit ListILMPoliciesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListILMPoliciesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListILMPoliciesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListILMPoliciesResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListILMPoliciesResponseBody() = default;
};
class ListILMPoliciesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListILMPoliciesResponseBody> body{};

  ListILMPoliciesResponse() {}

  explicit ListILMPoliciesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListILMPoliciesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListILMPoliciesResponseBody>(model1);
      }
    }
  }


  virtual ~ListILMPoliciesResponse() = default;
};
class ListIndexTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> indexTemplate{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};

  ListIndexTemplatesRequest() {}

  explicit ListIndexTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (indexTemplate) {
      res["indexTemplate"] = boost::any(*indexTemplate);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("indexTemplate") != m.end() && !m["indexTemplate"].empty()) {
      indexTemplate = make_shared<string>(boost::any_cast<string>(m["indexTemplate"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
  }


  virtual ~ListIndexTemplatesRequest() = default;
};
class ListIndexTemplatesResponseBodyResultTemplate : public Darabonba::Model {
public:
  shared_ptr<string> aliases{};
  shared_ptr<string> mappings{};
  shared_ptr<string> settings{};

  ListIndexTemplatesResponseBodyResultTemplate() {}

  explicit ListIndexTemplatesResponseBodyResultTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliases) {
      res["aliases"] = boost::any(*aliases);
    }
    if (mappings) {
      res["mappings"] = boost::any(*mappings);
    }
    if (settings) {
      res["settings"] = boost::any(*settings);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aliases") != m.end() && !m["aliases"].empty()) {
      aliases = make_shared<string>(boost::any_cast<string>(m["aliases"]));
    }
    if (m.find("mappings") != m.end() && !m["mappings"].empty()) {
      mappings = make_shared<string>(boost::any_cast<string>(m["mappings"]));
    }
    if (m.find("settings") != m.end() && !m["settings"].empty()) {
      settings = make_shared<string>(boost::any_cast<string>(m["settings"]));
    }
  }


  virtual ~ListIndexTemplatesResponseBodyResultTemplate() = default;
};
class ListIndexTemplatesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> dataStream{};
  shared_ptr<string> ilmPolicy{};
  shared_ptr<vector<string>> indexPatterns{};
  shared_ptr<string> indexTemplate{};
  shared_ptr<long> priority{};
  shared_ptr<ListIndexTemplatesResponseBodyResultTemplate> template_{};

  ListIndexTemplatesResponseBodyResult() {}

  explicit ListIndexTemplatesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (dataStream) {
      res["dataStream"] = boost::any(*dataStream);
    }
    if (ilmPolicy) {
      res["ilmPolicy"] = boost::any(*ilmPolicy);
    }
    if (indexPatterns) {
      res["indexPatterns"] = boost::any(*indexPatterns);
    }
    if (indexTemplate) {
      res["indexTemplate"] = boost::any(*indexTemplate);
    }
    if (priority) {
      res["priority"] = boost::any(*priority);
    }
    if (template_) {
      res["template"] = template_ ? boost::any(template_->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("dataStream") != m.end() && !m["dataStream"].empty()) {
      dataStream = make_shared<bool>(boost::any_cast<bool>(m["dataStream"]));
    }
    if (m.find("ilmPolicy") != m.end() && !m["ilmPolicy"].empty()) {
      ilmPolicy = make_shared<string>(boost::any_cast<string>(m["ilmPolicy"]));
    }
    if (m.find("indexPatterns") != m.end() && !m["indexPatterns"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["indexPatterns"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["indexPatterns"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      indexPatterns = make_shared<vector<string>>(toVec1);
    }
    if (m.find("indexTemplate") != m.end() && !m["indexTemplate"].empty()) {
      indexTemplate = make_shared<string>(boost::any_cast<string>(m["indexTemplate"]));
    }
    if (m.find("priority") != m.end() && !m["priority"].empty()) {
      priority = make_shared<long>(boost::any_cast<long>(m["priority"]));
    }
    if (m.find("template") != m.end() && !m["template"].empty()) {
      if (typeid(map<string, boost::any>) == m["template"].type()) {
        ListIndexTemplatesResponseBodyResultTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["template"]));
        template_ = make_shared<ListIndexTemplatesResponseBodyResultTemplate>(model1);
      }
    }
  }


  virtual ~ListIndexTemplatesResponseBodyResult() = default;
};
class ListIndexTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListIndexTemplatesResponseBodyResult>> result{};

  ListIndexTemplatesResponseBody() {}

  explicit ListIndexTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListIndexTemplatesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListIndexTemplatesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListIndexTemplatesResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListIndexTemplatesResponseBody() = default;
};
class ListIndexTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListIndexTemplatesResponseBody> body{};

  ListIndexTemplatesResponse() {}

  explicit ListIndexTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListIndexTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListIndexTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~ListIndexTemplatesResponse() = default;
};
class ListInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> esVersion{};
  shared_ptr<string> instanceCategory{};
  shared_ptr<string> instanceId{};
  shared_ptr<long> page{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> size{};
  shared_ptr<string> tags{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> zoneId{};

  ListInstanceRequest() {}

  explicit ListInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (esVersion) {
      res["esVersion"] = boost::any(*esVersion);
    }
    if (instanceCategory) {
      res["instanceCategory"] = boost::any(*instanceCategory);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (paymentType) {
      res["paymentType"] = boost::any(*paymentType);
    }
    if (resourceGroupId) {
      res["resourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    if (tags) {
      res["tags"] = boost::any(*tags);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    if (zoneId) {
      res["zoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("esVersion") != m.end() && !m["esVersion"].empty()) {
      esVersion = make_shared<string>(boost::any_cast<string>(m["esVersion"]));
    }
    if (m.find("instanceCategory") != m.end() && !m["instanceCategory"].empty()) {
      instanceCategory = make_shared<string>(boost::any_cast<string>(m["instanceCategory"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("paymentType") != m.end() && !m["paymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["paymentType"]));
    }
    if (m.find("resourceGroupId") != m.end() && !m["resourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["resourceGroupId"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["tags"]));
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
    if (m.find("zoneId") != m.end() && !m["zoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["zoneId"]));
    }
  }


  virtual ~ListInstanceRequest() = default;
};
class ListInstanceResponseBodyHeaders : public Darabonba::Model {
public:
  shared_ptr<long> xTotalCount{};

  ListInstanceResponseBodyHeaders() {}

  explicit ListInstanceResponseBodyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (xTotalCount) {
      res["X-Total-Count"] = boost::any(*xTotalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("X-Total-Count") != m.end() && !m["X-Total-Count"].empty()) {
      xTotalCount = make_shared<long>(boost::any_cast<long>(m["X-Total-Count"]));
    }
  }


  virtual ~ListInstanceResponseBodyHeaders() = default;
};
class ListInstanceResponseBodyResultClientNodeConfiguration : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<long> disk{};
  shared_ptr<string> diskType{};
  shared_ptr<string> spec{};

  ListInstanceResponseBodyResultClientNodeConfiguration() {}

  explicit ListInstanceResponseBodyResultClientNodeConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["amount"]));
    }
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~ListInstanceResponseBodyResultClientNodeConfiguration() = default;
};
class ListInstanceResponseBodyResultElasticDataNodeConfiguration : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<long> disk{};
  shared_ptr<bool> diskEncryption{};
  shared_ptr<string> diskType{};
  shared_ptr<string> spec{};

  ListInstanceResponseBodyResultElasticDataNodeConfiguration() {}

  explicit ListInstanceResponseBodyResultElasticDataNodeConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskEncryption) {
      res["diskEncryption"] = boost::any(*diskEncryption);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["amount"]));
    }
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskEncryption") != m.end() && !m["diskEncryption"].empty()) {
      diskEncryption = make_shared<bool>(boost::any_cast<bool>(m["diskEncryption"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~ListInstanceResponseBodyResultElasticDataNodeConfiguration() = default;
};
class ListInstanceResponseBodyResultKibanaConfiguration : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<long> disk{};
  shared_ptr<string> diskType{};
  shared_ptr<string> spec{};

  ListInstanceResponseBodyResultKibanaConfiguration() {}

  explicit ListInstanceResponseBodyResultKibanaConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["amount"]));
    }
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~ListInstanceResponseBodyResultKibanaConfiguration() = default;
};
class ListInstanceResponseBodyResultMasterConfiguration : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<long> disk{};
  shared_ptr<string> diskType{};
  shared_ptr<string> spec{};

  ListInstanceResponseBodyResultMasterConfiguration() {}

  explicit ListInstanceResponseBodyResultMasterConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["amount"]));
    }
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~ListInstanceResponseBodyResultMasterConfiguration() = default;
};
class ListInstanceResponseBodyResultNetworkConfig : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vsArea{};
  shared_ptr<string> vswitchId{};

  ListInstanceResponseBodyResultNetworkConfig() {}

  explicit ListInstanceResponseBodyResultNetworkConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    if (vsArea) {
      res["vsArea"] = boost::any(*vsArea);
    }
    if (vswitchId) {
      res["vswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
    if (m.find("vsArea") != m.end() && !m["vsArea"].empty()) {
      vsArea = make_shared<string>(boost::any_cast<string>(m["vsArea"]));
    }
    if (m.find("vswitchId") != m.end() && !m["vswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["vswitchId"]));
    }
  }


  virtual ~ListInstanceResponseBodyResultNetworkConfig() = default;
};
class ListInstanceResponseBodyResultNodeSpec : public Darabonba::Model {
public:
  shared_ptr<long> disk{};
  shared_ptr<bool> diskEncryption{};
  shared_ptr<string> diskType{};
  shared_ptr<string> spec{};

  ListInstanceResponseBodyResultNodeSpec() {}

  explicit ListInstanceResponseBodyResultNodeSpec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskEncryption) {
      res["diskEncryption"] = boost::any(*diskEncryption);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskEncryption") != m.end() && !m["diskEncryption"].empty()) {
      diskEncryption = make_shared<bool>(boost::any_cast<bool>(m["diskEncryption"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~ListInstanceResponseBodyResultNodeSpec() = default;
};
class ListInstanceResponseBodyResultTags : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListInstanceResponseBodyResultTags() {}

  explicit ListInstanceResponseBodyResultTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["tagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["tagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tagKey") != m.end() && !m["tagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["tagKey"]));
    }
    if (m.find("tagValue") != m.end() && !m["tagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["tagValue"]));
    }
  }


  virtual ~ListInstanceResponseBodyResultTags() = default;
};
class ListInstanceResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> advancedDedicateMaster{};
  shared_ptr<ListInstanceResponseBodyResultClientNodeConfiguration> clientNodeConfiguration{};
  shared_ptr<string> createdAt{};
  shared_ptr<bool> dedicateMaster{};
  shared_ptr<string> description{};
  shared_ptr<ListInstanceResponseBodyResultElasticDataNodeConfiguration> elasticDataNodeConfiguration{};
  shared_ptr<string> esVersion{};
  shared_ptr<vector<map<string, boost::any>>> extendConfigs{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> isNewDeployment{};
  shared_ptr<ListInstanceResponseBodyResultKibanaConfiguration> kibanaConfiguration{};
  shared_ptr<ListInstanceResponseBodyResultMasterConfiguration> masterConfiguration{};
  shared_ptr<ListInstanceResponseBodyResultNetworkConfig> networkConfig{};
  shared_ptr<long> nodeAmount{};
  shared_ptr<ListInstanceResponseBodyResultNodeSpec> nodeSpec{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> postpaidServiceStatus{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<bool> serviceVpc{};
  shared_ptr<string> status{};
  shared_ptr<vector<ListInstanceResponseBodyResultTags>> tags{};
  shared_ptr<string> updatedAt{};

  ListInstanceResponseBodyResult() {}

  explicit ListInstanceResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (advancedDedicateMaster) {
      res["advancedDedicateMaster"] = boost::any(*advancedDedicateMaster);
    }
    if (clientNodeConfiguration) {
      res["clientNodeConfiguration"] = clientNodeConfiguration ? boost::any(clientNodeConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (dedicateMaster) {
      res["dedicateMaster"] = boost::any(*dedicateMaster);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (elasticDataNodeConfiguration) {
      res["elasticDataNodeConfiguration"] = elasticDataNodeConfiguration ? boost::any(elasticDataNodeConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (esVersion) {
      res["esVersion"] = boost::any(*esVersion);
    }
    if (extendConfigs) {
      res["extendConfigs"] = boost::any(*extendConfigs);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (isNewDeployment) {
      res["isNewDeployment"] = boost::any(*isNewDeployment);
    }
    if (kibanaConfiguration) {
      res["kibanaConfiguration"] = kibanaConfiguration ? boost::any(kibanaConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (masterConfiguration) {
      res["masterConfiguration"] = masterConfiguration ? boost::any(masterConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (networkConfig) {
      res["networkConfig"] = networkConfig ? boost::any(networkConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodeAmount) {
      res["nodeAmount"] = boost::any(*nodeAmount);
    }
    if (nodeSpec) {
      res["nodeSpec"] = nodeSpec ? boost::any(nodeSpec->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (paymentType) {
      res["paymentType"] = boost::any(*paymentType);
    }
    if (postpaidServiceStatus) {
      res["postpaidServiceStatus"] = boost::any(*postpaidServiceStatus);
    }
    if (resourceGroupId) {
      res["resourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (serviceVpc) {
      res["serviceVpc"] = boost::any(*serviceVpc);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tags"] = boost::any(temp1);
    }
    if (updatedAt) {
      res["updatedAt"] = boost::any(*updatedAt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("advancedDedicateMaster") != m.end() && !m["advancedDedicateMaster"].empty()) {
      advancedDedicateMaster = make_shared<bool>(boost::any_cast<bool>(m["advancedDedicateMaster"]));
    }
    if (m.find("clientNodeConfiguration") != m.end() && !m["clientNodeConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["clientNodeConfiguration"].type()) {
        ListInstanceResponseBodyResultClientNodeConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["clientNodeConfiguration"]));
        clientNodeConfiguration = make_shared<ListInstanceResponseBodyResultClientNodeConfiguration>(model1);
      }
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("dedicateMaster") != m.end() && !m["dedicateMaster"].empty()) {
      dedicateMaster = make_shared<bool>(boost::any_cast<bool>(m["dedicateMaster"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("elasticDataNodeConfiguration") != m.end() && !m["elasticDataNodeConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["elasticDataNodeConfiguration"].type()) {
        ListInstanceResponseBodyResultElasticDataNodeConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["elasticDataNodeConfiguration"]));
        elasticDataNodeConfiguration = make_shared<ListInstanceResponseBodyResultElasticDataNodeConfiguration>(model1);
      }
    }
    if (m.find("esVersion") != m.end() && !m["esVersion"].empty()) {
      esVersion = make_shared<string>(boost::any_cast<string>(m["esVersion"]));
    }
    if (m.find("extendConfigs") != m.end() && !m["extendConfigs"].empty()) {
      vector<map<string, boost::any>> toVec1;
      if (typeid(vector<boost::any>) == m["extendConfigs"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["extendConfigs"]);
        for (auto item:vec1) {
          map<string, boost::any> map2 = boost::any_cast<map<string, boost::any>>(item);
          map<string, boost::any> toMap2;
          for (auto item:map2) {
             toMap2[item.first] = item.second;
          }
           toVec1.push_back(toMap2);
        }
      }
      extendConfigs = make_shared<vector<map<string, boost::any>>>(toVec1);
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("isNewDeployment") != m.end() && !m["isNewDeployment"].empty()) {
      isNewDeployment = make_shared<string>(boost::any_cast<string>(m["isNewDeployment"]));
    }
    if (m.find("kibanaConfiguration") != m.end() && !m["kibanaConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["kibanaConfiguration"].type()) {
        ListInstanceResponseBodyResultKibanaConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["kibanaConfiguration"]));
        kibanaConfiguration = make_shared<ListInstanceResponseBodyResultKibanaConfiguration>(model1);
      }
    }
    if (m.find("masterConfiguration") != m.end() && !m["masterConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["masterConfiguration"].type()) {
        ListInstanceResponseBodyResultMasterConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["masterConfiguration"]));
        masterConfiguration = make_shared<ListInstanceResponseBodyResultMasterConfiguration>(model1);
      }
    }
    if (m.find("networkConfig") != m.end() && !m["networkConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["networkConfig"].type()) {
        ListInstanceResponseBodyResultNetworkConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["networkConfig"]));
        networkConfig = make_shared<ListInstanceResponseBodyResultNetworkConfig>(model1);
      }
    }
    if (m.find("nodeAmount") != m.end() && !m["nodeAmount"].empty()) {
      nodeAmount = make_shared<long>(boost::any_cast<long>(m["nodeAmount"]));
    }
    if (m.find("nodeSpec") != m.end() && !m["nodeSpec"].empty()) {
      if (typeid(map<string, boost::any>) == m["nodeSpec"].type()) {
        ListInstanceResponseBodyResultNodeSpec model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["nodeSpec"]));
        nodeSpec = make_shared<ListInstanceResponseBodyResultNodeSpec>(model1);
      }
    }
    if (m.find("paymentType") != m.end() && !m["paymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["paymentType"]));
    }
    if (m.find("postpaidServiceStatus") != m.end() && !m["postpaidServiceStatus"].empty()) {
      postpaidServiceStatus = make_shared<string>(boost::any_cast<string>(m["postpaidServiceStatus"]));
    }
    if (m.find("resourceGroupId") != m.end() && !m["resourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["resourceGroupId"]));
    }
    if (m.find("serviceVpc") != m.end() && !m["serviceVpc"].empty()) {
      serviceVpc = make_shared<bool>(boost::any_cast<bool>(m["serviceVpc"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<ListInstanceResponseBodyResultTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstanceResponseBodyResultTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListInstanceResponseBodyResultTags>>(expect1);
      }
    }
    if (m.find("updatedAt") != m.end() && !m["updatedAt"].empty()) {
      updatedAt = make_shared<string>(boost::any_cast<string>(m["updatedAt"]));
    }
  }


  virtual ~ListInstanceResponseBodyResult() = default;
};
class ListInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListInstanceResponseBodyHeaders> headers{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListInstanceResponseBodyResult>> result{};

  ListInstanceResponseBody() {}

  explicit ListInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["Headers"] = headers ? boost::any(headers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      if (typeid(map<string, boost::any>) == m["Headers"].type()) {
        ListInstanceResponseBodyHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Headers"]));
        headers = make_shared<ListInstanceResponseBodyHeaders>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListInstanceResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstanceResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListInstanceResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListInstanceResponseBody() = default;
};
class ListInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInstanceResponseBody> body{};

  ListInstanceResponse() {}

  explicit ListInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~ListInstanceResponse() = default;
};
class ListInstanceHistoryEventsRequest : public Darabonba::Model {
public:
  shared_ptr<string> eventCreateEndTime{};
  shared_ptr<string> eventCreateStartTime{};
  shared_ptr<vector<string>> eventCycleStatus{};
  shared_ptr<string> eventExecuteEndTime{};
  shared_ptr<string> eventExecuteStartTime{};
  shared_ptr<string> eventFinashEndTime{};
  shared_ptr<string> eventFinashStartTime{};
  shared_ptr<vector<string>> eventLevel{};
  shared_ptr<vector<string>> eventType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeIP{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};

  ListInstanceHistoryEventsRequest() {}

  explicit ListInstanceHistoryEventsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventCreateEndTime) {
      res["eventCreateEndTime"] = boost::any(*eventCreateEndTime);
    }
    if (eventCreateStartTime) {
      res["eventCreateStartTime"] = boost::any(*eventCreateStartTime);
    }
    if (eventCycleStatus) {
      res["eventCycleStatus"] = boost::any(*eventCycleStatus);
    }
    if (eventExecuteEndTime) {
      res["eventExecuteEndTime"] = boost::any(*eventExecuteEndTime);
    }
    if (eventExecuteStartTime) {
      res["eventExecuteStartTime"] = boost::any(*eventExecuteStartTime);
    }
    if (eventFinashEndTime) {
      res["eventFinashEndTime"] = boost::any(*eventFinashEndTime);
    }
    if (eventFinashStartTime) {
      res["eventFinashStartTime"] = boost::any(*eventFinashStartTime);
    }
    if (eventLevel) {
      res["eventLevel"] = boost::any(*eventLevel);
    }
    if (eventType) {
      res["eventType"] = boost::any(*eventType);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (nodeIP) {
      res["nodeIP"] = boost::any(*nodeIP);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("eventCreateEndTime") != m.end() && !m["eventCreateEndTime"].empty()) {
      eventCreateEndTime = make_shared<string>(boost::any_cast<string>(m["eventCreateEndTime"]));
    }
    if (m.find("eventCreateStartTime") != m.end() && !m["eventCreateStartTime"].empty()) {
      eventCreateStartTime = make_shared<string>(boost::any_cast<string>(m["eventCreateStartTime"]));
    }
    if (m.find("eventCycleStatus") != m.end() && !m["eventCycleStatus"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["eventCycleStatus"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["eventCycleStatus"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      eventCycleStatus = make_shared<vector<string>>(toVec1);
    }
    if (m.find("eventExecuteEndTime") != m.end() && !m["eventExecuteEndTime"].empty()) {
      eventExecuteEndTime = make_shared<string>(boost::any_cast<string>(m["eventExecuteEndTime"]));
    }
    if (m.find("eventExecuteStartTime") != m.end() && !m["eventExecuteStartTime"].empty()) {
      eventExecuteStartTime = make_shared<string>(boost::any_cast<string>(m["eventExecuteStartTime"]));
    }
    if (m.find("eventFinashEndTime") != m.end() && !m["eventFinashEndTime"].empty()) {
      eventFinashEndTime = make_shared<string>(boost::any_cast<string>(m["eventFinashEndTime"]));
    }
    if (m.find("eventFinashStartTime") != m.end() && !m["eventFinashStartTime"].empty()) {
      eventFinashStartTime = make_shared<string>(boost::any_cast<string>(m["eventFinashStartTime"]));
    }
    if (m.find("eventLevel") != m.end() && !m["eventLevel"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["eventLevel"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["eventLevel"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      eventLevel = make_shared<vector<string>>(toVec1);
    }
    if (m.find("eventType") != m.end() && !m["eventType"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["eventType"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["eventType"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      eventType = make_shared<vector<string>>(toVec1);
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("nodeIP") != m.end() && !m["nodeIP"].empty()) {
      nodeIP = make_shared<string>(boost::any_cast<string>(m["nodeIP"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
  }


  virtual ~ListInstanceHistoryEventsRequest() = default;
};
class ListInstanceHistoryEventsShrinkRequest : public Darabonba::Model {
public:
  shared_ptr<string> eventCreateEndTime{};
  shared_ptr<string> eventCreateStartTime{};
  shared_ptr<string> eventCycleStatusShrink{};
  shared_ptr<string> eventExecuteEndTime{};
  shared_ptr<string> eventExecuteStartTime{};
  shared_ptr<string> eventFinashEndTime{};
  shared_ptr<string> eventFinashStartTime{};
  shared_ptr<string> eventLevelShrink{};
  shared_ptr<string> eventTypeShrink{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeIP{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};

  ListInstanceHistoryEventsShrinkRequest() {}

  explicit ListInstanceHistoryEventsShrinkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (eventCreateEndTime) {
      res["eventCreateEndTime"] = boost::any(*eventCreateEndTime);
    }
    if (eventCreateStartTime) {
      res["eventCreateStartTime"] = boost::any(*eventCreateStartTime);
    }
    if (eventCycleStatusShrink) {
      res["eventCycleStatus"] = boost::any(*eventCycleStatusShrink);
    }
    if (eventExecuteEndTime) {
      res["eventExecuteEndTime"] = boost::any(*eventExecuteEndTime);
    }
    if (eventExecuteStartTime) {
      res["eventExecuteStartTime"] = boost::any(*eventExecuteStartTime);
    }
    if (eventFinashEndTime) {
      res["eventFinashEndTime"] = boost::any(*eventFinashEndTime);
    }
    if (eventFinashStartTime) {
      res["eventFinashStartTime"] = boost::any(*eventFinashStartTime);
    }
    if (eventLevelShrink) {
      res["eventLevel"] = boost::any(*eventLevelShrink);
    }
    if (eventTypeShrink) {
      res["eventType"] = boost::any(*eventTypeShrink);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (nodeIP) {
      res["nodeIP"] = boost::any(*nodeIP);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("eventCreateEndTime") != m.end() && !m["eventCreateEndTime"].empty()) {
      eventCreateEndTime = make_shared<string>(boost::any_cast<string>(m["eventCreateEndTime"]));
    }
    if (m.find("eventCreateStartTime") != m.end() && !m["eventCreateStartTime"].empty()) {
      eventCreateStartTime = make_shared<string>(boost::any_cast<string>(m["eventCreateStartTime"]));
    }
    if (m.find("eventCycleStatus") != m.end() && !m["eventCycleStatus"].empty()) {
      eventCycleStatusShrink = make_shared<string>(boost::any_cast<string>(m["eventCycleStatus"]));
    }
    if (m.find("eventExecuteEndTime") != m.end() && !m["eventExecuteEndTime"].empty()) {
      eventExecuteEndTime = make_shared<string>(boost::any_cast<string>(m["eventExecuteEndTime"]));
    }
    if (m.find("eventExecuteStartTime") != m.end() && !m["eventExecuteStartTime"].empty()) {
      eventExecuteStartTime = make_shared<string>(boost::any_cast<string>(m["eventExecuteStartTime"]));
    }
    if (m.find("eventFinashEndTime") != m.end() && !m["eventFinashEndTime"].empty()) {
      eventFinashEndTime = make_shared<string>(boost::any_cast<string>(m["eventFinashEndTime"]));
    }
    if (m.find("eventFinashStartTime") != m.end() && !m["eventFinashStartTime"].empty()) {
      eventFinashStartTime = make_shared<string>(boost::any_cast<string>(m["eventFinashStartTime"]));
    }
    if (m.find("eventLevel") != m.end() && !m["eventLevel"].empty()) {
      eventLevelShrink = make_shared<string>(boost::any_cast<string>(m["eventLevel"]));
    }
    if (m.find("eventType") != m.end() && !m["eventType"].empty()) {
      eventTypeShrink = make_shared<string>(boost::any_cast<string>(m["eventType"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("nodeIP") != m.end() && !m["nodeIP"].empty()) {
      nodeIP = make_shared<string>(boost::any_cast<string>(m["nodeIP"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
  }


  virtual ~ListInstanceHistoryEventsShrinkRequest() = default;
};
class ListInstanceHistoryEventsResponseBodyHeaders : public Darabonba::Model {
public:
  shared_ptr<long> xTotalCount{};
  shared_ptr<long> xTotalFailed{};
  shared_ptr<long> xTotalSuccess{};

  ListInstanceHistoryEventsResponseBodyHeaders() {}

  explicit ListInstanceHistoryEventsResponseBodyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (xTotalCount) {
      res["X-Total-Count"] = boost::any(*xTotalCount);
    }
    if (xTotalFailed) {
      res["X-Total-Failed"] = boost::any(*xTotalFailed);
    }
    if (xTotalSuccess) {
      res["X-Total-Success"] = boost::any(*xTotalSuccess);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("X-Total-Count") != m.end() && !m["X-Total-Count"].empty()) {
      xTotalCount = make_shared<long>(boost::any_cast<long>(m["X-Total-Count"]));
    }
    if (m.find("X-Total-Failed") != m.end() && !m["X-Total-Failed"].empty()) {
      xTotalFailed = make_shared<long>(boost::any_cast<long>(m["X-Total-Failed"]));
    }
    if (m.find("X-Total-Success") != m.end() && !m["X-Total-Success"].empty()) {
      xTotalSuccess = make_shared<long>(boost::any_cast<long>(m["X-Total-Success"]));
    }
  }


  virtual ~ListInstanceHistoryEventsResponseBodyHeaders() = default;
};
class ListInstanceHistoryEventsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> ecsId{};
  shared_ptr<string> eventCreateTime{};
  shared_ptr<string> eventCycleStatus{};
  shared_ptr<string> eventExecuteTime{};
  shared_ptr<string> eventFinashTime{};
  shared_ptr<string> eventLevel{};
  shared_ptr<string> eventType{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> nodeIP{};
  shared_ptr<string> regionId{};

  ListInstanceHistoryEventsResponseBodyResult() {}

  explicit ListInstanceHistoryEventsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecsId) {
      res["ecsId"] = boost::any(*ecsId);
    }
    if (eventCreateTime) {
      res["eventCreateTime"] = boost::any(*eventCreateTime);
    }
    if (eventCycleStatus) {
      res["eventCycleStatus"] = boost::any(*eventCycleStatus);
    }
    if (eventExecuteTime) {
      res["eventExecuteTime"] = boost::any(*eventExecuteTime);
    }
    if (eventFinashTime) {
      res["eventFinashTime"] = boost::any(*eventFinashTime);
    }
    if (eventLevel) {
      res["eventLevel"] = boost::any(*eventLevel);
    }
    if (eventType) {
      res["eventType"] = boost::any(*eventType);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (nodeIP) {
      res["nodeIP"] = boost::any(*nodeIP);
    }
    if (regionId) {
      res["regionId"] = boost::any(*regionId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ecsId") != m.end() && !m["ecsId"].empty()) {
      ecsId = make_shared<string>(boost::any_cast<string>(m["ecsId"]));
    }
    if (m.find("eventCreateTime") != m.end() && !m["eventCreateTime"].empty()) {
      eventCreateTime = make_shared<string>(boost::any_cast<string>(m["eventCreateTime"]));
    }
    if (m.find("eventCycleStatus") != m.end() && !m["eventCycleStatus"].empty()) {
      eventCycleStatus = make_shared<string>(boost::any_cast<string>(m["eventCycleStatus"]));
    }
    if (m.find("eventExecuteTime") != m.end() && !m["eventExecuteTime"].empty()) {
      eventExecuteTime = make_shared<string>(boost::any_cast<string>(m["eventExecuteTime"]));
    }
    if (m.find("eventFinashTime") != m.end() && !m["eventFinashTime"].empty()) {
      eventFinashTime = make_shared<string>(boost::any_cast<string>(m["eventFinashTime"]));
    }
    if (m.find("eventLevel") != m.end() && !m["eventLevel"].empty()) {
      eventLevel = make_shared<string>(boost::any_cast<string>(m["eventLevel"]));
    }
    if (m.find("eventType") != m.end() && !m["eventType"].empty()) {
      eventType = make_shared<string>(boost::any_cast<string>(m["eventType"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("nodeIP") != m.end() && !m["nodeIP"].empty()) {
      nodeIP = make_shared<string>(boost::any_cast<string>(m["nodeIP"]));
    }
    if (m.find("regionId") != m.end() && !m["regionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["regionId"]));
    }
  }


  virtual ~ListInstanceHistoryEventsResponseBodyResult() = default;
};
class ListInstanceHistoryEventsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListInstanceHistoryEventsResponseBodyHeaders> headers{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListInstanceHistoryEventsResponseBodyResult>> result{};

  ListInstanceHistoryEventsResponseBody() {}

  explicit ListInstanceHistoryEventsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["Headers"] = headers ? boost::any(headers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      if (typeid(map<string, boost::any>) == m["Headers"].type()) {
        ListInstanceHistoryEventsResponseBodyHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Headers"]));
        headers = make_shared<ListInstanceHistoryEventsResponseBodyHeaders>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListInstanceHistoryEventsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstanceHistoryEventsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListInstanceHistoryEventsResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListInstanceHistoryEventsResponseBody() = default;
};
class ListInstanceHistoryEventsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInstanceHistoryEventsResponseBody> body{};

  ListInstanceHistoryEventsResponse() {}

  explicit ListInstanceHistoryEventsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInstanceHistoryEventsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInstanceHistoryEventsResponseBody>(model1);
      }
    }
  }


  virtual ~ListInstanceHistoryEventsResponse() = default;
};
class ListInstanceIndicesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<bool> isManaged{};
  shared_ptr<bool> isOpenstore{};
  shared_ptr<string> name{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};

  ListInstanceIndicesRequest() {}

  explicit ListInstanceIndicesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["all"] = boost::any(*all);
    }
    if (isManaged) {
      res["isManaged"] = boost::any(*isManaged);
    }
    if (isOpenstore) {
      res["isOpenstore"] = boost::any(*isOpenstore);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("all") != m.end() && !m["all"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["all"]));
    }
    if (m.find("isManaged") != m.end() && !m["isManaged"].empty()) {
      isManaged = make_shared<bool>(boost::any_cast<bool>(m["isManaged"]));
    }
    if (m.find("isOpenstore") != m.end() && !m["isOpenstore"].empty()) {
      isOpenstore = make_shared<bool>(boost::any_cast<bool>(m["isOpenstore"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
  }


  virtual ~ListInstanceIndicesRequest() = default;
};
class ListInstanceIndicesResponseBodyHeaders : public Darabonba::Model {
public:
  shared_ptr<long> xManagedCount{};
  shared_ptr<long> xManagedStorageSize{};
  shared_ptr<long> xOSSCount{};
  shared_ptr<long> xOSSStorageSize{};

  ListInstanceIndicesResponseBodyHeaders() {}

  explicit ListInstanceIndicesResponseBodyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (xManagedCount) {
      res["X-Managed-Count"] = boost::any(*xManagedCount);
    }
    if (xManagedStorageSize) {
      res["X-Managed-StorageSize"] = boost::any(*xManagedStorageSize);
    }
    if (xOSSCount) {
      res["X-OSS-Count"] = boost::any(*xOSSCount);
    }
    if (xOSSStorageSize) {
      res["X-OSS-StorageSize"] = boost::any(*xOSSStorageSize);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("X-Managed-Count") != m.end() && !m["X-Managed-Count"].empty()) {
      xManagedCount = make_shared<long>(boost::any_cast<long>(m["X-Managed-Count"]));
    }
    if (m.find("X-Managed-StorageSize") != m.end() && !m["X-Managed-StorageSize"].empty()) {
      xManagedStorageSize = make_shared<long>(boost::any_cast<long>(m["X-Managed-StorageSize"]));
    }
    if (m.find("X-OSS-Count") != m.end() && !m["X-OSS-Count"].empty()) {
      xOSSCount = make_shared<long>(boost::any_cast<long>(m["X-OSS-Count"]));
    }
    if (m.find("X-OSS-StorageSize") != m.end() && !m["X-OSS-StorageSize"].empty()) {
      xOSSStorageSize = make_shared<long>(boost::any_cast<long>(m["X-OSS-StorageSize"]));
    }
  }


  virtual ~ListInstanceIndicesResponseBodyHeaders() = default;
};
class ListInstanceIndicesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> createTime{};
  shared_ptr<string> health{};
  shared_ptr<string> ilmExplain{};
  shared_ptr<string> isManaged{};
  shared_ptr<string> managedStatus{};
  shared_ptr<string> name{};
  shared_ptr<string> phase{};
  shared_ptr<long> size{};

  ListInstanceIndicesResponseBodyResult() {}

  explicit ListInstanceIndicesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (health) {
      res["health"] = boost::any(*health);
    }
    if (ilmExplain) {
      res["ilmExplain"] = boost::any(*ilmExplain);
    }
    if (isManaged) {
      res["isManaged"] = boost::any(*isManaged);
    }
    if (managedStatus) {
      res["managedStatus"] = boost::any(*managedStatus);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (phase) {
      res["phase"] = boost::any(*phase);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("health") != m.end() && !m["health"].empty()) {
      health = make_shared<string>(boost::any_cast<string>(m["health"]));
    }
    if (m.find("ilmExplain") != m.end() && !m["ilmExplain"].empty()) {
      ilmExplain = make_shared<string>(boost::any_cast<string>(m["ilmExplain"]));
    }
    if (m.find("isManaged") != m.end() && !m["isManaged"].empty()) {
      isManaged = make_shared<string>(boost::any_cast<string>(m["isManaged"]));
    }
    if (m.find("managedStatus") != m.end() && !m["managedStatus"].empty()) {
      managedStatus = make_shared<string>(boost::any_cast<string>(m["managedStatus"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("phase") != m.end() && !m["phase"].empty()) {
      phase = make_shared<string>(boost::any_cast<string>(m["phase"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
  }


  virtual ~ListInstanceIndicesResponseBodyResult() = default;
};
class ListInstanceIndicesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListInstanceIndicesResponseBodyHeaders> headers{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListInstanceIndicesResponseBodyResult>> result{};

  ListInstanceIndicesResponseBody() {}

  explicit ListInstanceIndicesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["Headers"] = headers ? boost::any(headers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      if (typeid(map<string, boost::any>) == m["Headers"].type()) {
        ListInstanceIndicesResponseBodyHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Headers"]));
        headers = make_shared<ListInstanceIndicesResponseBodyHeaders>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListInstanceIndicesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListInstanceIndicesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListInstanceIndicesResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListInstanceIndicesResponseBody() = default;
};
class ListInstanceIndicesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListInstanceIndicesResponseBody> body{};

  ListInstanceIndicesResponse() {}

  explicit ListInstanceIndicesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListInstanceIndicesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListInstanceIndicesResponseBody>(model1);
      }
    }
  }


  virtual ~ListInstanceIndicesResponse() = default;
};
class ListKibanaPluginsRequest : public Darabonba::Model {
public:
  shared_ptr<string> page{};
  shared_ptr<long> size{};

  ListKibanaPluginsRequest() {}

  explicit ListKibanaPluginsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<string>(boost::any_cast<string>(m["page"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
  }


  virtual ~ListKibanaPluginsRequest() = default;
};
class ListKibanaPluginsResponseBodyHeaders : public Darabonba::Model {
public:
  shared_ptr<long> xTotalCount{};

  ListKibanaPluginsResponseBodyHeaders() {}

  explicit ListKibanaPluginsResponseBodyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (xTotalCount) {
      res["X-Total-Count"] = boost::any(*xTotalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("X-Total-Count") != m.end() && !m["X-Total-Count"].empty()) {
      xTotalCount = make_shared<long>(boost::any_cast<long>(m["X-Total-Count"]));
    }
  }


  virtual ~ListKibanaPluginsResponseBodyHeaders() = default;
};
class ListKibanaPluginsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> source{};
  shared_ptr<string> specificationUrl{};
  shared_ptr<string> state{};

  ListKibanaPluginsResponseBodyResult() {}

  explicit ListKibanaPluginsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (specificationUrl) {
      res["specificationUrl"] = boost::any(*specificationUrl);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("specificationUrl") != m.end() && !m["specificationUrl"].empty()) {
      specificationUrl = make_shared<string>(boost::any_cast<string>(m["specificationUrl"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
  }


  virtual ~ListKibanaPluginsResponseBodyResult() = default;
};
class ListKibanaPluginsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListKibanaPluginsResponseBodyHeaders> headers{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListKibanaPluginsResponseBodyResult>> result{};

  ListKibanaPluginsResponseBody() {}

  explicit ListKibanaPluginsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["Headers"] = headers ? boost::any(headers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      if (typeid(map<string, boost::any>) == m["Headers"].type()) {
        ListKibanaPluginsResponseBodyHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Headers"]));
        headers = make_shared<ListKibanaPluginsResponseBodyHeaders>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListKibanaPluginsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListKibanaPluginsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListKibanaPluginsResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListKibanaPluginsResponseBody() = default;
};
class ListKibanaPluginsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListKibanaPluginsResponseBody> body{};

  ListKibanaPluginsResponse() {}

  explicit ListKibanaPluginsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListKibanaPluginsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListKibanaPluginsResponseBody>(model1);
      }
    }
  }


  virtual ~ListKibanaPluginsResponse() = default;
};
class ListLogstashRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> ownerId{};
  shared_ptr<long> page{};
  shared_ptr<string> resourceGroupId{};
  shared_ptr<long> size{};
  shared_ptr<string> tags{};
  shared_ptr<string> version{};

  ListLogstashRequest() {}

  explicit ListLogstashRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (ownerId) {
      res["ownerId"] = boost::any(*ownerId);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (resourceGroupId) {
      res["resourceGroupId"] = boost::any(*resourceGroupId);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    if (tags) {
      res["tags"] = boost::any(*tags);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("ownerId") != m.end() && !m["ownerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["ownerId"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("resourceGroupId") != m.end() && !m["resourceGroupId"].empty()) {
      resourceGroupId = make_shared<string>(boost::any_cast<string>(m["resourceGroupId"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["tags"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
  }


  virtual ~ListLogstashRequest() = default;
};
class ListLogstashResponseBodyHeaders : public Darabonba::Model {
public:
  shared_ptr<long> xTotalCount{};

  ListLogstashResponseBodyHeaders() {}

  explicit ListLogstashResponseBodyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (xTotalCount) {
      res["X-Total-Count"] = boost::any(*xTotalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("X-Total-Count") != m.end() && !m["X-Total-Count"].empty()) {
      xTotalCount = make_shared<long>(boost::any_cast<long>(m["X-Total-Count"]));
    }
  }


  virtual ~ListLogstashResponseBodyHeaders() = default;
};
class ListLogstashResponseBodyResultTags : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListLogstashResponseBodyResultTags() {}

  explicit ListLogstashResponseBodyResultTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListLogstashResponseBodyResultTags() = default;
};
class ListLogstashResponseBodyResultNetworkConfig : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vsArea{};
  shared_ptr<string> vswitchId{};

  ListLogstashResponseBodyResultNetworkConfig() {}

  explicit ListLogstashResponseBodyResultNetworkConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    if (vsArea) {
      res["vsArea"] = boost::any(*vsArea);
    }
    if (vswitchId) {
      res["vswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
    if (m.find("vsArea") != m.end() && !m["vsArea"].empty()) {
      vsArea = make_shared<string>(boost::any_cast<string>(m["vsArea"]));
    }
    if (m.find("vswitchId") != m.end() && !m["vswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["vswitchId"]));
    }
  }


  virtual ~ListLogstashResponseBodyResultNetworkConfig() = default;
};
class ListLogstashResponseBodyResultNodeSpec : public Darabonba::Model {
public:
  shared_ptr<long> disk{};
  shared_ptr<bool> diskEncryption{};
  shared_ptr<string> diskType{};
  shared_ptr<string> spec{};

  ListLogstashResponseBodyResultNodeSpec() {}

  explicit ListLogstashResponseBodyResultNodeSpec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskEncryption) {
      res["diskEncryption"] = boost::any(*diskEncryption);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskEncryption") != m.end() && !m["diskEncryption"].empty()) {
      diskEncryption = make_shared<bool>(boost::any_cast<bool>(m["diskEncryption"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~ListLogstashResponseBodyResultNodeSpec() = default;
};
class ListLogstashResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<ListLogstashResponseBodyResultTags>> tags{};
  shared_ptr<string> createdAt{};
  shared_ptr<string> description{};
  shared_ptr<string> instanceId{};
  shared_ptr<ListLogstashResponseBodyResultNetworkConfig> networkConfig{};
  shared_ptr<long> nodeAmount{};
  shared_ptr<ListLogstashResponseBodyResultNodeSpec> nodeSpec{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> status{};
  shared_ptr<string> updatedAt{};
  shared_ptr<string> version{};

  ListLogstashResponseBodyResult() {}

  explicit ListLogstashResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (networkConfig) {
      res["networkConfig"] = networkConfig ? boost::any(networkConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodeAmount) {
      res["nodeAmount"] = boost::any(*nodeAmount);
    }
    if (nodeSpec) {
      res["nodeSpec"] = nodeSpec ? boost::any(nodeSpec->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (paymentType) {
      res["paymentType"] = boost::any(*paymentType);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (updatedAt) {
      res["updatedAt"] = boost::any(*updatedAt);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<ListLogstashResponseBodyResultTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLogstashResponseBodyResultTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListLogstashResponseBodyResultTags>>(expect1);
      }
    }
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("networkConfig") != m.end() && !m["networkConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["networkConfig"].type()) {
        ListLogstashResponseBodyResultNetworkConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["networkConfig"]));
        networkConfig = make_shared<ListLogstashResponseBodyResultNetworkConfig>(model1);
      }
    }
    if (m.find("nodeAmount") != m.end() && !m["nodeAmount"].empty()) {
      nodeAmount = make_shared<long>(boost::any_cast<long>(m["nodeAmount"]));
    }
    if (m.find("nodeSpec") != m.end() && !m["nodeSpec"].empty()) {
      if (typeid(map<string, boost::any>) == m["nodeSpec"].type()) {
        ListLogstashResponseBodyResultNodeSpec model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["nodeSpec"]));
        nodeSpec = make_shared<ListLogstashResponseBodyResultNodeSpec>(model1);
      }
    }
    if (m.find("paymentType") != m.end() && !m["paymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["paymentType"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("updatedAt") != m.end() && !m["updatedAt"].empty()) {
      updatedAt = make_shared<string>(boost::any_cast<string>(m["updatedAt"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
  }


  virtual ~ListLogstashResponseBodyResult() = default;
};
class ListLogstashResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListLogstashResponseBodyHeaders> headers{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListLogstashResponseBodyResult>> result{};

  ListLogstashResponseBody() {}

  explicit ListLogstashResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["Headers"] = headers ? boost::any(headers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      if (typeid(map<string, boost::any>) == m["Headers"].type()) {
        ListLogstashResponseBodyHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Headers"]));
        headers = make_shared<ListLogstashResponseBodyHeaders>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListLogstashResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLogstashResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListLogstashResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListLogstashResponseBody() = default;
};
class ListLogstashResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLogstashResponseBody> body{};

  ListLogstashResponse() {}

  explicit ListLogstashResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLogstashResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLogstashResponseBody>(model1);
      }
    }
  }


  virtual ~ListLogstashResponse() = default;
};
class ListLogstashLogRequest : public Darabonba::Model {
public:
  shared_ptr<long> beginTime{};
  shared_ptr<long> endTime{};
  shared_ptr<long> page{};
  shared_ptr<string> query{};
  shared_ptr<long> size{};
  shared_ptr<string> type{};

  ListLogstashLogRequest() {}

  explicit ListLogstashLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginTime) {
      res["beginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (query) {
      res["query"] = boost::any(*query);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("beginTime") != m.end() && !m["beginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["beginTime"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("query") != m.end() && !m["query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["query"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ListLogstashLogRequest() = default;
};
class ListLogstashLogResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> host{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> level{};
  shared_ptr<long> timestamp{};

  ListLogstashLogResponseBodyResult() {}

  explicit ListLogstashLogResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (host) {
      res["host"] = boost::any(*host);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (level) {
      res["level"] = boost::any(*level);
    }
    if (timestamp) {
      res["timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("host") != m.end() && !m["host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["host"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("level") != m.end() && !m["level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["level"]));
    }
    if (m.find("timestamp") != m.end() && !m["timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["timestamp"]));
    }
  }


  virtual ~ListLogstashLogResponseBodyResult() = default;
};
class ListLogstashLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListLogstashLogResponseBodyResult>> result{};

  ListLogstashLogResponseBody() {}

  explicit ListLogstashLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListLogstashLogResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLogstashLogResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListLogstashLogResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListLogstashLogResponseBody() = default;
};
class ListLogstashLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLogstashLogResponseBody> body{};

  ListLogstashLogResponse() {}

  explicit ListLogstashLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLogstashLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLogstashLogResponseBody>(model1);
      }
    }
  }


  virtual ~ListLogstashLogResponse() = default;
};
class ListLogstashPluginsRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<string> source{};

  ListLogstashPluginsRequest() {}

  explicit ListLogstashPluginsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
  }


  virtual ~ListLogstashPluginsRequest() = default;
};
class ListLogstashPluginsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> source{};
  shared_ptr<string> specificationUrl{};
  shared_ptr<string> state{};

  ListLogstashPluginsResponseBodyResult() {}

  explicit ListLogstashPluginsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (specificationUrl) {
      res["specificationUrl"] = boost::any(*specificationUrl);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("specificationUrl") != m.end() && !m["specificationUrl"].empty()) {
      specificationUrl = make_shared<string>(boost::any_cast<string>(m["specificationUrl"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
  }


  virtual ~ListLogstashPluginsResponseBodyResult() = default;
};
class ListLogstashPluginsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListLogstashPluginsResponseBodyResult>> result{};

  ListLogstashPluginsResponseBody() {}

  explicit ListLogstashPluginsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListLogstashPluginsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListLogstashPluginsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListLogstashPluginsResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListLogstashPluginsResponseBody() = default;
};
class ListLogstashPluginsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListLogstashPluginsResponseBody> body{};

  ListLogstashPluginsResponse() {}

  explicit ListLogstashPluginsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListLogstashPluginsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListLogstashPluginsResponseBody>(model1);
      }
    }
  }


  virtual ~ListLogstashPluginsResponse() = default;
};
class ListNodesRequest : public Darabonba::Model {
public:
  shared_ptr<string> ecsInstanceIds{};
  shared_ptr<string> ecsInstanceName{};
  shared_ptr<long> page{};
  shared_ptr<long> size{};
  shared_ptr<string> tags{};

  ListNodesRequest() {}

  explicit ListNodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (ecsInstanceIds) {
      res["ecsInstanceIds"] = boost::any(*ecsInstanceIds);
    }
    if (ecsInstanceName) {
      res["ecsInstanceName"] = boost::any(*ecsInstanceName);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    if (tags) {
      res["tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ecsInstanceIds") != m.end() && !m["ecsInstanceIds"].empty()) {
      ecsInstanceIds = make_shared<string>(boost::any_cast<string>(m["ecsInstanceIds"]));
    }
    if (m.find("ecsInstanceName") != m.end() && !m["ecsInstanceName"].empty()) {
      ecsInstanceName = make_shared<string>(boost::any_cast<string>(m["ecsInstanceName"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["tags"]));
    }
  }


  virtual ~ListNodesRequest() = default;
};
class ListNodesResponseBodyHeaders : public Darabonba::Model {
public:
  shared_ptr<long> xTotalCount{};

  ListNodesResponseBodyHeaders() {}

  explicit ListNodesResponseBodyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (xTotalCount) {
      res["X-Total-Count"] = boost::any(*xTotalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("X-Total-Count") != m.end() && !m["X-Total-Count"].empty()) {
      xTotalCount = make_shared<long>(boost::any_cast<long>(m["X-Total-Count"]));
    }
  }


  virtual ~ListNodesResponseBodyHeaders() = default;
};
class ListNodesResponseBodyResultIpAddress : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<string> ipType{};

  ListNodesResponseBodyResultIpAddress() {}

  explicit ListNodesResponseBodyResultIpAddress(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["host"] = boost::any(*host);
    }
    if (ipType) {
      res["ipType"] = boost::any(*ipType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("host") != m.end() && !m["host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["host"]));
    }
    if (m.find("ipType") != m.end() && !m["ipType"].empty()) {
      ipType = make_shared<string>(boost::any_cast<string>(m["ipType"]));
    }
  }


  virtual ~ListNodesResponseBodyResultIpAddress() = default;
};
class ListNodesResponseBodyResultTags : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListNodesResponseBodyResultTags() {}

  explicit ListNodesResponseBodyResultTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["tagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["tagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("tagKey") != m.end() && !m["tagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["tagKey"]));
    }
    if (m.find("tagValue") != m.end() && !m["tagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["tagValue"]));
    }
  }


  virtual ~ListNodesResponseBodyResultTags() = default;
};
class ListNodesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> agentStatus{};
  shared_ptr<string> cloudAssistantStatus{};
  shared_ptr<string> ecsInstanceId{};
  shared_ptr<string> ecsInstanceName{};
  shared_ptr<vector<ListNodesResponseBodyResultIpAddress>> ipAddress{};
  shared_ptr<string> osType{};
  shared_ptr<string> status{};
  shared_ptr<vector<ListNodesResponseBodyResultTags>> tags{};

  ListNodesResponseBodyResult() {}

  explicit ListNodesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentStatus) {
      res["agentStatus"] = boost::any(*agentStatus);
    }
    if (cloudAssistantStatus) {
      res["cloudAssistantStatus"] = boost::any(*cloudAssistantStatus);
    }
    if (ecsInstanceId) {
      res["ecsInstanceId"] = boost::any(*ecsInstanceId);
    }
    if (ecsInstanceName) {
      res["ecsInstanceName"] = boost::any(*ecsInstanceName);
    }
    if (ipAddress) {
      vector<boost::any> temp1;
      for(auto item1:*ipAddress){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["ipAddress"] = boost::any(temp1);
    }
    if (osType) {
      res["osType"] = boost::any(*osType);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("agentStatus") != m.end() && !m["agentStatus"].empty()) {
      agentStatus = make_shared<string>(boost::any_cast<string>(m["agentStatus"]));
    }
    if (m.find("cloudAssistantStatus") != m.end() && !m["cloudAssistantStatus"].empty()) {
      cloudAssistantStatus = make_shared<string>(boost::any_cast<string>(m["cloudAssistantStatus"]));
    }
    if (m.find("ecsInstanceId") != m.end() && !m["ecsInstanceId"].empty()) {
      ecsInstanceId = make_shared<string>(boost::any_cast<string>(m["ecsInstanceId"]));
    }
    if (m.find("ecsInstanceName") != m.end() && !m["ecsInstanceName"].empty()) {
      ecsInstanceName = make_shared<string>(boost::any_cast<string>(m["ecsInstanceName"]));
    }
    if (m.find("ipAddress") != m.end() && !m["ipAddress"].empty()) {
      if (typeid(vector<boost::any>) == m["ipAddress"].type()) {
        vector<ListNodesResponseBodyResultIpAddress> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["ipAddress"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesResponseBodyResultIpAddress model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        ipAddress = make_shared<vector<ListNodesResponseBodyResultIpAddress>>(expect1);
      }
    }
    if (m.find("osType") != m.end() && !m["osType"].empty()) {
      osType = make_shared<string>(boost::any_cast<string>(m["osType"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("tags") != m.end() && !m["tags"].empty()) {
      if (typeid(vector<boost::any>) == m["tags"].type()) {
        vector<ListNodesResponseBodyResultTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesResponseBodyResultTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<ListNodesResponseBodyResultTags>>(expect1);
      }
    }
  }


  virtual ~ListNodesResponseBodyResult() = default;
};
class ListNodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListNodesResponseBodyHeaders> headers{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListNodesResponseBodyResult>> result{};

  ListNodesResponseBody() {}

  explicit ListNodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["Headers"] = headers ? boost::any(headers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      if (typeid(map<string, boost::any>) == m["Headers"].type()) {
        ListNodesResponseBodyHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Headers"]));
        headers = make_shared<ListNodesResponseBodyHeaders>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListNodesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListNodesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListNodesResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListNodesResponseBody() = default;
};
class ListNodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListNodesResponseBody> body{};

  ListNodesResponse() {}

  explicit ListNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListNodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListNodesResponseBody>(model1);
      }
    }
  }


  virtual ~ListNodesResponse() = default;
};
class ListPipelineRequest : public Darabonba::Model {
public:
  shared_ptr<long> page{};
  shared_ptr<string> pipelineId{};
  shared_ptr<long> size{};

  ListPipelineRequest() {}

  explicit ListPipelineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (pipelineId) {
      res["pipelineId"] = boost::any(*pipelineId);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("pipelineId") != m.end() && !m["pipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["pipelineId"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
  }


  virtual ~ListPipelineRequest() = default;
};
class ListPipelineResponseBodyHeaders : public Darabonba::Model {
public:
  shared_ptr<long> xTotalCount{};

  ListPipelineResponseBodyHeaders() {}

  explicit ListPipelineResponseBodyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (xTotalCount) {
      res["X-Total-Count"] = boost::any(*xTotalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("X-Total-Count") != m.end() && !m["X-Total-Count"].empty()) {
      xTotalCount = make_shared<long>(boost::any_cast<long>(m["X-Total-Count"]));
    }
  }


  virtual ~ListPipelineResponseBodyHeaders() = default;
};
class ListPipelineResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> gmtCreatedTime{};
  shared_ptr<string> gmtUpdateTime{};
  shared_ptr<string> pipelineId{};
  shared_ptr<string> pipelineStatus{};

  ListPipelineResponseBodyResult() {}

  explicit ListPipelineResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (gmtCreatedTime) {
      res["gmtCreatedTime"] = boost::any(*gmtCreatedTime);
    }
    if (gmtUpdateTime) {
      res["gmtUpdateTime"] = boost::any(*gmtUpdateTime);
    }
    if (pipelineId) {
      res["pipelineId"] = boost::any(*pipelineId);
    }
    if (pipelineStatus) {
      res["pipelineStatus"] = boost::any(*pipelineStatus);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("gmtCreatedTime") != m.end() && !m["gmtCreatedTime"].empty()) {
      gmtCreatedTime = make_shared<string>(boost::any_cast<string>(m["gmtCreatedTime"]));
    }
    if (m.find("gmtUpdateTime") != m.end() && !m["gmtUpdateTime"].empty()) {
      gmtUpdateTime = make_shared<string>(boost::any_cast<string>(m["gmtUpdateTime"]));
    }
    if (m.find("pipelineId") != m.end() && !m["pipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["pipelineId"]));
    }
    if (m.find("pipelineStatus") != m.end() && !m["pipelineStatus"].empty()) {
      pipelineStatus = make_shared<string>(boost::any_cast<string>(m["pipelineStatus"]));
    }
  }


  virtual ~ListPipelineResponseBodyResult() = default;
};
class ListPipelineResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListPipelineResponseBodyHeaders> headers{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListPipelineResponseBodyResult>> result{};

  ListPipelineResponseBody() {}

  explicit ListPipelineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["Headers"] = headers ? boost::any(headers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      if (typeid(map<string, boost::any>) == m["Headers"].type()) {
        ListPipelineResponseBodyHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Headers"]));
        headers = make_shared<ListPipelineResponseBodyHeaders>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListPipelineResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPipelineResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListPipelineResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListPipelineResponseBody() = default;
};
class ListPipelineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPipelineResponseBody> body{};

  ListPipelineResponse() {}

  explicit ListPipelineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPipelineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPipelineResponseBody>(model1);
      }
    }
  }


  virtual ~ListPipelineResponse() = default;
};
class ListPipelineIdsRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};

  ListPipelineIdsRequest() {}

  explicit ListPipelineIdsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~ListPipelineIdsRequest() = default;
};
class ListPipelineIdsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> available{};
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> pipelineId{};

  ListPipelineIdsResponseBodyResult() {}

  explicit ListPipelineIdsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (available) {
      res["available"] = boost::any(*available);
    }
    if (code) {
      res["code"] = boost::any(*code);
    }
    if (message) {
      res["message"] = boost::any(*message);
    }
    if (pipelineId) {
      res["pipelineId"] = boost::any(*pipelineId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("available") != m.end() && !m["available"].empty()) {
      available = make_shared<bool>(boost::any_cast<bool>(m["available"]));
    }
    if (m.find("code") != m.end() && !m["code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["code"]));
    }
    if (m.find("message") != m.end() && !m["message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["message"]));
    }
    if (m.find("pipelineId") != m.end() && !m["pipelineId"].empty()) {
      pipelineId = make_shared<string>(boost::any_cast<string>(m["pipelineId"]));
    }
  }


  virtual ~ListPipelineIdsResponseBodyResult() = default;
};
class ListPipelineIdsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListPipelineIdsResponseBodyResult>> result{};

  ListPipelineIdsResponseBody() {}

  explicit ListPipelineIdsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListPipelineIdsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPipelineIdsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListPipelineIdsResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListPipelineIdsResponseBody() = default;
};
class ListPipelineIdsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPipelineIdsResponseBody> body{};

  ListPipelineIdsResponse() {}

  explicit ListPipelineIdsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPipelineIdsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPipelineIdsResponseBody>(model1);
      }
    }
  }


  virtual ~ListPipelineIdsResponse() = default;
};
class ListPluginsRequest : public Darabonba::Model {
public:
  shared_ptr<string> name{};
  shared_ptr<string> page{};
  shared_ptr<long> size{};
  shared_ptr<string> source{};

  ListPluginsRequest() {}

  explicit ListPluginsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<string>(boost::any_cast<string>(m["page"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
  }


  virtual ~ListPluginsRequest() = default;
};
class ListPluginsResponseBodyHeaders : public Darabonba::Model {
public:
  shared_ptr<long> xTotalCount{};

  ListPluginsResponseBodyHeaders() {}

  explicit ListPluginsResponseBodyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (xTotalCount) {
      res["X-Total-Count"] = boost::any(*xTotalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("X-Total-Count") != m.end() && !m["X-Total-Count"].empty()) {
      xTotalCount = make_shared<long>(boost::any_cast<long>(m["X-Total-Count"]));
    }
  }


  virtual ~ListPluginsResponseBodyHeaders() = default;
};
class ListPluginsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> name{};
  shared_ptr<string> source{};
  shared_ptr<string> specificationUrl{};
  shared_ptr<string> state{};

  ListPluginsResponseBodyResult() {}

  explicit ListPluginsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (source) {
      res["source"] = boost::any(*source);
    }
    if (specificationUrl) {
      res["specificationUrl"] = boost::any(*specificationUrl);
    }
    if (state) {
      res["state"] = boost::any(*state);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("source") != m.end() && !m["source"].empty()) {
      source = make_shared<string>(boost::any_cast<string>(m["source"]));
    }
    if (m.find("specificationUrl") != m.end() && !m["specificationUrl"].empty()) {
      specificationUrl = make_shared<string>(boost::any_cast<string>(m["specificationUrl"]));
    }
    if (m.find("state") != m.end() && !m["state"].empty()) {
      state = make_shared<string>(boost::any_cast<string>(m["state"]));
    }
  }


  virtual ~ListPluginsResponseBodyResult() = default;
};
class ListPluginsResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListPluginsResponseBodyHeaders> headers{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListPluginsResponseBodyResult>> result{};

  ListPluginsResponseBody() {}

  explicit ListPluginsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["Headers"] = headers ? boost::any(headers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      if (typeid(map<string, boost::any>) == m["Headers"].type()) {
        ListPluginsResponseBodyHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Headers"]));
        headers = make_shared<ListPluginsResponseBodyHeaders>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListPluginsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListPluginsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListPluginsResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListPluginsResponseBody() = default;
};
class ListPluginsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListPluginsResponseBody> body{};

  ListPluginsResponse() {}

  explicit ListPluginsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListPluginsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListPluginsResponseBody>(model1);
      }
    }
  }


  virtual ~ListPluginsResponse() = default;
};
class ListSearchLogRequest : public Darabonba::Model {
public:
  shared_ptr<long> beginTime{};
  shared_ptr<long> endTime{};
  shared_ptr<long> page{};
  shared_ptr<string> query{};
  shared_ptr<long> size{};
  shared_ptr<string> type{};

  ListSearchLogRequest() {}

  explicit ListSearchLogRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (beginTime) {
      res["beginTime"] = boost::any(*beginTime);
    }
    if (endTime) {
      res["endTime"] = boost::any(*endTime);
    }
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (query) {
      res["query"] = boost::any(*query);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("beginTime") != m.end() && !m["beginTime"].empty()) {
      beginTime = make_shared<long>(boost::any_cast<long>(m["beginTime"]));
    }
    if (m.find("endTime") != m.end() && !m["endTime"].empty()) {
      endTime = make_shared<long>(boost::any_cast<long>(m["endTime"]));
    }
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("query") != m.end() && !m["query"].empty()) {
      query = make_shared<string>(boost::any_cast<string>(m["query"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~ListSearchLogRequest() = default;
};
class ListSearchLogResponseBodyHeaders : public Darabonba::Model {
public:
  shared_ptr<long> xTotalCount{};

  ListSearchLogResponseBodyHeaders() {}

  explicit ListSearchLogResponseBodyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (xTotalCount) {
      res["X-Total-Count"] = boost::any(*xTotalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("X-Total-Count") != m.end() && !m["X-Total-Count"].empty()) {
      xTotalCount = make_shared<long>(boost::any_cast<long>(m["X-Total-Count"]));
    }
  }


  virtual ~ListSearchLogResponseBodyHeaders() = default;
};
class ListSearchLogResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<map<string, boost::any>> contentCollection{};
  shared_ptr<string> host{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> level{};
  shared_ptr<long> timestamp{};

  ListSearchLogResponseBodyResult() {}

  explicit ListSearchLogResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (contentCollection) {
      res["contentCollection"] = boost::any(*contentCollection);
    }
    if (host) {
      res["host"] = boost::any(*host);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (level) {
      res["level"] = boost::any(*level);
    }
    if (timestamp) {
      res["timestamp"] = boost::any(*timestamp);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("contentCollection") != m.end() && !m["contentCollection"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["contentCollection"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      contentCollection = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("host") != m.end() && !m["host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["host"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("level") != m.end() && !m["level"].empty()) {
      level = make_shared<string>(boost::any_cast<string>(m["level"]));
    }
    if (m.find("timestamp") != m.end() && !m["timestamp"].empty()) {
      timestamp = make_shared<long>(boost::any_cast<long>(m["timestamp"]));
    }
  }


  virtual ~ListSearchLogResponseBodyResult() = default;
};
class ListSearchLogResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListSearchLogResponseBodyHeaders> headers{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSearchLogResponseBodyResult>> result{};

  ListSearchLogResponseBody() {}

  explicit ListSearchLogResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["Headers"] = headers ? boost::any(headers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      if (typeid(map<string, boost::any>) == m["Headers"].type()) {
        ListSearchLogResponseBodyHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Headers"]));
        headers = make_shared<ListSearchLogResponseBodyHeaders>(model1);
      }
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListSearchLogResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSearchLogResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListSearchLogResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListSearchLogResponseBody() = default;
};
class ListSearchLogResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSearchLogResponseBody> body{};

  ListSearchLogResponse() {}

  explicit ListSearchLogResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSearchLogResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSearchLogResponseBody>(model1);
      }
    }
  }


  virtual ~ListSearchLogResponse() = default;
};
class ListShardRecoveriesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> activeOnly{};

  ListShardRecoveriesRequest() {}

  explicit ListShardRecoveriesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (activeOnly) {
      res["activeOnly"] = boost::any(*activeOnly);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("activeOnly") != m.end() && !m["activeOnly"].empty()) {
      activeOnly = make_shared<bool>(boost::any_cast<bool>(m["activeOnly"]));
    }
  }


  virtual ~ListShardRecoveriesRequest() = default;
};
class ListShardRecoveriesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> bytesPercent{};
  shared_ptr<long> bytesTotal{};
  shared_ptr<string> filesPercent{};
  shared_ptr<long> filesTotal{};
  shared_ptr<string> index{};
  shared_ptr<string> sourceHost{};
  shared_ptr<string> sourceNode{};
  shared_ptr<string> stage{};
  shared_ptr<string> targetHost{};
  shared_ptr<string> targetNode{};
  shared_ptr<long> translogOps{};
  shared_ptr<string> translogOpsPercent{};

  ListShardRecoveriesResponseBodyResult() {}

  explicit ListShardRecoveriesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (bytesPercent) {
      res["bytesPercent"] = boost::any(*bytesPercent);
    }
    if (bytesTotal) {
      res["bytesTotal"] = boost::any(*bytesTotal);
    }
    if (filesPercent) {
      res["filesPercent"] = boost::any(*filesPercent);
    }
    if (filesTotal) {
      res["filesTotal"] = boost::any(*filesTotal);
    }
    if (index) {
      res["index"] = boost::any(*index);
    }
    if (sourceHost) {
      res["sourceHost"] = boost::any(*sourceHost);
    }
    if (sourceNode) {
      res["sourceNode"] = boost::any(*sourceNode);
    }
    if (stage) {
      res["stage"] = boost::any(*stage);
    }
    if (targetHost) {
      res["targetHost"] = boost::any(*targetHost);
    }
    if (targetNode) {
      res["targetNode"] = boost::any(*targetNode);
    }
    if (translogOps) {
      res["translogOps"] = boost::any(*translogOps);
    }
    if (translogOpsPercent) {
      res["translogOpsPercent"] = boost::any(*translogOpsPercent);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("bytesPercent") != m.end() && !m["bytesPercent"].empty()) {
      bytesPercent = make_shared<string>(boost::any_cast<string>(m["bytesPercent"]));
    }
    if (m.find("bytesTotal") != m.end() && !m["bytesTotal"].empty()) {
      bytesTotal = make_shared<long>(boost::any_cast<long>(m["bytesTotal"]));
    }
    if (m.find("filesPercent") != m.end() && !m["filesPercent"].empty()) {
      filesPercent = make_shared<string>(boost::any_cast<string>(m["filesPercent"]));
    }
    if (m.find("filesTotal") != m.end() && !m["filesTotal"].empty()) {
      filesTotal = make_shared<long>(boost::any_cast<long>(m["filesTotal"]));
    }
    if (m.find("index") != m.end() && !m["index"].empty()) {
      index = make_shared<string>(boost::any_cast<string>(m["index"]));
    }
    if (m.find("sourceHost") != m.end() && !m["sourceHost"].empty()) {
      sourceHost = make_shared<string>(boost::any_cast<string>(m["sourceHost"]));
    }
    if (m.find("sourceNode") != m.end() && !m["sourceNode"].empty()) {
      sourceNode = make_shared<string>(boost::any_cast<string>(m["sourceNode"]));
    }
    if (m.find("stage") != m.end() && !m["stage"].empty()) {
      stage = make_shared<string>(boost::any_cast<string>(m["stage"]));
    }
    if (m.find("targetHost") != m.end() && !m["targetHost"].empty()) {
      targetHost = make_shared<string>(boost::any_cast<string>(m["targetHost"]));
    }
    if (m.find("targetNode") != m.end() && !m["targetNode"].empty()) {
      targetNode = make_shared<string>(boost::any_cast<string>(m["targetNode"]));
    }
    if (m.find("translogOps") != m.end() && !m["translogOps"].empty()) {
      translogOps = make_shared<long>(boost::any_cast<long>(m["translogOps"]));
    }
    if (m.find("translogOpsPercent") != m.end() && !m["translogOpsPercent"].empty()) {
      translogOpsPercent = make_shared<string>(boost::any_cast<string>(m["translogOpsPercent"]));
    }
  }


  virtual ~ListShardRecoveriesResponseBodyResult() = default;
};
class ListShardRecoveriesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListShardRecoveriesResponseBodyResult>> result{};

  ListShardRecoveriesResponseBody() {}

  explicit ListShardRecoveriesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListShardRecoveriesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListShardRecoveriesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListShardRecoveriesResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListShardRecoveriesResponseBody() = default;
};
class ListShardRecoveriesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListShardRecoveriesResponseBody> body{};

  ListShardRecoveriesResponse() {}

  explicit ListShardRecoveriesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListShardRecoveriesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListShardRecoveriesResponseBody>(model1);
      }
    }
  }


  virtual ~ListShardRecoveriesResponse() = default;
};
class ListSnapshotReposByInstanceIdResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};
  shared_ptr<string> repoPath{};
  shared_ptr<string> snapWarehouse{};
  shared_ptr<string> status{};

  ListSnapshotReposByInstanceIdResponseBodyResult() {}

  explicit ListSnapshotReposByInstanceIdResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (repoPath) {
      res["repoPath"] = boost::any(*repoPath);
    }
    if (snapWarehouse) {
      res["snapWarehouse"] = boost::any(*snapWarehouse);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("repoPath") != m.end() && !m["repoPath"].empty()) {
      repoPath = make_shared<string>(boost::any_cast<string>(m["repoPath"]));
    }
    if (m.find("snapWarehouse") != m.end() && !m["snapWarehouse"].empty()) {
      snapWarehouse = make_shared<string>(boost::any_cast<string>(m["snapWarehouse"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~ListSnapshotReposByInstanceIdResponseBodyResult() = default;
};
class ListSnapshotReposByInstanceIdResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListSnapshotReposByInstanceIdResponseBodyResult>> result{};

  ListSnapshotReposByInstanceIdResponseBody() {}

  explicit ListSnapshotReposByInstanceIdResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListSnapshotReposByInstanceIdResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListSnapshotReposByInstanceIdResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListSnapshotReposByInstanceIdResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListSnapshotReposByInstanceIdResponseBody() = default;
};
class ListSnapshotReposByInstanceIdResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListSnapshotReposByInstanceIdResponseBody> body{};

  ListSnapshotReposByInstanceIdResponse() {}

  explicit ListSnapshotReposByInstanceIdResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListSnapshotReposByInstanceIdResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListSnapshotReposByInstanceIdResponseBody>(model1);
      }
    }
  }


  virtual ~ListSnapshotReposByInstanceIdResponse() = default;
};
class ListTagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<string> nextToken{};
  shared_ptr<long> page{};
  shared_ptr<string> resourceIds{};
  shared_ptr<string> resourceType{};
  shared_ptr<long> size{};
  shared_ptr<string> tags{};

  ListTagResourcesRequest() {}

  explicit ListTagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nextToken) {
      res["NextToken"] = boost::any(*nextToken);
    }
    if (page) {
      res["Page"] = boost::any(*page);
    }
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (size) {
      res["Size"] = boost::any(*size);
    }
    if (tags) {
      res["Tags"] = boost::any(*tags);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("NextToken") != m.end() && !m["NextToken"].empty()) {
      nextToken = make_shared<string>(boost::any_cast<string>(m["NextToken"]));
    }
    if (m.find("Page") != m.end() && !m["Page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["Page"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      resourceIds = make_shared<string>(boost::any_cast<string>(m["ResourceIds"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Size") != m.end() && !m["Size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["Size"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      tags = make_shared<string>(boost::any_cast<string>(m["Tags"]));
    }
  }


  virtual ~ListTagResourcesRequest() = default;
};
class ListTagResourcesResponseBodyHeaders : public Darabonba::Model {
public:
  shared_ptr<long> xTotalCount{};

  ListTagResourcesResponseBodyHeaders() {}

  explicit ListTagResourcesResponseBodyHeaders(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (xTotalCount) {
      res["X-Total-Count"] = boost::any(*xTotalCount);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("X-Total-Count") != m.end() && !m["X-Total-Count"].empty()) {
      xTotalCount = make_shared<long>(boost::any_cast<long>(m["X-Total-Count"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyHeaders() = default;
};
class ListTagResourcesResponseBodyTagResourcesTagResource : public Darabonba::Model {
public:
  shared_ptr<string> resourceId{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListTagResourcesResponseBodyTagResourcesTagResource() {}

  explicit ListTagResourcesResponseBodyTagResourcesTagResource(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceId) {
      res["ResourceId"] = boost::any(*resourceId);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceId") != m.end() && !m["ResourceId"].empty()) {
      resourceId = make_shared<string>(boost::any_cast<string>(m["ResourceId"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResourcesTagResource() = default;
};
class ListTagResourcesResponseBodyTagResources : public Darabonba::Model {
public:
  shared_ptr<vector<ListTagResourcesResponseBodyTagResourcesTagResource>> tagResource{};

  ListTagResourcesResponseBodyTagResources() {}

  explicit ListTagResourcesResponseBodyTagResources(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagResource) {
      vector<boost::any> temp1;
      for(auto item1:*tagResource){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["TagResource"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagResource") != m.end() && !m["TagResource"].empty()) {
      if (typeid(vector<boost::any>) == m["TagResource"].type()) {
        vector<ListTagResourcesResponseBodyTagResourcesTagResource> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["TagResource"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagResourcesResponseBodyTagResourcesTagResource model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tagResource = make_shared<vector<ListTagResourcesResponseBodyTagResourcesTagResource>>(expect1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBodyTagResources() = default;
};
class ListTagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<ListTagResourcesResponseBodyHeaders> headers{};
  shared_ptr<long> pageSize{};
  shared_ptr<string> requestId{};
  shared_ptr<ListTagResourcesResponseBodyTagResources> tagResources{};

  ListTagResourcesResponseBody() {}

  explicit ListTagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["Headers"] = headers ? boost::any(headers->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (pageSize) {
      res["PageSize"] = boost::any(*pageSize);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (tagResources) {
      res["TagResources"] = tagResources ? boost::any(tagResources->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      if (typeid(map<string, boost::any>) == m["Headers"].type()) {
        ListTagResourcesResponseBodyHeaders model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Headers"]));
        headers = make_shared<ListTagResourcesResponseBodyHeaders>(model1);
      }
    }
    if (m.find("PageSize") != m.end() && !m["PageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["PageSize"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("TagResources") != m.end() && !m["TagResources"].empty()) {
      if (typeid(map<string, boost::any>) == m["TagResources"].type()) {
        ListTagResourcesResponseBodyTagResources model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["TagResources"]));
        tagResources = make_shared<ListTagResourcesResponseBodyTagResources>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponseBody() = default;
};
class ListTagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagResourcesResponseBody> body{};

  ListTagResourcesResponse() {}

  explicit ListTagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagResourcesResponse() = default;
};
class ListTagsRequest : public Darabonba::Model {
public:
  shared_ptr<long> pageSize{};
  shared_ptr<string> resourceType{};

  ListTagsRequest() {}

  explicit ListTagsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (pageSize) {
      res["pageSize"] = boost::any(*pageSize);
    }
    if (resourceType) {
      res["resourceType"] = boost::any(*resourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("pageSize") != m.end() && !m["pageSize"].empty()) {
      pageSize = make_shared<long>(boost::any_cast<long>(m["pageSize"]));
    }
    if (m.find("resourceType") != m.end() && !m["resourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["resourceType"]));
    }
  }


  virtual ~ListTagsRequest() = default;
};
class ListTagsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> tagKey{};
  shared_ptr<string> tagValue{};

  ListTagsResponseBodyResult() {}

  explicit ListTagsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (tagKey) {
      res["TagKey"] = boost::any(*tagKey);
    }
    if (tagValue) {
      res["TagValue"] = boost::any(*tagValue);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("TagKey") != m.end() && !m["TagKey"].empty()) {
      tagKey = make_shared<string>(boost::any_cast<string>(m["TagKey"]));
    }
    if (m.find("TagValue") != m.end() && !m["TagValue"].empty()) {
      tagValue = make_shared<string>(boost::any_cast<string>(m["TagValue"]));
    }
  }


  virtual ~ListTagsResponseBodyResult() = default;
};
class ListTagsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListTagsResponseBodyResult>> result{};

  ListTagsResponseBody() {}

  explicit ListTagsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListTagsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListTagsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListTagsResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListTagsResponseBody() = default;
};
class ListTagsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListTagsResponseBody> body{};

  ListTagsResponse() {}

  explicit ListTagsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListTagsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListTagsResponseBody>(model1);
      }
    }
  }


  virtual ~ListTagsResponse() = default;
};
class ListVpcEndpointsRequest : public Darabonba::Model {
public:
  shared_ptr<long> page{};
  shared_ptr<long> size{};

  ListVpcEndpointsRequest() {}

  explicit ListVpcEndpointsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (page) {
      res["page"] = boost::any(*page);
    }
    if (size) {
      res["size"] = boost::any(*size);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("page") != m.end() && !m["page"].empty()) {
      page = make_shared<long>(boost::any_cast<long>(m["page"]));
    }
    if (m.find("size") != m.end() && !m["size"].empty()) {
      size = make_shared<long>(boost::any_cast<long>(m["size"]));
    }
  }


  virtual ~ListVpcEndpointsRequest() = default;
};
class ListVpcEndpointsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> connectionStatus{};
  shared_ptr<string> createTime{};
  shared_ptr<string> endpointBusinessStatus{};
  shared_ptr<string> endpointDomain{};
  shared_ptr<string> endpointId{};
  shared_ptr<string> endpointName{};
  shared_ptr<string> endpointStatus{};
  shared_ptr<string> serviceId{};
  shared_ptr<string> serviceName{};

  ListVpcEndpointsResponseBodyResult() {}

  explicit ListVpcEndpointsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (connectionStatus) {
      res["connectionStatus"] = boost::any(*connectionStatus);
    }
    if (createTime) {
      res["createTime"] = boost::any(*createTime);
    }
    if (endpointBusinessStatus) {
      res["endpointBusinessStatus"] = boost::any(*endpointBusinessStatus);
    }
    if (endpointDomain) {
      res["endpointDomain"] = boost::any(*endpointDomain);
    }
    if (endpointId) {
      res["endpointId"] = boost::any(*endpointId);
    }
    if (endpointName) {
      res["endpointName"] = boost::any(*endpointName);
    }
    if (endpointStatus) {
      res["endpointStatus"] = boost::any(*endpointStatus);
    }
    if (serviceId) {
      res["serviceId"] = boost::any(*serviceId);
    }
    if (serviceName) {
      res["serviceName"] = boost::any(*serviceName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("connectionStatus") != m.end() && !m["connectionStatus"].empty()) {
      connectionStatus = make_shared<string>(boost::any_cast<string>(m["connectionStatus"]));
    }
    if (m.find("createTime") != m.end() && !m["createTime"].empty()) {
      createTime = make_shared<string>(boost::any_cast<string>(m["createTime"]));
    }
    if (m.find("endpointBusinessStatus") != m.end() && !m["endpointBusinessStatus"].empty()) {
      endpointBusinessStatus = make_shared<string>(boost::any_cast<string>(m["endpointBusinessStatus"]));
    }
    if (m.find("endpointDomain") != m.end() && !m["endpointDomain"].empty()) {
      endpointDomain = make_shared<string>(boost::any_cast<string>(m["endpointDomain"]));
    }
    if (m.find("endpointId") != m.end() && !m["endpointId"].empty()) {
      endpointId = make_shared<string>(boost::any_cast<string>(m["endpointId"]));
    }
    if (m.find("endpointName") != m.end() && !m["endpointName"].empty()) {
      endpointName = make_shared<string>(boost::any_cast<string>(m["endpointName"]));
    }
    if (m.find("endpointStatus") != m.end() && !m["endpointStatus"].empty()) {
      endpointStatus = make_shared<string>(boost::any_cast<string>(m["endpointStatus"]));
    }
    if (m.find("serviceId") != m.end() && !m["serviceId"].empty()) {
      serviceId = make_shared<string>(boost::any_cast<string>(m["serviceId"]));
    }
    if (m.find("serviceName") != m.end() && !m["serviceName"].empty()) {
      serviceName = make_shared<string>(boost::any_cast<string>(m["serviceName"]));
    }
  }


  virtual ~ListVpcEndpointsResponseBodyResult() = default;
};
class ListVpcEndpointsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<ListVpcEndpointsResponseBodyResult>> result{};

  ListVpcEndpointsResponseBody() {}

  explicit ListVpcEndpointsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<ListVpcEndpointsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ListVpcEndpointsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<ListVpcEndpointsResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~ListVpcEndpointsResponseBody() = default;
};
class ListVpcEndpointsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ListVpcEndpointsResponseBody> body{};

  ListVpcEndpointsResponse() {}

  explicit ListVpcEndpointsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ListVpcEndpointsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ListVpcEndpointsResponseBody>(model1);
      }
    }
  }


  virtual ~ListVpcEndpointsResponse() = default;
};
class MigrateToOtherZoneRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<bool> dryRun{};

  MigrateToOtherZoneRequest() {}

  explicit MigrateToOtherZoneRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (dryRun) {
      res["dryRun"] = boost::any(*dryRun);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("dryRun") != m.end() && !m["dryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["dryRun"]));
    }
  }


  virtual ~MigrateToOtherZoneRequest() = default;
};
class MigrateToOtherZoneResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  MigrateToOtherZoneResponseBody() {}

  explicit MigrateToOtherZoneResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~MigrateToOtherZoneResponseBody() = default;
};
class MigrateToOtherZoneResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MigrateToOtherZoneResponseBody> body{};

  MigrateToOtherZoneResponse() {}

  explicit MigrateToOtherZoneResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MigrateToOtherZoneResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MigrateToOtherZoneResponseBody>(model1);
      }
    }
  }


  virtual ~MigrateToOtherZoneResponse() = default;
};
class ModifyDeployMachineRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> body{};

  ModifyDeployMachineRequest() {}

  explicit ModifyDeployMachineRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~ModifyDeployMachineRequest() = default;
};
class ModifyDeployMachineResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  ModifyDeployMachineResponseBody() {}

  explicit ModifyDeployMachineResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~ModifyDeployMachineResponseBody() = default;
};
class ModifyDeployMachineResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyDeployMachineResponseBody> body{};

  ModifyDeployMachineResponse() {}

  explicit ModifyDeployMachineResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyDeployMachineResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyDeployMachineResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyDeployMachineResponse() = default;
};
class ModifyElastictaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};

  ModifyElastictaskRequest() {}

  explicit ModifyElastictaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~ModifyElastictaskRequest() = default;
};
class ModifyElastictaskResponseBodyResultElasticExpansionTask : public Darabonba::Model {
public:
  shared_ptr<string> cronExpression{};
  shared_ptr<long> elasticNodeCount{};
  shared_ptr<long> replicaCount{};
  shared_ptr<vector<string>> targetIndices{};
  shared_ptr<string> triggerType{};

  ModifyElastictaskResponseBodyResultElasticExpansionTask() {}

  explicit ModifyElastictaskResponseBodyResultElasticExpansionTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cronExpression) {
      res["cronExpression"] = boost::any(*cronExpression);
    }
    if (elasticNodeCount) {
      res["elasticNodeCount"] = boost::any(*elasticNodeCount);
    }
    if (replicaCount) {
      res["replicaCount"] = boost::any(*replicaCount);
    }
    if (targetIndices) {
      res["targetIndices"] = boost::any(*targetIndices);
    }
    if (triggerType) {
      res["triggerType"] = boost::any(*triggerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cronExpression") != m.end() && !m["cronExpression"].empty()) {
      cronExpression = make_shared<string>(boost::any_cast<string>(m["cronExpression"]));
    }
    if (m.find("elasticNodeCount") != m.end() && !m["elasticNodeCount"].empty()) {
      elasticNodeCount = make_shared<long>(boost::any_cast<long>(m["elasticNodeCount"]));
    }
    if (m.find("replicaCount") != m.end() && !m["replicaCount"].empty()) {
      replicaCount = make_shared<long>(boost::any_cast<long>(m["replicaCount"]));
    }
    if (m.find("targetIndices") != m.end() && !m["targetIndices"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["targetIndices"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["targetIndices"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      targetIndices = make_shared<vector<string>>(toVec1);
    }
    if (m.find("triggerType") != m.end() && !m["triggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["triggerType"]));
    }
  }


  virtual ~ModifyElastictaskResponseBodyResultElasticExpansionTask() = default;
};
class ModifyElastictaskResponseBodyResultElasticShrinkTask : public Darabonba::Model {
public:
  shared_ptr<string> cronExpression{};
  shared_ptr<long> elasticNodeCount{};
  shared_ptr<long> replicaCount{};
  shared_ptr<vector<string>> targetIndices{};
  shared_ptr<string> triggerType{};

  ModifyElastictaskResponseBodyResultElasticShrinkTask() {}

  explicit ModifyElastictaskResponseBodyResultElasticShrinkTask(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (cronExpression) {
      res["cronExpression"] = boost::any(*cronExpression);
    }
    if (elasticNodeCount) {
      res["elasticNodeCount"] = boost::any(*elasticNodeCount);
    }
    if (replicaCount) {
      res["replicaCount"] = boost::any(*replicaCount);
    }
    if (targetIndices) {
      res["targetIndices"] = boost::any(*targetIndices);
    }
    if (triggerType) {
      res["triggerType"] = boost::any(*triggerType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("cronExpression") != m.end() && !m["cronExpression"].empty()) {
      cronExpression = make_shared<string>(boost::any_cast<string>(m["cronExpression"]));
    }
    if (m.find("elasticNodeCount") != m.end() && !m["elasticNodeCount"].empty()) {
      elasticNodeCount = make_shared<long>(boost::any_cast<long>(m["elasticNodeCount"]));
    }
    if (m.find("replicaCount") != m.end() && !m["replicaCount"].empty()) {
      replicaCount = make_shared<long>(boost::any_cast<long>(m["replicaCount"]));
    }
    if (m.find("targetIndices") != m.end() && !m["targetIndices"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["targetIndices"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["targetIndices"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      targetIndices = make_shared<vector<string>>(toVec1);
    }
    if (m.find("triggerType") != m.end() && !m["triggerType"].empty()) {
      triggerType = make_shared<string>(boost::any_cast<string>(m["triggerType"]));
    }
  }


  virtual ~ModifyElastictaskResponseBodyResultElasticShrinkTask() = default;
};
class ModifyElastictaskResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<ModifyElastictaskResponseBodyResultElasticExpansionTask> elasticExpansionTask{};
  shared_ptr<ModifyElastictaskResponseBodyResultElasticShrinkTask> elasticShrinkTask{};

  ModifyElastictaskResponseBodyResult() {}

  explicit ModifyElastictaskResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (elasticExpansionTask) {
      res["elasticExpansionTask"] = elasticExpansionTask ? boost::any(elasticExpansionTask->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (elasticShrinkTask) {
      res["elasticShrinkTask"] = elasticShrinkTask ? boost::any(elasticShrinkTask->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("elasticExpansionTask") != m.end() && !m["elasticExpansionTask"].empty()) {
      if (typeid(map<string, boost::any>) == m["elasticExpansionTask"].type()) {
        ModifyElastictaskResponseBodyResultElasticExpansionTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["elasticExpansionTask"]));
        elasticExpansionTask = make_shared<ModifyElastictaskResponseBodyResultElasticExpansionTask>(model1);
      }
    }
    if (m.find("elasticShrinkTask") != m.end() && !m["elasticShrinkTask"].empty()) {
      if (typeid(map<string, boost::any>) == m["elasticShrinkTask"].type()) {
        ModifyElastictaskResponseBodyResultElasticShrinkTask model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["elasticShrinkTask"]));
        elasticShrinkTask = make_shared<ModifyElastictaskResponseBodyResultElasticShrinkTask>(model1);
      }
    }
  }


  virtual ~ModifyElastictaskResponseBodyResult() = default;
};
class ModifyElastictaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<ModifyElastictaskResponseBodyResult> result{};

  ModifyElastictaskResponseBody() {}

  explicit ModifyElastictaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        ModifyElastictaskResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<ModifyElastictaskResponseBodyResult>(model1);
      }
    }
  }


  virtual ~ModifyElastictaskResponseBody() = default;
};
class ModifyElastictaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyElastictaskResponseBody> body{};

  ModifyElastictaskResponse() {}

  explicit ModifyElastictaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyElastictaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyElastictaskResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyElastictaskResponse() = default;
};
class ModifyInstanceMaintainTimeRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> body{};

  ModifyInstanceMaintainTimeRequest() {}

  explicit ModifyInstanceMaintainTimeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~ModifyInstanceMaintainTimeRequest() = default;
};
class ModifyInstanceMaintainTimeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  ModifyInstanceMaintainTimeResponseBody() {}

  explicit ModifyInstanceMaintainTimeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~ModifyInstanceMaintainTimeResponseBody() = default;
};
class ModifyInstanceMaintainTimeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyInstanceMaintainTimeResponseBody> body{};

  ModifyInstanceMaintainTimeResponse() {}

  explicit ModifyInstanceMaintainTimeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyInstanceMaintainTimeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyInstanceMaintainTimeResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyInstanceMaintainTimeResponse() = default;
};
class ModifyWhiteIpsRequestWhiteIpGroup : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<vector<string>> ips{};
  shared_ptr<string> whiteIpType{};

  ModifyWhiteIpsRequestWhiteIpGroup() {}

  explicit ModifyWhiteIpsRequestWhiteIpGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["groupName"] = boost::any(*groupName);
    }
    if (ips) {
      res["ips"] = boost::any(*ips);
    }
    if (whiteIpType) {
      res["whiteIpType"] = boost::any(*whiteIpType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("groupName") != m.end() && !m["groupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["groupName"]));
    }
    if (m.find("ips") != m.end() && !m["ips"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ips"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ips"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ips = make_shared<vector<string>>(toVec1);
    }
    if (m.find("whiteIpType") != m.end() && !m["whiteIpType"].empty()) {
      whiteIpType = make_shared<string>(boost::any_cast<string>(m["whiteIpType"]));
    }
  }


  virtual ~ModifyWhiteIpsRequestWhiteIpGroup() = default;
};
class ModifyWhiteIpsRequest : public Darabonba::Model {
public:
  shared_ptr<string> modifyMode{};
  shared_ptr<string> networkType{};
  shared_ptr<string> nodeType{};
  shared_ptr<ModifyWhiteIpsRequestWhiteIpGroup> whiteIpGroup{};
  shared_ptr<vector<string>> whiteIpList{};
  shared_ptr<string> clientToken{};

  ModifyWhiteIpsRequest() {}

  explicit ModifyWhiteIpsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (modifyMode) {
      res["modifyMode"] = boost::any(*modifyMode);
    }
    if (networkType) {
      res["networkType"] = boost::any(*networkType);
    }
    if (nodeType) {
      res["nodeType"] = boost::any(*nodeType);
    }
    if (whiteIpGroup) {
      res["whiteIpGroup"] = whiteIpGroup ? boost::any(whiteIpGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (whiteIpList) {
      res["whiteIpList"] = boost::any(*whiteIpList);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("modifyMode") != m.end() && !m["modifyMode"].empty()) {
      modifyMode = make_shared<string>(boost::any_cast<string>(m["modifyMode"]));
    }
    if (m.find("networkType") != m.end() && !m["networkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["networkType"]));
    }
    if (m.find("nodeType") != m.end() && !m["nodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["nodeType"]));
    }
    if (m.find("whiteIpGroup") != m.end() && !m["whiteIpGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["whiteIpGroup"].type()) {
        ModifyWhiteIpsRequestWhiteIpGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["whiteIpGroup"]));
        whiteIpGroup = make_shared<ModifyWhiteIpsRequestWhiteIpGroup>(model1);
      }
    }
    if (m.find("whiteIpList") != m.end() && !m["whiteIpList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["whiteIpList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["whiteIpList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      whiteIpList = make_shared<vector<string>>(toVec1);
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~ModifyWhiteIpsRequest() = default;
};
class ModifyWhiteIpsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  ModifyWhiteIpsResponseBody() {}

  explicit ModifyWhiteIpsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~ModifyWhiteIpsResponseBody() = default;
};
class ModifyWhiteIpsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ModifyWhiteIpsResponseBody> body{};

  ModifyWhiteIpsResponse() {}

  explicit ModifyWhiteIpsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ModifyWhiteIpsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ModifyWhiteIpsResponseBody>(model1);
      }
    }
  }


  virtual ~ModifyWhiteIpsResponse() = default;
};
class MoveResourceGroupRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};

  MoveResourceGroupRequest() {}

  explicit MoveResourceGroupRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~MoveResourceGroupRequest() = default;
};
class MoveResourceGroupResponseBodyResultDictList : public Darabonba::Model {
public:
  shared_ptr<long> fileSize{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> type{};

  MoveResourceGroupResponseBodyResultDictList() {}

  explicit MoveResourceGroupResponseBodyResultDictList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileSize) {
      res["fileSize"] = boost::any(*fileSize);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fileSize") != m.end() && !m["fileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["fileSize"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~MoveResourceGroupResponseBodyResultDictList() = default;
};
class MoveResourceGroupResponseBodyResultKibanaConfiguration : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<long> disk{};
  shared_ptr<string> diskType{};
  shared_ptr<string> spec{};

  MoveResourceGroupResponseBodyResultKibanaConfiguration() {}

  explicit MoveResourceGroupResponseBodyResultKibanaConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["amount"]));
    }
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~MoveResourceGroupResponseBodyResultKibanaConfiguration() = default;
};
class MoveResourceGroupResponseBodyResultMasterConfiguration : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<long> disk{};
  shared_ptr<string> diskType{};
  shared_ptr<string> spec{};

  MoveResourceGroupResponseBodyResultMasterConfiguration() {}

  explicit MoveResourceGroupResponseBodyResultMasterConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["amount"]));
    }
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~MoveResourceGroupResponseBodyResultMasterConfiguration() = default;
};
class MoveResourceGroupResponseBodyResultNetworkConfig : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vsArea{};
  shared_ptr<string> vswitchId{};

  MoveResourceGroupResponseBodyResultNetworkConfig() {}

  explicit MoveResourceGroupResponseBodyResultNetworkConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    if (vsArea) {
      res["vsArea"] = boost::any(*vsArea);
    }
    if (vswitchId) {
      res["vswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
    if (m.find("vsArea") != m.end() && !m["vsArea"].empty()) {
      vsArea = make_shared<string>(boost::any_cast<string>(m["vsArea"]));
    }
    if (m.find("vswitchId") != m.end() && !m["vswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["vswitchId"]));
    }
  }


  virtual ~MoveResourceGroupResponseBodyResultNetworkConfig() = default;
};
class MoveResourceGroupResponseBodyResultNodeSpec : public Darabonba::Model {
public:
  shared_ptr<long> disk{};
  shared_ptr<string> diskType{};
  shared_ptr<string> spec{};

  MoveResourceGroupResponseBodyResultNodeSpec() {}

  explicit MoveResourceGroupResponseBodyResultNodeSpec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~MoveResourceGroupResponseBodyResultNodeSpec() = default;
};
class MoveResourceGroupResponseBodyResultSynonymsDicts : public Darabonba::Model {
public:
  shared_ptr<long> fileSize{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> type{};

  MoveResourceGroupResponseBodyResultSynonymsDicts() {}

  explicit MoveResourceGroupResponseBodyResultSynonymsDicts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileSize) {
      res["fileSize"] = boost::any(*fileSize);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fileSize") != m.end() && !m["fileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["fileSize"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~MoveResourceGroupResponseBodyResultSynonymsDicts() = default;
};
class MoveResourceGroupResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> createdAt{};
  shared_ptr<string> description{};
  shared_ptr<vector<MoveResourceGroupResponseBodyResultDictList>> dictList{};
  shared_ptr<string> domain{};
  shared_ptr<string> esVersion{};
  shared_ptr<string> instanceId{};
  shared_ptr<MoveResourceGroupResponseBodyResultKibanaConfiguration> kibanaConfiguration{};
  shared_ptr<string> kibanaDomain{};
  shared_ptr<long> kibanaPort{};
  shared_ptr<MoveResourceGroupResponseBodyResultMasterConfiguration> masterConfiguration{};
  shared_ptr<MoveResourceGroupResponseBodyResultNetworkConfig> networkConfig{};
  shared_ptr<long> nodeAmount{};
  shared_ptr<MoveResourceGroupResponseBodyResultNodeSpec> nodeSpec{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> publicDomain{};
  shared_ptr<long> publicPort{};
  shared_ptr<string> status{};
  shared_ptr<vector<MoveResourceGroupResponseBodyResultSynonymsDicts>> synonymsDicts{};
  shared_ptr<string> updatedAt{};

  MoveResourceGroupResponseBodyResult() {}

  explicit MoveResourceGroupResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (dictList) {
      vector<boost::any> temp1;
      for(auto item1:*dictList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["dictList"] = boost::any(temp1);
    }
    if (domain) {
      res["domain"] = boost::any(*domain);
    }
    if (esVersion) {
      res["esVersion"] = boost::any(*esVersion);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (kibanaConfiguration) {
      res["kibanaConfiguration"] = kibanaConfiguration ? boost::any(kibanaConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (kibanaDomain) {
      res["kibanaDomain"] = boost::any(*kibanaDomain);
    }
    if (kibanaPort) {
      res["kibanaPort"] = boost::any(*kibanaPort);
    }
    if (masterConfiguration) {
      res["masterConfiguration"] = masterConfiguration ? boost::any(masterConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (networkConfig) {
      res["networkConfig"] = networkConfig ? boost::any(networkConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodeAmount) {
      res["nodeAmount"] = boost::any(*nodeAmount);
    }
    if (nodeSpec) {
      res["nodeSpec"] = nodeSpec ? boost::any(nodeSpec->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (paymentType) {
      res["paymentType"] = boost::any(*paymentType);
    }
    if (publicDomain) {
      res["publicDomain"] = boost::any(*publicDomain);
    }
    if (publicPort) {
      res["publicPort"] = boost::any(*publicPort);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (synonymsDicts) {
      vector<boost::any> temp1;
      for(auto item1:*synonymsDicts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["synonymsDicts"] = boost::any(temp1);
    }
    if (updatedAt) {
      res["updatedAt"] = boost::any(*updatedAt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("dictList") != m.end() && !m["dictList"].empty()) {
      if (typeid(vector<boost::any>) == m["dictList"].type()) {
        vector<MoveResourceGroupResponseBodyResultDictList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["dictList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MoveResourceGroupResponseBodyResultDictList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dictList = make_shared<vector<MoveResourceGroupResponseBodyResultDictList>>(expect1);
      }
    }
    if (m.find("domain") != m.end() && !m["domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["domain"]));
    }
    if (m.find("esVersion") != m.end() && !m["esVersion"].empty()) {
      esVersion = make_shared<string>(boost::any_cast<string>(m["esVersion"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("kibanaConfiguration") != m.end() && !m["kibanaConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["kibanaConfiguration"].type()) {
        MoveResourceGroupResponseBodyResultKibanaConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["kibanaConfiguration"]));
        kibanaConfiguration = make_shared<MoveResourceGroupResponseBodyResultKibanaConfiguration>(model1);
      }
    }
    if (m.find("kibanaDomain") != m.end() && !m["kibanaDomain"].empty()) {
      kibanaDomain = make_shared<string>(boost::any_cast<string>(m["kibanaDomain"]));
    }
    if (m.find("kibanaPort") != m.end() && !m["kibanaPort"].empty()) {
      kibanaPort = make_shared<long>(boost::any_cast<long>(m["kibanaPort"]));
    }
    if (m.find("masterConfiguration") != m.end() && !m["masterConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["masterConfiguration"].type()) {
        MoveResourceGroupResponseBodyResultMasterConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["masterConfiguration"]));
        masterConfiguration = make_shared<MoveResourceGroupResponseBodyResultMasterConfiguration>(model1);
      }
    }
    if (m.find("networkConfig") != m.end() && !m["networkConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["networkConfig"].type()) {
        MoveResourceGroupResponseBodyResultNetworkConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["networkConfig"]));
        networkConfig = make_shared<MoveResourceGroupResponseBodyResultNetworkConfig>(model1);
      }
    }
    if (m.find("nodeAmount") != m.end() && !m["nodeAmount"].empty()) {
      nodeAmount = make_shared<long>(boost::any_cast<long>(m["nodeAmount"]));
    }
    if (m.find("nodeSpec") != m.end() && !m["nodeSpec"].empty()) {
      if (typeid(map<string, boost::any>) == m["nodeSpec"].type()) {
        MoveResourceGroupResponseBodyResultNodeSpec model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["nodeSpec"]));
        nodeSpec = make_shared<MoveResourceGroupResponseBodyResultNodeSpec>(model1);
      }
    }
    if (m.find("paymentType") != m.end() && !m["paymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["paymentType"]));
    }
    if (m.find("publicDomain") != m.end() && !m["publicDomain"].empty()) {
      publicDomain = make_shared<string>(boost::any_cast<string>(m["publicDomain"]));
    }
    if (m.find("publicPort") != m.end() && !m["publicPort"].empty()) {
      publicPort = make_shared<long>(boost::any_cast<long>(m["publicPort"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("synonymsDicts") != m.end() && !m["synonymsDicts"].empty()) {
      if (typeid(vector<boost::any>) == m["synonymsDicts"].type()) {
        vector<MoveResourceGroupResponseBodyResultSynonymsDicts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["synonymsDicts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            MoveResourceGroupResponseBodyResultSynonymsDicts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        synonymsDicts = make_shared<vector<MoveResourceGroupResponseBodyResultSynonymsDicts>>(expect1);
      }
    }
    if (m.find("updatedAt") != m.end() && !m["updatedAt"].empty()) {
      updatedAt = make_shared<string>(boost::any_cast<string>(m["updatedAt"]));
    }
  }


  virtual ~MoveResourceGroupResponseBodyResult() = default;
};
class MoveResourceGroupResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<MoveResourceGroupResponseBodyResult> result{};

  MoveResourceGroupResponseBody() {}

  explicit MoveResourceGroupResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        MoveResourceGroupResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<MoveResourceGroupResponseBodyResult>(model1);
      }
    }
  }


  virtual ~MoveResourceGroupResponseBody() = default;
};
class MoveResourceGroupResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<MoveResourceGroupResponseBody> body{};

  MoveResourceGroupResponse() {}

  explicit MoveResourceGroupResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        MoveResourceGroupResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<MoveResourceGroupResponseBody>(model1);
      }
    }
  }


  virtual ~MoveResourceGroupResponse() = default;
};
class OpenDiagnosisRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> lang{};

  OpenDiagnosisRequest() {}

  explicit OpenDiagnosisRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (lang) {
      res["lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("lang") != m.end() && !m["lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["lang"]));
    }
  }


  virtual ~OpenDiagnosisRequest() = default;
};
class OpenDiagnosisResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  OpenDiagnosisResponseBody() {}

  explicit OpenDiagnosisResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~OpenDiagnosisResponseBody() = default;
};
class OpenDiagnosisResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenDiagnosisResponseBody> body{};

  OpenDiagnosisResponse() {}

  explicit OpenDiagnosisResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenDiagnosisResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenDiagnosisResponseBody>(model1);
      }
    }
  }


  virtual ~OpenDiagnosisResponse() = default;
};
class OpenHttpsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};

  OpenHttpsRequest() {}

  explicit OpenHttpsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~OpenHttpsRequest() = default;
};
class OpenHttpsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  OpenHttpsResponseBody() {}

  explicit OpenHttpsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~OpenHttpsResponseBody() = default;
};
class OpenHttpsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<OpenHttpsResponseBody> body{};

  OpenHttpsResponse() {}

  explicit OpenHttpsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        OpenHttpsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<OpenHttpsResponseBody>(model1);
      }
    }
  }


  virtual ~OpenHttpsResponse() = default;
};
class PostEmonTryAlarmRuleRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};

  PostEmonTryAlarmRuleRequest() {}

  explicit PostEmonTryAlarmRuleRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~PostEmonTryAlarmRuleRequest() = default;
};
class PostEmonTryAlarmRuleResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> success{};

  PostEmonTryAlarmRuleResponseBody() {}

  explicit PostEmonTryAlarmRuleResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (success) {
      res["Success"] = boost::any(*success);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Success") != m.end() && !m["Success"].empty()) {
      success = make_shared<bool>(boost::any_cast<bool>(m["Success"]));
    }
  }


  virtual ~PostEmonTryAlarmRuleResponseBody() = default;
};
class PostEmonTryAlarmRuleResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<PostEmonTryAlarmRuleResponseBody> body{};

  PostEmonTryAlarmRuleResponse() {}

  explicit PostEmonTryAlarmRuleResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        PostEmonTryAlarmRuleResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<PostEmonTryAlarmRuleResponseBody>(model1);
      }
    }
  }


  virtual ~PostEmonTryAlarmRuleResponse() = default;
};
class RecommendTemplatesRequest : public Darabonba::Model {
public:
  shared_ptr<string> usageScenario{};

  RecommendTemplatesRequest() {}

  explicit RecommendTemplatesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (usageScenario) {
      res["usageScenario"] = boost::any(*usageScenario);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("usageScenario") != m.end() && !m["usageScenario"].empty()) {
      usageScenario = make_shared<string>(boost::any_cast<string>(m["usageScenario"]));
    }
  }


  virtual ~RecommendTemplatesRequest() = default;
};
class RecommendTemplatesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> templateName{};

  RecommendTemplatesResponseBodyResult() {}

  explicit RecommendTemplatesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (templateName) {
      res["templateName"] = boost::any(*templateName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("templateName") != m.end() && !m["templateName"].empty()) {
      templateName = make_shared<string>(boost::any_cast<string>(m["templateName"]));
    }
  }


  virtual ~RecommendTemplatesResponseBodyResult() = default;
};
class RecommendTemplatesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<RecommendTemplatesResponseBodyResult>> result{};

  RecommendTemplatesResponseBody() {}

  explicit RecommendTemplatesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<RecommendTemplatesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RecommendTemplatesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<RecommendTemplatesResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~RecommendTemplatesResponseBody() = default;
};
class RecommendTemplatesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RecommendTemplatesResponseBody> body{};

  RecommendTemplatesResponse() {}

  explicit RecommendTemplatesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RecommendTemplatesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RecommendTemplatesResponseBody>(model1);
      }
    }
  }


  virtual ~RecommendTemplatesResponse() = default;
};
class ReinstallCollectorRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> body{};

  ReinstallCollectorRequest() {}

  explicit ReinstallCollectorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~ReinstallCollectorRequest() = default;
};
class ReinstallCollectorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  ReinstallCollectorResponseBody() {}

  explicit ReinstallCollectorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~ReinstallCollectorResponseBody() = default;
};
class ReinstallCollectorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ReinstallCollectorResponseBody> body{};

  ReinstallCollectorResponse() {}

  explicit ReinstallCollectorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ReinstallCollectorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ReinstallCollectorResponseBody>(model1);
      }
    }
  }


  virtual ~ReinstallCollectorResponse() = default;
};
class RemoveApmResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  RemoveApmResponseBody() {}

  explicit RemoveApmResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~RemoveApmResponseBody() = default;
};
class RemoveApmResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RemoveApmResponseBody> body{};

  RemoveApmResponse() {}

  explicit RemoveApmResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RemoveApmResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RemoveApmResponseBody>(model1);
      }
    }
  }


  virtual ~RemoveApmResponse() = default;
};
class RenewInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};

  RenewInstanceRequest() {}

  explicit RenewInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~RenewInstanceRequest() = default;
};
class RenewInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  RenewInstanceResponseBody() {}

  explicit RenewInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~RenewInstanceResponseBody() = default;
};
class RenewInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RenewInstanceResponseBody> body{};

  RenewInstanceResponse() {}

  explicit RenewInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RenewInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RenewInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~RenewInstanceResponse() = default;
};
class RenewLogstashRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};

  RenewLogstashRequest() {}

  explicit RenewLogstashRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~RenewLogstashRequest() = default;
};
class RenewLogstashResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  RenewLogstashResponseBody() {}

  explicit RenewLogstashResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~RenewLogstashResponseBody() = default;
};
class RenewLogstashResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RenewLogstashResponseBody> body{};

  RenewLogstashResponse() {}

  explicit RenewLogstashResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RenewLogstashResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RenewLogstashResponseBody>(model1);
      }
    }
  }


  virtual ~RenewLogstashResponse() = default;
};
class RestartCollectorRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};

  RestartCollectorRequest() {}

  explicit RestartCollectorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~RestartCollectorRequest() = default;
};
class RestartCollectorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  RestartCollectorResponseBody() {}

  explicit RestartCollectorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~RestartCollectorResponseBody() = default;
};
class RestartCollectorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RestartCollectorResponseBody> body{};

  RestartCollectorResponse() {}

  explicit RestartCollectorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RestartCollectorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RestartCollectorResponseBody>(model1);
      }
    }
  }


  virtual ~RestartCollectorResponse() = default;
};
class RestartInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> force{};

  RestartInstanceRequest() {}

  explicit RestartInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (force) {
      res["force"] = boost::any(*force);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("force") != m.end() && !m["force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["force"]));
    }
  }


  virtual ~RestartInstanceRequest() = default;
};
class RestartInstanceResponseBodyResultDictList : public Darabonba::Model {
public:
  shared_ptr<long> fileSize{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> type{};

  RestartInstanceResponseBodyResultDictList() {}

  explicit RestartInstanceResponseBodyResultDictList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileSize) {
      res["fileSize"] = boost::any(*fileSize);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fileSize") != m.end() && !m["fileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["fileSize"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~RestartInstanceResponseBodyResultDictList() = default;
};
class RestartInstanceResponseBodyResultKibanaConfiguration : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<long> disk{};
  shared_ptr<string> diskType{};
  shared_ptr<string> spec{};

  RestartInstanceResponseBodyResultKibanaConfiguration() {}

  explicit RestartInstanceResponseBodyResultKibanaConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["amount"]));
    }
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~RestartInstanceResponseBodyResultKibanaConfiguration() = default;
};
class RestartInstanceResponseBodyResultMasterConfiguration : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<long> disk{};
  shared_ptr<string> diskType{};
  shared_ptr<string> spec{};

  RestartInstanceResponseBodyResultMasterConfiguration() {}

  explicit RestartInstanceResponseBodyResultMasterConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["amount"]));
    }
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~RestartInstanceResponseBodyResultMasterConfiguration() = default;
};
class RestartInstanceResponseBodyResultNetworkConfig : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vsArea{};
  shared_ptr<string> vswitchId{};

  RestartInstanceResponseBodyResultNetworkConfig() {}

  explicit RestartInstanceResponseBodyResultNetworkConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    if (vsArea) {
      res["vsArea"] = boost::any(*vsArea);
    }
    if (vswitchId) {
      res["vswitchId"] = boost::any(*vswitchId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
    if (m.find("vsArea") != m.end() && !m["vsArea"].empty()) {
      vsArea = make_shared<string>(boost::any_cast<string>(m["vsArea"]));
    }
    if (m.find("vswitchId") != m.end() && !m["vswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["vswitchId"]));
    }
  }


  virtual ~RestartInstanceResponseBodyResultNetworkConfig() = default;
};
class RestartInstanceResponseBodyResultNodeSpec : public Darabonba::Model {
public:
  shared_ptr<long> disk{};
  shared_ptr<string> diskType{};
  shared_ptr<string> spec{};

  RestartInstanceResponseBodyResultNodeSpec() {}

  explicit RestartInstanceResponseBodyResultNodeSpec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~RestartInstanceResponseBodyResultNodeSpec() = default;
};
class RestartInstanceResponseBodyResultSynonymsDicts : public Darabonba::Model {
public:
  shared_ptr<long> fileSize{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> type{};

  RestartInstanceResponseBodyResultSynonymsDicts() {}

  explicit RestartInstanceResponseBodyResultSynonymsDicts(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileSize) {
      res["fileSize"] = boost::any(*fileSize);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fileSize") != m.end() && !m["fileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["fileSize"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~RestartInstanceResponseBodyResultSynonymsDicts() = default;
};
class RestartInstanceResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> createdAt{};
  shared_ptr<string> description{};
  shared_ptr<vector<RestartInstanceResponseBodyResultDictList>> dictList{};
  shared_ptr<string> domain{};
  shared_ptr<string> esVersion{};
  shared_ptr<string> instanceId{};
  shared_ptr<RestartInstanceResponseBodyResultKibanaConfiguration> kibanaConfiguration{};
  shared_ptr<string> kibanaDomain{};
  shared_ptr<long> kibanaPort{};
  shared_ptr<RestartInstanceResponseBodyResultMasterConfiguration> masterConfiguration{};
  shared_ptr<RestartInstanceResponseBodyResultNetworkConfig> networkConfig{};
  shared_ptr<long> nodeAmount{};
  shared_ptr<RestartInstanceResponseBodyResultNodeSpec> nodeSpec{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> publicDomain{};
  shared_ptr<long> publicPort{};
  shared_ptr<string> status{};
  shared_ptr<vector<RestartInstanceResponseBodyResultSynonymsDicts>> synonymsDicts{};
  shared_ptr<string> updatedAt{};

  RestartInstanceResponseBodyResult() {}

  explicit RestartInstanceResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (dictList) {
      vector<boost::any> temp1;
      for(auto item1:*dictList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["dictList"] = boost::any(temp1);
    }
    if (domain) {
      res["domain"] = boost::any(*domain);
    }
    if (esVersion) {
      res["esVersion"] = boost::any(*esVersion);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (kibanaConfiguration) {
      res["kibanaConfiguration"] = kibanaConfiguration ? boost::any(kibanaConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (kibanaDomain) {
      res["kibanaDomain"] = boost::any(*kibanaDomain);
    }
    if (kibanaPort) {
      res["kibanaPort"] = boost::any(*kibanaPort);
    }
    if (masterConfiguration) {
      res["masterConfiguration"] = masterConfiguration ? boost::any(masterConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (networkConfig) {
      res["networkConfig"] = networkConfig ? boost::any(networkConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodeAmount) {
      res["nodeAmount"] = boost::any(*nodeAmount);
    }
    if (nodeSpec) {
      res["nodeSpec"] = nodeSpec ? boost::any(nodeSpec->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (paymentType) {
      res["paymentType"] = boost::any(*paymentType);
    }
    if (publicDomain) {
      res["publicDomain"] = boost::any(*publicDomain);
    }
    if (publicPort) {
      res["publicPort"] = boost::any(*publicPort);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (synonymsDicts) {
      vector<boost::any> temp1;
      for(auto item1:*synonymsDicts){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["synonymsDicts"] = boost::any(temp1);
    }
    if (updatedAt) {
      res["updatedAt"] = boost::any(*updatedAt);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("dictList") != m.end() && !m["dictList"].empty()) {
      if (typeid(vector<boost::any>) == m["dictList"].type()) {
        vector<RestartInstanceResponseBodyResultDictList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["dictList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RestartInstanceResponseBodyResultDictList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        dictList = make_shared<vector<RestartInstanceResponseBodyResultDictList>>(expect1);
      }
    }
    if (m.find("domain") != m.end() && !m["domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["domain"]));
    }
    if (m.find("esVersion") != m.end() && !m["esVersion"].empty()) {
      esVersion = make_shared<string>(boost::any_cast<string>(m["esVersion"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("kibanaConfiguration") != m.end() && !m["kibanaConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["kibanaConfiguration"].type()) {
        RestartInstanceResponseBodyResultKibanaConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["kibanaConfiguration"]));
        kibanaConfiguration = make_shared<RestartInstanceResponseBodyResultKibanaConfiguration>(model1);
      }
    }
    if (m.find("kibanaDomain") != m.end() && !m["kibanaDomain"].empty()) {
      kibanaDomain = make_shared<string>(boost::any_cast<string>(m["kibanaDomain"]));
    }
    if (m.find("kibanaPort") != m.end() && !m["kibanaPort"].empty()) {
      kibanaPort = make_shared<long>(boost::any_cast<long>(m["kibanaPort"]));
    }
    if (m.find("masterConfiguration") != m.end() && !m["masterConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["masterConfiguration"].type()) {
        RestartInstanceResponseBodyResultMasterConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["masterConfiguration"]));
        masterConfiguration = make_shared<RestartInstanceResponseBodyResultMasterConfiguration>(model1);
      }
    }
    if (m.find("networkConfig") != m.end() && !m["networkConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["networkConfig"].type()) {
        RestartInstanceResponseBodyResultNetworkConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["networkConfig"]));
        networkConfig = make_shared<RestartInstanceResponseBodyResultNetworkConfig>(model1);
      }
    }
    if (m.find("nodeAmount") != m.end() && !m["nodeAmount"].empty()) {
      nodeAmount = make_shared<long>(boost::any_cast<long>(m["nodeAmount"]));
    }
    if (m.find("nodeSpec") != m.end() && !m["nodeSpec"].empty()) {
      if (typeid(map<string, boost::any>) == m["nodeSpec"].type()) {
        RestartInstanceResponseBodyResultNodeSpec model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["nodeSpec"]));
        nodeSpec = make_shared<RestartInstanceResponseBodyResultNodeSpec>(model1);
      }
    }
    if (m.find("paymentType") != m.end() && !m["paymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["paymentType"]));
    }
    if (m.find("publicDomain") != m.end() && !m["publicDomain"].empty()) {
      publicDomain = make_shared<string>(boost::any_cast<string>(m["publicDomain"]));
    }
    if (m.find("publicPort") != m.end() && !m["publicPort"].empty()) {
      publicPort = make_shared<long>(boost::any_cast<long>(m["publicPort"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("synonymsDicts") != m.end() && !m["synonymsDicts"].empty()) {
      if (typeid(vector<boost::any>) == m["synonymsDicts"].type()) {
        vector<RestartInstanceResponseBodyResultSynonymsDicts> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["synonymsDicts"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            RestartInstanceResponseBodyResultSynonymsDicts model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        synonymsDicts = make_shared<vector<RestartInstanceResponseBodyResultSynonymsDicts>>(expect1);
      }
    }
    if (m.find("updatedAt") != m.end() && !m["updatedAt"].empty()) {
      updatedAt = make_shared<string>(boost::any_cast<string>(m["updatedAt"]));
    }
  }


  virtual ~RestartInstanceResponseBodyResult() = default;
};
class RestartInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<RestartInstanceResponseBodyResult> result{};

  RestartInstanceResponseBody() {}

  explicit RestartInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        RestartInstanceResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<RestartInstanceResponseBodyResult>(model1);
      }
    }
  }


  virtual ~RestartInstanceResponseBody() = default;
};
class RestartInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RestartInstanceResponseBody> body{};

  RestartInstanceResponse() {}

  explicit RestartInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RestartInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RestartInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~RestartInstanceResponse() = default;
};
class RestartLogstashRequest : public Darabonba::Model {
public:
  shared_ptr<double> batchCount{};
  shared_ptr<bool> blueGreenDep{};
  shared_ptr<vector<string>> nodeTypes{};
  shared_ptr<vector<string>> nodes{};
  shared_ptr<string> restartType{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> force{};

  RestartLogstashRequest() {}

  explicit RestartLogstashRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (batchCount) {
      res["batchCount"] = boost::any(*batchCount);
    }
    if (blueGreenDep) {
      res["blueGreenDep"] = boost::any(*blueGreenDep);
    }
    if (nodeTypes) {
      res["nodeTypes"] = boost::any(*nodeTypes);
    }
    if (nodes) {
      res["nodes"] = boost::any(*nodes);
    }
    if (restartType) {
      res["restartType"] = boost::any(*restartType);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (force) {
      res["force"] = boost::any(*force);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("batchCount") != m.end() && !m["batchCount"].empty()) {
      batchCount = make_shared<double>(boost::any_cast<double>(m["batchCount"]));
    }
    if (m.find("blueGreenDep") != m.end() && !m["blueGreenDep"].empty()) {
      blueGreenDep = make_shared<bool>(boost::any_cast<bool>(m["blueGreenDep"]));
    }
    if (m.find("nodeTypes") != m.end() && !m["nodeTypes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["nodeTypes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["nodeTypes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodeTypes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("nodes") != m.end() && !m["nodes"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["nodes"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["nodes"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      nodes = make_shared<vector<string>>(toVec1);
    }
    if (m.find("restartType") != m.end() && !m["restartType"].empty()) {
      restartType = make_shared<string>(boost::any_cast<string>(m["restartType"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("force") != m.end() && !m["force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["force"]));
    }
  }


  virtual ~RestartLogstashRequest() = default;
};
class RestartLogstashResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<Logstash> result{};

  RestartLogstashResponseBody() {}

  explicit RestartLogstashResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        Logstash model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<Logstash>(model1);
      }
    }
  }


  virtual ~RestartLogstashResponseBody() = default;
};
class RestartLogstashResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RestartLogstashResponseBody> body{};

  RestartLogstashResponse() {}

  explicit RestartLogstashResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RestartLogstashResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RestartLogstashResponseBody>(model1);
      }
    }
  }


  virtual ~RestartLogstashResponse() = default;
};
class ResumeElasticsearchTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};

  ResumeElasticsearchTaskRequest() {}

  explicit ResumeElasticsearchTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~ResumeElasticsearchTaskRequest() = default;
};
class ResumeElasticsearchTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  ResumeElasticsearchTaskResponseBody() {}

  explicit ResumeElasticsearchTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~ResumeElasticsearchTaskResponseBody() = default;
};
class ResumeElasticsearchTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResumeElasticsearchTaskResponseBody> body{};

  ResumeElasticsearchTaskResponse() {}

  explicit ResumeElasticsearchTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResumeElasticsearchTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResumeElasticsearchTaskResponseBody>(model1);
      }
    }
  }


  virtual ~ResumeElasticsearchTaskResponse() = default;
};
class ResumeLogstashTaskRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};

  ResumeLogstashTaskRequest() {}

  explicit ResumeLogstashTaskRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~ResumeLogstashTaskRequest() = default;
};
class ResumeLogstashTaskResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> code{};
  shared_ptr<string> message{};
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  ResumeLogstashTaskResponseBody() {}

  explicit ResumeLogstashTaskResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (code) {
      res["Code"] = boost::any(*code);
    }
    if (message) {
      res["Message"] = boost::any(*message);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Code") != m.end() && !m["Code"].empty()) {
      code = make_shared<string>(boost::any_cast<string>(m["Code"]));
    }
    if (m.find("Message") != m.end() && !m["Message"].empty()) {
      message = make_shared<string>(boost::any_cast<string>(m["Message"]));
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~ResumeLogstashTaskResponseBody() = default;
};
class ResumeLogstashTaskResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ResumeLogstashTaskResponseBody> body{};

  ResumeLogstashTaskResponse() {}

  explicit ResumeLogstashTaskResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ResumeLogstashTaskResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ResumeLogstashTaskResponseBody>(model1);
      }
    }
  }


  virtual ~ResumeLogstashTaskResponse() = default;
};
class RolloverDataStreamRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};

  RolloverDataStreamRequest() {}

  explicit RolloverDataStreamRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~RolloverDataStreamRequest() = default;
};
class RolloverDataStreamResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  RolloverDataStreamResponseBody() {}

  explicit RolloverDataStreamResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~RolloverDataStreamResponseBody() = default;
};
class RolloverDataStreamResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RolloverDataStreamResponseBody> body{};

  RolloverDataStreamResponse() {}

  explicit RolloverDataStreamResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RolloverDataStreamResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RolloverDataStreamResponseBody>(model1);
      }
    }
  }


  virtual ~RolloverDataStreamResponse() = default;
};
class RunPipelinesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> body{};

  RunPipelinesRequest() {}

  explicit RunPipelinesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~RunPipelinesRequest() = default;
};
class RunPipelinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  RunPipelinesResponseBody() {}

  explicit RunPipelinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~RunPipelinesResponseBody() = default;
};
class RunPipelinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<RunPipelinesResponseBody> body{};

  RunPipelinesResponse() {}

  explicit RunPipelinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        RunPipelinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<RunPipelinesResponseBody>(model1);
      }
    }
  }


  virtual ~RunPipelinesResponse() = default;
};
class ShrinkNodeRequestBody : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<string> hostName{};
  shared_ptr<string> nodeType{};
  shared_ptr<long> port{};
  shared_ptr<string> zoneId{};

  ShrinkNodeRequestBody() {}

  explicit ShrinkNodeRequestBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["host"] = boost::any(*host);
    }
    if (hostName) {
      res["hostName"] = boost::any(*hostName);
    }
    if (nodeType) {
      res["nodeType"] = boost::any(*nodeType);
    }
    if (port) {
      res["port"] = boost::any(*port);
    }
    if (zoneId) {
      res["zoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("host") != m.end() && !m["host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["host"]));
    }
    if (m.find("hostName") != m.end() && !m["hostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["hostName"]));
    }
    if (m.find("nodeType") != m.end() && !m["nodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["nodeType"]));
    }
    if (m.find("port") != m.end() && !m["port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["port"]));
    }
    if (m.find("zoneId") != m.end() && !m["zoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["zoneId"]));
    }
  }


  virtual ~ShrinkNodeRequestBody() = default;
};
class ShrinkNodeRequest : public Darabonba::Model {
public:
  shared_ptr<vector<ShrinkNodeRequestBody>> body{};
  shared_ptr<string> clientToken{};
  shared_ptr<long> count{};
  shared_ptr<bool> ignoreStatus{};
  shared_ptr<string> nodeType{};

  ShrinkNodeRequest() {}

  explicit ShrinkNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      vector<boost::any> temp1;
      for(auto item1:*body){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["body"] = boost::any(temp1);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (count) {
      res["count"] = boost::any(*count);
    }
    if (ignoreStatus) {
      res["ignoreStatus"] = boost::any(*ignoreStatus);
    }
    if (nodeType) {
      res["nodeType"] = boost::any(*nodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(vector<boost::any>) == m["body"].type()) {
        vector<ShrinkNodeRequestBody> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["body"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ShrinkNodeRequestBody model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        body = make_shared<vector<ShrinkNodeRequestBody>>(expect1);
      }
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("count") != m.end() && !m["count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["count"]));
    }
    if (m.find("ignoreStatus") != m.end() && !m["ignoreStatus"].empty()) {
      ignoreStatus = make_shared<bool>(boost::any_cast<bool>(m["ignoreStatus"]));
    }
    if (m.find("nodeType") != m.end() && !m["nodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["nodeType"]));
    }
  }


  virtual ~ShrinkNodeRequest() = default;
};
class ShrinkNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  ShrinkNodeResponseBody() {}

  explicit ShrinkNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~ShrinkNodeResponseBody() = default;
};
class ShrinkNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ShrinkNodeResponseBody> body{};

  ShrinkNodeResponse() {}

  explicit ShrinkNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ShrinkNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ShrinkNodeResponseBody>(model1);
      }
    }
  }


  virtual ~ShrinkNodeResponse() = default;
};
class StartApmResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  StartApmResponseBody() {}

  explicit StartApmResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~StartApmResponseBody() = default;
};
class StartApmResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartApmResponseBody> body{};

  StartApmResponse() {}

  explicit StartApmResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartApmResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartApmResponseBody>(model1);
      }
    }
  }


  virtual ~StartApmResponse() = default;
};
class StartCollectorRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};

  StartCollectorRequest() {}

  explicit StartCollectorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~StartCollectorRequest() = default;
};
class StartCollectorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  StartCollectorResponseBody() {}

  explicit StartCollectorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~StartCollectorResponseBody() = default;
};
class StartCollectorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StartCollectorResponseBody> body{};

  StartCollectorResponse() {}

  explicit StartCollectorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StartCollectorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StartCollectorResponseBody>(model1);
      }
    }
  }


  virtual ~StartCollectorResponse() = default;
};
class StopApmResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  StopApmResponseBody() {}

  explicit StopApmResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~StopApmResponseBody() = default;
};
class StopApmResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopApmResponseBody> body{};

  StopApmResponse() {}

  explicit StopApmResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopApmResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopApmResponseBody>(model1);
      }
    }
  }


  virtual ~StopApmResponse() = default;
};
class StopCollectorRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};

  StopCollectorRequest() {}

  explicit StopCollectorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
  }


  virtual ~StopCollectorRequest() = default;
};
class StopCollectorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  StopCollectorResponseBody() {}

  explicit StopCollectorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~StopCollectorResponseBody() = default;
};
class StopCollectorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopCollectorResponseBody> body{};

  StopCollectorResponse() {}

  explicit StopCollectorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopCollectorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopCollectorResponseBody>(model1);
      }
    }
  }


  virtual ~StopCollectorResponse() = default;
};
class StopPipelinesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> body{};

  StopPipelinesRequest() {}

  explicit StopPipelinesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~StopPipelinesRequest() = default;
};
class StopPipelinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  StopPipelinesResponseBody() {}

  explicit StopPipelinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~StopPipelinesResponseBody() = default;
};
class StopPipelinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<StopPipelinesResponseBody> body{};

  StopPipelinesResponse() {}

  explicit StopPipelinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        StopPipelinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<StopPipelinesResponseBody>(model1);
      }
    }
  }


  virtual ~StopPipelinesResponse() = default;
};
class TagResourcesRequestTags : public Darabonba::Model {
public:
  shared_ptr<string> key{};
  shared_ptr<string> value{};

  TagResourcesRequestTags() {}

  explicit TagResourcesRequestTags(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (key) {
      res["key"] = boost::any(*key);
    }
    if (value) {
      res["value"] = boost::any(*value);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("key") != m.end() && !m["key"].empty()) {
      key = make_shared<string>(boost::any_cast<string>(m["key"]));
    }
    if (m.find("value") != m.end() && !m["value"].empty()) {
      value = make_shared<string>(boost::any_cast<string>(m["value"]));
    }
  }


  virtual ~TagResourcesRequestTags() = default;
};
class TagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> resourceIds{};
  shared_ptr<string> resourceType{};
  shared_ptr<vector<TagResourcesRequestTags>> tags{};

  TagResourcesRequest() {}

  explicit TagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tags) {
      vector<boost::any> temp1;
      for(auto item1:*tags){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Tags"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ResourceIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ResourceIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      resourceIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("Tags") != m.end() && !m["Tags"].empty()) {
      if (typeid(vector<boost::any>) == m["Tags"].type()) {
        vector<TagResourcesRequestTags> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Tags"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TagResourcesRequestTags model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        tags = make_shared<vector<TagResourcesRequestTags>>(expect1);
      }
    }
  }


  virtual ~TagResourcesRequest() = default;
};
class TagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  TagResourcesResponseBody() {}

  explicit TagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~TagResourcesResponseBody() = default;
};
class TagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TagResourcesResponseBody> body{};

  TagResourcesResponse() {}

  explicit TagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~TagResourcesResponse() = default;
};
class TransferNodeRequestBody : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<long> port{};
  shared_ptr<string> zoneId{};

  TransferNodeRequestBody() {}

  explicit TransferNodeRequestBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["host"] = boost::any(*host);
    }
    if (port) {
      res["port"] = boost::any(*port);
    }
    if (zoneId) {
      res["zoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("host") != m.end() && !m["host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["host"]));
    }
    if (m.find("port") != m.end() && !m["port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["port"]));
    }
    if (m.find("zoneId") != m.end() && !m["zoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["zoneId"]));
    }
  }


  virtual ~TransferNodeRequestBody() = default;
};
class TransferNodeRequest : public Darabonba::Model {
public:
  shared_ptr<vector<TransferNodeRequestBody>> body{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> nodeType{};

  TransferNodeRequest() {}

  explicit TransferNodeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      vector<boost::any> temp1;
      for(auto item1:*body){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["body"] = boost::any(temp1);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (nodeType) {
      res["nodeType"] = boost::any(*nodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(vector<boost::any>) == m["body"].type()) {
        vector<TransferNodeRequestBody> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["body"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            TransferNodeRequestBody model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        body = make_shared<vector<TransferNodeRequestBody>>(expect1);
      }
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("nodeType") != m.end() && !m["nodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["nodeType"]));
    }
  }


  virtual ~TransferNodeRequest() = default;
};
class TransferNodeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  TransferNodeResponseBody() {}

  explicit TransferNodeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~TransferNodeResponseBody() = default;
};
class TransferNodeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TransferNodeResponseBody> body{};

  TransferNodeResponse() {}

  explicit TransferNodeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TransferNodeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TransferNodeResponseBody>(model1);
      }
    }
  }


  virtual ~TransferNodeResponse() = default;
};
class TriggerNetworkRequest : public Darabonba::Model {
public:
  shared_ptr<string> actionType{};
  shared_ptr<string> networkType{};
  shared_ptr<string> nodeType{};
  shared_ptr<string> clientToken{};

  TriggerNetworkRequest() {}

  explicit TriggerNetworkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (actionType) {
      res["actionType"] = boost::any(*actionType);
    }
    if (networkType) {
      res["networkType"] = boost::any(*networkType);
    }
    if (nodeType) {
      res["nodeType"] = boost::any(*nodeType);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("actionType") != m.end() && !m["actionType"].empty()) {
      actionType = make_shared<string>(boost::any_cast<string>(m["actionType"]));
    }
    if (m.find("networkType") != m.end() && !m["networkType"].empty()) {
      networkType = make_shared<string>(boost::any_cast<string>(m["networkType"]));
    }
    if (m.find("nodeType") != m.end() && !m["nodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["nodeType"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~TriggerNetworkRequest() = default;
};
class TriggerNetworkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  TriggerNetworkResponseBody() {}

  explicit TriggerNetworkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~TriggerNetworkResponseBody() = default;
};
class TriggerNetworkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<TriggerNetworkResponseBody> body{};

  TriggerNetworkResponse() {}

  explicit TriggerNetworkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        TriggerNetworkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<TriggerNetworkResponseBody>(model1);
      }
    }
  }


  virtual ~TriggerNetworkResponse() = default;
};
class UninstallKibanaPluginRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};

  UninstallKibanaPluginRequest() {}

  explicit UninstallKibanaPluginRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~UninstallKibanaPluginRequest() = default;
};
class UninstallKibanaPluginResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> result{};

  UninstallKibanaPluginResponseBody() {}

  explicit UninstallKibanaPluginResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Result"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      result = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UninstallKibanaPluginResponseBody() = default;
};
class UninstallKibanaPluginResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UninstallKibanaPluginResponseBody> body{};

  UninstallKibanaPluginResponse() {}

  explicit UninstallKibanaPluginResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UninstallKibanaPluginResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UninstallKibanaPluginResponseBody>(model1);
      }
    }
  }


  virtual ~UninstallKibanaPluginResponse() = default;
};
class UninstallLogstashPluginRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> body{};
  shared_ptr<string> clientToken{};

  UninstallLogstashPluginRequest() {}

  explicit UninstallLogstashPluginRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["body"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["body"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      body = make_shared<vector<string>>(toVec1);
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~UninstallLogstashPluginRequest() = default;
};
class UninstallLogstashPluginResponseBody : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> headers{};
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> result{};

  UninstallLogstashPluginResponseBody() {}

  explicit UninstallLogstashPluginResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["Headers"] = boost::any(*headers);
    }
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("Headers") != m.end() && !m["Headers"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["Headers"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Result"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      result = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UninstallLogstashPluginResponseBody() = default;
};
class UninstallLogstashPluginResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UninstallLogstashPluginResponseBody> body{};

  UninstallLogstashPluginResponse() {}

  explicit UninstallLogstashPluginResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UninstallLogstashPluginResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UninstallLogstashPluginResponseBody>(model1);
      }
    }
  }


  virtual ~UninstallLogstashPluginResponse() = default;
};
class UninstallPluginRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};

  UninstallPluginRequest() {}

  explicit UninstallPluginRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~UninstallPluginRequest() = default;
};
class UninstallPluginResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<string>> result{};

  UninstallPluginResponseBody() {}

  explicit UninstallPluginResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["Result"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      result = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UninstallPluginResponseBody() = default;
};
class UninstallPluginResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UninstallPluginResponseBody> body{};

  UninstallPluginResponse() {}

  explicit UninstallPluginResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UninstallPluginResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UninstallPluginResponseBody>(model1);
      }
    }
  }


  virtual ~UninstallPluginResponse() = default;
};
class UntagResourcesRequest : public Darabonba::Model {
public:
  shared_ptr<bool> all{};
  shared_ptr<string> resourceIds{};
  shared_ptr<string> resourceType{};
  shared_ptr<string> tagKeys{};
  shared_ptr<string> body{};

  UntagResourcesRequest() {}

  explicit UntagResourcesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (all) {
      res["All"] = boost::any(*all);
    }
    if (resourceIds) {
      res["ResourceIds"] = boost::any(*resourceIds);
    }
    if (resourceType) {
      res["ResourceType"] = boost::any(*resourceType);
    }
    if (tagKeys) {
      res["TagKeys"] = boost::any(*tagKeys);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("All") != m.end() && !m["All"].empty()) {
      all = make_shared<bool>(boost::any_cast<bool>(m["All"]));
    }
    if (m.find("ResourceIds") != m.end() && !m["ResourceIds"].empty()) {
      resourceIds = make_shared<string>(boost::any_cast<string>(m["ResourceIds"]));
    }
    if (m.find("ResourceType") != m.end() && !m["ResourceType"].empty()) {
      resourceType = make_shared<string>(boost::any_cast<string>(m["ResourceType"]));
    }
    if (m.find("TagKeys") != m.end() && !m["TagKeys"].empty()) {
      tagKeys = make_shared<string>(boost::any_cast<string>(m["TagKeys"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~UntagResourcesRequest() = default;
};
class UntagResourcesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  UntagResourcesResponseBody() {}

  explicit UntagResourcesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~UntagResourcesResponseBody() = default;
};
class UntagResourcesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UntagResourcesResponseBody> body{};

  UntagResourcesResponse() {}

  explicit UntagResourcesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UntagResourcesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UntagResourcesResponseBody>(model1);
      }
    }
  }


  virtual ~UntagResourcesResponse() = default;
};
class UpdateAdminPasswordRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};

  UpdateAdminPasswordRequest() {}

  explicit UpdateAdminPasswordRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~UpdateAdminPasswordRequest() = default;
};
class UpdateAdminPasswordResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateAdminPasswordResponseBody() {}

  explicit UpdateAdminPasswordResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateAdminPasswordResponseBody() = default;
};
class UpdateAdminPasswordResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAdminPasswordResponseBody> body{};

  UpdateAdminPasswordResponse() {}

  explicit UpdateAdminPasswordResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAdminPasswordResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAdminPasswordResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAdminPasswordResponse() = default;
};
class UpdateAdvancedSettingRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};

  UpdateAdvancedSettingRequest() {}

  explicit UpdateAdvancedSettingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~UpdateAdvancedSettingRequest() = default;
};
class UpdateAdvancedSettingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  UpdateAdvancedSettingResponseBody() {}

  explicit UpdateAdvancedSettingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~UpdateAdvancedSettingResponseBody() = default;
};
class UpdateAdvancedSettingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAdvancedSettingResponseBody> body{};

  UpdateAdvancedSettingResponse() {}

  explicit UpdateAdvancedSettingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAdvancedSettingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAdvancedSettingResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAdvancedSettingResponse() = default;
};
class UpdateAliwsDictRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};

  UpdateAliwsDictRequest() {}

  explicit UpdateAliwsDictRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~UpdateAliwsDictRequest() = default;
};
class UpdateAliwsDictResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> fileSize{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> type{};

  UpdateAliwsDictResponseBodyResult() {}

  explicit UpdateAliwsDictResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileSize) {
      res["fileSize"] = boost::any(*fileSize);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fileSize") != m.end() && !m["fileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["fileSize"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~UpdateAliwsDictResponseBodyResult() = default;
};
class UpdateAliwsDictResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<UpdateAliwsDictResponseBodyResult>> result{};

  UpdateAliwsDictResponseBody() {}

  explicit UpdateAliwsDictResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<UpdateAliwsDictResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateAliwsDictResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<UpdateAliwsDictResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~UpdateAliwsDictResponseBody() = default;
};
class UpdateAliwsDictResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateAliwsDictResponseBody> body{};

  UpdateAliwsDictResponse() {}

  explicit UpdateAliwsDictResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateAliwsDictResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateAliwsDictResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateAliwsDictResponse() = default;
};
class UpdateApmRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> outputES{};
  shared_ptr<string> outputESPassword{};
  shared_ptr<string> outputESUserName{};
  shared_ptr<string> token{};

  UpdateApmRequest() {}

  explicit UpdateApmRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (outputES) {
      res["outputES"] = boost::any(*outputES);
    }
    if (outputESPassword) {
      res["outputESPassword"] = boost::any(*outputESPassword);
    }
    if (outputESUserName) {
      res["outputESUserName"] = boost::any(*outputESUserName);
    }
    if (token) {
      res["token"] = boost::any(*token);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("outputES") != m.end() && !m["outputES"].empty()) {
      outputES = make_shared<string>(boost::any_cast<string>(m["outputES"]));
    }
    if (m.find("outputESPassword") != m.end() && !m["outputESPassword"].empty()) {
      outputESPassword = make_shared<string>(boost::any_cast<string>(m["outputESPassword"]));
    }
    if (m.find("outputESUserName") != m.end() && !m["outputESUserName"].empty()) {
      outputESUserName = make_shared<string>(boost::any_cast<string>(m["outputESUserName"]));
    }
    if (m.find("token") != m.end() && !m["token"].empty()) {
      token = make_shared<string>(boost::any_cast<string>(m["token"]));
    }
  }


  virtual ~UpdateApmRequest() = default;
};
class UpdateApmResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  UpdateApmResponseBody() {}

  explicit UpdateApmResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~UpdateApmResponseBody() = default;
};
class UpdateApmResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateApmResponseBody> body{};

  UpdateApmResponse() {}

  explicit UpdateApmResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateApmResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateApmResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateApmResponse() = default;
};
class UpdateBlackIpsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};

  UpdateBlackIpsRequest() {}

  explicit UpdateBlackIpsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~UpdateBlackIpsRequest() = default;
};
class UpdateBlackIpsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<string>> esIPBlacklist{};

  UpdateBlackIpsResponseBodyResult() {}

  explicit UpdateBlackIpsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (esIPBlacklist) {
      res["esIPBlacklist"] = boost::any(*esIPBlacklist);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("esIPBlacklist") != m.end() && !m["esIPBlacklist"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["esIPBlacklist"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["esIPBlacklist"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      esIPBlacklist = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdateBlackIpsResponseBodyResult() = default;
};
class UpdateBlackIpsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateBlackIpsResponseBodyResult> result{};

  UpdateBlackIpsResponseBody() {}

  explicit UpdateBlackIpsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        UpdateBlackIpsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<UpdateBlackIpsResponseBodyResult>(model1);
      }
    }
  }


  virtual ~UpdateBlackIpsResponseBody() = default;
};
class UpdateBlackIpsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateBlackIpsResponseBody> body{};

  UpdateBlackIpsResponse() {}

  explicit UpdateBlackIpsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateBlackIpsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateBlackIpsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateBlackIpsResponse() = default;
};
class UpdateCollectorRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> body{};

  UpdateCollectorRequest() {}

  explicit UpdateCollectorRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~UpdateCollectorRequest() = default;
};
class UpdateCollectorResponseBodyResultConfigs : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> fileName{};

  UpdateCollectorResponseBodyResultConfigs() {}

  explicit UpdateCollectorResponseBodyResultConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (fileName) {
      res["fileName"] = boost::any(*fileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("fileName") != m.end() && !m["fileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["fileName"]));
    }
  }


  virtual ~UpdateCollectorResponseBodyResultConfigs() = default;
};
class UpdateCollectorResponseBodyResultExtendConfigsMachines : public Darabonba::Model {
public:
  shared_ptr<string> agentStatus{};
  shared_ptr<string> instanceId{};

  UpdateCollectorResponseBodyResultExtendConfigsMachines() {}

  explicit UpdateCollectorResponseBodyResultExtendConfigsMachines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentStatus) {
      res["agentStatus"] = boost::any(*agentStatus);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("agentStatus") != m.end() && !m["agentStatus"].empty()) {
      agentStatus = make_shared<string>(boost::any_cast<string>(m["agentStatus"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
  }


  virtual ~UpdateCollectorResponseBodyResultExtendConfigsMachines() = default;
};
class UpdateCollectorResponseBodyResultExtendConfigs : public Darabonba::Model {
public:
  shared_ptr<string> configType{};
  shared_ptr<bool> enableMonitoring{};
  shared_ptr<string> groupId{};
  shared_ptr<string> host{};
  shared_ptr<vector<string>> hosts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> kibanaHost{};
  shared_ptr<vector<UpdateCollectorResponseBodyResultExtendConfigsMachines>> machines{};
  shared_ptr<string> protocol{};
  shared_ptr<string> successPodsCount{};
  shared_ptr<string> totalPodsCount{};
  shared_ptr<string> type{};
  shared_ptr<string> userName{};

  UpdateCollectorResponseBodyResultExtendConfigs() {}

  explicit UpdateCollectorResponseBodyResultExtendConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configType) {
      res["configType"] = boost::any(*configType);
    }
    if (enableMonitoring) {
      res["enableMonitoring"] = boost::any(*enableMonitoring);
    }
    if (groupId) {
      res["groupId"] = boost::any(*groupId);
    }
    if (host) {
      res["host"] = boost::any(*host);
    }
    if (hosts) {
      res["hosts"] = boost::any(*hosts);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["instanceType"] = boost::any(*instanceType);
    }
    if (kibanaHost) {
      res["kibanaHost"] = boost::any(*kibanaHost);
    }
    if (machines) {
      vector<boost::any> temp1;
      for(auto item1:*machines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["machines"] = boost::any(temp1);
    }
    if (protocol) {
      res["protocol"] = boost::any(*protocol);
    }
    if (successPodsCount) {
      res["successPodsCount"] = boost::any(*successPodsCount);
    }
    if (totalPodsCount) {
      res["totalPodsCount"] = boost::any(*totalPodsCount);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (userName) {
      res["userName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("configType") != m.end() && !m["configType"].empty()) {
      configType = make_shared<string>(boost::any_cast<string>(m["configType"]));
    }
    if (m.find("enableMonitoring") != m.end() && !m["enableMonitoring"].empty()) {
      enableMonitoring = make_shared<bool>(boost::any_cast<bool>(m["enableMonitoring"]));
    }
    if (m.find("groupId") != m.end() && !m["groupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["groupId"]));
    }
    if (m.find("host") != m.end() && !m["host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["host"]));
    }
    if (m.find("hosts") != m.end() && !m["hosts"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["hosts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["hosts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hosts = make_shared<vector<string>>(toVec1);
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("instanceType") != m.end() && !m["instanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["instanceType"]));
    }
    if (m.find("kibanaHost") != m.end() && !m["kibanaHost"].empty()) {
      kibanaHost = make_shared<string>(boost::any_cast<string>(m["kibanaHost"]));
    }
    if (m.find("machines") != m.end() && !m["machines"].empty()) {
      if (typeid(vector<boost::any>) == m["machines"].type()) {
        vector<UpdateCollectorResponseBodyResultExtendConfigsMachines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["machines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCollectorResponseBodyResultExtendConfigsMachines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        machines = make_shared<vector<UpdateCollectorResponseBodyResultExtendConfigsMachines>>(expect1);
      }
    }
    if (m.find("protocol") != m.end() && !m["protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["protocol"]));
    }
    if (m.find("successPodsCount") != m.end() && !m["successPodsCount"].empty()) {
      successPodsCount = make_shared<string>(boost::any_cast<string>(m["successPodsCount"]));
    }
    if (m.find("totalPodsCount") != m.end() && !m["totalPodsCount"].empty()) {
      totalPodsCount = make_shared<string>(boost::any_cast<string>(m["totalPodsCount"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("userName") != m.end() && !m["userName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["userName"]));
    }
  }


  virtual ~UpdateCollectorResponseBodyResultExtendConfigs() = default;
};
class UpdateCollectorResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<string>> collectorPaths{};
  shared_ptr<vector<UpdateCollectorResponseBodyResultConfigs>> configs{};
  shared_ptr<bool> dryRun{};
  shared_ptr<vector<UpdateCollectorResponseBodyResultExtendConfigs>> extendConfigs{};
  shared_ptr<string> gmtCreatedTime{};
  shared_ptr<string> gmtUpdateTime{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> resId{};
  shared_ptr<string> resType{};
  shared_ptr<string> resVersion{};
  shared_ptr<string> status{};
  shared_ptr<string> vpcId{};

  UpdateCollectorResponseBodyResult() {}

  explicit UpdateCollectorResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (collectorPaths) {
      res["collectorPaths"] = boost::any(*collectorPaths);
    }
    if (configs) {
      vector<boost::any> temp1;
      for(auto item1:*configs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["configs"] = boost::any(temp1);
    }
    if (dryRun) {
      res["dryRun"] = boost::any(*dryRun);
    }
    if (extendConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*extendConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extendConfigs"] = boost::any(temp1);
    }
    if (gmtCreatedTime) {
      res["gmtCreatedTime"] = boost::any(*gmtCreatedTime);
    }
    if (gmtUpdateTime) {
      res["gmtUpdateTime"] = boost::any(*gmtUpdateTime);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (ownerId) {
      res["ownerId"] = boost::any(*ownerId);
    }
    if (resId) {
      res["resId"] = boost::any(*resId);
    }
    if (resType) {
      res["resType"] = boost::any(*resType);
    }
    if (resVersion) {
      res["resVersion"] = boost::any(*resVersion);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("collectorPaths") != m.end() && !m["collectorPaths"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["collectorPaths"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["collectorPaths"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      collectorPaths = make_shared<vector<string>>(toVec1);
    }
    if (m.find("configs") != m.end() && !m["configs"].empty()) {
      if (typeid(vector<boost::any>) == m["configs"].type()) {
        vector<UpdateCollectorResponseBodyResultConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["configs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCollectorResponseBodyResultConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configs = make_shared<vector<UpdateCollectorResponseBodyResultConfigs>>(expect1);
      }
    }
    if (m.find("dryRun") != m.end() && !m["dryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["dryRun"]));
    }
    if (m.find("extendConfigs") != m.end() && !m["extendConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["extendConfigs"].type()) {
        vector<UpdateCollectorResponseBodyResultExtendConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extendConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCollectorResponseBodyResultExtendConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extendConfigs = make_shared<vector<UpdateCollectorResponseBodyResultExtendConfigs>>(expect1);
      }
    }
    if (m.find("gmtCreatedTime") != m.end() && !m["gmtCreatedTime"].empty()) {
      gmtCreatedTime = make_shared<string>(boost::any_cast<string>(m["gmtCreatedTime"]));
    }
    if (m.find("gmtUpdateTime") != m.end() && !m["gmtUpdateTime"].empty()) {
      gmtUpdateTime = make_shared<string>(boost::any_cast<string>(m["gmtUpdateTime"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("ownerId") != m.end() && !m["ownerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["ownerId"]));
    }
    if (m.find("resId") != m.end() && !m["resId"].empty()) {
      resId = make_shared<string>(boost::any_cast<string>(m["resId"]));
    }
    if (m.find("resType") != m.end() && !m["resType"].empty()) {
      resType = make_shared<string>(boost::any_cast<string>(m["resType"]));
    }
    if (m.find("resVersion") != m.end() && !m["resVersion"].empty()) {
      resVersion = make_shared<string>(boost::any_cast<string>(m["resVersion"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
  }


  virtual ~UpdateCollectorResponseBodyResult() = default;
};
class UpdateCollectorResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateCollectorResponseBodyResult> result{};

  UpdateCollectorResponseBody() {}

  explicit UpdateCollectorResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        UpdateCollectorResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<UpdateCollectorResponseBodyResult>(model1);
      }
    }
  }


  virtual ~UpdateCollectorResponseBody() = default;
};
class UpdateCollectorResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCollectorResponseBody> body{};

  UpdateCollectorResponse() {}

  explicit UpdateCollectorResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCollectorResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCollectorResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCollectorResponse() = default;
};
class UpdateCollectorNameRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> body{};

  UpdateCollectorNameRequest() {}

  explicit UpdateCollectorNameRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~UpdateCollectorNameRequest() = default;
};
class UpdateCollectorNameResponseBodyResultConfigs : public Darabonba::Model {
public:
  shared_ptr<string> content{};
  shared_ptr<string> fileName{};

  UpdateCollectorNameResponseBodyResultConfigs() {}

  explicit UpdateCollectorNameResponseBodyResultConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (content) {
      res["content"] = boost::any(*content);
    }
    if (fileName) {
      res["fileName"] = boost::any(*fileName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("content") != m.end() && !m["content"].empty()) {
      content = make_shared<string>(boost::any_cast<string>(m["content"]));
    }
    if (m.find("fileName") != m.end() && !m["fileName"].empty()) {
      fileName = make_shared<string>(boost::any_cast<string>(m["fileName"]));
    }
  }


  virtual ~UpdateCollectorNameResponseBodyResultConfigs() = default;
};
class UpdateCollectorNameResponseBodyResultExtendConfigsMachines : public Darabonba::Model {
public:
  shared_ptr<string> agentStatus{};
  shared_ptr<string> instanceId{};

  UpdateCollectorNameResponseBodyResultExtendConfigsMachines() {}

  explicit UpdateCollectorNameResponseBodyResultExtendConfigsMachines(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (agentStatus) {
      res["agentStatus"] = boost::any(*agentStatus);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("agentStatus") != m.end() && !m["agentStatus"].empty()) {
      agentStatus = make_shared<string>(boost::any_cast<string>(m["agentStatus"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
  }


  virtual ~UpdateCollectorNameResponseBodyResultExtendConfigsMachines() = default;
};
class UpdateCollectorNameResponseBodyResultExtendConfigs : public Darabonba::Model {
public:
  shared_ptr<string> configType{};
  shared_ptr<bool> enableMonitoring{};
  shared_ptr<string> groupId{};
  shared_ptr<string> host{};
  shared_ptr<vector<string>> hosts{};
  shared_ptr<string> instanceId{};
  shared_ptr<string> instanceType{};
  shared_ptr<string> kibanaHost{};
  shared_ptr<vector<UpdateCollectorNameResponseBodyResultExtendConfigsMachines>> machines{};
  shared_ptr<string> protocol{};
  shared_ptr<string> successPodsCount{};
  shared_ptr<string> totalPodsCount{};
  shared_ptr<string> type{};
  shared_ptr<string> userName{};

  UpdateCollectorNameResponseBodyResultExtendConfigs() {}

  explicit UpdateCollectorNameResponseBodyResultExtendConfigs(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (configType) {
      res["configType"] = boost::any(*configType);
    }
    if (enableMonitoring) {
      res["enableMonitoring"] = boost::any(*enableMonitoring);
    }
    if (groupId) {
      res["groupId"] = boost::any(*groupId);
    }
    if (host) {
      res["host"] = boost::any(*host);
    }
    if (hosts) {
      res["hosts"] = boost::any(*hosts);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (instanceType) {
      res["instanceType"] = boost::any(*instanceType);
    }
    if (kibanaHost) {
      res["kibanaHost"] = boost::any(*kibanaHost);
    }
    if (machines) {
      vector<boost::any> temp1;
      for(auto item1:*machines){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["machines"] = boost::any(temp1);
    }
    if (protocol) {
      res["protocol"] = boost::any(*protocol);
    }
    if (successPodsCount) {
      res["successPodsCount"] = boost::any(*successPodsCount);
    }
    if (totalPodsCount) {
      res["totalPodsCount"] = boost::any(*totalPodsCount);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (userName) {
      res["userName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("configType") != m.end() && !m["configType"].empty()) {
      configType = make_shared<string>(boost::any_cast<string>(m["configType"]));
    }
    if (m.find("enableMonitoring") != m.end() && !m["enableMonitoring"].empty()) {
      enableMonitoring = make_shared<bool>(boost::any_cast<bool>(m["enableMonitoring"]));
    }
    if (m.find("groupId") != m.end() && !m["groupId"].empty()) {
      groupId = make_shared<string>(boost::any_cast<string>(m["groupId"]));
    }
    if (m.find("host") != m.end() && !m["host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["host"]));
    }
    if (m.find("hosts") != m.end() && !m["hosts"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["hosts"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["hosts"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      hosts = make_shared<vector<string>>(toVec1);
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("instanceType") != m.end() && !m["instanceType"].empty()) {
      instanceType = make_shared<string>(boost::any_cast<string>(m["instanceType"]));
    }
    if (m.find("kibanaHost") != m.end() && !m["kibanaHost"].empty()) {
      kibanaHost = make_shared<string>(boost::any_cast<string>(m["kibanaHost"]));
    }
    if (m.find("machines") != m.end() && !m["machines"].empty()) {
      if (typeid(vector<boost::any>) == m["machines"].type()) {
        vector<UpdateCollectorNameResponseBodyResultExtendConfigsMachines> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["machines"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCollectorNameResponseBodyResultExtendConfigsMachines model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        machines = make_shared<vector<UpdateCollectorNameResponseBodyResultExtendConfigsMachines>>(expect1);
      }
    }
    if (m.find("protocol") != m.end() && !m["protocol"].empty()) {
      protocol = make_shared<string>(boost::any_cast<string>(m["protocol"]));
    }
    if (m.find("successPodsCount") != m.end() && !m["successPodsCount"].empty()) {
      successPodsCount = make_shared<string>(boost::any_cast<string>(m["successPodsCount"]));
    }
    if (m.find("totalPodsCount") != m.end() && !m["totalPodsCount"].empty()) {
      totalPodsCount = make_shared<string>(boost::any_cast<string>(m["totalPodsCount"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("userName") != m.end() && !m["userName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["userName"]));
    }
  }


  virtual ~UpdateCollectorNameResponseBodyResultExtendConfigs() = default;
};
class UpdateCollectorNameResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<string>> collectorPaths{};
  shared_ptr<vector<UpdateCollectorNameResponseBodyResultConfigs>> configs{};
  shared_ptr<bool> dryRun{};
  shared_ptr<vector<UpdateCollectorNameResponseBodyResultExtendConfigs>> extendConfigs{};
  shared_ptr<string> gmtCreatedTime{};
  shared_ptr<string> gmtUpdateTime{};
  shared_ptr<string> name{};
  shared_ptr<string> ownerId{};
  shared_ptr<string> resId{};
  shared_ptr<string> resType{};
  shared_ptr<string> resVersion{};
  shared_ptr<string> status{};
  shared_ptr<string> vpcId{};

  UpdateCollectorNameResponseBodyResult() {}

  explicit UpdateCollectorNameResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (collectorPaths) {
      res["collectorPaths"] = boost::any(*collectorPaths);
    }
    if (configs) {
      vector<boost::any> temp1;
      for(auto item1:*configs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["configs"] = boost::any(temp1);
    }
    if (dryRun) {
      res["dryRun"] = boost::any(*dryRun);
    }
    if (extendConfigs) {
      vector<boost::any> temp1;
      for(auto item1:*extendConfigs){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["extendConfigs"] = boost::any(temp1);
    }
    if (gmtCreatedTime) {
      res["gmtCreatedTime"] = boost::any(*gmtCreatedTime);
    }
    if (gmtUpdateTime) {
      res["gmtUpdateTime"] = boost::any(*gmtUpdateTime);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (ownerId) {
      res["ownerId"] = boost::any(*ownerId);
    }
    if (resId) {
      res["resId"] = boost::any(*resId);
    }
    if (resType) {
      res["resType"] = boost::any(*resType);
    }
    if (resVersion) {
      res["resVersion"] = boost::any(*resVersion);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("collectorPaths") != m.end() && !m["collectorPaths"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["collectorPaths"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["collectorPaths"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      collectorPaths = make_shared<vector<string>>(toVec1);
    }
    if (m.find("configs") != m.end() && !m["configs"].empty()) {
      if (typeid(vector<boost::any>) == m["configs"].type()) {
        vector<UpdateCollectorNameResponseBodyResultConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["configs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCollectorNameResponseBodyResultConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        configs = make_shared<vector<UpdateCollectorNameResponseBodyResultConfigs>>(expect1);
      }
    }
    if (m.find("dryRun") != m.end() && !m["dryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["dryRun"]));
    }
    if (m.find("extendConfigs") != m.end() && !m["extendConfigs"].empty()) {
      if (typeid(vector<boost::any>) == m["extendConfigs"].type()) {
        vector<UpdateCollectorNameResponseBodyResultExtendConfigs> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["extendConfigs"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateCollectorNameResponseBodyResultExtendConfigs model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        extendConfigs = make_shared<vector<UpdateCollectorNameResponseBodyResultExtendConfigs>>(expect1);
      }
    }
    if (m.find("gmtCreatedTime") != m.end() && !m["gmtCreatedTime"].empty()) {
      gmtCreatedTime = make_shared<string>(boost::any_cast<string>(m["gmtCreatedTime"]));
    }
    if (m.find("gmtUpdateTime") != m.end() && !m["gmtUpdateTime"].empty()) {
      gmtUpdateTime = make_shared<string>(boost::any_cast<string>(m["gmtUpdateTime"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("ownerId") != m.end() && !m["ownerId"].empty()) {
      ownerId = make_shared<string>(boost::any_cast<string>(m["ownerId"]));
    }
    if (m.find("resId") != m.end() && !m["resId"].empty()) {
      resId = make_shared<string>(boost::any_cast<string>(m["resId"]));
    }
    if (m.find("resType") != m.end() && !m["resType"].empty()) {
      resType = make_shared<string>(boost::any_cast<string>(m["resType"]));
    }
    if (m.find("resVersion") != m.end() && !m["resVersion"].empty()) {
      resVersion = make_shared<string>(boost::any_cast<string>(m["resVersion"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
  }


  virtual ~UpdateCollectorNameResponseBodyResult() = default;
};
class UpdateCollectorNameResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateCollectorNameResponseBodyResult> result{};

  UpdateCollectorNameResponseBody() {}

  explicit UpdateCollectorNameResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        UpdateCollectorNameResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<UpdateCollectorNameResponseBodyResult>(model1);
      }
    }
  }


  virtual ~UpdateCollectorNameResponseBody() = default;
};
class UpdateCollectorNameResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateCollectorNameResponseBody> body{};

  UpdateCollectorNameResponse() {}

  explicit UpdateCollectorNameResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateCollectorNameResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateCollectorNameResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateCollectorNameResponse() = default;
};
class UpdateComponentIndexRequestTemplate : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> aliases{};
  shared_ptr<map<string, boost::any>> mappings{};
  shared_ptr<map<string, boost::any>> settings{};

  UpdateComponentIndexRequestTemplate() {}

  explicit UpdateComponentIndexRequestTemplate(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (aliases) {
      res["aliases"] = boost::any(*aliases);
    }
    if (mappings) {
      res["mappings"] = boost::any(*mappings);
    }
    if (settings) {
      res["settings"] = boost::any(*settings);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("aliases") != m.end() && !m["aliases"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["aliases"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      aliases = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("mappings") != m.end() && !m["mappings"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["mappings"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      mappings = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("settings") != m.end() && !m["settings"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["settings"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      settings = make_shared<map<string, boost::any>>(toMap1);
    }
  }


  virtual ~UpdateComponentIndexRequestTemplate() = default;
};
class UpdateComponentIndexRequest : public Darabonba::Model {
public:
  shared_ptr<map<string, boost::any>> meta{};
  shared_ptr<UpdateComponentIndexRequestTemplate> template_{};

  UpdateComponentIndexRequest() {}

  explicit UpdateComponentIndexRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (meta) {
      res["_meta"] = boost::any(*meta);
    }
    if (template_) {
      res["template"] = template_ ? boost::any(template_->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("_meta") != m.end() && !m["_meta"].empty()) {
      map<string, boost::any> map1 = boost::any_cast<map<string, boost::any>>(m["_meta"]);
      map<string, boost::any> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      meta = make_shared<map<string, boost::any>>(toMap1);
    }
    if (m.find("template") != m.end() && !m["template"].empty()) {
      if (typeid(map<string, boost::any>) == m["template"].type()) {
        UpdateComponentIndexRequestTemplate model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["template"]));
        template_ = make_shared<UpdateComponentIndexRequestTemplate>(model1);
      }
    }
  }


  virtual ~UpdateComponentIndexRequest() = default;
};
class UpdateComponentIndexResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateComponentIndexResponseBody() {}

  explicit UpdateComponentIndexResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["requestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("requestId") != m.end() && !m["requestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["requestId"]));
    }
  }


  virtual ~UpdateComponentIndexResponseBody() = default;
};
class UpdateComponentIndexResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateComponentIndexResponseBody> body{};

  UpdateComponentIndexResponse() {}

  explicit UpdateComponentIndexResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateComponentIndexResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateComponentIndexResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateComponentIndexResponse() = default;
};
class UpdateDescriptionRequest : public Darabonba::Model {
public:
  shared_ptr<string> description{};
  shared_ptr<string> clientToken{};

  UpdateDescriptionRequest() {}

  explicit UpdateDescriptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~UpdateDescriptionRequest() = default;
};
class UpdateDescriptionResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> description{};

  UpdateDescriptionResponseBodyResult() {}

  explicit UpdateDescriptionResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
  }


  virtual ~UpdateDescriptionResponseBodyResult() = default;
};
class UpdateDescriptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateDescriptionResponseBodyResult> result{};

  UpdateDescriptionResponseBody() {}

  explicit UpdateDescriptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        UpdateDescriptionResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<UpdateDescriptionResponseBodyResult>(model1);
      }
    }
  }


  virtual ~UpdateDescriptionResponseBody() = default;
};
class UpdateDescriptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDescriptionResponseBody> body{};

  UpdateDescriptionResponse() {}

  explicit UpdateDescriptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDescriptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDescriptionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDescriptionResponse() = default;
};
class UpdateDiagnosisSettingsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> body{};
  shared_ptr<string> lang{};

  UpdateDiagnosisSettingsRequest() {}

  explicit UpdateDiagnosisSettingsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (lang) {
      res["lang"] = boost::any(*lang);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("lang") != m.end() && !m["lang"].empty()) {
      lang = make_shared<string>(boost::any_cast<string>(m["lang"]));
    }
  }


  virtual ~UpdateDiagnosisSettingsRequest() = default;
};
class UpdateDiagnosisSettingsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  UpdateDiagnosisSettingsResponseBody() {}

  explicit UpdateDiagnosisSettingsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~UpdateDiagnosisSettingsResponseBody() = default;
};
class UpdateDiagnosisSettingsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDiagnosisSettingsResponseBody> body{};

  UpdateDiagnosisSettingsResponse() {}

  explicit UpdateDiagnosisSettingsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDiagnosisSettingsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDiagnosisSettingsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDiagnosisSettingsResponse() = default;
};
class UpdateDictRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};

  UpdateDictRequest() {}

  explicit UpdateDictRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~UpdateDictRequest() = default;
};
class UpdateDictResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> fileSize{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> type{};

  UpdateDictResponseBodyResult() {}

  explicit UpdateDictResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileSize) {
      res["fileSize"] = boost::any(*fileSize);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fileSize") != m.end() && !m["fileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["fileSize"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~UpdateDictResponseBodyResult() = default;
};
class UpdateDictResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<UpdateDictResponseBodyResult>> result{};

  UpdateDictResponseBody() {}

  explicit UpdateDictResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<UpdateDictResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateDictResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<UpdateDictResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~UpdateDictResponseBody() = default;
};
class UpdateDictResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDictResponseBody> body{};

  UpdateDictResponse() {}

  explicit UpdateDictResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDictResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDictResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDictResponse() = default;
};
class UpdateDynamicSettingsRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> regionId{};
  shared_ptr<string> body{};
  shared_ptr<string> mode{};

  UpdateDynamicSettingsRequest() {}

  explicit UpdateDynamicSettingsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (regionId) {
      res["RegionId"] = boost::any(*regionId);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (mode) {
      res["mode"] = boost::any(*mode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("RegionId") != m.end() && !m["RegionId"].empty()) {
      regionId = make_shared<string>(boost::any_cast<string>(m["RegionId"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("mode") != m.end() && !m["mode"].empty()) {
      mode = make_shared<string>(boost::any_cast<string>(m["mode"]));
    }
  }


  virtual ~UpdateDynamicSettingsRequest() = default;
};
class UpdateDynamicSettingsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  UpdateDynamicSettingsResponseBody() {}

  explicit UpdateDynamicSettingsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~UpdateDynamicSettingsResponseBody() = default;
};
class UpdateDynamicSettingsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateDynamicSettingsResponseBody> body{};

  UpdateDynamicSettingsResponse() {}

  explicit UpdateDynamicSettingsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateDynamicSettingsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateDynamicSettingsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateDynamicSettingsResponse() = default;
};
class UpdateExtendConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> body{};

  UpdateExtendConfigRequest() {}

  explicit UpdateExtendConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~UpdateExtendConfigRequest() = default;
};
class UpdateExtendConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  UpdateExtendConfigResponseBody() {}

  explicit UpdateExtendConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~UpdateExtendConfigResponseBody() = default;
};
class UpdateExtendConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateExtendConfigResponseBody> body{};

  UpdateExtendConfigResponse() {}

  explicit UpdateExtendConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateExtendConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateExtendConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateExtendConfigResponse() = default;
};
class UpdateExtendfilesRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> body{};

  UpdateExtendfilesRequest() {}

  explicit UpdateExtendfilesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~UpdateExtendfilesRequest() = default;
};
class UpdateExtendfilesResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> fileSize{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceType{};

  UpdateExtendfilesResponseBodyResult() {}

  explicit UpdateExtendfilesResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileSize) {
      res["fileSize"] = boost::any(*fileSize);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fileSize") != m.end() && !m["fileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["fileSize"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
  }


  virtual ~UpdateExtendfilesResponseBodyResult() = default;
};
class UpdateExtendfilesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<UpdateExtendfilesResponseBodyResult>> result{};

  UpdateExtendfilesResponseBody() {}

  explicit UpdateExtendfilesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<UpdateExtendfilesResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateExtendfilesResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<UpdateExtendfilesResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~UpdateExtendfilesResponseBody() = default;
};
class UpdateExtendfilesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateExtendfilesResponseBody> body{};

  UpdateExtendfilesResponse() {}

  explicit UpdateExtendfilesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateExtendfilesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateExtendfilesResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateExtendfilesResponse() = default;
};
class UpdateHotIkDictsRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};

  UpdateHotIkDictsRequest() {}

  explicit UpdateHotIkDictsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~UpdateHotIkDictsRequest() = default;
};
class UpdateHotIkDictsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> fileSize{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> type{};

  UpdateHotIkDictsResponseBodyResult() {}

  explicit UpdateHotIkDictsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileSize) {
      res["fileSize"] = boost::any(*fileSize);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fileSize") != m.end() && !m["fileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["fileSize"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~UpdateHotIkDictsResponseBodyResult() = default;
};
class UpdateHotIkDictsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<UpdateHotIkDictsResponseBodyResult>> result{};

  UpdateHotIkDictsResponseBody() {}

  explicit UpdateHotIkDictsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<UpdateHotIkDictsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateHotIkDictsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<UpdateHotIkDictsResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~UpdateHotIkDictsResponseBody() = default;
};
class UpdateHotIkDictsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateHotIkDictsResponseBody> body{};

  UpdateHotIkDictsResponse() {}

  explicit UpdateHotIkDictsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateHotIkDictsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateHotIkDictsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateHotIkDictsResponse() = default;
};
class UpdateILMPolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> body{};

  UpdateILMPolicyRequest() {}

  explicit UpdateILMPolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~UpdateILMPolicyRequest() = default;
};
class UpdateILMPolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  UpdateILMPolicyResponseBody() {}

  explicit UpdateILMPolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~UpdateILMPolicyResponseBody() = default;
};
class UpdateILMPolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateILMPolicyResponseBody> body{};

  UpdateILMPolicyResponse() {}

  explicit UpdateILMPolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateILMPolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateILMPolicyResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateILMPolicyResponse() = default;
};
class UpdateIndexTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> body{};

  UpdateIndexTemplateRequest() {}

  explicit UpdateIndexTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~UpdateIndexTemplateRequest() = default;
};
class UpdateIndexTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<string> result{};

  UpdateIndexTemplateResponseBody() {}

  explicit UpdateIndexTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<string>(boost::any_cast<string>(m["Result"]));
    }
  }


  virtual ~UpdateIndexTemplateResponseBody() = default;
};
class UpdateIndexTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateIndexTemplateResponseBody> body{};

  UpdateIndexTemplateResponse() {}

  explicit UpdateIndexTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateIndexTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateIndexTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateIndexTemplateResponse() = default;
};
class UpdateInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<ClientNodeConfiguration> clientNodeConfiguration{};
  shared_ptr<ElasticDataNodeConfiguration> elasticDataNodeConfiguration{};
  shared_ptr<string> instanceCategory{};
  shared_ptr<KibanaNodeConfiguration> kibanaConfiguration{};
  shared_ptr<MasterNodeConfiguration> masterConfiguration{};
  shared_ptr<long> nodeAmount{};
  shared_ptr<NodeSpec> nodeSpec{};
  shared_ptr<WarmNodeConfiguration> warmNodeConfiguration{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> force{};
  shared_ptr<string> orderActionType{};

  UpdateInstanceRequest() {}

  explicit UpdateInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientNodeConfiguration) {
      res["clientNodeConfiguration"] = clientNodeConfiguration ? boost::any(clientNodeConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (elasticDataNodeConfiguration) {
      res["elasticDataNodeConfiguration"] = elasticDataNodeConfiguration ? boost::any(elasticDataNodeConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (instanceCategory) {
      res["instanceCategory"] = boost::any(*instanceCategory);
    }
    if (kibanaConfiguration) {
      res["kibanaConfiguration"] = kibanaConfiguration ? boost::any(kibanaConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (masterConfiguration) {
      res["masterConfiguration"] = masterConfiguration ? boost::any(masterConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodeAmount) {
      res["nodeAmount"] = boost::any(*nodeAmount);
    }
    if (nodeSpec) {
      res["nodeSpec"] = nodeSpec ? boost::any(nodeSpec->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (warmNodeConfiguration) {
      res["warmNodeConfiguration"] = warmNodeConfiguration ? boost::any(warmNodeConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (force) {
      res["force"] = boost::any(*force);
    }
    if (orderActionType) {
      res["orderActionType"] = boost::any(*orderActionType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientNodeConfiguration") != m.end() && !m["clientNodeConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["clientNodeConfiguration"].type()) {
        ClientNodeConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["clientNodeConfiguration"]));
        clientNodeConfiguration = make_shared<ClientNodeConfiguration>(model1);
      }
    }
    if (m.find("elasticDataNodeConfiguration") != m.end() && !m["elasticDataNodeConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["elasticDataNodeConfiguration"].type()) {
        ElasticDataNodeConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["elasticDataNodeConfiguration"]));
        elasticDataNodeConfiguration = make_shared<ElasticDataNodeConfiguration>(model1);
      }
    }
    if (m.find("instanceCategory") != m.end() && !m["instanceCategory"].empty()) {
      instanceCategory = make_shared<string>(boost::any_cast<string>(m["instanceCategory"]));
    }
    if (m.find("kibanaConfiguration") != m.end() && !m["kibanaConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["kibanaConfiguration"].type()) {
        KibanaNodeConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["kibanaConfiguration"]));
        kibanaConfiguration = make_shared<KibanaNodeConfiguration>(model1);
      }
    }
    if (m.find("masterConfiguration") != m.end() && !m["masterConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["masterConfiguration"].type()) {
        MasterNodeConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["masterConfiguration"]));
        masterConfiguration = make_shared<MasterNodeConfiguration>(model1);
      }
    }
    if (m.find("nodeAmount") != m.end() && !m["nodeAmount"].empty()) {
      nodeAmount = make_shared<long>(boost::any_cast<long>(m["nodeAmount"]));
    }
    if (m.find("nodeSpec") != m.end() && !m["nodeSpec"].empty()) {
      if (typeid(map<string, boost::any>) == m["nodeSpec"].type()) {
        NodeSpec model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["nodeSpec"]));
        nodeSpec = make_shared<NodeSpec>(model1);
      }
    }
    if (m.find("warmNodeConfiguration") != m.end() && !m["warmNodeConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["warmNodeConfiguration"].type()) {
        WarmNodeConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["warmNodeConfiguration"]));
        warmNodeConfiguration = make_shared<WarmNodeConfiguration>(model1);
      }
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("force") != m.end() && !m["force"].empty()) {
      force = make_shared<bool>(boost::any_cast<bool>(m["force"]));
    }
    if (m.find("orderActionType") != m.end() && !m["orderActionType"].empty()) {
      orderActionType = make_shared<string>(boost::any_cast<string>(m["orderActionType"]));
    }
  }


  virtual ~UpdateInstanceRequest() = default;
};
class UpdateInstanceResponseBodyResultKibanaConfiguration : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<long> disk{};
  shared_ptr<string> diskType{};
  shared_ptr<string> spec{};

  UpdateInstanceResponseBodyResultKibanaConfiguration() {}

  explicit UpdateInstanceResponseBodyResultKibanaConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["amount"]));
    }
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~UpdateInstanceResponseBodyResultKibanaConfiguration() = default;
};
class UpdateInstanceResponseBodyResultMasterConfiguration : public Darabonba::Model {
public:
  shared_ptr<long> amount{};
  shared_ptr<long> disk{};
  shared_ptr<string> diskType{};
  shared_ptr<string> spec{};

  UpdateInstanceResponseBodyResultMasterConfiguration() {}

  explicit UpdateInstanceResponseBodyResultMasterConfiguration(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (amount) {
      res["amount"] = boost::any(*amount);
    }
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("amount") != m.end() && !m["amount"].empty()) {
      amount = make_shared<long>(boost::any_cast<long>(m["amount"]));
    }
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~UpdateInstanceResponseBodyResultMasterConfiguration() = default;
};
class UpdateInstanceResponseBodyResultNodeSpec : public Darabonba::Model {
public:
  shared_ptr<long> disk{};
  shared_ptr<string> diskType{};
  shared_ptr<string> spec{};

  UpdateInstanceResponseBodyResultNodeSpec() {}

  explicit UpdateInstanceResponseBodyResultNodeSpec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~UpdateInstanceResponseBodyResultNodeSpec() = default;
};
class UpdateInstanceResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> createdAt{};
  shared_ptr<string> description{};
  shared_ptr<string> domain{};
  shared_ptr<string> esVersion{};
  shared_ptr<string> instanceId{};
  shared_ptr<UpdateInstanceResponseBodyResultKibanaConfiguration> kibanaConfiguration{};
  shared_ptr<UpdateInstanceResponseBodyResultMasterConfiguration> masterConfiguration{};
  shared_ptr<long> nodeAmount{};
  shared_ptr<UpdateInstanceResponseBodyResultNodeSpec> nodeSpec{};
  shared_ptr<string> paymentType{};
  shared_ptr<string> status{};

  UpdateInstanceResponseBodyResult() {}

  explicit UpdateInstanceResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (createdAt) {
      res["createdAt"] = boost::any(*createdAt);
    }
    if (description) {
      res["description"] = boost::any(*description);
    }
    if (domain) {
      res["domain"] = boost::any(*domain);
    }
    if (esVersion) {
      res["esVersion"] = boost::any(*esVersion);
    }
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    if (kibanaConfiguration) {
      res["kibanaConfiguration"] = kibanaConfiguration ? boost::any(kibanaConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (masterConfiguration) {
      res["masterConfiguration"] = masterConfiguration ? boost::any(masterConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodeAmount) {
      res["nodeAmount"] = boost::any(*nodeAmount);
    }
    if (nodeSpec) {
      res["nodeSpec"] = nodeSpec ? boost::any(nodeSpec->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (paymentType) {
      res["paymentType"] = boost::any(*paymentType);
    }
    if (status) {
      res["status"] = boost::any(*status);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("createdAt") != m.end() && !m["createdAt"].empty()) {
      createdAt = make_shared<string>(boost::any_cast<string>(m["createdAt"]));
    }
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
    if (m.find("domain") != m.end() && !m["domain"].empty()) {
      domain = make_shared<string>(boost::any_cast<string>(m["domain"]));
    }
    if (m.find("esVersion") != m.end() && !m["esVersion"].empty()) {
      esVersion = make_shared<string>(boost::any_cast<string>(m["esVersion"]));
    }
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
    if (m.find("kibanaConfiguration") != m.end() && !m["kibanaConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["kibanaConfiguration"].type()) {
        UpdateInstanceResponseBodyResultKibanaConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["kibanaConfiguration"]));
        kibanaConfiguration = make_shared<UpdateInstanceResponseBodyResultKibanaConfiguration>(model1);
      }
    }
    if (m.find("masterConfiguration") != m.end() && !m["masterConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["masterConfiguration"].type()) {
        UpdateInstanceResponseBodyResultMasterConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["masterConfiguration"]));
        masterConfiguration = make_shared<UpdateInstanceResponseBodyResultMasterConfiguration>(model1);
      }
    }
    if (m.find("nodeAmount") != m.end() && !m["nodeAmount"].empty()) {
      nodeAmount = make_shared<long>(boost::any_cast<long>(m["nodeAmount"]));
    }
    if (m.find("nodeSpec") != m.end() && !m["nodeSpec"].empty()) {
      if (typeid(map<string, boost::any>) == m["nodeSpec"].type()) {
        UpdateInstanceResponseBodyResultNodeSpec model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["nodeSpec"]));
        nodeSpec = make_shared<UpdateInstanceResponseBodyResultNodeSpec>(model1);
      }
    }
    if (m.find("paymentType") != m.end() && !m["paymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["paymentType"]));
    }
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
  }


  virtual ~UpdateInstanceResponseBodyResult() = default;
};
class UpdateInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateInstanceResponseBodyResult> result{};

  UpdateInstanceResponseBody() {}

  explicit UpdateInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        UpdateInstanceResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<UpdateInstanceResponseBodyResult>(model1);
      }
    }
  }


  virtual ~UpdateInstanceResponseBody() = default;
};
class UpdateInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateInstanceResponseBody> body{};

  UpdateInstanceResponse() {}

  explicit UpdateInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateInstanceResponse() = default;
};
class UpdateInstanceChargeTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};

  UpdateInstanceChargeTypeRequest() {}

  explicit UpdateInstanceChargeTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~UpdateInstanceChargeTypeRequest() = default;
};
class UpdateInstanceChargeTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  UpdateInstanceChargeTypeResponseBody() {}

  explicit UpdateInstanceChargeTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~UpdateInstanceChargeTypeResponseBody() = default;
};
class UpdateInstanceChargeTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateInstanceChargeTypeResponseBody> body{};

  UpdateInstanceChargeTypeResponse() {}

  explicit UpdateInstanceChargeTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateInstanceChargeTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateInstanceChargeTypeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateInstanceChargeTypeResponse() = default;
};
class UpdateInstanceSettingsRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};

  UpdateInstanceSettingsRequest() {}

  explicit UpdateInstanceSettingsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~UpdateInstanceSettingsRequest() = default;
};
class UpdateInstanceSettingsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateInstanceSettingsResponseBody() {}

  explicit UpdateInstanceSettingsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateInstanceSettingsResponseBody() = default;
};
class UpdateInstanceSettingsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateInstanceSettingsResponseBody> body{};

  UpdateInstanceSettingsResponse() {}

  explicit UpdateInstanceSettingsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateInstanceSettingsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateInstanceSettingsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateInstanceSettingsResponse() = default;
};
class UpdateKibanaSettingsRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};

  UpdateKibanaSettingsRequest() {}

  explicit UpdateKibanaSettingsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~UpdateKibanaSettingsRequest() = default;
};
class UpdateKibanaSettingsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  UpdateKibanaSettingsResponseBody() {}

  explicit UpdateKibanaSettingsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~UpdateKibanaSettingsResponseBody() = default;
};
class UpdateKibanaSettingsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateKibanaSettingsResponseBody> body{};

  UpdateKibanaSettingsResponse() {}

  explicit UpdateKibanaSettingsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateKibanaSettingsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateKibanaSettingsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateKibanaSettingsResponse() = default;
};
class UpdateKibanaWhiteIpsRequestWhiteIpGroup : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<vector<string>> ips{};
  shared_ptr<string> whiteIpType{};

  UpdateKibanaWhiteIpsRequestWhiteIpGroup() {}

  explicit UpdateKibanaWhiteIpsRequestWhiteIpGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["groupName"] = boost::any(*groupName);
    }
    if (ips) {
      res["ips"] = boost::any(*ips);
    }
    if (whiteIpType) {
      res["whiteIpType"] = boost::any(*whiteIpType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("groupName") != m.end() && !m["groupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["groupName"]));
    }
    if (m.find("ips") != m.end() && !m["ips"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ips"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ips"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ips = make_shared<vector<string>>(toVec1);
    }
    if (m.find("whiteIpType") != m.end() && !m["whiteIpType"].empty()) {
      whiteIpType = make_shared<string>(boost::any_cast<string>(m["whiteIpType"]));
    }
  }


  virtual ~UpdateKibanaWhiteIpsRequestWhiteIpGroup() = default;
};
class UpdateKibanaWhiteIpsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> kibanaIPWhitelist{};
  shared_ptr<UpdateKibanaWhiteIpsRequestWhiteIpGroup> whiteIpGroup{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> modifyMode{};

  UpdateKibanaWhiteIpsRequest() {}

  explicit UpdateKibanaWhiteIpsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (kibanaIPWhitelist) {
      res["kibanaIPWhitelist"] = boost::any(*kibanaIPWhitelist);
    }
    if (whiteIpGroup) {
      res["whiteIpGroup"] = whiteIpGroup ? boost::any(whiteIpGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (modifyMode) {
      res["modifyMode"] = boost::any(*modifyMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("kibanaIPWhitelist") != m.end() && !m["kibanaIPWhitelist"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["kibanaIPWhitelist"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["kibanaIPWhitelist"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      kibanaIPWhitelist = make_shared<vector<string>>(toVec1);
    }
    if (m.find("whiteIpGroup") != m.end() && !m["whiteIpGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["whiteIpGroup"].type()) {
        UpdateKibanaWhiteIpsRequestWhiteIpGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["whiteIpGroup"]));
        whiteIpGroup = make_shared<UpdateKibanaWhiteIpsRequestWhiteIpGroup>(model1);
      }
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("modifyMode") != m.end() && !m["modifyMode"].empty()) {
      modifyMode = make_shared<string>(boost::any_cast<string>(m["modifyMode"]));
    }
  }


  virtual ~UpdateKibanaWhiteIpsRequest() = default;
};
class UpdateKibanaWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<vector<string>> ips{};
  shared_ptr<string> whiteIpType{};

  UpdateKibanaWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList() {}

  explicit UpdateKibanaWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["groupName"] = boost::any(*groupName);
    }
    if (ips) {
      res["ips"] = boost::any(*ips);
    }
    if (whiteIpType) {
      res["whiteIpType"] = boost::any(*whiteIpType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("groupName") != m.end() && !m["groupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["groupName"]));
    }
    if (m.find("ips") != m.end() && !m["ips"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ips"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ips"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ips = make_shared<vector<string>>(toVec1);
    }
    if (m.find("whiteIpType") != m.end() && !m["whiteIpType"].empty()) {
      whiteIpType = make_shared<string>(boost::any_cast<string>(m["whiteIpType"]));
    }
  }


  virtual ~UpdateKibanaWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList() = default;
};
class UpdateKibanaWhiteIpsResponseBodyResultNetworkConfig : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> vpcId{};
  shared_ptr<string> vsArea{};
  shared_ptr<string> vswitchId{};
  shared_ptr<vector<UpdateKibanaWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList>> whiteIpGroupList{};

  UpdateKibanaWhiteIpsResponseBodyResultNetworkConfig() {}

  explicit UpdateKibanaWhiteIpsResponseBodyResultNetworkConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (vpcId) {
      res["vpcId"] = boost::any(*vpcId);
    }
    if (vsArea) {
      res["vsArea"] = boost::any(*vsArea);
    }
    if (vswitchId) {
      res["vswitchId"] = boost::any(*vswitchId);
    }
    if (whiteIpGroupList) {
      vector<boost::any> temp1;
      for(auto item1:*whiteIpGroupList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["whiteIpGroupList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("vpcId") != m.end() && !m["vpcId"].empty()) {
      vpcId = make_shared<string>(boost::any_cast<string>(m["vpcId"]));
    }
    if (m.find("vsArea") != m.end() && !m["vsArea"].empty()) {
      vsArea = make_shared<string>(boost::any_cast<string>(m["vsArea"]));
    }
    if (m.find("vswitchId") != m.end() && !m["vswitchId"].empty()) {
      vswitchId = make_shared<string>(boost::any_cast<string>(m["vswitchId"]));
    }
    if (m.find("whiteIpGroupList") != m.end() && !m["whiteIpGroupList"].empty()) {
      if (typeid(vector<boost::any>) == m["whiteIpGroupList"].type()) {
        vector<UpdateKibanaWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["whiteIpGroupList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateKibanaWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        whiteIpGroupList = make_shared<vector<UpdateKibanaWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList>>(expect1);
      }
    }
  }


  virtual ~UpdateKibanaWhiteIpsResponseBodyResultNetworkConfig() = default;
};
class UpdateKibanaWhiteIpsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<string>> kibanaIPWhitelist{};
  shared_ptr<vector<string>> kibanaPrivateIPWhitelist{};
  shared_ptr<UpdateKibanaWhiteIpsResponseBodyResultNetworkConfig> networkConfig{};

  UpdateKibanaWhiteIpsResponseBodyResult() {}

  explicit UpdateKibanaWhiteIpsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (kibanaIPWhitelist) {
      res["kibanaIPWhitelist"] = boost::any(*kibanaIPWhitelist);
    }
    if (kibanaPrivateIPWhitelist) {
      res["kibanaPrivateIPWhitelist"] = boost::any(*kibanaPrivateIPWhitelist);
    }
    if (networkConfig) {
      res["networkConfig"] = networkConfig ? boost::any(networkConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("kibanaIPWhitelist") != m.end() && !m["kibanaIPWhitelist"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["kibanaIPWhitelist"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["kibanaIPWhitelist"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      kibanaIPWhitelist = make_shared<vector<string>>(toVec1);
    }
    if (m.find("kibanaPrivateIPWhitelist") != m.end() && !m["kibanaPrivateIPWhitelist"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["kibanaPrivateIPWhitelist"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["kibanaPrivateIPWhitelist"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      kibanaPrivateIPWhitelist = make_shared<vector<string>>(toVec1);
    }
    if (m.find("networkConfig") != m.end() && !m["networkConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["networkConfig"].type()) {
        UpdateKibanaWhiteIpsResponseBodyResultNetworkConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["networkConfig"]));
        networkConfig = make_shared<UpdateKibanaWhiteIpsResponseBodyResultNetworkConfig>(model1);
      }
    }
  }


  virtual ~UpdateKibanaWhiteIpsResponseBodyResult() = default;
};
class UpdateKibanaWhiteIpsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateKibanaWhiteIpsResponseBodyResult> result{};

  UpdateKibanaWhiteIpsResponseBody() {}

  explicit UpdateKibanaWhiteIpsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        UpdateKibanaWhiteIpsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<UpdateKibanaWhiteIpsResponseBodyResult>(model1);
      }
    }
  }


  virtual ~UpdateKibanaWhiteIpsResponseBody() = default;
};
class UpdateKibanaWhiteIpsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateKibanaWhiteIpsResponseBody> body{};

  UpdateKibanaWhiteIpsResponse() {}

  explicit UpdateKibanaWhiteIpsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateKibanaWhiteIpsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateKibanaWhiteIpsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateKibanaWhiteIpsResponse() = default;
};
class UpdateLogstashRequestNodeSpec : public Darabonba::Model {
public:
  shared_ptr<long> disk{};
  shared_ptr<string> diskType{};
  shared_ptr<string> spec{};

  UpdateLogstashRequestNodeSpec() {}

  explicit UpdateLogstashRequestNodeSpec(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (disk) {
      res["disk"] = boost::any(*disk);
    }
    if (diskType) {
      res["diskType"] = boost::any(*diskType);
    }
    if (spec) {
      res["spec"] = boost::any(*spec);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("disk") != m.end() && !m["disk"].empty()) {
      disk = make_shared<long>(boost::any_cast<long>(m["disk"]));
    }
    if (m.find("diskType") != m.end() && !m["diskType"].empty()) {
      diskType = make_shared<string>(boost::any_cast<string>(m["diskType"]));
    }
    if (m.find("spec") != m.end() && !m["spec"].empty()) {
      spec = make_shared<string>(boost::any_cast<string>(m["spec"]));
    }
  }


  virtual ~UpdateLogstashRequestNodeSpec() = default;
};
class UpdateLogstashRequest : public Darabonba::Model {
public:
  shared_ptr<long> nodeAmount{};
  shared_ptr<UpdateLogstashRequestNodeSpec> nodeSpec{};
  shared_ptr<string> clientToken{};

  UpdateLogstashRequest() {}

  explicit UpdateLogstashRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (nodeAmount) {
      res["nodeAmount"] = boost::any(*nodeAmount);
    }
    if (nodeSpec) {
      res["nodeSpec"] = nodeSpec ? boost::any(nodeSpec->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("nodeAmount") != m.end() && !m["nodeAmount"].empty()) {
      nodeAmount = make_shared<long>(boost::any_cast<long>(m["nodeAmount"]));
    }
    if (m.find("nodeSpec") != m.end() && !m["nodeSpec"].empty()) {
      if (typeid(map<string, boost::any>) == m["nodeSpec"].type()) {
        UpdateLogstashRequestNodeSpec model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["nodeSpec"]));
        nodeSpec = make_shared<UpdateLogstashRequestNodeSpec>(model1);
      }
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~UpdateLogstashRequest() = default;
};
class UpdateLogstashResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  UpdateLogstashResponseBody() {}

  explicit UpdateLogstashResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~UpdateLogstashResponseBody() = default;
};
class UpdateLogstashResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLogstashResponseBody> body{};

  UpdateLogstashResponse() {}

  explicit UpdateLogstashResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLogstashResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLogstashResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLogstashResponse() = default;
};
class UpdateLogstashChargeTypeRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};

  UpdateLogstashChargeTypeRequest() {}

  explicit UpdateLogstashChargeTypeRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~UpdateLogstashChargeTypeRequest() = default;
};
class UpdateLogstashChargeTypeResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  UpdateLogstashChargeTypeResponseBody() {}

  explicit UpdateLogstashChargeTypeResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~UpdateLogstashChargeTypeResponseBody() = default;
};
class UpdateLogstashChargeTypeResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLogstashChargeTypeResponseBody> body{};

  UpdateLogstashChargeTypeResponse() {}

  explicit UpdateLogstashChargeTypeResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLogstashChargeTypeResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLogstashChargeTypeResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLogstashChargeTypeResponse() = default;
};
class UpdateLogstashDescriptionRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};

  UpdateLogstashDescriptionRequest() {}

  explicit UpdateLogstashDescriptionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~UpdateLogstashDescriptionRequest() = default;
};
class UpdateLogstashDescriptionResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> description{};

  UpdateLogstashDescriptionResponseBodyResult() {}

  explicit UpdateLogstashDescriptionResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (description) {
      res["description"] = boost::any(*description);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("description") != m.end() && !m["description"].empty()) {
      description = make_shared<string>(boost::any_cast<string>(m["description"]));
    }
  }


  virtual ~UpdateLogstashDescriptionResponseBodyResult() = default;
};
class UpdateLogstashDescriptionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateLogstashDescriptionResponseBodyResult> result{};

  UpdateLogstashDescriptionResponseBody() {}

  explicit UpdateLogstashDescriptionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        UpdateLogstashDescriptionResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<UpdateLogstashDescriptionResponseBodyResult>(model1);
      }
    }
  }


  virtual ~UpdateLogstashDescriptionResponseBody() = default;
};
class UpdateLogstashDescriptionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLogstashDescriptionResponseBody> body{};

  UpdateLogstashDescriptionResponse() {}

  explicit UpdateLogstashDescriptionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLogstashDescriptionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLogstashDescriptionResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLogstashDescriptionResponse() = default;
};
class UpdateLogstashSettingsRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};

  UpdateLogstashSettingsRequest() {}

  explicit UpdateLogstashSettingsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~UpdateLogstashSettingsRequest() = default;
};
class UpdateLogstashSettingsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};

  UpdateLogstashSettingsResponseBody() {}

  explicit UpdateLogstashSettingsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
  }


  virtual ~UpdateLogstashSettingsResponseBody() = default;
};
class UpdateLogstashSettingsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateLogstashSettingsResponseBody> body{};

  UpdateLogstashSettingsResponse() {}

  explicit UpdateLogstashSettingsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateLogstashSettingsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateLogstashSettingsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateLogstashSettingsResponse() = default;
};
class UpdatePipelineManagementConfigRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> endpoints{};
  shared_ptr<string> password{};
  shared_ptr<vector<string>> pipelineIds{};
  shared_ptr<string> pipelineManagementType{};
  shared_ptr<string> userName{};
  shared_ptr<string> clientToken{};

  UpdatePipelineManagementConfigRequest() {}

  explicit UpdatePipelineManagementConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (endpoints) {
      res["endpoints"] = boost::any(*endpoints);
    }
    if (password) {
      res["password"] = boost::any(*password);
    }
    if (pipelineIds) {
      res["pipelineIds"] = boost::any(*pipelineIds);
    }
    if (pipelineManagementType) {
      res["pipelineManagementType"] = boost::any(*pipelineManagementType);
    }
    if (userName) {
      res["userName"] = boost::any(*userName);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("endpoints") != m.end() && !m["endpoints"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["endpoints"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["endpoints"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endpoints = make_shared<vector<string>>(toVec1);
    }
    if (m.find("password") != m.end() && !m["password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["password"]));
    }
    if (m.find("pipelineIds") != m.end() && !m["pipelineIds"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["pipelineIds"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["pipelineIds"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      pipelineIds = make_shared<vector<string>>(toVec1);
    }
    if (m.find("pipelineManagementType") != m.end() && !m["pipelineManagementType"].empty()) {
      pipelineManagementType = make_shared<string>(boost::any_cast<string>(m["pipelineManagementType"]));
    }
    if (m.find("userName") != m.end() && !m["userName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["userName"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~UpdatePipelineManagementConfigRequest() = default;
};
class UpdatePipelineManagementConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  UpdatePipelineManagementConfigResponseBody() {}

  explicit UpdatePipelineManagementConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~UpdatePipelineManagementConfigResponseBody() = default;
};
class UpdatePipelineManagementConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePipelineManagementConfigResponseBody> body{};

  UpdatePipelineManagementConfigResponse() {}

  explicit UpdatePipelineManagementConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePipelineManagementConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePipelineManagementConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePipelineManagementConfigResponse() = default;
};
class UpdatePipelinesRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> trigger{};

  UpdatePipelinesRequest() {}

  explicit UpdatePipelinesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (trigger) {
      res["trigger"] = boost::any(*trigger);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("trigger") != m.end() && !m["trigger"].empty()) {
      trigger = make_shared<bool>(boost::any_cast<bool>(m["trigger"]));
    }
  }


  virtual ~UpdatePipelinesRequest() = default;
};
class UpdatePipelinesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  UpdatePipelinesResponseBody() {}

  explicit UpdatePipelinesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~UpdatePipelinesResponseBody() = default;
};
class UpdatePipelinesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePipelinesResponseBody> body{};

  UpdatePipelinesResponse() {}

  explicit UpdatePipelinesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePipelinesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePipelinesResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePipelinesResponse() = default;
};
class UpdatePrivateNetworkWhiteIpsRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> modifyMode{};

  UpdatePrivateNetworkWhiteIpsRequest() {}

  explicit UpdatePrivateNetworkWhiteIpsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (modifyMode) {
      res["modifyMode"] = boost::any(*modifyMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("modifyMode") != m.end() && !m["modifyMode"].empty()) {
      modifyMode = make_shared<string>(boost::any_cast<string>(m["modifyMode"]));
    }
  }


  virtual ~UpdatePrivateNetworkWhiteIpsRequest() = default;
};
class UpdatePrivateNetworkWhiteIpsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<string>> privateNetworkIpWhiteList{};

  UpdatePrivateNetworkWhiteIpsResponseBodyResult() {}

  explicit UpdatePrivateNetworkWhiteIpsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (privateNetworkIpWhiteList) {
      res["privateNetworkIpWhiteList"] = boost::any(*privateNetworkIpWhiteList);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("privateNetworkIpWhiteList") != m.end() && !m["privateNetworkIpWhiteList"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["privateNetworkIpWhiteList"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["privateNetworkIpWhiteList"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      privateNetworkIpWhiteList = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdatePrivateNetworkWhiteIpsResponseBodyResult() = default;
};
class UpdatePrivateNetworkWhiteIpsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdatePrivateNetworkWhiteIpsResponseBodyResult> result{};

  UpdatePrivateNetworkWhiteIpsResponseBody() {}

  explicit UpdatePrivateNetworkWhiteIpsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        UpdatePrivateNetworkWhiteIpsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<UpdatePrivateNetworkWhiteIpsResponseBodyResult>(model1);
      }
    }
  }


  virtual ~UpdatePrivateNetworkWhiteIpsResponseBody() = default;
};
class UpdatePrivateNetworkWhiteIpsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePrivateNetworkWhiteIpsResponseBody> body{};

  UpdatePrivateNetworkWhiteIpsResponse() {}

  explicit UpdatePrivateNetworkWhiteIpsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePrivateNetworkWhiteIpsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePrivateNetworkWhiteIpsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePrivateNetworkWhiteIpsResponse() = default;
};
class UpdatePublicNetworkRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};

  UpdatePublicNetworkRequest() {}

  explicit UpdatePublicNetworkRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~UpdatePublicNetworkRequest() = default;
};
class UpdatePublicNetworkResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> enablePublic{};

  UpdatePublicNetworkResponseBodyResult() {}

  explicit UpdatePublicNetworkResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enablePublic) {
      res["enablePublic"] = boost::any(*enablePublic);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enablePublic") != m.end() && !m["enablePublic"].empty()) {
      enablePublic = make_shared<bool>(boost::any_cast<bool>(m["enablePublic"]));
    }
  }


  virtual ~UpdatePublicNetworkResponseBodyResult() = default;
};
class UpdatePublicNetworkResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdatePublicNetworkResponseBodyResult> result{};

  UpdatePublicNetworkResponseBody() {}

  explicit UpdatePublicNetworkResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        UpdatePublicNetworkResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<UpdatePublicNetworkResponseBodyResult>(model1);
      }
    }
  }


  virtual ~UpdatePublicNetworkResponseBody() = default;
};
class UpdatePublicNetworkResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePublicNetworkResponseBody> body{};

  UpdatePublicNetworkResponse() {}

  explicit UpdatePublicNetworkResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePublicNetworkResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePublicNetworkResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePublicNetworkResponse() = default;
};
class UpdatePublicWhiteIpsRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> modifyMode{};

  UpdatePublicWhiteIpsRequest() {}

  explicit UpdatePublicWhiteIpsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (modifyMode) {
      res["modifyMode"] = boost::any(*modifyMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("modifyMode") != m.end() && !m["modifyMode"].empty()) {
      modifyMode = make_shared<string>(boost::any_cast<string>(m["modifyMode"]));
    }
  }


  virtual ~UpdatePublicWhiteIpsRequest() = default;
};
class UpdatePublicWhiteIpsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<string>> publicIpWhitelist{};

  UpdatePublicWhiteIpsResponseBodyResult() {}

  explicit UpdatePublicWhiteIpsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (publicIpWhitelist) {
      res["publicIpWhitelist"] = boost::any(*publicIpWhitelist);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("publicIpWhitelist") != m.end() && !m["publicIpWhitelist"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["publicIpWhitelist"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["publicIpWhitelist"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      publicIpWhitelist = make_shared<vector<string>>(toVec1);
    }
  }


  virtual ~UpdatePublicWhiteIpsResponseBodyResult() = default;
};
class UpdatePublicWhiteIpsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdatePublicWhiteIpsResponseBodyResult> result{};

  UpdatePublicWhiteIpsResponseBody() {}

  explicit UpdatePublicWhiteIpsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        UpdatePublicWhiteIpsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<UpdatePublicWhiteIpsResponseBodyResult>(model1);
      }
    }
  }


  virtual ~UpdatePublicWhiteIpsResponseBody() = default;
};
class UpdatePublicWhiteIpsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdatePublicWhiteIpsResponseBody> body{};

  UpdatePublicWhiteIpsResponse() {}

  explicit UpdatePublicWhiteIpsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdatePublicWhiteIpsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdatePublicWhiteIpsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdatePublicWhiteIpsResponse() = default;
};
class UpdateReadWritePolicyRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> body{};

  UpdateReadWritePolicyRequest() {}

  explicit UpdateReadWritePolicyRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~UpdateReadWritePolicyRequest() = default;
};
class UpdateReadWritePolicyResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  UpdateReadWritePolicyResponseBody() {}

  explicit UpdateReadWritePolicyResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~UpdateReadWritePolicyResponseBody() = default;
};
class UpdateReadWritePolicyResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateReadWritePolicyResponseBody> body{};

  UpdateReadWritePolicyResponse() {}

  explicit UpdateReadWritePolicyResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateReadWritePolicyResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateReadWritePolicyResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateReadWritePolicyResponse() = default;
};
class UpdateSnapshotSettingRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};

  UpdateSnapshotSettingRequest() {}

  explicit UpdateSnapshotSettingRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~UpdateSnapshotSettingRequest() = default;
};
class UpdateSnapshotSettingResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<bool> enable{};
  shared_ptr<string> quartzRegex{};

  UpdateSnapshotSettingResponseBodyResult() {}

  explicit UpdateSnapshotSettingResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    if (quartzRegex) {
      res["quartzRegex"] = boost::any(*quartzRegex);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
    if (m.find("quartzRegex") != m.end() && !m["quartzRegex"].empty()) {
      quartzRegex = make_shared<string>(boost::any_cast<string>(m["quartzRegex"]));
    }
  }


  virtual ~UpdateSnapshotSettingResponseBodyResult() = default;
};
class UpdateSnapshotSettingResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateSnapshotSettingResponseBodyResult> result{};

  UpdateSnapshotSettingResponseBody() {}

  explicit UpdateSnapshotSettingResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        UpdateSnapshotSettingResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<UpdateSnapshotSettingResponseBodyResult>(model1);
      }
    }
  }


  virtual ~UpdateSnapshotSettingResponseBody() = default;
};
class UpdateSnapshotSettingResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSnapshotSettingResponseBody> body{};

  UpdateSnapshotSettingResponse() {}

  explicit UpdateSnapshotSettingResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSnapshotSettingResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSnapshotSettingResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSnapshotSettingResponse() = default;
};
class UpdateSynonymsDictsRequest : public Darabonba::Model {
public:
  shared_ptr<string> body{};
  shared_ptr<string> clientToken{};

  UpdateSynonymsDictsRequest() {}

  explicit UpdateSynonymsDictsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      res["body"] = boost::any(*body);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~UpdateSynonymsDictsRequest() = default;
};
class UpdateSynonymsDictsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<long> fileSize{};
  shared_ptr<string> name{};
  shared_ptr<string> sourceType{};
  shared_ptr<string> type{};

  UpdateSynonymsDictsResponseBodyResult() {}

  explicit UpdateSynonymsDictsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (fileSize) {
      res["fileSize"] = boost::any(*fileSize);
    }
    if (name) {
      res["name"] = boost::any(*name);
    }
    if (sourceType) {
      res["sourceType"] = boost::any(*sourceType);
    }
    if (type) {
      res["type"] = boost::any(*type);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("fileSize") != m.end() && !m["fileSize"].empty()) {
      fileSize = make_shared<long>(boost::any_cast<long>(m["fileSize"]));
    }
    if (m.find("name") != m.end() && !m["name"].empty()) {
      name = make_shared<string>(boost::any_cast<string>(m["name"]));
    }
    if (m.find("sourceType") != m.end() && !m["sourceType"].empty()) {
      sourceType = make_shared<string>(boost::any_cast<string>(m["sourceType"]));
    }
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
  }


  virtual ~UpdateSynonymsDictsResponseBodyResult() = default;
};
class UpdateSynonymsDictsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<UpdateSynonymsDictsResponseBodyResult>> result{};

  UpdateSynonymsDictsResponseBody() {}

  explicit UpdateSynonymsDictsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<UpdateSynonymsDictsResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateSynonymsDictsResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<UpdateSynonymsDictsResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~UpdateSynonymsDictsResponseBody() = default;
};
class UpdateSynonymsDictsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateSynonymsDictsResponseBody> body{};

  UpdateSynonymsDictsResponse() {}

  explicit UpdateSynonymsDictsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateSynonymsDictsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateSynonymsDictsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateSynonymsDictsResponse() = default;
};
class UpdateTemplateRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> body{};

  UpdateTemplateRequest() {}

  explicit UpdateTemplateRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~UpdateTemplateRequest() = default;
};
class UpdateTemplateResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  UpdateTemplateResponseBody() {}

  explicit UpdateTemplateResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~UpdateTemplateResponseBody() = default;
};
class UpdateTemplateResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateTemplateResponseBody> body{};

  UpdateTemplateResponse() {}

  explicit UpdateTemplateResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateTemplateResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateTemplateResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateTemplateResponse() = default;
};
class UpdateWhiteIpsRequestWhiteIpGroup : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<vector<string>> ips{};
  shared_ptr<string> whiteIpType{};

  UpdateWhiteIpsRequestWhiteIpGroup() {}

  explicit UpdateWhiteIpsRequestWhiteIpGroup(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["groupName"] = boost::any(*groupName);
    }
    if (ips) {
      res["ips"] = boost::any(*ips);
    }
    if (whiteIpType) {
      res["whiteIpType"] = boost::any(*whiteIpType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("groupName") != m.end() && !m["groupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["groupName"]));
    }
    if (m.find("ips") != m.end() && !m["ips"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ips"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ips"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ips = make_shared<vector<string>>(toVec1);
    }
    if (m.find("whiteIpType") != m.end() && !m["whiteIpType"].empty()) {
      whiteIpType = make_shared<string>(boost::any_cast<string>(m["whiteIpType"]));
    }
  }


  virtual ~UpdateWhiteIpsRequestWhiteIpGroup() = default;
};
class UpdateWhiteIpsRequest : public Darabonba::Model {
public:
  shared_ptr<vector<string>> esIPWhitelist{};
  shared_ptr<UpdateWhiteIpsRequestWhiteIpGroup> whiteIpGroup{};
  shared_ptr<string> clientToken{};
  shared_ptr<string> modifyMode{};

  UpdateWhiteIpsRequest() {}

  explicit UpdateWhiteIpsRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (esIPWhitelist) {
      res["esIPWhitelist"] = boost::any(*esIPWhitelist);
    }
    if (whiteIpGroup) {
      res["whiteIpGroup"] = whiteIpGroup ? boost::any(whiteIpGroup->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (modifyMode) {
      res["modifyMode"] = boost::any(*modifyMode);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("esIPWhitelist") != m.end() && !m["esIPWhitelist"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["esIPWhitelist"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["esIPWhitelist"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      esIPWhitelist = make_shared<vector<string>>(toVec1);
    }
    if (m.find("whiteIpGroup") != m.end() && !m["whiteIpGroup"].empty()) {
      if (typeid(map<string, boost::any>) == m["whiteIpGroup"].type()) {
        UpdateWhiteIpsRequestWhiteIpGroup model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["whiteIpGroup"]));
        whiteIpGroup = make_shared<UpdateWhiteIpsRequestWhiteIpGroup>(model1);
      }
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("modifyMode") != m.end() && !m["modifyMode"].empty()) {
      modifyMode = make_shared<string>(boost::any_cast<string>(m["modifyMode"]));
    }
  }


  virtual ~UpdateWhiteIpsRequest() = default;
};
class UpdateWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList : public Darabonba::Model {
public:
  shared_ptr<string> groupName{};
  shared_ptr<vector<string>> ips{};
  shared_ptr<string> whiteIpType{};

  UpdateWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList() {}

  explicit UpdateWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (groupName) {
      res["groupName"] = boost::any(*groupName);
    }
    if (ips) {
      res["ips"] = boost::any(*ips);
    }
    if (whiteIpType) {
      res["whiteIpType"] = boost::any(*whiteIpType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("groupName") != m.end() && !m["groupName"].empty()) {
      groupName = make_shared<string>(boost::any_cast<string>(m["groupName"]));
    }
    if (m.find("ips") != m.end() && !m["ips"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["ips"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["ips"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      ips = make_shared<vector<string>>(toVec1);
    }
    if (m.find("whiteIpType") != m.end() && !m["whiteIpType"].empty()) {
      whiteIpType = make_shared<string>(boost::any_cast<string>(m["whiteIpType"]));
    }
  }


  virtual ~UpdateWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList() = default;
};
class UpdateWhiteIpsResponseBodyResultNetworkConfig : public Darabonba::Model {
public:
  shared_ptr<vector<UpdateWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList>> whiteIpGroupList{};

  UpdateWhiteIpsResponseBodyResultNetworkConfig() {}

  explicit UpdateWhiteIpsResponseBodyResultNetworkConfig(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (whiteIpGroupList) {
      vector<boost::any> temp1;
      for(auto item1:*whiteIpGroupList){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["whiteIpGroupList"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("whiteIpGroupList") != m.end() && !m["whiteIpGroupList"].empty()) {
      if (typeid(vector<boost::any>) == m["whiteIpGroupList"].type()) {
        vector<UpdateWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["whiteIpGroupList"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpdateWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        whiteIpGroupList = make_shared<vector<UpdateWhiteIpsResponseBodyResultNetworkConfigWhiteIpGroupList>>(expect1);
      }
    }
  }


  virtual ~UpdateWhiteIpsResponseBodyResultNetworkConfig() = default;
};
class UpdateWhiteIpsResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<vector<string>> esIPWhitelist{};
  shared_ptr<UpdateWhiteIpsResponseBodyResultNetworkConfig> networkConfig{};

  UpdateWhiteIpsResponseBodyResult() {}

  explicit UpdateWhiteIpsResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (esIPWhitelist) {
      res["esIPWhitelist"] = boost::any(*esIPWhitelist);
    }
    if (networkConfig) {
      res["networkConfig"] = networkConfig ? boost::any(networkConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("esIPWhitelist") != m.end() && !m["esIPWhitelist"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["esIPWhitelist"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["esIPWhitelist"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      esIPWhitelist = make_shared<vector<string>>(toVec1);
    }
    if (m.find("networkConfig") != m.end() && !m["networkConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["networkConfig"].type()) {
        UpdateWhiteIpsResponseBodyResultNetworkConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["networkConfig"]));
        networkConfig = make_shared<UpdateWhiteIpsResponseBodyResultNetworkConfig>(model1);
      }
    }
  }


  virtual ~UpdateWhiteIpsResponseBodyResult() = default;
};
class UpdateWhiteIpsResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<UpdateWhiteIpsResponseBodyResult> result{};

  UpdateWhiteIpsResponseBody() {}

  explicit UpdateWhiteIpsResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        UpdateWhiteIpsResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<UpdateWhiteIpsResponseBodyResult>(model1);
      }
    }
  }


  virtual ~UpdateWhiteIpsResponseBody() = default;
};
class UpdateWhiteIpsResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateWhiteIpsResponseBody> body{};

  UpdateWhiteIpsResponse() {}

  explicit UpdateWhiteIpsResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateWhiteIpsResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateWhiteIpsResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateWhiteIpsResponse() = default;
};
class UpdateXpackMonitorConfigRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<bool> enable{};
  shared_ptr<vector<string>> endpoints{};
  shared_ptr<string> password{};
  shared_ptr<string> userName{};

  UpdateXpackMonitorConfigRequest() {}

  explicit UpdateXpackMonitorConfigRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (enable) {
      res["enable"] = boost::any(*enable);
    }
    if (endpoints) {
      res["endpoints"] = boost::any(*endpoints);
    }
    if (password) {
      res["password"] = boost::any(*password);
    }
    if (userName) {
      res["userName"] = boost::any(*userName);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("enable") != m.end() && !m["enable"].empty()) {
      enable = make_shared<bool>(boost::any_cast<bool>(m["enable"]));
    }
    if (m.find("endpoints") != m.end() && !m["endpoints"].empty()) {
      vector<string> toVec1;
      if (typeid(vector<boost::any>) == m["endpoints"].type()) {
        vector<boost::any> vec1 = boost::any_cast<vector<boost::any>>(m["endpoints"]);
        for (auto item:vec1) {
           toVec1.push_back(boost::any_cast<string>(item));
        }
      }
      endpoints = make_shared<vector<string>>(toVec1);
    }
    if (m.find("password") != m.end() && !m["password"].empty()) {
      password = make_shared<string>(boost::any_cast<string>(m["password"]));
    }
    if (m.find("userName") != m.end() && !m["userName"].empty()) {
      userName = make_shared<string>(boost::any_cast<string>(m["userName"]));
    }
  }


  virtual ~UpdateXpackMonitorConfigRequest() = default;
};
class UpdateXpackMonitorConfigResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  UpdateXpackMonitorConfigResponseBody() {}

  explicit UpdateXpackMonitorConfigResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~UpdateXpackMonitorConfigResponseBody() = default;
};
class UpdateXpackMonitorConfigResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpdateXpackMonitorConfigResponseBody> body{};

  UpdateXpackMonitorConfigResponse() {}

  explicit UpdateXpackMonitorConfigResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpdateXpackMonitorConfigResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpdateXpackMonitorConfigResponseBody>(model1);
      }
    }
  }


  virtual ~UpdateXpackMonitorConfigResponse() = default;
};
class UpgradeEngineVersionRequest : public Darabonba::Model {
public:
  shared_ptr<string> type{};
  shared_ptr<string> version{};
  shared_ptr<string> clientToken{};
  shared_ptr<bool> dryRun{};

  UpgradeEngineVersionRequest() {}

  explicit UpgradeEngineVersionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (type) {
      res["type"] = boost::any(*type);
    }
    if (version) {
      res["version"] = boost::any(*version);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    if (dryRun) {
      res["dryRun"] = boost::any(*dryRun);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("type") != m.end() && !m["type"].empty()) {
      type = make_shared<string>(boost::any_cast<string>(m["type"]));
    }
    if (m.find("version") != m.end() && !m["version"].empty()) {
      version = make_shared<string>(boost::any_cast<string>(m["version"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
    if (m.find("dryRun") != m.end() && !m["dryRun"].empty()) {
      dryRun = make_shared<bool>(boost::any_cast<bool>(m["dryRun"]));
    }
  }


  virtual ~UpgradeEngineVersionRequest() = default;
};
class UpgradeEngineVersionResponseBodyResultValidateResult : public Darabonba::Model {
public:
  shared_ptr<string> errorCode{};
  shared_ptr<string> errorMsg{};
  shared_ptr<string> errorType{};

  UpgradeEngineVersionResponseBodyResultValidateResult() {}

  explicit UpgradeEngineVersionResponseBodyResultValidateResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (errorCode) {
      res["errorCode"] = boost::any(*errorCode);
    }
    if (errorMsg) {
      res["errorMsg"] = boost::any(*errorMsg);
    }
    if (errorType) {
      res["errorType"] = boost::any(*errorType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("errorCode") != m.end() && !m["errorCode"].empty()) {
      errorCode = make_shared<string>(boost::any_cast<string>(m["errorCode"]));
    }
    if (m.find("errorMsg") != m.end() && !m["errorMsg"].empty()) {
      errorMsg = make_shared<string>(boost::any_cast<string>(m["errorMsg"]));
    }
    if (m.find("errorType") != m.end() && !m["errorType"].empty()) {
      errorType = make_shared<string>(boost::any_cast<string>(m["errorType"]));
    }
  }


  virtual ~UpgradeEngineVersionResponseBodyResultValidateResult() = default;
};
class UpgradeEngineVersionResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> status{};
  shared_ptr<vector<UpgradeEngineVersionResponseBodyResultValidateResult>> validateResult{};
  shared_ptr<string> validateType{};

  UpgradeEngineVersionResponseBodyResult() {}

  explicit UpgradeEngineVersionResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (status) {
      res["status"] = boost::any(*status);
    }
    if (validateResult) {
      vector<boost::any> temp1;
      for(auto item1:*validateResult){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["validateResult"] = boost::any(temp1);
    }
    if (validateType) {
      res["validateType"] = boost::any(*validateType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("status") != m.end() && !m["status"].empty()) {
      status = make_shared<string>(boost::any_cast<string>(m["status"]));
    }
    if (m.find("validateResult") != m.end() && !m["validateResult"].empty()) {
      if (typeid(vector<boost::any>) == m["validateResult"].type()) {
        vector<UpgradeEngineVersionResponseBodyResultValidateResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["validateResult"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpgradeEngineVersionResponseBodyResultValidateResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        validateResult = make_shared<vector<UpgradeEngineVersionResponseBodyResultValidateResult>>(expect1);
      }
    }
    if (m.find("validateType") != m.end() && !m["validateType"].empty()) {
      validateType = make_shared<string>(boost::any_cast<string>(m["validateType"]));
    }
  }


  virtual ~UpgradeEngineVersionResponseBodyResult() = default;
};
class UpgradeEngineVersionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<vector<UpgradeEngineVersionResponseBodyResult>> result{};

  UpgradeEngineVersionResponseBody() {}

  explicit UpgradeEngineVersionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      vector<boost::any> temp1;
      for(auto item1:*result){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["Result"] = boost::any(temp1);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(vector<boost::any>) == m["Result"].type()) {
        vector<UpgradeEngineVersionResponseBodyResult> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["Result"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            UpgradeEngineVersionResponseBodyResult model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        result = make_shared<vector<UpgradeEngineVersionResponseBodyResult>>(expect1);
      }
    }
  }


  virtual ~UpgradeEngineVersionResponseBody() = default;
};
class UpgradeEngineVersionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<UpgradeEngineVersionResponseBody> body{};

  UpgradeEngineVersionResponse() {}

  explicit UpgradeEngineVersionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        UpgradeEngineVersionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<UpgradeEngineVersionResponseBody>(model1);
      }
    }
  }


  virtual ~UpgradeEngineVersionResponse() = default;
};
class ValidateConnectionRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> body{};

  ValidateConnectionRequest() {}

  explicit ValidateConnectionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (body) {
      res["body"] = boost::any(*body);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      body = make_shared<string>(boost::any_cast<string>(m["body"]));
    }
  }


  virtual ~ValidateConnectionRequest() = default;
};
class ValidateConnectionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  ValidateConnectionResponseBody() {}

  explicit ValidateConnectionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~ValidateConnectionResponseBody() = default;
};
class ValidateConnectionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ValidateConnectionResponseBody> body{};

  ValidateConnectionResponse() {}

  explicit ValidateConnectionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ValidateConnectionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ValidateConnectionResponseBody>(model1);
      }
    }
  }


  virtual ~ValidateConnectionResponse() = default;
};
class ValidateShrinkNodesRequestBody : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<string> hostName{};
  shared_ptr<string> nodeType{};
  shared_ptr<long> port{};
  shared_ptr<string> zoneId{};

  ValidateShrinkNodesRequestBody() {}

  explicit ValidateShrinkNodesRequestBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["host"] = boost::any(*host);
    }
    if (hostName) {
      res["hostName"] = boost::any(*hostName);
    }
    if (nodeType) {
      res["nodeType"] = boost::any(*nodeType);
    }
    if (port) {
      res["port"] = boost::any(*port);
    }
    if (zoneId) {
      res["zoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("host") != m.end() && !m["host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["host"]));
    }
    if (m.find("hostName") != m.end() && !m["hostName"].empty()) {
      hostName = make_shared<string>(boost::any_cast<string>(m["hostName"]));
    }
    if (m.find("nodeType") != m.end() && !m["nodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["nodeType"]));
    }
    if (m.find("port") != m.end() && !m["port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["port"]));
    }
    if (m.find("zoneId") != m.end() && !m["zoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["zoneId"]));
    }
  }


  virtual ~ValidateShrinkNodesRequestBody() = default;
};
class ValidateShrinkNodesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<ValidateShrinkNodesRequestBody>> body{};
  shared_ptr<long> count{};
  shared_ptr<bool> ignoreStatus{};
  shared_ptr<string> nodeType{};

  ValidateShrinkNodesRequest() {}

  explicit ValidateShrinkNodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      vector<boost::any> temp1;
      for(auto item1:*body){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["body"] = boost::any(temp1);
    }
    if (count) {
      res["count"] = boost::any(*count);
    }
    if (ignoreStatus) {
      res["ignoreStatus"] = boost::any(*ignoreStatus);
    }
    if (nodeType) {
      res["nodeType"] = boost::any(*nodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(vector<boost::any>) == m["body"].type()) {
        vector<ValidateShrinkNodesRequestBody> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["body"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ValidateShrinkNodesRequestBody model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        body = make_shared<vector<ValidateShrinkNodesRequestBody>>(expect1);
      }
    }
    if (m.find("count") != m.end() && !m["count"].empty()) {
      count = make_shared<long>(boost::any_cast<long>(m["count"]));
    }
    if (m.find("ignoreStatus") != m.end() && !m["ignoreStatus"].empty()) {
      ignoreStatus = make_shared<bool>(boost::any_cast<bool>(m["ignoreStatus"]));
    }
    if (m.find("nodeType") != m.end() && !m["nodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["nodeType"]));
    }
  }


  virtual ~ValidateShrinkNodesRequest() = default;
};
class ValidateShrinkNodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  ValidateShrinkNodesResponseBody() {}

  explicit ValidateShrinkNodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~ValidateShrinkNodesResponseBody() = default;
};
class ValidateShrinkNodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ValidateShrinkNodesResponseBody> body{};

  ValidateShrinkNodesResponse() {}

  explicit ValidateShrinkNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ValidateShrinkNodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ValidateShrinkNodesResponseBody>(model1);
      }
    }
  }


  virtual ~ValidateShrinkNodesResponse() = default;
};
class ValidateSlrPermissionRequest : public Darabonba::Model {
public:
  shared_ptr<string> clientToken{};
  shared_ptr<string> rolename{};

  ValidateSlrPermissionRequest() {}

  explicit ValidateSlrPermissionRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientToken) {
      res["ClientToken"] = boost::any(*clientToken);
    }
    if (rolename) {
      res["rolename"] = boost::any(*rolename);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("ClientToken") != m.end() && !m["ClientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["ClientToken"]));
    }
    if (m.find("rolename") != m.end() && !m["rolename"].empty()) {
      rolename = make_shared<string>(boost::any_cast<string>(m["rolename"]));
    }
  }


  virtual ~ValidateSlrPermissionRequest() = default;
};
class ValidateSlrPermissionResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  ValidateSlrPermissionResponseBody() {}

  explicit ValidateSlrPermissionResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~ValidateSlrPermissionResponseBody() = default;
};
class ValidateSlrPermissionResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ValidateSlrPermissionResponseBody> body{};

  ValidateSlrPermissionResponse() {}

  explicit ValidateSlrPermissionResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ValidateSlrPermissionResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ValidateSlrPermissionResponseBody>(model1);
      }
    }
  }


  virtual ~ValidateSlrPermissionResponse() = default;
};
class ValidateTransferableNodesRequestBody : public Darabonba::Model {
public:
  shared_ptr<string> host{};
  shared_ptr<long> port{};
  shared_ptr<string> zoneId{};

  ValidateTransferableNodesRequestBody() {}

  explicit ValidateTransferableNodesRequestBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (host) {
      res["host"] = boost::any(*host);
    }
    if (port) {
      res["port"] = boost::any(*port);
    }
    if (zoneId) {
      res["zoneId"] = boost::any(*zoneId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("host") != m.end() && !m["host"].empty()) {
      host = make_shared<string>(boost::any_cast<string>(m["host"]));
    }
    if (m.find("port") != m.end() && !m["port"].empty()) {
      port = make_shared<long>(boost::any_cast<long>(m["port"]));
    }
    if (m.find("zoneId") != m.end() && !m["zoneId"].empty()) {
      zoneId = make_shared<string>(boost::any_cast<string>(m["zoneId"]));
    }
  }


  virtual ~ValidateTransferableNodesRequestBody() = default;
};
class ValidateTransferableNodesRequest : public Darabonba::Model {
public:
  shared_ptr<vector<ValidateTransferableNodesRequestBody>> body{};
  shared_ptr<string> nodeType{};

  ValidateTransferableNodesRequest() {}

  explicit ValidateTransferableNodesRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (body) {
      vector<boost::any> temp1;
      for(auto item1:*body){
        temp1.push_back(boost::any(item1.toMap()));
      }
      res["body"] = boost::any(temp1);
    }
    if (nodeType) {
      res["nodeType"] = boost::any(*nodeType);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(vector<boost::any>) == m["body"].type()) {
        vector<ValidateTransferableNodesRequestBody> expect1;
        for(auto item1:boost::any_cast<vector<boost::any>>(m["body"])){
          if (typeid(map<string, boost::any>) == item1.type()) {
            ValidateTransferableNodesRequestBody model2;
            model2.fromMap(boost::any_cast<map<string, boost::any>>(item1));
            expect1.push_back(model2);
          }
        }
        body = make_shared<vector<ValidateTransferableNodesRequestBody>>(expect1);
      }
    }
    if (m.find("nodeType") != m.end() && !m["nodeType"].empty()) {
      nodeType = make_shared<string>(boost::any_cast<string>(m["nodeType"]));
    }
  }


  virtual ~ValidateTransferableNodesRequest() = default;
};
class ValidateTransferableNodesResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<bool> result{};

  ValidateTransferableNodesResponseBody() {}

  explicit ValidateTransferableNodesResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = boost::any(*result);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      result = make_shared<bool>(boost::any_cast<bool>(m["Result"]));
    }
  }


  virtual ~ValidateTransferableNodesResponseBody() = default;
};
class ValidateTransferableNodesResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<ValidateTransferableNodesResponseBody> body{};

  ValidateTransferableNodesResponse() {}

  explicit ValidateTransferableNodesResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        ValidateTransferableNodesResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<ValidateTransferableNodesResponseBody>(model1);
      }
    }
  }


  virtual ~ValidateTransferableNodesResponse() = default;
};
class CreateInstanceRequest : public Darabonba::Model {
public:
  shared_ptr<ClientNodeConfiguration> clientNodeConfiguration{};
  shared_ptr<ElasticDataNodeConfiguration> elasticDataNodeConfiguration{};
  shared_ptr<string> esAdminPassword{};
  shared_ptr<string> esVersion{};
  shared_ptr<string> instanceCategory{};
  shared_ptr<KibanaNodeConfiguration> kibanaConfiguration{};
  shared_ptr<MasterNodeConfiguration> masterConfiguration{};
  shared_ptr<NetworkConfig> networkConfig{};
  shared_ptr<long> nodeAmount{};
  shared_ptr<NodeSpec> nodeSpec{};
  shared_ptr<PaymentInfo> paymentInfo{};
  shared_ptr<string> paymentType{};
  shared_ptr<WarmNodeConfiguration> warmNodeConfiguration{};
  shared_ptr<long> zoneCount{};
  shared_ptr<string> clientToken{};

  CreateInstanceRequest() {}

  explicit CreateInstanceRequest(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (clientNodeConfiguration) {
      res["clientNodeConfiguration"] = clientNodeConfiguration ? boost::any(clientNodeConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (elasticDataNodeConfiguration) {
      res["elasticDataNodeConfiguration"] = elasticDataNodeConfiguration ? boost::any(elasticDataNodeConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (esAdminPassword) {
      res["esAdminPassword"] = boost::any(*esAdminPassword);
    }
    if (esVersion) {
      res["esVersion"] = boost::any(*esVersion);
    }
    if (instanceCategory) {
      res["instanceCategory"] = boost::any(*instanceCategory);
    }
    if (kibanaConfiguration) {
      res["kibanaConfiguration"] = kibanaConfiguration ? boost::any(kibanaConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (masterConfiguration) {
      res["masterConfiguration"] = masterConfiguration ? boost::any(masterConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (networkConfig) {
      res["networkConfig"] = networkConfig ? boost::any(networkConfig->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (nodeAmount) {
      res["nodeAmount"] = boost::any(*nodeAmount);
    }
    if (nodeSpec) {
      res["nodeSpec"] = nodeSpec ? boost::any(nodeSpec->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (paymentInfo) {
      res["paymentInfo"] = paymentInfo ? boost::any(paymentInfo->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (paymentType) {
      res["paymentType"] = boost::any(*paymentType);
    }
    if (warmNodeConfiguration) {
      res["warmNodeConfiguration"] = warmNodeConfiguration ? boost::any(warmNodeConfiguration->toMap()) : boost::any(map<string,boost::any>({}));
    }
    if (zoneCount) {
      res["zoneCount"] = boost::any(*zoneCount);
    }
    if (clientToken) {
      res["clientToken"] = boost::any(*clientToken);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("clientNodeConfiguration") != m.end() && !m["clientNodeConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["clientNodeConfiguration"].type()) {
        ClientNodeConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["clientNodeConfiguration"]));
        clientNodeConfiguration = make_shared<ClientNodeConfiguration>(model1);
      }
    }
    if (m.find("elasticDataNodeConfiguration") != m.end() && !m["elasticDataNodeConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["elasticDataNodeConfiguration"].type()) {
        ElasticDataNodeConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["elasticDataNodeConfiguration"]));
        elasticDataNodeConfiguration = make_shared<ElasticDataNodeConfiguration>(model1);
      }
    }
    if (m.find("esAdminPassword") != m.end() && !m["esAdminPassword"].empty()) {
      esAdminPassword = make_shared<string>(boost::any_cast<string>(m["esAdminPassword"]));
    }
    if (m.find("esVersion") != m.end() && !m["esVersion"].empty()) {
      esVersion = make_shared<string>(boost::any_cast<string>(m["esVersion"]));
    }
    if (m.find("instanceCategory") != m.end() && !m["instanceCategory"].empty()) {
      instanceCategory = make_shared<string>(boost::any_cast<string>(m["instanceCategory"]));
    }
    if (m.find("kibanaConfiguration") != m.end() && !m["kibanaConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["kibanaConfiguration"].type()) {
        KibanaNodeConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["kibanaConfiguration"]));
        kibanaConfiguration = make_shared<KibanaNodeConfiguration>(model1);
      }
    }
    if (m.find("masterConfiguration") != m.end() && !m["masterConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["masterConfiguration"].type()) {
        MasterNodeConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["masterConfiguration"]));
        masterConfiguration = make_shared<MasterNodeConfiguration>(model1);
      }
    }
    if (m.find("networkConfig") != m.end() && !m["networkConfig"].empty()) {
      if (typeid(map<string, boost::any>) == m["networkConfig"].type()) {
        NetworkConfig model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["networkConfig"]));
        networkConfig = make_shared<NetworkConfig>(model1);
      }
    }
    if (m.find("nodeAmount") != m.end() && !m["nodeAmount"].empty()) {
      nodeAmount = make_shared<long>(boost::any_cast<long>(m["nodeAmount"]));
    }
    if (m.find("nodeSpec") != m.end() && !m["nodeSpec"].empty()) {
      if (typeid(map<string, boost::any>) == m["nodeSpec"].type()) {
        NodeSpec model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["nodeSpec"]));
        nodeSpec = make_shared<NodeSpec>(model1);
      }
    }
    if (m.find("paymentInfo") != m.end() && !m["paymentInfo"].empty()) {
      if (typeid(map<string, boost::any>) == m["paymentInfo"].type()) {
        PaymentInfo model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["paymentInfo"]));
        paymentInfo = make_shared<PaymentInfo>(model1);
      }
    }
    if (m.find("paymentType") != m.end() && !m["paymentType"].empty()) {
      paymentType = make_shared<string>(boost::any_cast<string>(m["paymentType"]));
    }
    if (m.find("warmNodeConfiguration") != m.end() && !m["warmNodeConfiguration"].empty()) {
      if (typeid(map<string, boost::any>) == m["warmNodeConfiguration"].type()) {
        WarmNodeConfiguration model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["warmNodeConfiguration"]));
        warmNodeConfiguration = make_shared<WarmNodeConfiguration>(model1);
      }
    }
    if (m.find("zoneCount") != m.end() && !m["zoneCount"].empty()) {
      zoneCount = make_shared<long>(boost::any_cast<long>(m["zoneCount"]));
    }
    if (m.find("clientToken") != m.end() && !m["clientToken"].empty()) {
      clientToken = make_shared<string>(boost::any_cast<string>(m["clientToken"]));
    }
  }


  virtual ~CreateInstanceRequest() = default;
};
class CreateInstanceResponseBodyResult : public Darabonba::Model {
public:
  shared_ptr<string> instanceId{};

  CreateInstanceResponseBodyResult() {}

  explicit CreateInstanceResponseBodyResult(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (instanceId) {
      res["instanceId"] = boost::any(*instanceId);
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("instanceId") != m.end() && !m["instanceId"].empty()) {
      instanceId = make_shared<string>(boost::any_cast<string>(m["instanceId"]));
    }
  }


  virtual ~CreateInstanceResponseBodyResult() = default;
};
class CreateInstanceResponseBody : public Darabonba::Model {
public:
  shared_ptr<string> requestId{};
  shared_ptr<CreateInstanceResponseBodyResult> result{};

  CreateInstanceResponseBody() {}

  explicit CreateInstanceResponseBody(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {}

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (requestId) {
      res["RequestId"] = boost::any(*requestId);
    }
    if (result) {
      res["Result"] = result ? boost::any(result->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("RequestId") != m.end() && !m["RequestId"].empty()) {
      requestId = make_shared<string>(boost::any_cast<string>(m["RequestId"]));
    }
    if (m.find("Result") != m.end() && !m["Result"].empty()) {
      if (typeid(map<string, boost::any>) == m["Result"].type()) {
        CreateInstanceResponseBodyResult model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["Result"]));
        result = make_shared<CreateInstanceResponseBodyResult>(model1);
      }
    }
  }


  virtual ~CreateInstanceResponseBody() = default;
};
class CreateInstanceResponse : public Darabonba::Model {
public:
  shared_ptr<map<string, string>> headers{};
  shared_ptr<long> statusCode{};
  shared_ptr<CreateInstanceResponseBody> body{};

  CreateInstanceResponse() {}

  explicit CreateInstanceResponse(const std::map<string, boost::any> &config) : Darabonba::Model(config) {
    fromMap(config);
  };

  void validate() override {
    if (!headers) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("headers is required.")));
    }
    if (!statusCode) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("statusCode is required.")));
    }
    if (!body) {
      BOOST_THROW_EXCEPTION(boost::enable_error_info(std::runtime_error("body is required.")));
    }
  }

  map<string, boost::any> toMap() override {
    map<string, boost::any> res;
    if (headers) {
      res["headers"] = boost::any(*headers);
    }
    if (statusCode) {
      res["statusCode"] = boost::any(*statusCode);
    }
    if (body) {
      res["body"] = body ? boost::any(body->toMap()) : boost::any(map<string,boost::any>({}));
    }
    return res;
  }

  void fromMap(map<string, boost::any> m) override {
    if (m.find("headers") != m.end() && !m["headers"].empty()) {
      map<string, string> map1 = boost::any_cast<map<string, string>>(m["headers"]);
      map<string, string> toMap1;
      for (auto item:map1) {
         toMap1[item.first] = item.second;
      }
      headers = make_shared<map<string, string>>(toMap1);
    }
    if (m.find("statusCode") != m.end() && !m["statusCode"].empty()) {
      statusCode = make_shared<long>(boost::any_cast<long>(m["statusCode"]));
    }
    if (m.find("body") != m.end() && !m["body"].empty()) {
      if (typeid(map<string, boost::any>) == m["body"].type()) {
        CreateInstanceResponseBody model1;
        model1.fromMap(boost::any_cast<map<string, boost::any>>(m["body"]));
        body = make_shared<CreateInstanceResponseBody>(model1);
      }
    }
  }


  virtual ~CreateInstanceResponse() = default;
};
class Client : Alibabacloud_OpenApi::Client {
public:
  explicit Client(const shared_ptr<Alibabacloud_OpenApi::Config>& config);
  string getEndpoint(shared_ptr<string> productId,
                     shared_ptr<string> regionId,
                     shared_ptr<string> endpointRule,
                     shared_ptr<string> network,
                     shared_ptr<string> suffix,
                     shared_ptr<map<string, string>> endpointMap,
                     shared_ptr<string> endpoint);
  ActivateZonesResponse activateZones(shared_ptr<string> InstanceId, shared_ptr<ActivateZonesRequest> request);
  ActivateZonesResponse activateZonesWithOptions(shared_ptr<string> InstanceId,
                                                 shared_ptr<ActivateZonesRequest> request,
                                                 shared_ptr<map<string, string>> headers,
                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddConnectableClusterResponse addConnectableCluster(shared_ptr<string> InstanceId, shared_ptr<AddConnectableClusterRequest> request);
  AddConnectableClusterResponse addConnectableClusterWithOptions(shared_ptr<string> InstanceId,
                                                                 shared_ptr<AddConnectableClusterRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  AddSnapshotRepoResponse addSnapshotRepo(shared_ptr<string> InstanceId, shared_ptr<AddSnapshotRepoRequest> request);
  AddSnapshotRepoResponse addSnapshotRepoWithOptions(shared_ptr<string> InstanceId,
                                                     shared_ptr<AddSnapshotRepoRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelDeletionResponse cancelDeletion(shared_ptr<string> InstanceId, shared_ptr<CancelDeletionRequest> request);
  CancelDeletionResponse cancelDeletionWithOptions(shared_ptr<string> InstanceId,
                                                   shared_ptr<CancelDeletionRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelLogstashDeletionResponse cancelLogstashDeletion(shared_ptr<string> InstanceId, shared_ptr<CancelLogstashDeletionRequest> request);
  CancelLogstashDeletionResponse cancelLogstashDeletionWithOptions(shared_ptr<string> InstanceId,
                                                                   shared_ptr<CancelLogstashDeletionRequest> request,
                                                                   shared_ptr<map<string, string>> headers,
                                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CancelTaskResponse cancelTask(shared_ptr<string> InstanceId, shared_ptr<CancelTaskRequest> request);
  CancelTaskResponse cancelTaskWithOptions(shared_ptr<string> InstanceId,
                                           shared_ptr<CancelTaskRequest> request,
                                           shared_ptr<map<string, string>> headers,
                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CapacityPlanResponse capacityPlan(shared_ptr<CapacityPlanRequest> request);
  CapacityPlanResponse capacityPlanWithOptions(shared_ptr<CapacityPlanRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CloseDiagnosisResponse closeDiagnosis(shared_ptr<string> InstanceId, shared_ptr<CloseDiagnosisRequest> request);
  CloseDiagnosisResponse closeDiagnosisWithOptions(shared_ptr<string> InstanceId,
                                                   shared_ptr<CloseDiagnosisRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CloseHttpsResponse closeHttps(shared_ptr<string> InstanceId, shared_ptr<CloseHttpsRequest> request);
  CloseHttpsResponse closeHttpsWithOptions(shared_ptr<string> InstanceId,
                                           shared_ptr<CloseHttpsRequest> request,
                                           shared_ptr<map<string, string>> headers,
                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CloseManagedIndexResponse closeManagedIndex(shared_ptr<string> InstanceId, shared_ptr<string> Index, shared_ptr<CloseManagedIndexRequest> request);
  CloseManagedIndexResponse closeManagedIndexWithOptions(shared_ptr<string> InstanceId,
                                                         shared_ptr<string> Index,
                                                         shared_ptr<CloseManagedIndexRequest> request,
                                                         shared_ptr<map<string, string>> headers,
                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateCollectorResponse createCollector(shared_ptr<CreateCollectorRequest> request);
  CreateCollectorResponse createCollectorWithOptions(shared_ptr<CreateCollectorRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateComponentIndexResponse createComponentIndex(shared_ptr<string> InstanceId, shared_ptr<string> name, shared_ptr<CreateComponentIndexRequest> request);
  CreateComponentIndexResponse createComponentIndexWithOptions(shared_ptr<string> InstanceId,
                                                               shared_ptr<string> name,
                                                               shared_ptr<CreateComponentIndexRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataStreamResponse createDataStream(shared_ptr<string> InstanceId, shared_ptr<CreateDataStreamRequest> request);
  CreateDataStreamResponse createDataStreamWithOptions(shared_ptr<string> InstanceId,
                                                       shared_ptr<CreateDataStreamRequest> request,
                                                       shared_ptr<map<string, string>> headers,
                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateDataTasksResponse createDataTasks(shared_ptr<string> InstanceId, shared_ptr<CreateDataTasksRequest> request);
  CreateDataTasksResponse createDataTasksWithOptions(shared_ptr<string> InstanceId,
                                                     shared_ptr<CreateDataTasksRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateILMPolicyResponse createILMPolicy(shared_ptr<string> InstanceId, shared_ptr<CreateILMPolicyRequest> request);
  CreateILMPolicyResponse createILMPolicyWithOptions(shared_ptr<string> InstanceId,
                                                     shared_ptr<CreateILMPolicyRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateIndexTemplateResponse createIndexTemplate(shared_ptr<string> InstanceId, shared_ptr<CreateIndexTemplateRequest> request);
  CreateIndexTemplateResponse createIndexTemplateWithOptions(shared_ptr<string> InstanceId,
                                                             shared_ptr<CreateIndexTemplateRequest> request,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateLogstashResponse createLogstash(shared_ptr<CreateLogstashRequest> request);
  CreateLogstashResponse createLogstashWithOptions(shared_ptr<CreateLogstashRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreatePipelinesResponse createPipelines(shared_ptr<string> InstanceId, shared_ptr<CreatePipelinesRequest> request);
  CreatePipelinesResponse createPipelinesWithOptions(shared_ptr<string> InstanceId,
                                                     shared_ptr<CreatePipelinesRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateSnapshotResponse createSnapshot(shared_ptr<string> InstanceId, shared_ptr<CreateSnapshotRequest> request);
  CreateSnapshotResponse createSnapshotWithOptions(shared_ptr<string> InstanceId,
                                                   shared_ptr<CreateSnapshotRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateVpcEndpointResponse createVpcEndpoint(shared_ptr<string> InstanceId, shared_ptr<CreateVpcEndpointRequest> request);
  CreateVpcEndpointResponse createVpcEndpointWithOptions(shared_ptr<string> InstanceId,
                                                         shared_ptr<CreateVpcEndpointRequest> request,
                                                         shared_ptr<map<string, string>> headers,
                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeactivateZonesResponse deactivateZones(shared_ptr<string> InstanceId, shared_ptr<DeactivateZonesRequest> request);
  DeactivateZonesResponse deactivateZonesWithOptions(shared_ptr<string> InstanceId,
                                                     shared_ptr<DeactivateZonesRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteCollectorResponse deleteCollector(shared_ptr<string> ResId, shared_ptr<DeleteCollectorRequest> request);
  DeleteCollectorResponse deleteCollectorWithOptions(shared_ptr<string> ResId,
                                                     shared_ptr<DeleteCollectorRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteComponentIndexResponse deleteComponentIndex(shared_ptr<string> InstanceId, shared_ptr<string> name);
  DeleteComponentIndexResponse deleteComponentIndexWithOptions(shared_ptr<string> InstanceId,
                                                               shared_ptr<string> name,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteConnectedClusterResponse deleteConnectedCluster(shared_ptr<string> InstanceId, shared_ptr<DeleteConnectedClusterRequest> request);
  DeleteConnectedClusterResponse deleteConnectedClusterWithOptions(shared_ptr<string> InstanceId,
                                                                   shared_ptr<DeleteConnectedClusterRequest> request,
                                                                   shared_ptr<map<string, string>> headers,
                                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDataStreamResponse deleteDataStream(shared_ptr<string> InstanceId, shared_ptr<string> DataStream, shared_ptr<DeleteDataStreamRequest> request);
  DeleteDataStreamResponse deleteDataStreamWithOptions(shared_ptr<string> InstanceId,
                                                       shared_ptr<string> DataStream,
                                                       shared_ptr<DeleteDataStreamRequest> request,
                                                       shared_ptr<map<string, string>> headers,
                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDataTaskResponse deleteDataTask(shared_ptr<string> InstanceId, shared_ptr<DeleteDataTaskRequest> request);
  DeleteDataTaskResponse deleteDataTaskWithOptions(shared_ptr<string> InstanceId,
                                                   shared_ptr<DeleteDataTaskRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteDeprecatedTemplateResponse deleteDeprecatedTemplate(shared_ptr<string> InstanceId, shared_ptr<string> name);
  DeleteDeprecatedTemplateResponse deleteDeprecatedTemplateWithOptions(shared_ptr<string> InstanceId,
                                                                       shared_ptr<string> name,
                                                                       shared_ptr<map<string, string>> headers,
                                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteILMPolicyResponse deleteILMPolicy(shared_ptr<string> InstanceId, shared_ptr<string> PolicyName);
  DeleteILMPolicyResponse deleteILMPolicyWithOptions(shared_ptr<string> InstanceId,
                                                     shared_ptr<string> PolicyName,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteIndexTemplateResponse deleteIndexTemplate(shared_ptr<string> InstanceId, shared_ptr<string> IndexTemplate);
  DeleteIndexTemplateResponse deleteIndexTemplateWithOptions(shared_ptr<string> InstanceId,
                                                             shared_ptr<string> IndexTemplate,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteInstanceResponse deleteInstance(shared_ptr<string> InstanceId, shared_ptr<DeleteInstanceRequest> request);
  DeleteInstanceResponse deleteInstanceWithOptions(shared_ptr<string> InstanceId,
                                                   shared_ptr<DeleteInstanceRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteLogstashResponse deleteLogstash(shared_ptr<string> InstanceId, shared_ptr<DeleteLogstashRequest> request);
  DeleteLogstashResponse deleteLogstashWithOptions(shared_ptr<string> InstanceId,
                                                   shared_ptr<DeleteLogstashRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeletePipelinesResponse deletePipelines(shared_ptr<string> InstanceId, shared_ptr<DeletePipelinesRequest> request);
  DeletePipelinesResponse deletePipelinesWithOptions(shared_ptr<string> InstanceId,
                                                     shared_ptr<DeletePipelinesRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteSnapshotRepoResponse deleteSnapshotRepo(shared_ptr<string> InstanceId, shared_ptr<DeleteSnapshotRepoRequest> request);
  DeleteSnapshotRepoResponse deleteSnapshotRepoWithOptions(shared_ptr<string> InstanceId,
                                                           shared_ptr<DeleteSnapshotRepoRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DeleteVpcEndpointResponse deleteVpcEndpoint(shared_ptr<string> InstanceId, shared_ptr<string> EndpointId, shared_ptr<DeleteVpcEndpointRequest> request);
  DeleteVpcEndpointResponse deleteVpcEndpointWithOptions(shared_ptr<string> InstanceId,
                                                         shared_ptr<string> EndpointId,
                                                         shared_ptr<DeleteVpcEndpointRequest> request,
                                                         shared_ptr<map<string, string>> headers,
                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeAckOperatorResponse describeAckOperator(shared_ptr<string> ClusterId);
  DescribeAckOperatorResponse describeAckOperatorWithOptions(shared_ptr<string> ClusterId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeApmResponse describeApm(shared_ptr<string> instanceId);
  DescribeApmResponse describeApmWithOptions(shared_ptr<string> instanceId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeCollectorResponse describeCollector(shared_ptr<string> ResId);
  DescribeCollectorResponse describeCollectorWithOptions(shared_ptr<string> ResId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeComponentIndexResponse describeComponentIndex(shared_ptr<string> InstanceId, shared_ptr<string> name);
  DescribeComponentIndexResponse describeComponentIndexWithOptions(shared_ptr<string> InstanceId,
                                                                   shared_ptr<string> name,
                                                                   shared_ptr<map<string, string>> headers,
                                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeConnectableClustersResponse describeConnectableClusters(shared_ptr<string> InstanceId, shared_ptr<DescribeConnectableClustersRequest> request);
  DescribeConnectableClustersResponse describeConnectableClustersWithOptions(shared_ptr<string> InstanceId,
                                                                             shared_ptr<DescribeConnectableClustersRequest> request,
                                                                             shared_ptr<map<string, string>> headers,
                                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDeprecatedTemplateResponse describeDeprecatedTemplate(shared_ptr<string> InstanceId, shared_ptr<string> name);
  DescribeDeprecatedTemplateResponse describeDeprecatedTemplateWithOptions(shared_ptr<string> InstanceId,
                                                                           shared_ptr<string> name,
                                                                           shared_ptr<map<string, string>> headers,
                                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDiagnoseReportResponse describeDiagnoseReport(shared_ptr<string> InstanceId, shared_ptr<string> ReportId, shared_ptr<DescribeDiagnoseReportRequest> request);
  DescribeDiagnoseReportResponse describeDiagnoseReportWithOptions(shared_ptr<string> InstanceId,
                                                                   shared_ptr<string> ReportId,
                                                                   shared_ptr<DescribeDiagnoseReportRequest> request,
                                                                   shared_ptr<map<string, string>> headers,
                                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDiagnosisSettingsResponse describeDiagnosisSettings(shared_ptr<string> InstanceId, shared_ptr<DescribeDiagnosisSettingsRequest> request);
  DescribeDiagnosisSettingsResponse describeDiagnosisSettingsWithOptions(shared_ptr<string> InstanceId,
                                                                         shared_ptr<DescribeDiagnosisSettingsRequest> request,
                                                                         shared_ptr<map<string, string>> headers,
                                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeDynamicSettingsResponse describeDynamicSettings(shared_ptr<string> InstanceId);
  DescribeDynamicSettingsResponse describeDynamicSettingsWithOptions(shared_ptr<string> InstanceId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeElasticsearchHealthResponse describeElasticsearchHealth(shared_ptr<string> InstanceId);
  DescribeElasticsearchHealthResponse describeElasticsearchHealthWithOptions(shared_ptr<string> InstanceId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeILMPolicyResponse describeILMPolicy(shared_ptr<string> InstanceId, shared_ptr<string> PolicyName);
  DescribeILMPolicyResponse describeILMPolicyWithOptions(shared_ptr<string> InstanceId,
                                                         shared_ptr<string> PolicyName,
                                                         shared_ptr<map<string, string>> headers,
                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeIndexTemplateResponse describeIndexTemplate(shared_ptr<string> InstanceId, shared_ptr<string> IndexTemplate);
  DescribeIndexTemplateResponse describeIndexTemplateWithOptions(shared_ptr<string> InstanceId,
                                                                 shared_ptr<string> IndexTemplate,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeInstanceResponse describeInstance(shared_ptr<string> InstanceId);
  DescribeInstanceResponse describeInstanceWithOptions(shared_ptr<string> InstanceId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeKibanaSettingsResponse describeKibanaSettings(shared_ptr<string> InstanceId);
  DescribeKibanaSettingsResponse describeKibanaSettingsWithOptions(shared_ptr<string> InstanceId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeLogstashResponse describeLogstash(shared_ptr<string> InstanceId);
  DescribeLogstashResponse describeLogstashWithOptions(shared_ptr<string> InstanceId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePipelineResponse describePipeline(shared_ptr<string> InstanceId, shared_ptr<string> PipelineId);
  DescribePipelineResponse describePipelineWithOptions(shared_ptr<string> InstanceId,
                                                       shared_ptr<string> PipelineId,
                                                       shared_ptr<map<string, string>> headers,
                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribePipelineManagementConfigResponse describePipelineManagementConfig(shared_ptr<string> InstanceId, shared_ptr<DescribePipelineManagementConfigRequest> request);
  DescribePipelineManagementConfigResponse describePipelineManagementConfigWithOptions(shared_ptr<string> InstanceId,
                                                                                       shared_ptr<DescribePipelineManagementConfigRequest> request,
                                                                                       shared_ptr<map<string, string>> headers,
                                                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeRegionsResponse describeRegions();
  DescribeRegionsResponse describeRegionsWithOptions(shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeSnapshotSettingResponse describeSnapshotSetting(shared_ptr<string> InstanceId);
  DescribeSnapshotSettingResponse describeSnapshotSettingWithOptions(shared_ptr<string> InstanceId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeTemplatesResponse describeTemplates(shared_ptr<string> InstanceId);
  DescribeTemplatesResponse describeTemplatesWithOptions(shared_ptr<string> InstanceId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DescribeXpackMonitorConfigResponse describeXpackMonitorConfig(shared_ptr<string> InstanceId);
  DescribeXpackMonitorConfigResponse describeXpackMonitorConfigWithOptions(shared_ptr<string> InstanceId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  DiagnoseInstanceResponse diagnoseInstance(shared_ptr<string> InstanceId, shared_ptr<DiagnoseInstanceRequest> request);
  DiagnoseInstanceResponse diagnoseInstanceWithOptions(shared_ptr<string> InstanceId,
                                                       shared_ptr<DiagnoseInstanceRequest> request,
                                                       shared_ptr<map<string, string>> headers,
                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EstimatedLogstashRestartTimeResponse estimatedLogstashRestartTime(shared_ptr<string> InstanceId, shared_ptr<EstimatedLogstashRestartTimeRequest> request);
  EstimatedLogstashRestartTimeResponse estimatedLogstashRestartTimeWithOptions(shared_ptr<string> InstanceId,
                                                                               shared_ptr<EstimatedLogstashRestartTimeRequest> request,
                                                                               shared_ptr<map<string, string>> headers,
                                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  EstimatedRestartTimeResponse estimatedRestartTime(shared_ptr<string> InstanceId, shared_ptr<EstimatedRestartTimeRequest> request);
  EstimatedRestartTimeResponse estimatedRestartTimeWithOptions(shared_ptr<string> InstanceId,
                                                               shared_ptr<EstimatedRestartTimeRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetClusterDataInformationResponse getClusterDataInformation(shared_ptr<GetClusterDataInformationRequest> request);
  GetClusterDataInformationResponse getClusterDataInformationWithOptions(shared_ptr<GetClusterDataInformationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetElastictaskResponse getElastictask(shared_ptr<string> InstanceId);
  GetElastictaskResponse getElastictaskWithOptions(shared_ptr<string> InstanceId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEmonGrafanaAlertsResponse getEmonGrafanaAlerts(shared_ptr<string> ProjectId, shared_ptr<GetEmonGrafanaAlertsRequest> request);
  GetEmonGrafanaAlertsResponse getEmonGrafanaAlertsWithOptions(shared_ptr<string> ProjectId,
                                                               shared_ptr<GetEmonGrafanaAlertsRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEmonGrafanaDashboardsResponse getEmonGrafanaDashboards(shared_ptr<string> ProjectId, shared_ptr<GetEmonGrafanaDashboardsRequest> request);
  GetEmonGrafanaDashboardsResponse getEmonGrafanaDashboardsWithOptions(shared_ptr<string> ProjectId,
                                                                       shared_ptr<GetEmonGrafanaDashboardsRequest> request,
                                                                       shared_ptr<map<string, string>> headers,
                                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetEmonMonitorDataResponse getEmonMonitorData(shared_ptr<string> ProjectId, shared_ptr<GetEmonMonitorDataRequest> request);
  GetEmonMonitorDataResponse getEmonMonitorDataWithOptions(shared_ptr<string> ProjectId,
                                                           shared_ptr<GetEmonMonitorDataRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetOpenStoreUsageResponse getOpenStoreUsage(shared_ptr<string> InstanceId);
  GetOpenStoreUsageResponse getOpenStoreUsageWithOptions(shared_ptr<string> InstanceId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetRegionConfigurationResponse getRegionConfiguration(shared_ptr<GetRegionConfigurationRequest> request);
  GetRegionConfigurationResponse getRegionConfigurationWithOptions(shared_ptr<GetRegionConfigurationRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetSuggestShrinkableNodesResponse getSuggestShrinkableNodes(shared_ptr<string> InstanceId, shared_ptr<GetSuggestShrinkableNodesRequest> request);
  GetSuggestShrinkableNodesResponse getSuggestShrinkableNodesWithOptions(shared_ptr<string> InstanceId,
                                                                         shared_ptr<GetSuggestShrinkableNodesRequest> request,
                                                                         shared_ptr<map<string, string>> headers,
                                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  GetTransferableNodesResponse getTransferableNodes(shared_ptr<string> InstanceId, shared_ptr<GetTransferableNodesRequest> request);
  GetTransferableNodesResponse getTransferableNodesWithOptions(shared_ptr<string> InstanceId,
                                                               shared_ptr<GetTransferableNodesRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InitializeOperationRoleResponse initializeOperationRole(shared_ptr<InitializeOperationRoleRequest> request);
  InitializeOperationRoleResponse initializeOperationRoleWithOptions(shared_ptr<InitializeOperationRoleRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstallAckOperatorResponse installAckOperator(shared_ptr<string> ClusterId, shared_ptr<InstallAckOperatorRequest> request);
  InstallAckOperatorResponse installAckOperatorWithOptions(shared_ptr<string> ClusterId,
                                                           shared_ptr<InstallAckOperatorRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstallKibanaSystemPluginResponse installKibanaSystemPlugin(shared_ptr<string> InstanceId, shared_ptr<InstallKibanaSystemPluginRequest> request);
  InstallKibanaSystemPluginResponse installKibanaSystemPluginWithOptions(shared_ptr<string> InstanceId,
                                                                         shared_ptr<InstallKibanaSystemPluginRequest> request,
                                                                         shared_ptr<map<string, string>> headers,
                                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstallLogstashSystemPluginResponse installLogstashSystemPlugin(shared_ptr<string> InstanceId, shared_ptr<InstallLogstashSystemPluginRequest> request);
  InstallLogstashSystemPluginResponse installLogstashSystemPluginWithOptions(shared_ptr<string> InstanceId,
                                                                             shared_ptr<InstallLogstashSystemPluginRequest> request,
                                                                             shared_ptr<map<string, string>> headers,
                                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstallSystemPluginResponse installSystemPlugin(shared_ptr<string> InstanceId, shared_ptr<InstallSystemPluginRequest> request);
  InstallSystemPluginResponse installSystemPluginWithOptions(shared_ptr<string> InstanceId,
                                                             shared_ptr<InstallSystemPluginRequest> request,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InstallUserPluginsResponse installUserPlugins(shared_ptr<string> InstanceId, shared_ptr<InstallUserPluginsRequest> request);
  InstallUserPluginsResponse installUserPluginsWithOptions(shared_ptr<string> InstanceId,
                                                           shared_ptr<InstallUserPluginsRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InterruptElasticsearchTaskResponse interruptElasticsearchTask(shared_ptr<string> InstanceId, shared_ptr<InterruptElasticsearchTaskRequest> request);
  InterruptElasticsearchTaskResponse interruptElasticsearchTaskWithOptions(shared_ptr<string> InstanceId,
                                                                           shared_ptr<InterruptElasticsearchTaskRequest> request,
                                                                           shared_ptr<map<string, string>> headers,
                                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  InterruptLogstashTaskResponse interruptLogstashTask(shared_ptr<string> InstanceId, shared_ptr<InterruptLogstashTaskRequest> request);
  InterruptLogstashTaskResponse interruptLogstashTaskWithOptions(shared_ptr<string> InstanceId,
                                                                 shared_ptr<InterruptLogstashTaskRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAckClustersResponse listAckClusters(shared_ptr<ListAckClustersRequest> request);
  ListAckClustersResponse listAckClustersWithOptions(shared_ptr<ListAckClustersRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAckNamespacesResponse listAckNamespaces(shared_ptr<string> ClusterId, shared_ptr<ListAckNamespacesRequest> request);
  ListAckNamespacesResponse listAckNamespacesWithOptions(shared_ptr<string> ClusterId,
                                                         shared_ptr<ListAckNamespacesRequest> request,
                                                         shared_ptr<map<string, string>> headers,
                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListActionRecordsResponse listActionRecords(shared_ptr<string> InstanceId, shared_ptr<ListActionRecordsRequest> request);
  ListActionRecordsResponse listActionRecordsWithOptions(shared_ptr<string> InstanceId,
                                                         shared_ptr<ListActionRecordsRequest> request,
                                                         shared_ptr<map<string, string>> headers,
                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAllNodeResponse listAllNode(shared_ptr<string> InstanceId, shared_ptr<ListAllNodeRequest> request);
  ListAllNodeResponse listAllNodeWithOptions(shared_ptr<string> InstanceId,
                                             shared_ptr<ListAllNodeRequest> request,
                                             shared_ptr<map<string, string>> headers,
                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAlternativeSnapshotReposResponse listAlternativeSnapshotRepos(shared_ptr<string> InstanceId, shared_ptr<ListAlternativeSnapshotReposRequest> request);
  ListAlternativeSnapshotReposResponse listAlternativeSnapshotReposWithOptions(shared_ptr<string> InstanceId,
                                                                               shared_ptr<ListAlternativeSnapshotReposRequest> request,
                                                                               shared_ptr<map<string, string>> headers,
                                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListApmResponse listApm(shared_ptr<ListApmRequest> request);
  ListApmResponse listApmWithOptions(shared_ptr<ListApmRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListAvailableEsInstanceIdsResponse listAvailableEsInstanceIds(shared_ptr<string> InstanceId);
  ListAvailableEsInstanceIdsResponse listAvailableEsInstanceIdsWithOptions(shared_ptr<string> InstanceId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListCollectorsResponse listCollectors(shared_ptr<ListCollectorsRequest> request);
  ListCollectorsResponse listCollectorsWithOptions(shared_ptr<ListCollectorsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListComponentIndicesResponse listComponentIndices(shared_ptr<string> InstanceId, shared_ptr<ListComponentIndicesRequest> request);
  ListComponentIndicesResponse listComponentIndicesWithOptions(shared_ptr<string> InstanceId,
                                                               shared_ptr<ListComponentIndicesRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListConnectedClustersResponse listConnectedClusters(shared_ptr<string> InstanceId);
  ListConnectedClustersResponse listConnectedClustersWithOptions(shared_ptr<string> InstanceId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataStreamsResponse listDataStreams(shared_ptr<string> InstanceId, shared_ptr<ListDataStreamsRequest> request);
  ListDataStreamsResponse listDataStreamsWithOptions(shared_ptr<string> InstanceId,
                                                     shared_ptr<ListDataStreamsRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDataTasksResponse listDataTasks(shared_ptr<string> InstanceId);
  ListDataTasksResponse listDataTasksWithOptions(shared_ptr<string> InstanceId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDefaultCollectorConfigurationsResponse listDefaultCollectorConfigurations(shared_ptr<ListDefaultCollectorConfigurationsRequest> request);
  ListDefaultCollectorConfigurationsResponse listDefaultCollectorConfigurationsWithOptions(shared_ptr<ListDefaultCollectorConfigurationsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDeprecatedTemplatesResponse listDeprecatedTemplates(shared_ptr<string> InstanceId, shared_ptr<ListDeprecatedTemplatesRequest> request);
  ListDeprecatedTemplatesResponse listDeprecatedTemplatesWithOptions(shared_ptr<string> InstanceId,
                                                                     shared_ptr<ListDeprecatedTemplatesRequest> request,
                                                                     shared_ptr<map<string, string>> headers,
                                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDiagnoseIndicesResponse listDiagnoseIndices(shared_ptr<string> InstanceId, shared_ptr<ListDiagnoseIndicesRequest> request);
  ListDiagnoseIndicesResponse listDiagnoseIndicesWithOptions(shared_ptr<string> InstanceId,
                                                             shared_ptr<ListDiagnoseIndicesRequest> request,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDiagnoseReportResponse listDiagnoseReport(shared_ptr<string> InstanceId, shared_ptr<ListDiagnoseReportRequest> request);
  ListDiagnoseReportResponse listDiagnoseReportWithOptions(shared_ptr<string> InstanceId,
                                                           shared_ptr<ListDiagnoseReportRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDiagnoseReportIdsResponse listDiagnoseReportIds(shared_ptr<string> InstanceId, shared_ptr<ListDiagnoseReportIdsRequest> request);
  ListDiagnoseReportIdsResponse listDiagnoseReportIdsWithOptions(shared_ptr<string> InstanceId,
                                                                 shared_ptr<ListDiagnoseReportIdsRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDictInformationResponse listDictInformation(shared_ptr<string> InstanceId, shared_ptr<ListDictInformationRequest> request);
  ListDictInformationResponse listDictInformationWithOptions(shared_ptr<string> InstanceId,
                                                             shared_ptr<ListDictInformationRequest> request,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListDictsResponse listDicts(shared_ptr<string> InstanceId, shared_ptr<ListDictsRequest> request);
  ListDictsResponse listDictsWithOptions(shared_ptr<string> InstanceId,
                                         shared_ptr<ListDictsRequest> request,
                                         shared_ptr<map<string, string>> headers,
                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListEcsInstancesResponse listEcsInstances(shared_ptr<ListEcsInstancesRequest> request);
  ListEcsInstancesResponse listEcsInstancesWithOptions(shared_ptr<ListEcsInstancesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListExtendfilesResponse listExtendfiles(shared_ptr<string> InstanceId);
  ListExtendfilesResponse listExtendfilesWithOptions(shared_ptr<string> InstanceId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListILMPoliciesResponse listILMPolicies(shared_ptr<string> InstanceId, shared_ptr<ListILMPoliciesRequest> request);
  ListILMPoliciesResponse listILMPoliciesWithOptions(shared_ptr<string> InstanceId,
                                                     shared_ptr<ListILMPoliciesRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListIndexTemplatesResponse listIndexTemplates(shared_ptr<string> InstanceId, shared_ptr<ListIndexTemplatesRequest> request);
  ListIndexTemplatesResponse listIndexTemplatesWithOptions(shared_ptr<string> InstanceId,
                                                           shared_ptr<ListIndexTemplatesRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInstanceResponse listInstance(shared_ptr<ListInstanceRequest> request);
  ListInstanceResponse listInstanceWithOptions(shared_ptr<ListInstanceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInstanceHistoryEventsResponse listInstanceHistoryEvents(shared_ptr<ListInstanceHistoryEventsRequest> request);
  ListInstanceHistoryEventsResponse listInstanceHistoryEventsWithOptions(shared_ptr<ListInstanceHistoryEventsRequest> tmpReq, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListInstanceIndicesResponse listInstanceIndices(shared_ptr<string> InstanceId, shared_ptr<ListInstanceIndicesRequest> request);
  ListInstanceIndicesResponse listInstanceIndicesWithOptions(shared_ptr<string> InstanceId,
                                                             shared_ptr<ListInstanceIndicesRequest> request,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListKibanaPluginsResponse listKibanaPlugins(shared_ptr<string> InstanceId, shared_ptr<ListKibanaPluginsRequest> request);
  ListKibanaPluginsResponse listKibanaPluginsWithOptions(shared_ptr<string> InstanceId,
                                                         shared_ptr<ListKibanaPluginsRequest> request,
                                                         shared_ptr<map<string, string>> headers,
                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLogstashResponse listLogstash(shared_ptr<ListLogstashRequest> request);
  ListLogstashResponse listLogstashWithOptions(shared_ptr<ListLogstashRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLogstashLogResponse listLogstashLog(shared_ptr<string> InstanceId, shared_ptr<ListLogstashLogRequest> request);
  ListLogstashLogResponse listLogstashLogWithOptions(shared_ptr<string> InstanceId,
                                                     shared_ptr<ListLogstashLogRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListLogstashPluginsResponse listLogstashPlugins(shared_ptr<string> InstanceId, shared_ptr<ListLogstashPluginsRequest> request);
  ListLogstashPluginsResponse listLogstashPluginsWithOptions(shared_ptr<string> InstanceId,
                                                             shared_ptr<ListLogstashPluginsRequest> request,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListNodesResponse listNodes(shared_ptr<string> ResId, shared_ptr<ListNodesRequest> request);
  ListNodesResponse listNodesWithOptions(shared_ptr<string> ResId,
                                         shared_ptr<ListNodesRequest> request,
                                         shared_ptr<map<string, string>> headers,
                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPipelineResponse listPipeline(shared_ptr<string> InstanceId, shared_ptr<ListPipelineRequest> request);
  ListPipelineResponse listPipelineWithOptions(shared_ptr<string> InstanceId,
                                               shared_ptr<ListPipelineRequest> request,
                                               shared_ptr<map<string, string>> headers,
                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPipelineIdsResponse listPipelineIds(shared_ptr<string> InstanceId, shared_ptr<ListPipelineIdsRequest> request);
  ListPipelineIdsResponse listPipelineIdsWithOptions(shared_ptr<string> InstanceId,
                                                     shared_ptr<ListPipelineIdsRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListPluginsResponse listPlugins(shared_ptr<string> InstanceId, shared_ptr<ListPluginsRequest> request);
  ListPluginsResponse listPluginsWithOptions(shared_ptr<string> InstanceId,
                                             shared_ptr<ListPluginsRequest> request,
                                             shared_ptr<map<string, string>> headers,
                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSearchLogResponse listSearchLog(shared_ptr<string> InstanceId, shared_ptr<ListSearchLogRequest> request);
  ListSearchLogResponse listSearchLogWithOptions(shared_ptr<string> InstanceId,
                                                 shared_ptr<ListSearchLogRequest> request,
                                                 shared_ptr<map<string, string>> headers,
                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListShardRecoveriesResponse listShardRecoveries(shared_ptr<string> InstanceId, shared_ptr<ListShardRecoveriesRequest> request);
  ListShardRecoveriesResponse listShardRecoveriesWithOptions(shared_ptr<string> InstanceId,
                                                             shared_ptr<ListShardRecoveriesRequest> request,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListSnapshotReposByInstanceIdResponse listSnapshotReposByInstanceId(shared_ptr<string> InstanceId);
  ListSnapshotReposByInstanceIdResponse listSnapshotReposByInstanceIdWithOptions(shared_ptr<string> InstanceId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagResourcesResponse listTagResources(shared_ptr<ListTagResourcesRequest> request);
  ListTagResourcesResponse listTagResourcesWithOptions(shared_ptr<ListTagResourcesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListTagsResponse listTags(shared_ptr<ListTagsRequest> request);
  ListTagsResponse listTagsWithOptions(shared_ptr<ListTagsRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ListVpcEndpointsResponse listVpcEndpoints(shared_ptr<string> InstanceId, shared_ptr<ListVpcEndpointsRequest> request);
  ListVpcEndpointsResponse listVpcEndpointsWithOptions(shared_ptr<string> InstanceId,
                                                       shared_ptr<ListVpcEndpointsRequest> request,
                                                       shared_ptr<map<string, string>> headers,
                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MigrateToOtherZoneResponse migrateToOtherZone(shared_ptr<string> InstanceId, shared_ptr<MigrateToOtherZoneRequest> request);
  MigrateToOtherZoneResponse migrateToOtherZoneWithOptions(shared_ptr<string> InstanceId,
                                                           shared_ptr<MigrateToOtherZoneRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyDeployMachineResponse modifyDeployMachine(shared_ptr<string> ResId, shared_ptr<ModifyDeployMachineRequest> request);
  ModifyDeployMachineResponse modifyDeployMachineWithOptions(shared_ptr<string> ResId,
                                                             shared_ptr<ModifyDeployMachineRequest> request,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyElastictaskResponse modifyElastictask(shared_ptr<string> InstanceId, shared_ptr<ModifyElastictaskRequest> request);
  ModifyElastictaskResponse modifyElastictaskWithOptions(shared_ptr<string> InstanceId,
                                                         shared_ptr<ModifyElastictaskRequest> request,
                                                         shared_ptr<map<string, string>> headers,
                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyInstanceMaintainTimeResponse modifyInstanceMaintainTime(shared_ptr<string> InstanceId, shared_ptr<ModifyInstanceMaintainTimeRequest> request);
  ModifyInstanceMaintainTimeResponse modifyInstanceMaintainTimeWithOptions(shared_ptr<string> InstanceId,
                                                                           shared_ptr<ModifyInstanceMaintainTimeRequest> request,
                                                                           shared_ptr<map<string, string>> headers,
                                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ModifyWhiteIpsResponse modifyWhiteIps(shared_ptr<string> InstanceId, shared_ptr<ModifyWhiteIpsRequest> request);
  ModifyWhiteIpsResponse modifyWhiteIpsWithOptions(shared_ptr<string> InstanceId,
                                                   shared_ptr<ModifyWhiteIpsRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  MoveResourceGroupResponse moveResourceGroup(shared_ptr<string> InstanceId, shared_ptr<MoveResourceGroupRequest> request);
  MoveResourceGroupResponse moveResourceGroupWithOptions(shared_ptr<string> InstanceId,
                                                         shared_ptr<MoveResourceGroupRequest> request,
                                                         shared_ptr<map<string, string>> headers,
                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenDiagnosisResponse openDiagnosis(shared_ptr<string> InstanceId, shared_ptr<OpenDiagnosisRequest> request);
  OpenDiagnosisResponse openDiagnosisWithOptions(shared_ptr<string> InstanceId,
                                                 shared_ptr<OpenDiagnosisRequest> request,
                                                 shared_ptr<map<string, string>> headers,
                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  OpenHttpsResponse openHttps(shared_ptr<string> InstanceId, shared_ptr<OpenHttpsRequest> request);
  OpenHttpsResponse openHttpsWithOptions(shared_ptr<string> InstanceId,
                                         shared_ptr<OpenHttpsRequest> request,
                                         shared_ptr<map<string, string>> headers,
                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  PostEmonTryAlarmRuleResponse postEmonTryAlarmRule(shared_ptr<string> ProjectId, shared_ptr<string> AlarmGroupId, shared_ptr<PostEmonTryAlarmRuleRequest> request);
  PostEmonTryAlarmRuleResponse postEmonTryAlarmRuleWithOptions(shared_ptr<string> ProjectId,
                                                               shared_ptr<string> AlarmGroupId,
                                                               shared_ptr<PostEmonTryAlarmRuleRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RecommendTemplatesResponse recommendTemplates(shared_ptr<string> InstanceId, shared_ptr<RecommendTemplatesRequest> request);
  RecommendTemplatesResponse recommendTemplatesWithOptions(shared_ptr<string> InstanceId,
                                                           shared_ptr<RecommendTemplatesRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ReinstallCollectorResponse reinstallCollector(shared_ptr<string> ResId, shared_ptr<ReinstallCollectorRequest> request);
  ReinstallCollectorResponse reinstallCollectorWithOptions(shared_ptr<string> ResId,
                                                           shared_ptr<ReinstallCollectorRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RemoveApmResponse removeApm(shared_ptr<string> instanceId);
  RemoveApmResponse removeApmWithOptions(shared_ptr<string> instanceId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RenewInstanceResponse renewInstance(shared_ptr<string> InstanceId, shared_ptr<RenewInstanceRequest> request);
  RenewInstanceResponse renewInstanceWithOptions(shared_ptr<string> InstanceId,
                                                 shared_ptr<RenewInstanceRequest> request,
                                                 shared_ptr<map<string, string>> headers,
                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RenewLogstashResponse renewLogstash(shared_ptr<string> InstanceId, shared_ptr<RenewLogstashRequest> request);
  RenewLogstashResponse renewLogstashWithOptions(shared_ptr<string> InstanceId,
                                                 shared_ptr<RenewLogstashRequest> request,
                                                 shared_ptr<map<string, string>> headers,
                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RestartCollectorResponse restartCollector(shared_ptr<string> ResId, shared_ptr<RestartCollectorRequest> request);
  RestartCollectorResponse restartCollectorWithOptions(shared_ptr<string> ResId,
                                                       shared_ptr<RestartCollectorRequest> request,
                                                       shared_ptr<map<string, string>> headers,
                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RestartInstanceResponse restartInstance(shared_ptr<string> InstanceId, shared_ptr<RestartInstanceRequest> request);
  RestartInstanceResponse restartInstanceWithOptions(shared_ptr<string> InstanceId,
                                                     shared_ptr<RestartInstanceRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RestartLogstashResponse restartLogstash(shared_ptr<string> InstanceId, shared_ptr<RestartLogstashRequest> request);
  RestartLogstashResponse restartLogstashWithOptions(shared_ptr<string> InstanceId,
                                                     shared_ptr<RestartLogstashRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResumeElasticsearchTaskResponse resumeElasticsearchTask(shared_ptr<string> InstanceId, shared_ptr<ResumeElasticsearchTaskRequest> request);
  ResumeElasticsearchTaskResponse resumeElasticsearchTaskWithOptions(shared_ptr<string> InstanceId,
                                                                     shared_ptr<ResumeElasticsearchTaskRequest> request,
                                                                     shared_ptr<map<string, string>> headers,
                                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ResumeLogstashTaskResponse resumeLogstashTask(shared_ptr<string> InstanceId, shared_ptr<ResumeLogstashTaskRequest> request);
  ResumeLogstashTaskResponse resumeLogstashTaskWithOptions(shared_ptr<string> InstanceId,
                                                           shared_ptr<ResumeLogstashTaskRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RolloverDataStreamResponse rolloverDataStream(shared_ptr<string> InstanceId, shared_ptr<string> DataStream, shared_ptr<RolloverDataStreamRequest> request);
  RolloverDataStreamResponse rolloverDataStreamWithOptions(shared_ptr<string> InstanceId,
                                                           shared_ptr<string> DataStream,
                                                           shared_ptr<RolloverDataStreamRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  RunPipelinesResponse runPipelines(shared_ptr<string> InstanceId, shared_ptr<RunPipelinesRequest> request);
  RunPipelinesResponse runPipelinesWithOptions(shared_ptr<string> InstanceId,
                                               shared_ptr<RunPipelinesRequest> request,
                                               shared_ptr<map<string, string>> headers,
                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ShrinkNodeResponse shrinkNode(shared_ptr<string> InstanceId, shared_ptr<ShrinkNodeRequest> request);
  ShrinkNodeResponse shrinkNodeWithOptions(shared_ptr<string> InstanceId,
                                           shared_ptr<ShrinkNodeRequest> request,
                                           shared_ptr<map<string, string>> headers,
                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartApmResponse startApm(shared_ptr<string> instanceId);
  StartApmResponse startApmWithOptions(shared_ptr<string> instanceId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StartCollectorResponse startCollector(shared_ptr<string> ResId, shared_ptr<StartCollectorRequest> request);
  StartCollectorResponse startCollectorWithOptions(shared_ptr<string> ResId,
                                                   shared_ptr<StartCollectorRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopApmResponse stopApm(shared_ptr<string> instanceId);
  StopApmResponse stopApmWithOptions(shared_ptr<string> instanceId, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopCollectorResponse stopCollector(shared_ptr<string> ResId, shared_ptr<StopCollectorRequest> request);
  StopCollectorResponse stopCollectorWithOptions(shared_ptr<string> ResId,
                                                 shared_ptr<StopCollectorRequest> request,
                                                 shared_ptr<map<string, string>> headers,
                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  StopPipelinesResponse stopPipelines(shared_ptr<string> InstanceId, shared_ptr<StopPipelinesRequest> request);
  StopPipelinesResponse stopPipelinesWithOptions(shared_ptr<string> InstanceId,
                                                 shared_ptr<StopPipelinesRequest> request,
                                                 shared_ptr<map<string, string>> headers,
                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TagResourcesResponse tagResources(shared_ptr<TagResourcesRequest> request);
  TagResourcesResponse tagResourcesWithOptions(shared_ptr<TagResourcesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TransferNodeResponse transferNode(shared_ptr<string> InstanceId, shared_ptr<TransferNodeRequest> request);
  TransferNodeResponse transferNodeWithOptions(shared_ptr<string> InstanceId,
                                               shared_ptr<TransferNodeRequest> request,
                                               shared_ptr<map<string, string>> headers,
                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  TriggerNetworkResponse triggerNetwork(shared_ptr<string> InstanceId, shared_ptr<TriggerNetworkRequest> request);
  TriggerNetworkResponse triggerNetworkWithOptions(shared_ptr<string> InstanceId,
                                                   shared_ptr<TriggerNetworkRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UninstallKibanaPluginResponse uninstallKibanaPlugin(shared_ptr<string> InstanceId, shared_ptr<UninstallKibanaPluginRequest> request);
  UninstallKibanaPluginResponse uninstallKibanaPluginWithOptions(shared_ptr<string> InstanceId,
                                                                 shared_ptr<UninstallKibanaPluginRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UninstallLogstashPluginResponse uninstallLogstashPlugin(shared_ptr<string> InstanceId, shared_ptr<UninstallLogstashPluginRequest> request);
  UninstallLogstashPluginResponse uninstallLogstashPluginWithOptions(shared_ptr<string> InstanceId,
                                                                     shared_ptr<UninstallLogstashPluginRequest> request,
                                                                     shared_ptr<map<string, string>> headers,
                                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UninstallPluginResponse uninstallPlugin(shared_ptr<string> InstanceId, shared_ptr<UninstallPluginRequest> request);
  UninstallPluginResponse uninstallPluginWithOptions(shared_ptr<string> InstanceId,
                                                     shared_ptr<UninstallPluginRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UntagResourcesResponse untagResources(shared_ptr<UntagResourcesRequest> request);
  UntagResourcesResponse untagResourcesWithOptions(shared_ptr<UntagResourcesRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAdminPasswordResponse updateAdminPassword(shared_ptr<string> InstanceId, shared_ptr<UpdateAdminPasswordRequest> request);
  UpdateAdminPasswordResponse updateAdminPasswordWithOptions(shared_ptr<string> InstanceId,
                                                             shared_ptr<UpdateAdminPasswordRequest> request,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAdvancedSettingResponse updateAdvancedSetting(shared_ptr<string> InstanceId, shared_ptr<UpdateAdvancedSettingRequest> request);
  UpdateAdvancedSettingResponse updateAdvancedSettingWithOptions(shared_ptr<string> InstanceId,
                                                                 shared_ptr<UpdateAdvancedSettingRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateAliwsDictResponse updateAliwsDict(shared_ptr<string> InstanceId, shared_ptr<UpdateAliwsDictRequest> request);
  UpdateAliwsDictResponse updateAliwsDictWithOptions(shared_ptr<string> InstanceId,
                                                     shared_ptr<UpdateAliwsDictRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateApmResponse updateApm(shared_ptr<string> instanceId, shared_ptr<UpdateApmRequest> request);
  UpdateApmResponse updateApmWithOptions(shared_ptr<string> instanceId,
                                         shared_ptr<UpdateApmRequest> request,
                                         shared_ptr<map<string, string>> headers,
                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateBlackIpsResponse updateBlackIps(shared_ptr<string> InstanceId, shared_ptr<UpdateBlackIpsRequest> request);
  UpdateBlackIpsResponse updateBlackIpsWithOptions(shared_ptr<string> InstanceId,
                                                   shared_ptr<UpdateBlackIpsRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCollectorResponse updateCollector(shared_ptr<string> ResId, shared_ptr<UpdateCollectorRequest> request);
  UpdateCollectorResponse updateCollectorWithOptions(shared_ptr<string> ResId,
                                                     shared_ptr<UpdateCollectorRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateCollectorNameResponse updateCollectorName(shared_ptr<string> ResId, shared_ptr<UpdateCollectorNameRequest> request);
  UpdateCollectorNameResponse updateCollectorNameWithOptions(shared_ptr<string> ResId,
                                                             shared_ptr<UpdateCollectorNameRequest> request,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateComponentIndexResponse updateComponentIndex(shared_ptr<string> InstanceId, shared_ptr<string> name, shared_ptr<UpdateComponentIndexRequest> request);
  UpdateComponentIndexResponse updateComponentIndexWithOptions(shared_ptr<string> InstanceId,
                                                               shared_ptr<string> name,
                                                               shared_ptr<UpdateComponentIndexRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDescriptionResponse updateDescription(shared_ptr<string> InstanceId, shared_ptr<UpdateDescriptionRequest> request);
  UpdateDescriptionResponse updateDescriptionWithOptions(shared_ptr<string> InstanceId,
                                                         shared_ptr<UpdateDescriptionRequest> request,
                                                         shared_ptr<map<string, string>> headers,
                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDiagnosisSettingsResponse updateDiagnosisSettings(shared_ptr<string> InstanceId, shared_ptr<UpdateDiagnosisSettingsRequest> request);
  UpdateDiagnosisSettingsResponse updateDiagnosisSettingsWithOptions(shared_ptr<string> InstanceId,
                                                                     shared_ptr<UpdateDiagnosisSettingsRequest> request,
                                                                     shared_ptr<map<string, string>> headers,
                                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDictResponse updateDict(shared_ptr<string> InstanceId, shared_ptr<UpdateDictRequest> request);
  UpdateDictResponse updateDictWithOptions(shared_ptr<string> InstanceId,
                                           shared_ptr<UpdateDictRequest> request,
                                           shared_ptr<map<string, string>> headers,
                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateDynamicSettingsResponse updateDynamicSettings(shared_ptr<string> InstanceId, shared_ptr<UpdateDynamicSettingsRequest> request);
  UpdateDynamicSettingsResponse updateDynamicSettingsWithOptions(shared_ptr<string> InstanceId,
                                                                 shared_ptr<UpdateDynamicSettingsRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateExtendConfigResponse updateExtendConfig(shared_ptr<string> InstanceId, shared_ptr<UpdateExtendConfigRequest> request);
  UpdateExtendConfigResponse updateExtendConfigWithOptions(shared_ptr<string> InstanceId,
                                                           shared_ptr<UpdateExtendConfigRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateExtendfilesResponse updateExtendfiles(shared_ptr<string> InstanceId, shared_ptr<UpdateExtendfilesRequest> request);
  UpdateExtendfilesResponse updateExtendfilesWithOptions(shared_ptr<string> InstanceId,
                                                         shared_ptr<UpdateExtendfilesRequest> request,
                                                         shared_ptr<map<string, string>> headers,
                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateHotIkDictsResponse updateHotIkDicts(shared_ptr<string> InstanceId, shared_ptr<UpdateHotIkDictsRequest> request);
  UpdateHotIkDictsResponse updateHotIkDictsWithOptions(shared_ptr<string> InstanceId,
                                                       shared_ptr<UpdateHotIkDictsRequest> request,
                                                       shared_ptr<map<string, string>> headers,
                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateILMPolicyResponse updateILMPolicy(shared_ptr<string> InstanceId, shared_ptr<string> PolicyName, shared_ptr<UpdateILMPolicyRequest> request);
  UpdateILMPolicyResponse updateILMPolicyWithOptions(shared_ptr<string> InstanceId,
                                                     shared_ptr<string> PolicyName,
                                                     shared_ptr<UpdateILMPolicyRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateIndexTemplateResponse updateIndexTemplate(shared_ptr<string> InstanceId, shared_ptr<string> IndexTemplate, shared_ptr<UpdateIndexTemplateRequest> request);
  UpdateIndexTemplateResponse updateIndexTemplateWithOptions(shared_ptr<string> InstanceId,
                                                             shared_ptr<string> IndexTemplate,
                                                             shared_ptr<UpdateIndexTemplateRequest> request,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateInstanceResponse updateInstance(shared_ptr<string> InstanceId, shared_ptr<UpdateInstanceRequest> request);
  UpdateInstanceResponse updateInstanceWithOptions(shared_ptr<string> InstanceId,
                                                   shared_ptr<UpdateInstanceRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateInstanceChargeTypeResponse updateInstanceChargeType(shared_ptr<string> InstanceId, shared_ptr<UpdateInstanceChargeTypeRequest> request);
  UpdateInstanceChargeTypeResponse updateInstanceChargeTypeWithOptions(shared_ptr<string> InstanceId,
                                                                       shared_ptr<UpdateInstanceChargeTypeRequest> request,
                                                                       shared_ptr<map<string, string>> headers,
                                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateInstanceSettingsResponse updateInstanceSettings(shared_ptr<string> InstanceId, shared_ptr<UpdateInstanceSettingsRequest> request);
  UpdateInstanceSettingsResponse updateInstanceSettingsWithOptions(shared_ptr<string> InstanceId,
                                                                   shared_ptr<UpdateInstanceSettingsRequest> request,
                                                                   shared_ptr<map<string, string>> headers,
                                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateKibanaSettingsResponse updateKibanaSettings(shared_ptr<string> InstanceId, shared_ptr<UpdateKibanaSettingsRequest> request);
  UpdateKibanaSettingsResponse updateKibanaSettingsWithOptions(shared_ptr<string> InstanceId,
                                                               shared_ptr<UpdateKibanaSettingsRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateKibanaWhiteIpsResponse updateKibanaWhiteIps(shared_ptr<string> InstanceId, shared_ptr<UpdateKibanaWhiteIpsRequest> request);
  UpdateKibanaWhiteIpsResponse updateKibanaWhiteIpsWithOptions(shared_ptr<string> InstanceId,
                                                               shared_ptr<UpdateKibanaWhiteIpsRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLogstashResponse updateLogstash(shared_ptr<string> InstanceId, shared_ptr<UpdateLogstashRequest> request);
  UpdateLogstashResponse updateLogstashWithOptions(shared_ptr<string> InstanceId,
                                                   shared_ptr<UpdateLogstashRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLogstashChargeTypeResponse updateLogstashChargeType(shared_ptr<string> InstanceId, shared_ptr<UpdateLogstashChargeTypeRequest> request);
  UpdateLogstashChargeTypeResponse updateLogstashChargeTypeWithOptions(shared_ptr<string> InstanceId,
                                                                       shared_ptr<UpdateLogstashChargeTypeRequest> request,
                                                                       shared_ptr<map<string, string>> headers,
                                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLogstashDescriptionResponse updateLogstashDescription(shared_ptr<string> InstanceId, shared_ptr<UpdateLogstashDescriptionRequest> request);
  UpdateLogstashDescriptionResponse updateLogstashDescriptionWithOptions(shared_ptr<string> InstanceId,
                                                                         shared_ptr<UpdateLogstashDescriptionRequest> request,
                                                                         shared_ptr<map<string, string>> headers,
                                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateLogstashSettingsResponse updateLogstashSettings(shared_ptr<string> InstanceId, shared_ptr<UpdateLogstashSettingsRequest> request);
  UpdateLogstashSettingsResponse updateLogstashSettingsWithOptions(shared_ptr<string> InstanceId,
                                                                   shared_ptr<UpdateLogstashSettingsRequest> request,
                                                                   shared_ptr<map<string, string>> headers,
                                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePipelineManagementConfigResponse updatePipelineManagementConfig(shared_ptr<string> InstanceId, shared_ptr<UpdatePipelineManagementConfigRequest> request);
  UpdatePipelineManagementConfigResponse updatePipelineManagementConfigWithOptions(shared_ptr<string> InstanceId,
                                                                                   shared_ptr<UpdatePipelineManagementConfigRequest> request,
                                                                                   shared_ptr<map<string, string>> headers,
                                                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePipelinesResponse updatePipelines(shared_ptr<string> InstanceId, shared_ptr<UpdatePipelinesRequest> request);
  UpdatePipelinesResponse updatePipelinesWithOptions(shared_ptr<string> InstanceId,
                                                     shared_ptr<UpdatePipelinesRequest> request,
                                                     shared_ptr<map<string, string>> headers,
                                                     shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePrivateNetworkWhiteIpsResponse updatePrivateNetworkWhiteIps(shared_ptr<string> InstanceId, shared_ptr<UpdatePrivateNetworkWhiteIpsRequest> request);
  UpdatePrivateNetworkWhiteIpsResponse updatePrivateNetworkWhiteIpsWithOptions(shared_ptr<string> InstanceId,
                                                                               shared_ptr<UpdatePrivateNetworkWhiteIpsRequest> request,
                                                                               shared_ptr<map<string, string>> headers,
                                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePublicNetworkResponse updatePublicNetwork(shared_ptr<string> InstanceId, shared_ptr<UpdatePublicNetworkRequest> request);
  UpdatePublicNetworkResponse updatePublicNetworkWithOptions(shared_ptr<string> InstanceId,
                                                             shared_ptr<UpdatePublicNetworkRequest> request,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdatePublicWhiteIpsResponse updatePublicWhiteIps(shared_ptr<string> InstanceId, shared_ptr<UpdatePublicWhiteIpsRequest> request);
  UpdatePublicWhiteIpsResponse updatePublicWhiteIpsWithOptions(shared_ptr<string> InstanceId,
                                                               shared_ptr<UpdatePublicWhiteIpsRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateReadWritePolicyResponse updateReadWritePolicy(shared_ptr<string> InstanceId, shared_ptr<UpdateReadWritePolicyRequest> request);
  UpdateReadWritePolicyResponse updateReadWritePolicyWithOptions(shared_ptr<string> InstanceId,
                                                                 shared_ptr<UpdateReadWritePolicyRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSnapshotSettingResponse updateSnapshotSetting(shared_ptr<string> InstanceId, shared_ptr<UpdateSnapshotSettingRequest> request);
  UpdateSnapshotSettingResponse updateSnapshotSettingWithOptions(shared_ptr<string> InstanceId,
                                                                 shared_ptr<UpdateSnapshotSettingRequest> request,
                                                                 shared_ptr<map<string, string>> headers,
                                                                 shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateSynonymsDictsResponse updateSynonymsDicts(shared_ptr<string> InstanceId, shared_ptr<UpdateSynonymsDictsRequest> request);
  UpdateSynonymsDictsResponse updateSynonymsDictsWithOptions(shared_ptr<string> InstanceId,
                                                             shared_ptr<UpdateSynonymsDictsRequest> request,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateTemplateResponse updateTemplate(shared_ptr<string> InstanceId, shared_ptr<string> TemplateName, shared_ptr<UpdateTemplateRequest> request);
  UpdateTemplateResponse updateTemplateWithOptions(shared_ptr<string> InstanceId,
                                                   shared_ptr<string> TemplateName,
                                                   shared_ptr<UpdateTemplateRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateWhiteIpsResponse updateWhiteIps(shared_ptr<string> InstanceId, shared_ptr<UpdateWhiteIpsRequest> request);
  UpdateWhiteIpsResponse updateWhiteIpsWithOptions(shared_ptr<string> InstanceId,
                                                   shared_ptr<UpdateWhiteIpsRequest> request,
                                                   shared_ptr<map<string, string>> headers,
                                                   shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpdateXpackMonitorConfigResponse updateXpackMonitorConfig(shared_ptr<string> InstanceId, shared_ptr<UpdateXpackMonitorConfigRequest> request);
  UpdateXpackMonitorConfigResponse updateXpackMonitorConfigWithOptions(shared_ptr<string> InstanceId,
                                                                       shared_ptr<UpdateXpackMonitorConfigRequest> request,
                                                                       shared_ptr<map<string, string>> headers,
                                                                       shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  UpgradeEngineVersionResponse upgradeEngineVersion(shared_ptr<string> InstanceId, shared_ptr<UpgradeEngineVersionRequest> request);
  UpgradeEngineVersionResponse upgradeEngineVersionWithOptions(shared_ptr<string> InstanceId,
                                                               shared_ptr<UpgradeEngineVersionRequest> request,
                                                               shared_ptr<map<string, string>> headers,
                                                               shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ValidateConnectionResponse validateConnection(shared_ptr<string> InstanceId, shared_ptr<ValidateConnectionRequest> request);
  ValidateConnectionResponse validateConnectionWithOptions(shared_ptr<string> InstanceId,
                                                           shared_ptr<ValidateConnectionRequest> request,
                                                           shared_ptr<map<string, string>> headers,
                                                           shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ValidateShrinkNodesResponse validateShrinkNodes(shared_ptr<string> InstanceId, shared_ptr<ValidateShrinkNodesRequest> request);
  ValidateShrinkNodesResponse validateShrinkNodesWithOptions(shared_ptr<string> InstanceId,
                                                             shared_ptr<ValidateShrinkNodesRequest> request,
                                                             shared_ptr<map<string, string>> headers,
                                                             shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ValidateSlrPermissionResponse validateSlrPermission(shared_ptr<ValidateSlrPermissionRequest> request);
  ValidateSlrPermissionResponse validateSlrPermissionWithOptions(shared_ptr<ValidateSlrPermissionRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  ValidateTransferableNodesResponse validateTransferableNodes(shared_ptr<string> InstanceId, shared_ptr<ValidateTransferableNodesRequest> request);
  ValidateTransferableNodesResponse validateTransferableNodesWithOptions(shared_ptr<string> InstanceId,
                                                                         shared_ptr<ValidateTransferableNodesRequest> request,
                                                                         shared_ptr<map<string, string>> headers,
                                                                         shared_ptr<Darabonba_Util::RuntimeOptions> runtime);
  CreateInstanceResponse createInstance(shared_ptr<CreateInstanceRequest> request);
  CreateInstanceResponse createInstanceWithOptions(shared_ptr<CreateInstanceRequest> request, shared_ptr<map<string, string>> headers, shared_ptr<Darabonba_Util::RuntimeOptions> runtime);

  virtual ~Client() = default;
};
} // namespace Alibabacloud_Elasticsearch20170613

#endif
